--
-- PostgreSQL database dump
--

-- Dumped from database version 14.10 (Ubuntu 14.10-0ubuntu0.22.04.1)
-- Dumped by pg_dump version 14.10 (Ubuntu 14.10-0ubuntu0.22.04.1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: case_sampling; Type: TABLE DATA; Schema: public; Owner: ubiuser1
--

COPY public.case_sampling (id, lineno, function, file, var_name, last_round, "group", type, notes, raw_ctx, ex) FROM stdin;
260	659	pmd_set_huge	arch/x86/mm/pgtable.c	uniform	1	21	\N	\N	\tu8 mtrr, uniform;\n\n\tmtrr = mtrr_type_lookup(addr, addr + PMD_SIZE, &uniform);\n\tif ((mtrr != MTRR_TYPE_INVALID) && (!uniform) &&\n	f
1149	1142	sbc_parse_cdb	drivers/target/target_core_sbc.c	size	1	21	\N	\N	\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tunsigned int size;\n\tu32 sectors = 0;\n\tsense_reason_t ret;\n\n\tcmd->protocol_data = ops;\n\n\tswitch (cdb[0]) {\n\tcase READ_6:\n\t\tsectors = transport_get_sectors_6(cdb);\n\t\tcmd->t_task_lba = transport_lba_21(cdb);\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_10:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_12:\n\t\tsectors = transport_get_sectors_12(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_6:\n\t\tsectors = transport_get_sectors_6(cdb);\n\t\tcmd->t_task_lba = transport_lba_21(cdb);\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_10:\n\tcase WRITE_VERIFY:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_12:\n\t\tsectors = transport_get_sectors_12(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_16:\n\tcase WRITE_VERIFY_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase XDWRITEREAD_10:\n\t\tif (cmd->data_direction != DMA_TO_DEVICE ||\n\t\t    !(cmd->se_cmd_flags & SCF_BIDI))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\tsectors = transport_get_sectors_10(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\n\t\t/*\n\t\t * Setup BIDI XOR callback to be run after I/O completion.\n\t\t */\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tcmd->transport_complete_callback = &xdreadwrite_callback;\n\t\tbreak;\n\tcase VARIABLE_LENGTH_CMD:\n\t{\n\t\tu16 service_action = get_unaligned_be16(&cdb[8]);\n\t\tswitch (service_action) {\n\t\tcase XDWRITEREAD_32:\n\t\t\tsectors = transport_get_sectors_32(cdb);\n\n\t\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t\t/*\n\t\t\t * Use WRITE_32 and READ_32 opcodes for the emulated\n\t\t\t * XDWRITE_READ_32 logic.\n\t\t\t */\n\t\t\tcmd->t_task_lba = transport_lba_64_ext(cdb);\n\t\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\n\t\t\t/*\n\t\t\t * Setup BIDI XOR callback to be run during after I/O\n\t\t\t * completion.\n\t\t\t */\n\t\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\t\tcmd->transport_complete_callback = &xdreadwrite_callback;\n\t\t\tbreak;\n\t\tcase WRITE_SAME_32:\n\t\t\tsectors = transport_get_sectors_32(cdb);\n\t\t\tif (!sectors) {\n\t\t\t\tpr_err("WSNZ=1, WRITE_SAME w/sectors=0 not"\n\t\t\t\t       " supported\\n");\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t\t}\n\n\t\t\tsize = sbc_get_size(cmd, 1);\n\t\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[12]);\n\n\t\t\tret = sbc_setup_write_same(cmd, &cdb[10], ops);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err("VARIABLE_LENGTH_CMD service action"\n\t\t\t\t" 0x%04x not supported\\n", service_action);\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase COMPARE_AND_WRITE:\n\t\tif (!dev->dev_attrib.emulate_caw) {\n\t\t\tpr_err_ratelimited("se_device %s/%s (vpd_unit_serial %s) reject"\n\t\t\t\t" COMPARE_AND_WRITE\\n", dev->se_hba->backend->ops->name,\n\t\t\t\tdev->dev_group.cg_item.ci_name, dev->t10_wwn.unit_serial);\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tsectors = cdb[13];\n\t\t/*\n\t\t * Currently enforce COMPARE_AND_WRITE for a single sector\n\t\t */\n\t\tif (sectors > 1) {\n\t\t\tpr_err("COMPARE_AND_WRITE contains NoLB: %u greater"\n\t\t\t       " than 1\\n", sectors);\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\t/*\n\t\t * Double size because we have two buffers, note that\n\t\t * zero is not an error..\n\t\t */\n\t\tsize = 2 * sbc_get_size(cmd, sectors);\n\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[2]);\n\t\tcmd->t_task_nolb = sectors;\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB | SCF_COMPARE_AND_WRITE;\n\t\tcmd->execute_cmd = sbc_compare_and_write;\n\t\tcmd->transport_complete_callback = compare_and_write_callback;\n\t\tbreak;\n\tcase READ_CAPACITY:\n\t\tsize = READ_CAP_LEN;\n\t\tcmd->execute_cmd = sbc_emulate_readcapacity;\n\t\tbreak;\n\tcase SERVICE_ACTION_IN_16:\n\t\tswitch (cmd->t_task_cdb[1] & 0x1f) {\n\t\tcase SAI_READ_CAPACITY_16:\n\t\t\tcmd->execute_cmd = sbc_emulate_readcapacity_16;\n\t\t\tbreak;\n\t\tcase SAI_REPORT_REFERRALS:\n\t\t\tcmd->execute_cmd = target_emulate_report_referrals;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err("Unsupported SA: 0x%02x\\n",\n\t\t\t\tcmd->t_task_cdb[1] & 0x1f);\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\t\tsize = get_unaligned_be32(&cdb[10]);\n\t\tbreak;\n\tcase SYNCHRONIZE_CACHE:\n\tcase SYNCHRONIZE_CACHE_16:\n\t\tif (cdb[0] == SYNCHRONIZE_CACHE) {\n\t\t\tsectors = transport_get_sectors_10(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\t\t} else {\n\t\t\tsectors = transport_get_sectors_16(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\t\t}\n\t\tif (ops->execute_sync_cache) {\n\t\t\tcmd->execute_cmd = ops->execute_sync_cache;\n\t\t\tgoto check_lba;\n\t\t}\n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tbreak;\n\tcase UNMAP:\n\t\tif (!ops->execute_unmap)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\t\tif (!dev->dev_attrib.emulate_tpu) {\n\t\t\tpr_err("Got UNMAP, but backend device has"\n\t\t\t       " emulate_tpu disabled\\n");\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tsize = get_unaligned_be16(&cdb[7]);\n\t\tcmd->execute_cmd = sbc_execute_unmap;\n\t\tbreak;\n\tcase WRITE_SAME_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tif (!sectors) {\n\t\t\tpr_err("WSNZ=1, WRITE_SAME w/sectors=0 not supported\\n");\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\n\t\tsize = sbc_get_size(cmd, 1);\n\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[2]);\n\n\t\tret = sbc_setup_write_same(cmd, &cdb[1], ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase WRITE_SAME:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tif (!sectors) {\n\t\t\tpr_err("WSNZ=1, WRITE_SAME w/sectors=0 not supported\\n");\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\n\t\tsize = sbc_get_size(cmd, 1);\n\t\tcmd->t_task_lba = get_unaligned_be32(&cdb[2]);\n\n\t\t/*\n\t\t * Follow sbcr26 with WRITE_SAME (10) and check for the existence\n\t\t * of byte 1 bit 3 UNMAP instead of original reserved field\n\t\t */\n\t\tret = sbc_setup_write_same(cmd, &cdb[1], ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VERIFY:\n\tcase VERIFY_16:\n\t\tsize = 0;\n\t\tif (cdb[0] == VERIFY) {\n\t\t\tsectors = transport_get_sectors_10(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\t\t} else {\n\t\t\tsectors = transport_get_sectors_16(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\t\t}\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tgoto check_lba;\n\tcase REZERO_UNIT:\n\tcase SEEK_6:\n\tcase SEEK_10:\n\t\t/*\n\t\t * There are still clients out there which use these old SCSI-2\n\t\t * commands. This mainly happens when running VMs with legacy\n\t\t * guest systems, connected via SCSI command pass-through to\n\t\t * iSCSI targets. Make them happy and return status GOOD.\n\t\t */\n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tbreak;\n\tcase START_STOP:\n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_startstop;\n\t\tbreak;\n\tdefault:\n\t\tret = spc_parse_cdb(cmd, &size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* reject any command that we don't have a handler for */\n\tif (!cmd->execute_cmd)\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\tif (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {\n\t\tunsigned long long end_lba;\ncheck_lba:\n\t\tend_lba = dev->transport->get_blocks(dev) + 1;\n\t\tif (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||\n\t\t    ((cmd->t_task_lba + sectors) > end_lba)) {\n\t\t\tpr_err("cmd exceeds last lba %llu "\n\t\t\t\t"(lba %llu, sectors %u)\\n",\n\t\t\t\tend_lba, cmd->t_task_lba, sectors);\n\t\t\treturn TCM_ADDRESS_OUT_OF_RANGE;\n\t\t}\n\n\t\tif (!(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE))\n\t\t\tsize = sbc_get_size(cmd, sectors);\n\t}\n\n\treturn target_cmd_size_check(cmd, size);\n	f
-5	1523	iommu_unmap_page	drivers/iommu/amd_iommu.c	unmap_size	19	2	arg_no	\N	\tunsigned long long unmapped;\n\tunsigned long unmap_size;\n\tu64 *pte;\n\n\tBUG_ON(!is_power_of_2(page_size));\n\n\tunmapped = 0;\n\n\twhile (unmapped < page_size) {\n\n\t\tpte = fetch_pte(dom, bus_addr, &unmap_size);\n\n\t\tif (pte) {\n\t\t\tint i, count;\n\n\t\t\tcount = PAGE_SIZE_PTE_COUNT(unmap_size);\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpte[i] = 0ULL;\n\t\t}\n\n\t\tbus_addr  = (bus_addr & ~(unmap_size - 1)) + unmap_size;\n	f
-3	244	ec_read_u8	drivers/platform/x86/compal-laptop.c	value	21	2	arg_no		\tu8 value;\n\tec_read(addr, &value);\n\treturn value;\n	f
-10	507	hpet_msi_resume	arch/x86/kernel/hpet.c	msg.f2	22	2	arg_no	\N	\tstruct hpet_dev *hdev = EVT_TO_HPET_DEV(evt);\n\tstruct irq_data *data = irq_get_irq_data(hdev->irq);\n\tstruct msi_msg msg;\n\n\t/* Restore the MSI msg and unmask the interrupt */\n\tirq_chip_compose_msi_msg(data, &msg);\n\thpet_msi_write(hdev, &msg);\n	f
102303	1507	read_interrupt_descriptor	arch/x86/kvm/emulate.c	dt.size	1	5	var_name	\N	\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n	f
-221	455	stm32_counter_write_raw	drivers/iio/trigger/stm32-timer-trigger.c	dar	4	20	\N	\N	\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 dat;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn regmap_write(priv->regmap, TIM_CNT, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t/* fixed scale */\n\t\treturn -EINVAL;\n\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tif (val) {\n\t\t\tregmap_read(priv->regmap, TIM_CR1, &dat);\n\t\t\tif (!(dat & TIM_CR1_CEN))\n\t\t\t\tclk_enable(priv->clk);\n	f
9043	201	ASIE_store	drivers/uwb/lc-rc.c	ie->element_id	0	21	\N	\N	\tstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\n\tstruct uwb_rc *rc = uwb_dev->rc;\n\tchar ie_buf[255];\n\tint result, ie_len = 0;\n\tconst char *cur_ptr = buf;\n\tstruct uwb_ie_hdr *ie;\n\n\t/* empty string means clear the ASIE. */\n\tif (strlen(buf) <= 1) {\n\t\tuwb_rc_ie_rm(rc, UWB_APP_SPEC_IE);\n\t\treturn size;\n\t}\n\n\t/* if non-empty string, convert string of hex chars to binary. */\n\twhile (ie_len < sizeof(ie_buf)) {\n\t\tint char_count;\n\n\t\tif (sscanf(cur_ptr, " %02hhX %n",\n\t\t\t\t&(ie_buf[ie_len]), &char_count) > 0) {\n\t\t\t++ie_len;\n\t\t\t/* skip chars read from cur_ptr. */\n\t\t\tcur_ptr += char_count;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* validate IE length and type. */\n\tif (ie_len < sizeof(struct uwb_ie_hdr)) {\n\t\tdev_err(dev, "%s: Invalid ASIE size %d.\\n", __func__, ie_len);\n\t\treturn -EINVAL;\n\t}\n\n\tie = (struct uwb_ie_hdr *)ie_buf;\n\tif (ie->element_id != UWB_APP_SPEC_IE) {\n	f
-213	135	stm32_timer_start	drivers/iio/trigger/stm32-timer-trigger.c	ccer	4	20	\N	\N	\tunsigned long long prd, div;\n\tint prescaler = 0;\n\tu32 ccer, cr1;\n\n\t/* Period and prescaler values depends of clock rate */\n\tdiv = (unsigned long long)clk_get_rate(priv->clk);\n\n\tdo_div(div, frequency);\n\n\tprd = div;\n\n\t/*\n\t * Increase prescaler value until we get a result that fit\n\t * with auto reload register maximum value.\n\t */\n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, (prescaler + 1));\n\t}\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC) {\n\t\tdev_err(priv->dev, "prescaler exceeds the maximum value\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if nobody else use the timer */\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n	f
102652	1713	_rtl92de_efuse_update_chip_version	drivers/net/wireless/realtek/rtlwifi/rtl8192de/hw.c	chipvalue	1	5	var_name	\N	\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tenum version_8192d chipver = rtlpriv->rtlhal.version;\n\tu8 cutvalue[2];\n\tu16 chipvalue;\n\n\trtlpriv->intf_ops->read_efuse_byte(hw, EEPROME_CHIP_VERSION_H,\n\t\t\t\t\t   &cutvalue[1]);\n\trtlpriv->intf_ops->read_efuse_byte(hw, EEPROME_CHIP_VERSION_L,\n\t\t\t\t\t   &cutvalue[0]);\n\tchipvalue = (cutvalue[1] << 8) | cutvalue[0];\n\tswitch (chipvalue) {\n	f
103392	281	efx_mcdi_read_response_header	drivers/net/ethernet/sfc/mcdi.c	respcmd	1	5	var_name	\N	\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n\tunsigned int respseq, respcmd, error;\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tchar *buf = mcdi->logging_buffer; /* page-sized */\n#endif\n\tefx_dword_t hdr;\n\n\tefx->type->mcdi_read_response(efx, &hdr, 0, 4);\n\trespseq = EFX_DWORD_FIELD(hdr, MCDI_HEADER_SEQ);\n\trespcmd = EFX_DWORD_FIELD(hdr, MCDI_HEADER_CODE);\n\terror = EFX_DWORD_FIELD(hdr, MCDI_HEADER_ERROR);\n\n\tif (respcmd != MC_CMD_V2_EXTN) {\n	f
100668	1631	xfs_da3_node_order	fs/xfs/libxfs/xfs_da_btree.c	node2hdr.count	1	5	var_name	\N	\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n	f
101109	128	virtinput_cfg_bits	drivers/virtio/virtio_input.c	bytes	1	5	var_name	\N	\tunsigned int bit;\n\tu8 *virtio_bits;\n\tu8 bytes;\n\n\tbytes = virtinput_cfg_select(vi, select, subsel);\n\tif (!bytes)\n	f
101873	425	print_pin_ctls	sound/pci/hda/hda_proc.c	pinctls	1	5	var_name	\N	\tunsigned int pinctls;\n\n\tpinctls = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t     AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\tsnd_iprintf(buffer, "  Pin-ctls: 0x%02x:", pinctls);\n\tif (pinctls & AC_PINCTL_IN_EN)\n\t\tsnd_iprintf(buffer, " IN");\n\tif (pinctls & AC_PINCTL_OUT_EN)\n	f
100050	497	print_digital_conv	sound/pci/hda/hda_proc.c	digi1	1	5	var_name	\N	\tunsigned int digi1 = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t\tAC_VERB_GET_DIGI_CONVERT_1, 0);\n\tunsigned char digi2 = digi1 >> 8;\n\tunsigned char digi3 = digi1 >> 16;\n\n\tsnd_iprintf(buffer, "  Digital:");\n\tif (digi1 & AC_DIG1_ENABLE)\n\t\tsnd_iprintf(buffer, " Enabled");\n\tif (digi1 & AC_DIG1_V)\n\t\tsnd_iprintf(buffer, " Validity");\n\tif (digi1 & AC_DIG1_VCFG)\n\t\tsnd_iprintf(buffer, " ValidityCfg");\n\tif (digi1 & AC_DIG1_EMPHASIS)\n	f
8393	314	bmp280_read_press	drivers/iio/pressure/bmp280-core.c	ret	1	11	\N	\N	\tint ret;\n\t__be32 tmp = 0;\n\ts32 adc_press;\n\tu32 comp_press;\n\n\t/* Read and compensate temperature so we get a reading of t_fine. */\n\tret = bmp280_read_temp(data, NULL);\n\tif (ret < 0)\n	t
60236	496	temp_cpu	drivers/platform/x86/compal-laptop.c	temp_cpu_1000$mul$	0	13	\N	\N	\treturn sprintf(buf, "%d\\n", get_fan_rpm());\n}\n\n\n/* Temperature interface */\n#define TEMPERATURE_SHOW_TEMP_AND_LABEL(POSTFIX, ADDRESS, LABEL)\t\\\nstatic ssize_t temp_##POSTFIX(struct device *dev,\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, "%d\\n", 1000 * (int)ec_read_s8(ADDRESS));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t label_##POSTFIX(struct device *dev,\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, "%s\\n", LABEL);\t\t\t\t\\\n}\n\n/* Labels as in service guide */\nTEMPERATURE_SHOW_TEMP_AND_LABEL(cpu,        TEMP_CPU,        "CPU_TEMP");\n	f
7608	1007	store_min_perf_pct	drivers/cpufreq/intel_pstate.c	store_min_perf_pct_$__UNIQUE_ID_min1_250$obj	0	21	\N	\N	\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, "%u", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tglobal.min_perf_pct = clamp_t(int, input,\n	f
38739	549	xfs_dir2_block_addname	fs/xfs/libxfs/xfs_dir2_block.c	dep->inumber	1	13	\N	\N	\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n	f
63206	559	ax88179_get_wol	drivers/net/usb/ax88179_178a.c	opt	1	13	\N	\N	\tstruct usbnet *dev = netdev_priv(net);\n\tu8 opt;\n\n\tif (ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\n\t\t\t     1, 1, &opt) < 0) {\n\t\twolinfo->supported = 0;\n\t\twolinfo->wolopts = 0;\n\t\treturn;\n\t}\n\n\twolinfo->supported = WAKE_PHY | WAKE_MAGIC;\n\twolinfo->wolopts = 0;\n\tif (opt & AX_MONITOR_MODE_RWLC)\n\t\twolinfo->wolopts |= WAKE_PHY;\n\tif (opt & AX_MONITOR_MODE_RWMP)\n	f
101215	1207	b53_arl_search_wait	drivers/net/dsa/b53/b53_common.c	reg	1	5	var_name	\N	\tunsigned int timeout = 1000;\n\tu8 reg;\n\n\tdo {\n\t\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, &reg);\n\t\tif (!(reg & ARL_SRCH_STDN))\n\t\t\treturn 0;\n\n\t\tif (reg & ARL_SRCH_VLID)\n	f
101253	629	gnttab_max_grant_frames	drivers/xen/grant-table.c	xen_max	1	5	var_name	\N	\tunsigned int xen_max = __max_nr_grant_frames();\n\tstatic unsigned int boot_max_nr_grant_frames;\n\n\t/* First time, initialize it properly. */\n\tif (!boot_max_nr_grant_frames)\n\t\tboot_max_nr_grant_frames = __max_nr_grant_frames();\n\n\tif (xen_max > boot_max_nr_grant_frames)\n	f
102000	139	nvkm_i2c_intr	drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c	hi	1	5	var_name	\N	\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\tstruct nvkm_i2c_aux *aux;\n\tu32 hi, lo, rq, tx;\n\n\tif (!i2c->func->aux_stat)\n\t\treturn;\n\n\ti2c->func->aux_stat(i2c, &hi, &lo, &rq, &tx);\n\tif (!hi && !lo && !rq && !tx)\n	f
102206	811	bcm_sf2_sw_get_wol	drivers/net/dsa/bcm_sf2.c	pwol.wolopts	1	5	var_name	\N	\tstruct net_device *p = ds->dst->cpu_dp->netdev;\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tstruct ethtool_wolinfo pwol;\n\n\t/* Get the parent device WoL settings */\n\tp->ethtool_ops->get_wol(p, &pwol);\n\n\t/* Advertise the parent device supported settings */\n\twol->supported = pwol.supported;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n\n\tif (pwol.wolopts & WAKE_MAGICSECURE)\n	f
102270	414	mtrr_seq_show	arch/x86/kernel/cpu/mtrr/if.c	size	1	5	var_name	\N	\tchar factor;\n\tint i, max;\n\tmtrr_type type;\n\tunsigned long base, size;\n\n\tmax = num_var_ranges;\n\tfor (i = 0; i < max; i++) {\n\t\tmtrr_if->get(i, &base, &size, &type);\n\t\tif (size == 0) {\n	f
102553	5114	emulator_get_segment	arch/x86/kvm/x86.c	var.unusable	1	5	var_name	\N	\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n	f
102687	1344	hdac_hdmi_skl_enable_all_pins	sound/soc/codecs/hdac_hdmi.c	vendor_param	1	5	var_name	\N	\tunsigned int vendor_param;\n\tstruct hdac_ext_device *edev = to_ehdac_device(hdac);\n\tstruct hdac_hdmi_priv *hdmi = edev->private_data;\n\tunsigned int vendor_nid = hdmi->drv_data->vendor_nid;\n\n\tvendor_param = snd_hdac_codec_read(hdac, vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)\n	f
102688	1363	hdac_hdmi_skl_enable_dp12	sound/soc/codecs/hdac_hdmi.c	vendor_param	1	5	var_name	\N	\tunsigned int vendor_param;\n\tstruct hdac_ext_device *edev = to_ehdac_device(hdac);\n\tstruct hdac_hdmi_priv *hdmi = edev->private_data;\n\tunsigned int vendor_nid = hdmi->drv_data->vendor_nid;\n\n\tvendor_param = snd_hdac_codec_read(hdac, vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\n	f
102900	1074	arcnet_rx	drivers/net/arcnet/arcnet.c	pkt.hard.offset	1	5	var_name	\N	\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct archdr pkt;\n\tstruct arc_rfc1201 *soft;\n\tint length, ofs;\n\n\tsoft = &pkt.soft.rfc1201;\n\n\tlp->hw.copy_from_card(dev, bufnum, 0, &pkt, ARC_HDR_SIZE);\n\tif (pkt.hard.offset[0]) {\n	f
102964	567	ide_wait_ireason	drivers/ide/ide-atapi.c	ireason	1	5	var_name	\N	\tint retries = 100;\n\n\twhile (retries-- && ((ireason & ATAPI_COD) == 0 ||\n\t\t(ireason & ATAPI_IO))) {\n	f
102987	146	fetch_deref_string_size	kernel/trace/trace_probe.c	addr	1	5	var_name	\N	\tstruct deref_fetch_param *dprm = data;\n\tunsigned long addr;\n\n\tcall_fetch(&dprm->orig, regs, &addr);\n\tif (addr && dprm->fetch_size) {\n	f
281	339	static_protections	arch/x86/mm/pageattr.c	level	1	21	\N	\N	\tpgprot_t forbidden = __pgprot(0);\n\n\t/*\n\t * The BIOS area between 640k and 1Mb needs to be executable for\n\t * PCI BIOS based config access (CONFIG_PCI_GOBIOS) support.\n\t */\n#ifdef CONFIG_PCI_BIOS\n\tif (pcibios_enabled && within(pfn, BIOS_BEGIN >> PAGE_SHIFT, BIOS_END >> PAGE_SHIFT))\n\t\tpgprot_val(forbidden) |= _PAGE_NX;\n#endif\n\n\t/*\n\t * The kernel text needs to be executable for obvious reasons\n\t * Does not cover __inittext since that is gone later on. On\n\t * 64bit we do not enforce !NX on the low mapping\n\t */\n\tif (within(address, (unsigned long)_text, (unsigned long)_etext))\n\t\tpgprot_val(forbidden) |= _PAGE_NX;\n\n\t/*\n\t * The .rodata section needs to be read-only. Using the pfn\n\t * catches all aliases.\n\t */\n\tif (within(pfn, __pa_symbol(__start_rodata) >> PAGE_SHIFT,\n\t\t   __pa_symbol(__end_rodata) >> PAGE_SHIFT))\n\t\tpgprot_val(forbidden) |= _PAGE_RW;\n\n#if defined(CONFIG_X86_64)\n\t/*\n\t * Once the kernel maps the text as RO (kernel_set_to_readonly is set),\n\t * kernel text mappings for the large page aligned text, rodata sections\n\t * will be always read-only. For the kernel identity mappings covering\n\t * the holes caused by this alignment can be anything that user asks.\n\t *\n\t * This will preserve the large page mappings for kernel text/data\n\t * at no extra cost.\n\t */\n\tif (kernel_set_to_readonly &&\n\t    within(address, (unsigned long)_text,\n\t\t   (unsigned long)__end_rodata_hpage_align)) {\n\t\tunsigned int level;\n\n\t\t/*\n\t\t * Don't enforce the !RW mapping for the kernel text mapping,\n\t\t * if the current mapping is already using small page mapping.\n\t\t * No need to work hard to preserve large page mappings in this\n\t\t * case.\n\t\t *\n\t\t * This also fixes the Linux Xen paravirt guest boot failure\n\t\t * (because of unexpected read-only mappings for kernel identity\n\t\t * mappings). In this paravirt guest case, the kernel text\n\t\t * mapping and the kernel identity mapping share the same\n\t\t * page-table pages. Thus we can't really use different\n\t\t * protections for the kernel text and identity mappings. Also,\n\t\t * these shared mappings are made of small page mappings.\n\t\t * Thus this don't enforce !RW mapping for small page kernel\n\t\t * text mapping logic will help Linux Xen parvirt guest boot\n\t\t * as well.\n\t\t */\n\t\tif (lookup_address(address, &level) && (level != PG_LEVEL_4K))\n	f
100526	90	diva_istream_write	drivers/isdn/hardware/eicon/istream.c	tmp[0]	0	5	var_name	\N	\N	f
42968	192	SYSC_statfs64	fs/statfs.c	error	1	11	\N	\N	\tstruct kstatfs st;\n\tint error;\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\terror = user_statfs(pathname, &st);\n\tif (!error)\n	t
60804	6321	ath10k_wmi_op_gen_vdev_stop	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_vdev_stop_$cmd$obj	0	11	\N	\N	\tstruct wmi_vdev_stop_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_stop_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	t
100361	1341	e1000_check_mng_mode_82574	drivers/net/ethernet/intel/e1000e/82571.c	data	1	5	var_name	\N	\tu16 data;\n\n\te1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &data);\n\treturn (data & E1000_NVM_INIT_CTRL2_MNGM) != 0;\n	f
100427	542	xfs_dir2_leaf_lasthash	fs/xfs/libxfs/xfs_dir2_node.c	leafhdr.magic	1	5	var_name	\N	\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n	f
100514	499	print_digital_conv	sound/pci/hda/hda_proc.c	digi1	1	5	var_name	\N	\tunsigned int digi1 = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t\tAC_VERB_GET_DIGI_CONVERT_1, 0);\n\tunsigned char digi2 = digi1 >> 8;\n\tunsigned char digi3 = digi1 >> 16;\n\n\tsnd_iprintf(buffer, "  Digital:");\n\tif (digi1 & AC_DIG1_ENABLE)\n\t\tsnd_iprintf(buffer, " Enabled");\n\tif (digi1 & AC_DIG1_V)\n\t\tsnd_iprintf(buffer, " Validity");\n\tif (digi1 & AC_DIG1_VCFG)\n\t\tsnd_iprintf(buffer, " ValidityCfg");\n\tif (digi1 & AC_DIG1_EMPHASIS)\n\t\tsnd_iprintf(buffer, " Preemphasis");\n\tif (digi1 & AC_DIG1_COPYRIGHT)\n	f
100626	1631	xfs_da3_node_order	fs/xfs/libxfs/xfs_da_btree.c	node1hdr.count	1	5	var_name	\N	\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n	f
100659	1083	arcnet_rx	drivers/net/arcnet/arcnet.c	length	1	5	var_name	\N	\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct archdr pkt;\n\tstruct arc_rfc1201 *soft;\n\tint length, ofs;\n\n\tsoft = &pkt.soft.rfc1201;\n\n\tlp->hw.copy_from_card(dev, bufnum, 0, &pkt, ARC_HDR_SIZE);\n\tif (pkt.hard.offset[0]) {\n\t\tofs = pkt.hard.offset[0];\n\t\tlength = 256 - ofs;\n\t} else {\n\t\tofs = pkt.hard.offset[1];\n\t\tlength = 512 - ofs;\n\t}\n\n\t/* get the full header, if possible */\n\tif (sizeof(pkt.soft) <= length) {\n	f
100302	1064	b53_arl_op_wait	drivers/net/dsa/b53/b53_common.c	reg	1	5	var_name	\N	\tunsigned int timeout = 10;\n\tu8 reg;\n\n\tdo {\n\t\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, &reg);\n\t\tif (!(reg & ARLTBL_START_DONE))\n	f
100340	1204	b53_arl_search_wait	drivers/net/dsa/b53/b53_common.c	reg	1	5	var_name	\N	\tunsigned int timeout = 1000;\n\tu8 reg;\n\n\tdo {\n\t\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, &reg);\n\t\tif (!(reg & ARL_SRCH_STDN))\n	f
100428	1077	xfs_dir2_leafn_rebalance	fs/xfs/libxfs/xfs_dir2_node.c	oldsum	1	5	var_name	\N	\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\tint\t\t\tcount;\t\t/* count (& direction) leaves */\n\tint\t\t\tisleft;\t\t/* new goes in left leaf */\n\txfs_dir2_leaf_t\t\t*leaf1;\t\t/* first leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf2;\t\t/* second leaf structure */\n\tint\t\t\tmid;\t\t/* midpoint leaf index */\n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t/* old count of stale leaves */\n#endif\n\tint\t\t\toldsum;\t\t/* old total leaf count */\n\tint\t\t\tswap;\t\t/* swapped leaf blocks */\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t/*\n\t * If the block order is wrong, swap the arguments.\n\t */\n\tif ((swap = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp))) {\n\t\txfs_da_state_blk_t\t*tmp;\t/* temp for block swap */\n\n\t\ttmp = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp;\n\t}\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t/*\n\t * If the old leaf count was odd then the new one will be even,\n\t * so we need to divide the new count evenly.\n\t */\n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t/* middle entry hash value */\n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t/*\n\t * If the old count is even then the new count is odd, so there's\n\t * no preferred side for the new entry.\n\t * Pick the left one.\n\t */\n\telse\n\t\tisleft = 1;\n\t/*\n\t * Calculate moved entry count.  Positive means left-to-right,\n\t * negative means right-to-left.  Then move the entries.\n\t */\n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n	f
100791	238	b53_do_vlan_op	drivers/net/dsa/b53/b53_common.c	vta	1	5	var_name	\N	\tunsigned int i;\n\n\tb53_write8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], VTA_START_CMD | op);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu8 vta;\n\n\t\tb53_read8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], &vta);\n\t\tif (!(vta & VTA_START_CMD))\n	f
101053	826	ksz_port_fdb_dump	drivers/net/dsa/microchip/ksz_common.c	ksz_data	1	5	var_name	\N	\tstruct ksz_device *dev = ds->priv;\n\tint ret = 0;\n\tu32 ksz_data;\n\tu32 alu_table[4];\n\tstruct alu_struct alu;\n\tint timeout;\n\n\tmutex_lock(&dev->alu_mutex);\n\n\t/* start ALU search */\n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_START | ALU_SEARCH);\n\n\tdo {\n\t\ttimeout = 1000;\n\t\tdo {\n\t\t\tksz_read32(dev, REG_SW_ALU_CTRL__4, &ksz_data);\n\t\t\tif ((ksz_data & ALU_VALID) || !(ksz_data & ALU_START))\n	f
328	1507	usb_reset_configuration	drivers/usb/core/message.c	retval	1	21	\N	\N	\tint\t\t\ti, retval;\n\tstruct usb_host_config\t*config;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\t/* caller must have locked the device and must own\n\t * the usb bus readlock (so driver bindings are stable);\n\t * calls during probe() are fine\n\t */\n\n\tfor (i = 1; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n\n\tconfig = dev->actconfig;\n\tretval = 0;\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the configuration is reset, so\n\t * that the xHCI driver can recalculate the U1/U2 timeouts.\n\t */\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, "%s Failed to disable LPM\\n.", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t/* Make sure we have enough bandwidth for each alternate setting 0 */\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tif (alt != intf->cur_altsetting)\n\t\t\tretval = usb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\tintf->cur_altsetting, alt);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\t/* If not, reinstate the old alternate settings */\n\tif (retval < 0) {\nreset_old_alts:\n\t\tfor (i--; i >= 0; i--) {\n\t\t\tstruct usb_interface *intf = config->interface[i];\n\t\t\tstruct usb_host_interface *alt;\n\n\t\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\t\tif (!alt)\n\t\t\t\talt = &intf->altsetting[0];\n\t\t\tif (alt != intf->cur_altsetting)\n\t\t\t\tusb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\t\talt, intf->cur_altsetting);\n\t\t}\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0)\n	f
9237	148	public_key_verify_signature	crypto/asymmetric_keys/public_key.c	ret	1	21	\N	\N	\tstruct public_key_completion compl;\n\tstruct crypto_akcipher *tfm;\n\tstruct akcipher_request *req;\n\tstruct scatterlist sig_sg, digest_sg;\n\tconst char *alg_name;\n\tchar alg_name_buf[CRYPTO_MAX_ALG_NAME];\n\tvoid *output;\n\tunsigned int outlen;\n\tint ret = -ENOMEM;\n\n\tpr_devel("==>%s()\\n", __func__);\n\n\tBUG_ON(!pkey);\n\tBUG_ON(!sig);\n\tBUG_ON(!sig->digest);\n\tBUG_ON(!sig->s);\n\n\talg_name = sig->pkey_algo;\n\tif (strcmp(sig->pkey_algo, "rsa") == 0) {\n\t\t/* The data wangled by the RSA algorithm is typically padded\n\t\t * and encoded in some manner, such as EMSA-PKCS1-1_5 [RFC3447\n\t\t * sec 8.2].\n\t\t */\n\t\tif (snprintf(alg_name_buf, CRYPTO_MAX_ALG_NAME,\n\t\t\t     "pkcs1pad(rsa,%s)", sig->hash_algo\n\t\t\t     ) >= CRYPTO_MAX_ALG_NAME)\n\t\t\treturn -EINVAL;\n\t\talg_name = alg_name_buf;\n\t}\n\n\ttfm = crypto_alloc_akcipher(alg_name, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\treq = akcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\tgoto error_free_tfm;\n\n\tret = crypto_akcipher_set_pub_key(tfm, pkey->key, pkey->keylen);\n\tif (ret)\n\t\tgoto error_free_req;\n\n\tret = -ENOMEM;\n\toutlen = crypto_akcipher_maxsize(tfm);\n\toutput = kmalloc(outlen, GFP_KERNEL);\n\tif (!output)\n\t\tgoto error_free_req;\n\n\tsg_init_one(&sig_sg, sig->s, sig->s_size);\n\tsg_init_one(&digest_sg, output, outlen);\n\takcipher_request_set_crypt(req, &sig_sg, &digest_sg, sig->s_size,\n\t\t\t\t   outlen);\n\tinit_completion(&compl.completion);\n\takcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t      CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      public_key_verify_done, &compl);\n\n\t/* Perform the verification calculation.  This doesn't actually do the\n\t * verification, but rather calculates the hash expected by the\n\t * signature and returns that to us.\n\t */\n\tret = crypto_akcipher_verify(req);\n\tif ((ret == -EINPROGRESS) || (ret == -EBUSY)) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t}\n\tif (ret < 0)\n	f
32079	119	mcp4725_store_eeprom	drivers/iio/dac/mcp4725.c	inoutbuf	1	11	\N	\N	\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tint tries = 20;\n\tu8 inoutbuf[3];\n\tbool state;\n\tint ret;\n\n\tret = strtobool(buf, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!state)\n\t\treturn 0;\n\n\tinoutbuf[0] = 0x60; /* write EEPROM */\n\tinoutbuf[0] |= data->ref_mode << 3;\n\tinoutbuf[1] = data->dac_value >> 4;\n\tinoutbuf[2] = (data->dac_value & 0xf) << 4;\n\n\tret = i2c_master_send(data->client, inoutbuf, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 3)\n\t\treturn -EIO;\n\n\t/* wait for write complete, takes up to 50ms */\n\twhile (tries--) {\n\t\tmsleep(20);\n\t\tret = i2c_master_recv(data->client, inoutbuf, 3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != 3)\n\t\t\treturn -EIO;\n\n\t\tif (inoutbuf[0] & 0x80)\n	f
9792	74	ipv6_select_ident	net/ipv6/output_core.c	ip6_idents_hashrnd	0	21	\N	\N	\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n	f
-211	635	pfuze100_regulator_probe	drivers/regulator/pfuze100-regulator.c	val	4	20	\N	\N	\tstruct pfuze_chip *pfuze_chip;\n\tstruct pfuze_regulator_platform_data *pdata =\n\t    dev_get_platdata(&client->dev);\n\tstruct regulator_config config = { };\n\tint i, ret;\n\tconst struct of_device_id *match;\n\tu32 regulator_num;\n\tu32 sw_check_start, sw_check_end, sw_hi = 0x40;\n\n\tpfuze_chip = devm_kzalloc(&client->dev, sizeof(*pfuze_chip),\n\t\t\tGFP_KERNEL);\n\tif (!pfuze_chip)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node) {\n\t\tmatch = of_match_device(of_match_ptr(pfuze_dt_ids),\n\t\t\t\t&client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev, "Error: No device match found\\n");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tpfuze_chip->chip_id = (int)(long)match->data;\n\t} else if (id) {\n\t\tpfuze_chip->chip_id = id->driver_data;\n\t} else {\n\t\tdev_err(&client->dev, "No dts match or id table match found\\n");\n\t\treturn -ENODEV;\n\t}\n\n\ti2c_set_clientdata(client, pfuze_chip);\n\tpfuze_chip->dev = &client->dev;\n\n\tpfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);\n\tif (IS_ERR(pfuze_chip->regmap)) {\n\t\tret = PTR_ERR(pfuze_chip->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t"regmap allocation failed with err %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret = pfuze_identify(pfuze_chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, "unrecognized pfuze chip ID!\\n");\n\t\treturn ret;\n\t}\n\n\t/* use the right regulators after identify the right device */\n\tswitch (pfuze_chip->chip_id) {\n\tcase PFUZE3000:\n\t\tpfuze_chip->pfuze_regulators = pfuze3000_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze3000_regulators);\n\t\tsw_check_start = PFUZE3000_SW2;\n\t\tsw_check_end = PFUZE3000_SW2;\n\t\tsw_hi = 1 << 3;\n\t\tbreak;\n\tcase PFUZE200:\n\t\tpfuze_chip->pfuze_regulators = pfuze200_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze200_regulators);\n\t\tsw_check_start = PFUZE200_SW2;\n\t\tsw_check_end = PFUZE200_SW3B;\n\t\tbreak;\n\tcase PFUZE100:\n\tdefault:\n\t\tpfuze_chip->pfuze_regulators = pfuze100_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze100_regulators);\n\t\tsw_check_start = PFUZE100_SW2;\n\t\tsw_check_end = PFUZE100_SW4;\n\t\tbreak;\n\t}\n\tdev_info(&client->dev, "pfuze%s found.\\n",\n\t\t(pfuze_chip->chip_id == PFUZE100) ? "100" :\n\t\t((pfuze_chip->chip_id == PFUZE200) ? "200" : "3000"));\n\n\tmemcpy(pfuze_chip->regulator_descs, pfuze_chip->pfuze_regulators,\n\t\tsizeof(pfuze_chip->regulator_descs));\n\n\tret = pfuze_parse_regulators_dt(pfuze_chip);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < regulator_num; i++) {\n\t\tstruct regulator_init_data *init_data;\n\t\tstruct regulator_desc *desc;\n\t\tint val;\n\n\t\tdesc = &pfuze_chip->regulator_descs[i].desc;\n\n\t\tif (pdata)\n\t\t\tinit_data = pdata->init_data[i];\n\t\telse\n\t\t\tinit_data = match_init_data(i);\n\n\t\t/* SW2~SW4 high bit check and modify the voltage value table */\n\t\tif (i >= sw_check_start && i <= sw_check_end) {\n\t\t\tregmap_read(pfuze_chip->regmap, desc->vsel_reg, &val);\n\t\t\tif (val & sw_hi) {\n	f
599	138	acpi_ds_build_internal_object	drivers/acpi/acpica/dsobject.c	obj_desc	1	11	\N	\N	\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ds_build_internal_object);\n\n\t*obj_desc_ptr = NULL;\n\tif (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {\n\t\t/*\n\t\t * This is a named object reference. If this name was\n\t\t * previously looked up in the namespace, it was stored in\n\t\t * this op. Otherwise, go ahead and look it up now\n\t\t */\n\t\tif (!op->common.node) {\n\n\t\t\t/* Check if we are resolving a named reference within a package */\n\n\t\t\tif ((op->common.parent->common.aml_opcode ==\n\t\t\t     AML_PACKAGE_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_VARIABLE_PACKAGE_OP)) {\n\t\t\t\t/*\n\t\t\t\t * We won't resolve package elements here, we will do this\n\t\t\t\t * after all ACPI tables are loaded into the namespace. This\n\t\t\t\t * behavior supports both forward references to named objects\n\t\t\t\t * and external references to objects in other tables.\n\t\t\t\t */\n\t\t\t\tgoto create_new_object;\n\t\t\t} else {\n\t\t\t\tstatus = acpi_ns_lookup(walk_state->scope_info,\n\t\t\t\t\t\t\top->common.value.string,\n\t\t\t\t\t\t\tACPI_TYPE_ANY,\n\t\t\t\t\t\t\tACPI_IMODE_EXECUTE,\n\t\t\t\t\t\t\tACPI_NS_SEARCH_PARENT |\n\t\t\t\t\t\t\tACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tACPI_CAST_INDIRECT_PTR\n\t\t\t\t\t\t\t(struct\n\t\t\t\t\t\t\t acpi_namespace_node,\n\t\t\t\t\t\t\t &(op->common.node)));\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tACPI_ERROR_NAMESPACE(op->common.value.\n\t\t\t\t\t\t\t     string, status);\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ncreate_new_object:\n\n\t/* Create and init a new internal ACPI object */\n\n\tobj_desc = acpi_ut_create_internal_object((acpi_ps_get_opcode_info\n\t\t\t\t\t\t   (op->common.aml_opcode))->\n\t\t\t\t\t\t  object_type);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tstatus =\n\t    acpi_ds_init_object_from_op(walk_state, op, op->common.aml_opcode,\n\t\t\t\t\t&obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(obj_desc);\n	t
46581	303	ima_read_policy	security/integrity/ima/ima_fs.c	data	1	13	\N	\N	\tvoid *data;\n\tchar *datap;\n\tloff_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t/* remove \\n */\n\tdatap = path;\n\tstrsep(&datap, "\\n");\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err("Unable to open file: %s (%d)", path, rc);\n\t\treturn rc;\n\t}\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, "\\n"))) {\n\t\tpr_debug("rule: %s\\n", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n	f
1740	1573	r8712_restruct_sec_ie	drivers/staging/rtl8712/rtl871x_mlme.c	&out_ie[ielength]	1	21	\N	\N	\tu8 authmode = 0, match;\n\tu8 sec_ie[255], uncst_oui[4], bkup_ie[255];\n\tu8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};\n\tuint ielength, cnt, remove_cnt;\n\tint iEntry;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\tuint ndisauthmode = psecuritypriv->ndisauthtype;\n\tuint ndissecuritytype = psecuritypriv->ndisencryptstatus;\n\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA) ||\n\t    (ndisauthmode == Ndis802_11AuthModeWPAPSK)) {\n\t\tauthmode = _WPA_IE_ID_;\n\t\tuncst_oui[0] = 0x0;\n\t\tuncst_oui[1] = 0x50;\n\t\tuncst_oui[2] = 0xf2;\n\t}\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA2) ||\n\t    (ndisauthmode == Ndis802_11AuthModeWPA2PSK)) {\n\t\tauthmode = _WPA2_IE_ID_;\n\t\tuncst_oui[0] = 0x0;\n\t\tuncst_oui[1] = 0x0f;\n\t\tuncst_oui[2] = 0xac;\n\t}\n\tswitch (ndissecuritytype) {\n\tcase Ndis802_11Encryption1Enabled:\n\tcase Ndis802_11Encryption1KeyAbsent:\n\t\tuncst_oui[3] = 0x1;\n\t\tbreak;\n\tcase Ndis802_11Encryption2Enabled:\n\tcase Ndis802_11Encryption2KeyAbsent:\n\t\tuncst_oui[3] = 0x2;\n\t\tbreak;\n\tcase Ndis802_11Encryption3Enabled:\n\tcase Ndis802_11Encryption3KeyAbsent:\n\t\tuncst_oui[3] = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/*Search required WPA or WPA2 IE and copy to sec_ie[] */\n\tcnt = 12;\n\tmatch = false;\n\twhile (cnt < in_len) {\n\t\tif (in_ie[cnt] == authmode) {\n\t\t\tif ((authmode == _WPA_IE_ID_) &&\n\t\t\t    (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {\n\t\t\t\tmemcpy(&sec_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (authmode == _WPA2_IE_ID_) {\n\t\t\t\tmemcpy(&sec_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (((authmode == _WPA_IE_ID_) &&\n\t\t\t     (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) ||\n\t\t\t     (authmode == _WPA2_IE_ID_))\n\t\t\t\tmemcpy(&bkup_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t}\n\t\tcnt += in_ie[cnt + 1] + 2; /*get next*/\n\t}\n\t/*restruct WPA IE or WPA2 IE in sec_ie[] */\n\tif (match) {\n\t\tif (sec_ie[0] == _WPA_IE_ID_) {\n\t\t\t/* parsing SSN IE to select required encryption\n\t\t\t * algorithm, and set the bc/mc encryption algorithm\n\t\t\t */\n\t\t\twhile (true) {\n\t\t\t\t/*check wpa_oui tag*/\n\t\t\t\tif (memcmp(&sec_ie[2], &wpa_oui[0], 4)) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((sec_ie[6] != 0x01) || (sec_ie[7] != 0x0)) {\n\t\t\t\t\t/*IE Ver error*/\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!memcmp(&sec_ie[8], &wpa_oui[0], 3)) {\n\t\t\t\t\t/* get bc/mc encryption type (group\n\t\t\t\t\t * key type)\n\t\t\t\t\t */\n\t\t\t\t\tswitch (sec_ie[11]) {\n\t\t\t\t\tcase 0x0: /*none*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_NO_PRIVACY_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x1: /*WEP_40*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP40_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x2: /*TKIP*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_TKIP_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x3: /*AESCCMP*/\n\t\t\t\t\tcase 0x4:\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_AES_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x5: /*WEP_104*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP104_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sec_ie[12] == 0x01) {\n\t\t\t\t\t/*check the unicast encryption type*/\n\t\t\t\t\tif (memcmp(&sec_ie[14],\n\t\t\t\t\t    &uncst_oui[0], 4)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} /*else the uncst_oui is match*/\n\t\t\t\t} else { /*mixed mode, unicast_enc_type > 1*/\n\t\t\t\t\t/*select the uncst_oui and remove\n\t\t\t\t\t * the other uncst_oui\n\t\t\t\t\t */\n\t\t\t\t\tcnt = sec_ie[12];\n\t\t\t\t\tremove_cnt = (cnt - 1) * 4;\n\t\t\t\t\tsec_ie[12] = 0x01;\n\t\t\t\t\tmemcpy(&sec_ie[14], &uncst_oui[0], 4);\n\t\t\t\t\t/*remove the other unicast suit*/\n\t\t\t\t\tmemcpy(&sec_ie[18],\n\t\t\t\t\t\t&sec_ie[18 + remove_cnt],\n\t\t\t\t\t\tsec_ie[1] - 18 + 2 -\n\t\t\t\t\t\tremove_cnt);\n\t\t\t\t\tsec_ie[1] = sec_ie[1] - remove_cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (authmode == _WPA2_IE_ID_) {\n\t\t\t/* parsing RSN IE to select required encryption\n\t\t\t * algorithm, and set the bc/mc encryption algorithm\n\t\t\t */\n\t\t\twhile (true) {\n\t\t\t\tif ((sec_ie[2] != 0x01) || (sec_ie[3] != 0x0)) {\n\t\t\t\t\t/*IE Ver error*/\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!memcmp(&sec_ie[4], &uncst_oui[0], 3)) {\n\t\t\t\t\t/*get bc/mc encryption type*/\n\t\t\t\t\tswitch (sec_ie[7]) {\n\t\t\t\t\tcase 0x1: /*WEP_40*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP40_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x2: /*TKIP*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_TKIP_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x4: /*AESWRAP*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_AES_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x5: /*WEP_104*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP104_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /*one*/\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_NO_PRIVACY_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sec_ie[8] == 0x01) {\n\t\t\t\t\t/*check the unicast encryption type*/\n\t\t\t\t\tif (memcmp(&sec_ie[10],\n\t\t\t\t\t\t     &uncst_oui[0], 4)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} /*else the uncst_oui is match*/\n\t\t\t\t} else { /*mixed mode, unicast_enc_type > 1*/\n\t\t\t\t\t/*select the uncst_oui and remove the\n\t\t\t\t\t * other uncst_oui\n\t\t\t\t\t */\n\t\t\t\t\tcnt = sec_ie[8];\n\t\t\t\t\tremove_cnt = (cnt - 1) * 4;\n\t\t\t\t\tsec_ie[8] = 0x01;\n\t\t\t\t\tmemcpy(&sec_ie[10], &uncst_oui[0], 4);\n\t\t\t\t\t/*remove the other unicast suit*/\n\t\t\t\t\tmemcpy(&sec_ie[14],\n\t\t\t\t\t\t&sec_ie[14 + remove_cnt],\n\t\t\t\t\t\t(sec_ie[1] - 14 + 2 -\n\t\t\t\t\t\tremove_cnt));\n\t\t\t\t\tsec_ie[1] = sec_ie[1] - remove_cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {\n\t\t/*copy fixed ie*/\n\t\tmemcpy(out_ie, in_ie, 12);\n\t\tielength = 12;\n\t\t/*copy RSN or SSN*/\n\t\tif (match) {\n\t\t\tmemcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1] + 2);\n	f
2034	1676	__nvme_alloc_host_mem	drivers/nvme/host/pci.c	bufs[i]	1	21	\N	\N	\tstruct nvme_host_mem_buf_desc *descs;\n\tu32 max_entries, len;\n\tdma_addr_t descs_dma;\n\tint i = 0;\n\tvoid **bufs;\n\tu64 size = 0, tmp;\n\n\ttmp = (preferred + chunk_size - 1);\n\tdo_div(tmp, chunk_size);\n\tmax_entries = tmp;\n\n\tif (dev->ctrl.hmmaxd && dev->ctrl.hmmaxd < max_entries)\n\t\tmax_entries = dev->ctrl.hmmaxd;\n\n\tdescs = dma_zalloc_coherent(dev->dev, max_entries * sizeof(*descs),\n\t\t\t&descs_dma, GFP_KERNEL);\n\tif (!descs)\n\t\tgoto out;\n\n\tbufs = kcalloc(max_entries, sizeof(*bufs), GFP_KERNEL);\n\tif (!bufs)\n\t\tgoto out_free_descs;\n\n\tfor (size = 0; size < preferred; size += len) {\n\t\tdma_addr_t dma_addr;\n\n\t\tlen = min_t(u64, chunk_size, preferred - size);\n\t\tbufs[i] = dma_alloc_attrs(dev->dev, len, &dma_addr, GFP_KERNEL,\n\t\t\t\tDMA_ATTR_NO_KERNEL_MAPPING | DMA_ATTR_NO_WARN);\n\t\tif (!bufs[i])\n\t\t\tbreak;\n\n\t\tdescs[i].addr = cpu_to_le64(dma_addr);\n\t\tdescs[i].size = cpu_to_le32(len / dev->ctrl.page_size);\n\t\ti++;\n\t}\n\n\tif (!size)\n\t\tgoto out_free_bufs;\n\n\tdev->nr_host_mem_descs = i;\n\tdev->host_mem_size = size;\n\tdev->host_mem_descs = descs;\n\tdev->host_mem_descs_dma = descs_dma;\n\tdev->host_mem_desc_bufs = bufs;\n\treturn 0;\n\nout_free_bufs:\n\twhile (--i >= 0) {\n\t\tsize_t size = le32_to_cpu(descs[i].size) * dev->ctrl.page_size;\n\n\t\tdma_free_coherent(dev->dev, size, bufs[i],\n	f
2055	129	trace_event_raw_event_clk_parent	drivers/clk/clk.c	enable_owner != NULL	1	21	\N	\N	\tunsigned long flags;\n\n\tif (!spin_trylock_irqsave(&enable_lock, flags)) {\n\t\tif (enable_owner == current) {\n\t\t\tenable_refcnt++;\n\t\t\t__acquire(enable_lock);\n\t\t\treturn flags;\n\t\t}\n\t\tspin_lock_irqsave(&enable_lock, flags);\n\t}\n	f
21960	434	batadv_frag_create	net/batman-adv/fragmentation.c	skb_fragment->data	1	11	\N	\N	\tstruct sk_buff *skb_fragment;\n\tunsigned int header_size = sizeof(*frag_head);\n\tunsigned int mtu = fragment_size + header_size;\n\n\tskb_fragment = netdev_alloc_skb(NULL, mtu + ETH_HLEN);\n\tif (!skb_fragment)\n\t\tgoto err;\n\n\tskb_fragment->priority = skb->priority;\n\n\t/* Eat the last mtu-bytes of the skb */\n\tskb_reserve(skb_fragment, header_size + ETH_HLEN);\n\tskb_split(skb, skb_fragment, skb->len - fragment_size);\n\n\t/* Add the header */\n\tskb_push(skb_fragment, header_size);\n\tmemcpy(skb_fragment->data, frag_head, header_size);\n	f
1482	1061	__symbol_put	kernel/module.c	owner	1	-1	\N	BUG();	\tstruct module *owner;\n\n\tpreempt_disable();\n\tif (!find_symbol(symbol, &owner, NULL, true, false))\n\t\tBUG();\n\tmodule_put(owner);\n	t
4942	3414	raid_status	drivers/md/dm-raid.c	array_in_sync)	1	21	\N	\N	\tstruct raid_set *rs = ti->private;\n\tstruct mddev *mddev = &rs->md;\n\tstruct r5conf *conf = mddev->private;\n\tint i, max_nr_stripes = conf ? conf->max_nr_stripes : 0;\n\tbool array_in_sync;\n\tunsigned int raid_param_cnt = 1; /* at least 1 for chunksize */\n\tunsigned int sz = 0;\n\tunsigned int rebuild_disks;\n\tunsigned int write_mostly_params = 0;\n\tsector_t progress, resync_max_sectors, resync_mismatches;\n\tconst char *sync_action;\n\tstruct raid_type *rt;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\t/* *Should* always succeed */\n\t\trt = get_raid_type_by_ll(mddev->new_level, mddev->new_layout);\n\t\tif (!rt)\n\t\t\treturn;\n\n\t\tDMEMIT("%s %d ", rt->name, mddev->raid_disks);\n\n\t\t/* Access most recent mddev properties for status output */\n\t\tsmp_rmb();\n\t\t/* Get sensible max sectors even if raid set not yet started */\n\t\tresync_max_sectors = test_bit(RT_FLAG_RS_PRERESUMED, &rs->runtime_flags) ?\n\t\t\t\t      mddev->resync_max_sectors : mddev->dev_sectors;\n\t\tprogress = rs_get_progress(rs, resync_max_sectors, &array_in_sync);\n\t\tresync_mismatches = (mddev->last_sync_action && !strcasecmp(mddev->last_sync_action, "check")) ?\n\t\t\t\t    atomic64_read(&mddev->resync_mismatches) : 0;\n\t\tsync_action = decipher_sync_action(&rs->md);\n\n\t\t/* HM FIXME: do we want another state char for raid0? It shows 'D'/'A'/'-' now */\n\t\tfor (i = 0; i < rs->raid_disks; i++)\n\t\t\tDMEMIT(__raid_dev_status(rs, &rs->dev[i].rdev, array_in_sync));\n	f
51677	2264	ext4_dx_add_entry	fs/ext4/namei.c	frames	1	11	\N	\N	\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint restart;\n\tint err;\n\nagain:\n\trestart = 0;\n\tframe = dx_probe(fname, dir, NULL, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, fname, dir, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\terr = 0;\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG "using %u of %u node entries\\n",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tint levels = frame - frames + 1;\n\t\tunsigned int icount;\n\t\tint add_level = 1;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\twhile (frame > frames) {\n\t\t\tif (dx_get_count((frame - 1)->entries) <\n\t\t\t    dx_get_limit((frame - 1)->entries)) {\n\t\t\t\tadd_level = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe--; /* split higher index block */\n\t\t\tat = frame->at;\n\t\t\tentries = frame->entries;\n\t\t\trestart = 1;\n\t\t}\n\t\tif (add_level && levels == ext4_dir_htree_level(sb)) {\n\t\t\text4_warning(sb, "Directory (ino: %lu) index full, "\n\t\t\t\t\t "reach max htree level :%d",\n\t\t\t\t\t dir->i_ino, levels);\n\t\t\tif (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {\n\t\t\t\text4_warning(sb, "Large directory feature is "\n\t\t\t\t\t\t "not enabled on this "\n\t\t\t\t\t\t "filesystem");\n\t\t\t}\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ticount = dx_get_count(entries);\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, "get_write_access");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (!add_level) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG "Split index %i/%i\\n",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, "get_write_access"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     (frame - 1)->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block((frame - 1), hash2, newblock);\n\t\t\tdxtrace(dx_show_index("node", frame->entries));\n\t\t\tdxtrace(dx_show_index("node",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t   (frame - 1)->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tif (restart) {\n\t\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t\t   frame->bh);\n\t\t\t\tgoto journal_error;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct dx_root *dxroot;\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\tdxroot = (struct dx_root *)frames[0].bh->b_data;\n	f
5986	93	nvkm_memx_fini	drivers/gpu/drm/nouveau/nvkm/subdev/pmu/memx.c	reply	1	21	\N	TP?	\tstruct nvkm_memx *memx = *pmemx;\n\tstruct nvkm_pmu *pmu = memx->pmu;\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 finish, reply[2];\n\n\t/* flush the cache... */\n\tmemx_out(memx);\n\n\t/* release data segment access */\n\tfinish = nvkm_rd32(device, 0x10a1c0) & 0x00ffffff;\n\tnvkm_wr32(device, 0x10a580, 0x00000000);\n\n\t/* call MEMX process to execute the script, and wait for reply */\n\tif (exec) {\n\t\tnvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_EXEC,\n\t\t\t      memx->base, finish);\n\t}\n\n\tnvkm_debug(subdev, "Exec took %uns, PMU_IN %08x\\n",\n	f
8857	272	rsnd_adg_set_src_timesel_gen2	sound/soc/sh/rcar/adg.c	en	1	21	\N	TP?	\tstruct rsnd_priv *priv = rsnd_mod_to_priv(src_mod);\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tu32 in, out;\n\tu32 mask, en;\n\tint id = rsnd_mod_id(src_mod);\n\tint shift = (id % 2) ? 16 : 0;\n\n\trsnd_mod_confirm_src(src_mod);\n\n\trsnd_adg_get_timesel_ratio(priv, io,\n\t\t\t\t   in_rate, out_rate,\n\t\t\t\t   &in, &out, &en);\n\n\tin   = in\t<< shift;\n\tout  = out\t<< shift;\n\tmask = 0xffff\t<< shift;\n\n\tswitch (id / 2) {\n\tcase 0:\n\t\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL0,  mask, in);\n\t\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL0, mask, out);\n\t\tbreak;\n\tcase 1:\n\t\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL1,  mask, in);\n\t\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL1, mask, out);\n\t\tbreak;\n\tcase 2:\n\t\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL2,  mask, in);\n\t\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL2, mask, out);\n\t\tbreak;\n\tcase 3:\n\t\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL3,  mask, in);\n\t\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL3, mask, out);\n\t\tbreak;\n\tcase 4:\n\t\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL4,  mask, in);\n\t\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL4, mask, out);\n\t\tbreak;\n\t}\n\n\tif (en)\n	f
21230	542	axp20x_power_probe	drivers/power/supply/axp20x_battery.c	ccc	1	11	\N	\N	\tstruct axp20x_batt_ps *axp20x_batt;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct power_supply_battery_info info;\n\n\tif (!of_device_is_available(pdev->dev.of_node))\n\t\treturn -ENODEV;\n\n\taxp20x_batt = devm_kzalloc(&pdev->dev, sizeof(*axp20x_batt),\n\t\t\t\t   GFP_KERNEL);\n\tif (!axp20x_batt)\n\t\treturn -ENOMEM;\n\n\taxp20x_batt->dev = &pdev->dev;\n\n\taxp20x_batt->batt_v = devm_iio_channel_get(&pdev->dev, "batt_v");\n\tif (IS_ERR(axp20x_batt->batt_v)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_v) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_v);\n\t}\n\n\taxp20x_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev,\n\t\t\t\t\t\t\t"batt_chrg_i");\n\tif (IS_ERR(axp20x_batt->batt_chrg_i)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_chrg_i) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_chrg_i);\n\t}\n\n\taxp20x_batt->batt_dischrg_i = devm_iio_channel_get(&pdev->dev,\n\t\t\t\t\t\t\t   "batt_dischrg_i");\n\tif (IS_ERR(axp20x_batt->batt_dischrg_i)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_dischrg_i) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_dischrg_i);\n\t}\n\n\taxp20x_batt->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tplatform_set_drvdata(pdev, axp20x_batt);\n\n\tpsy_cfg.drv_data = axp20x_batt;\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\n\taxp20x_batt->axp_id = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\taxp20x_batt->batt = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t       &axp20x_batt_ps_desc,\n\t\t\t\t\t\t       &psy_cfg);\n\tif (IS_ERR(axp20x_batt->batt)) {\n\t\tdev_err(&pdev->dev, "failed to register power supply: %ld\\n",\n\t\t\tPTR_ERR(axp20x_batt->batt));\n\t\treturn PTR_ERR(axp20x_batt->batt);\n\t}\n\n\tif (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {\n\t\tint vmin = info.voltage_min_design_uv;\n\t\tint ccc = info.constant_charge_current_max_ua;\n\n\t\tif (vmin > 0 && axp20x_set_voltage_min_design(axp20x_batt,\n\t\t\t\t\t\t\t      vmin))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"couldn't set voltage_min_design\\n");\n\n\t\t/* Set max to unverified value to be able to set CCC */\n\t\taxp20x_batt->max_ccc = ccc;\n\n\t\tif (ccc <= 0 || axp20x_set_constant_charge_current(axp20x_batt,\n	t
32543	1576	nfs4_try_open_cached	fs/nfs/nfs4proc.c	&stateid	1	11	\N	\N	\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags;\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tenum open_claim_type4 claim = opendata->o_arg.claim;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tspin_lock(&state->owner->so_lock);\n\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\tgoto out_return_state;\n\t\t}\n\t\tspin_unlock(&state->owner->so_lock);\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (!can_open_delegated(delegation, fmode, claim)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n	f
51588	363	arvo_probe	drivers/hid/hid-roccat-arvo.c	retval	1	11	\N	\N	\tint retval;\n\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, "parse failed\\n");\n\t\tgoto exit;\n\t}\n\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\thid_err(hdev, "hw start failed\\n");\n\t\tgoto exit;\n\t}\n\n\tretval = arvo_init_specials(hdev);\n\tif (retval) {\n	f
1010	2977	sbridge_mce_output_error	drivers/edac/sb_edac.c	ha	1	21	\N	initializer error	\tstruct mem_ctl_info *new_mci;\n\tstruct sbridge_pvt *pvt = mci->pvt_info;\n\tenum hw_event_mc_err_type tp_event;\n\tchar *type, *optype, msg[256];\n\tbool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);\n\tbool overflow = GET_BITFIELD(m->status, 62, 62);\n\tbool uncorrected_error = GET_BITFIELD(m->status, 61, 61);\n\tbool recoverable;\n\tu32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);\n\tu32 mscod = GET_BITFIELD(m->status, 16, 31);\n\tu32 errcode = GET_BITFIELD(m->status, 0, 15);\n\tu32 channel = GET_BITFIELD(m->status, 0, 3);\n\tu32 optypenum = GET_BITFIELD(m->status, 4, 6);\n\tlong channel_mask, first_channel;\n\tu8  rank, socket, ha;\n\tint rc, dimm;\n\tchar *area_type = NULL;\n\n\tif (pvt->info.type != SANDY_BRIDGE)\n\t\trecoverable = true;\n\telse\n\t\trecoverable = GET_BITFIELD(m->status, 56, 56);\n\n\tif (uncorrected_error) {\n\t\tif (ripv) {\n\t\t\ttype = "FATAL";\n\t\t\ttp_event = HW_EVENT_ERR_FATAL;\n\t\t} else {\n\t\t\ttype = "NON_FATAL";\n\t\t\ttp_event = HW_EVENT_ERR_UNCORRECTED;\n\t\t}\n\t} else {\n\t\ttype = "CORRECTED";\n\t\ttp_event = HW_EVENT_ERR_CORRECTED;\n\t}\n\n\t/*\n\t * According with Table 15-9 of the Intel Architecture spec vol 3A,\n\t * memory errors should fit in this mask:\n\t *\t000f 0000 1mmm cccc (binary)\n\t * where:\n\t *\tf = Correction Report Filtering Bit. If 1, subsequent errors\n\t *\t    won't be shown\n\t *\tmmm = error type\n\t *\tcccc = channel\n\t * If the mask doesn't match, report an error to the parsing logic\n\t */\n\tif (! ((errcode & 0xef80) == 0x80)) {\n\t\toptype = "Can't parse: it is not a mem";\n\t} else {\n\t\tswitch (optypenum) {\n\t\tcase 0:\n\t\t\toptype = "generic undef request error";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\toptype = "memory read error";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\toptype = "memory write error";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\toptype = "addr/cmd error";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\toptype = "memory scrubbing error";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toptype = "reserved";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Only decode errors with an valid address (ADDRV) */\n\tif (!GET_BITFIELD(m->status, 58, 58))\n\t\treturn;\n\n\tif (pvt->info.type == KNIGHTS_LANDING) {\n\t\tif (channel == 14) {\n\t\t\tedac_dbg(0, "%s%s err_code:%04x:%04x EDRAM bank %d\\n",\n\t\t\t\toverflow ? " OVERFLOW" : "",\n\t\t\t\t(uncorrected_error && recoverable)\n\t\t\t\t? " recoverable" : "",\n\t\t\t\tmscod, errcode,\n\t\t\t\tm->bank);\n\t\t} else {\n\t\t\tchar A = *("A");\n\n\t\t\t/*\n\t\t\t * Reported channel is in range 0-2, so we can't map it\n\t\t\t * back to mc. To figure out mc we check machine check\n\t\t\t * bank register that reported this error.\n\t\t\t * bank15 means mc0 and bank16 means mc1.\n\t\t\t */\n\t\t\tchannel = knl_channel_remap(m->bank == 16, channel);\n\t\t\tchannel_mask = 1 << channel;\n\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t"%s%s err_code:%04x:%04x channel:%d (DIMM_%c)",\n\t\t\t\toverflow ? " OVERFLOW" : "",\n\t\t\t\t(uncorrected_error && recoverable)\n\t\t\t\t? " recoverable" : " ",\n\t\t\t\tmscod, errcode, channel, A + channel);\n\t\t\tedac_mc_handle_error(tp_event, mci, core_err_cnt,\n\t\t\t\tm->addr >> PAGE_SHIFT, m->addr & ~PAGE_MASK, 0,\n\t\t\t\tchannel, 0, -1,\n\t\t\t\toptype, msg);\n\t\t}\n\t\treturn;\n\t} else {\n\t\trc = get_memory_error_data(mci, m->addr, &socket, &ha,\n\t\t\t\t&channel_mask, &rank, &area_type, msg);\n\t}\n\n\tif (rc < 0)\n\t\tgoto err_parsing;\n\tnew_mci = get_mci_for_node_id(socket, ha);\n	f
31638	302	diva_driver_remove_card	drivers/isdn/hardware/eicon/diva.c	&a[i]->link	1	11	\N	\N	\tdiva_os_spin_lock_magic_t old_irql;\n\tdiva_os_xdi_adapter_t *a[4];\n\tdiva_os_xdi_adapter_t *pa;\n\tint i;\n\n\tpa = a[0] = (diva_os_xdi_adapter_t *) pdiva;\n\ta[1] = a[2] = a[3] = NULL;\n\n\tdiva_os_enter_spin_lock(&adapter_lock, &old_irql, "remode adapter");\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((pa = diva_q_get_next(&pa->link))\n\t\t    && !pa->interface.cleanup_adapter_proc) {\n\t\t\ta[i] = pa;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; ((i < 4) && a[i]); i++) {\n\t\tlist_del(&a[i]->link);\n	t
9115	1134	_rtl_pci_prepare_bcn_tasklet	drivers/net/wireless/realtek/rtlwifi/pci.c	pskb	1	-1	\N	\N	\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl8192_tx_ring *ring = NULL;\n\tstruct ieee80211_hdr *hdr = NULL;\n\tstruct ieee80211_tx_info *info = NULL;\n\tstruct sk_buff *pskb = NULL;\n\tstruct rtl_tx_desc *pdesc = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\t/*This is for new trx flow*/\n\tstruct rtl_tx_buffer_desc *pbuffer_desc = NULL;\n\tu8 temp_one = 1;\n\tu8 *entry;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\tring = &rtlpci->tx_ring[BEACON_QUEUE];\n\tpskb = __skb_dequeue(&ring->queue);\n\tif (rtlpriv->use_new_trx_flow)\n\t\tentry = (u8 *)(&ring->buffer_desc[ring->idx]);\n\telse\n\t\tentry = (u8 *)(&ring->desc[ring->idx]);\n\tif (pskb) {\n\t\tpci_unmap_single(rtlpci->pdev,\n\t\t\t\t rtlpriv->cfg->ops->get_desc(\n\t\t\t\t (u8 *)entry, true, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t pskb->len, PCI_DMA_TODEVICE);\n\t\tkfree_skb(pskb);\n\t}\n\n\t/*NB: the beacon data buffer must be 32-bit aligned. */\n\tpskb = ieee80211_beacon_get(hw, mac->vif);\n\tif (pskb == NULL)\n\t\treturn;\n\thdr = rtl_get_hdr(pskb);\n	f
8361	412	arfs_del_rules	drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c	arfs_del_rules_$__mptr21$obj	0	11	\N	\N	\tstruct hlist_node *htmp;\n\tstruct arfs_rule *rule;\n\tint i;\n\tint j;\n\n\tHLIST_HEAD(del_list);\n\tspin_lock_bh(&priv->fs.arfs.arfs_lock);\n\tmlx5e_for_each_arfs_rule(rule, htmp, priv->fs.arfs.arfs_tables, i, j) {\n	t
-8	319	axi_clkgen_recalc_rate	drivers/clk/clk-axi-clkgen.c	reg	20	2	arg_no	\N	\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\tunsigned int d, m, dout;\n\tunsigned int reg;\n\tunsigned long long tmp;\n\n\taxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLKOUT0_1, &reg);\n\tdout = (reg & 0x3f) + ((reg >> 6) & 0x3f);\n	f
36762	626	at91_read_msg	drivers/net/can/at91_can.c	cf->can_dlc	1	11	\N	\N	\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_can_skb(dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tat91_read_mb(dev, mb, cf);\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n	f
8410	93	cros_ec_pkt_xfer_lpc	drivers/platform/chrome/cros_ec_lpc.c	response.data_len	1	21	\N	\N	\tstruct ec_host_request *request;\n\tstruct ec_host_response response;\n\tu8 sum;\n\tint ret = 0;\n\tu8 *dout;\n\n\tret = cros_ec_prepare_tx(ec, msg);\n\n\t/* Write buffer */\n\tcros_ec_lpc_write_bytes(EC_LPC_ADDR_HOST_PACKET, ret, ec->dout);\n\n\trequest = (struct ec_host_request *)ec->dout;\n\n\t/* Here we go */\n\tsum = EC_COMMAND_PROTOCOL_3;\n\tcros_ec_lpc_write_bytes(EC_LPC_ADDR_HOST_CMD, 1, &sum);\n\n\tif (ec_response_timed_out()) {\n\t\tdev_warn(ec->dev, "EC responsed timed out\\n");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t/* Check result */\n\tmsg->result = cros_ec_lpc_read_bytes(EC_LPC_ADDR_HOST_DATA, 1, &sum);\n\tret = cros_ec_check_result(ec, msg);\n\tif (ret)\n\t\tgoto done;\n\n\t/* Read back response */\n\tdout = (u8 *)&response;\n\tsum = cros_ec_lpc_read_bytes(EC_LPC_ADDR_HOST_PACKET, sizeof(response),\n\t\t\t\t     dout);\n\n\tmsg->result = response.result;\n\n\tif (response.data_len > msg->insize) {\n	f
54374	1096	ubifs_clean_lebs	fs/ubifs/recovery.c	err	1	11	\N	\N	\tdbg_rcvry("recovery");\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\t\tint err;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\terr = clean_an_unclean_leb(c, ucleb, sbuf);\n\t\tif (err)\n	t
32240	1787	dce_v11_0_afmt_setmode	drivers/gpu/drm/amd/amdgpu/dce_v11_0.c	&frame	1	11	\N	\N	\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_device *adev = dev->dev_private;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\tstruct drm_connector *connector = amdgpu_get_connector_for_encoder(encoder);\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\n\tstruct hdmi_avi_infoframe frame;\n\tssize_t err;\n\tu32 tmp;\n\tint bpc = 8;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\t/* Silent, r600_hdmi_enable will raise WARN for us */\n\tif (!dig->afmt->enabled)\n\t\treturn;\n\n\t/* hdmi deep color mode general control packets setup, if bpc > 8 */\n\tif (encoder->crtc) {\n\t\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(encoder->crtc);\n\t\tbpc = amdgpu_crtc->bpc;\n\t}\n\n\t/* disable audio prior to setting up hw */\n\tdig->afmt->pin = dce_v11_0_audio_get_pin(adev);\n\tdce_v11_0_audio_enable(adev, dig->afmt->pin, false);\n\n\tdce_v11_0_audio_set_dto(encoder, mode->clock);\n\n\ttmp = RREG32(mmHDMI_VBI_PACKET_CONTROL + dig->afmt->offset);\n\ttmp = REG_SET_FIELD(tmp, HDMI_VBI_PACKET_CONTROL, HDMI_NULL_SEND, 1);\n\tWREG32(mmHDMI_VBI_PACKET_CONTROL + dig->afmt->offset, tmp); /* send null packets when required */\n\n\tWREG32(mmAFMT_AUDIO_CRC_CONTROL + dig->afmt->offset, 0x1000);\n\n\ttmp = RREG32(mmHDMI_CONTROL + dig->afmt->offset);\n\tswitch (bpc) {\n\tcase 0:\n\tcase 6:\n\tcase 8:\n\tcase 16:\n\tdefault:\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_ENABLE, 0);\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 0);\n\t\tDRM_DEBUG("%s: Disabling hdmi deep color for %d bpc.\\n",\n\t\t\t  connector->name, bpc);\n\t\tbreak;\n\tcase 10:\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_ENABLE, 1);\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 1);\n\t\tDRM_DEBUG("%s: Enabling hdmi deep color 30 for 10 bpc.\\n",\n\t\t\t  connector->name);\n\t\tbreak;\n\tcase 12:\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_ENABLE, 1);\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 2);\n\t\tDRM_DEBUG("%s: Enabling hdmi deep color 36 for 12 bpc.\\n",\n\t\t\t  connector->name);\n\t\tbreak;\n\t}\n\tWREG32(mmHDMI_CONTROL + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmHDMI_VBI_PACKET_CONTROL + dig->afmt->offset);\n\ttmp = REG_SET_FIELD(tmp, HDMI_VBI_PACKET_CONTROL, HDMI_NULL_SEND, 1); /* send null packets when required */\n\ttmp = REG_SET_FIELD(tmp, HDMI_VBI_PACKET_CONTROL, HDMI_GC_SEND, 1); /* send general control packets */\n\ttmp = REG_SET_FIELD(tmp, HDMI_VBI_PACKET_CONTROL, HDMI_GC_CONT, 1); /* send general control packets every frame */\n\tWREG32(mmHDMI_VBI_PACKET_CONTROL + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmHDMI_INFOFRAME_CONTROL0 + dig->afmt->offset);\n\t/* enable audio info frames (frames won't be set until audio is enabled) */\n\ttmp = REG_SET_FIELD(tmp, HDMI_INFOFRAME_CONTROL0, HDMI_AUDIO_INFO_SEND, 1);\n\t/* required for audio info values to be updated */\n\ttmp = REG_SET_FIELD(tmp, HDMI_INFOFRAME_CONTROL0, HDMI_AUDIO_INFO_CONT, 1);\n\tWREG32(mmHDMI_INFOFRAME_CONTROL0 + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmAFMT_INFOFRAME_CONTROL0 + dig->afmt->offset);\n\t/* required for audio info values to be updated */\n\ttmp = REG_SET_FIELD(tmp, AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);\n\tWREG32(mmAFMT_INFOFRAME_CONTROL0 + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmHDMI_INFOFRAME_CONTROL1 + dig->afmt->offset);\n\t/* anything other than 0 */\n\ttmp = REG_SET_FIELD(tmp, HDMI_INFOFRAME_CONTROL1, HDMI_AUDIO_INFO_LINE, 2);\n\tWREG32(mmHDMI_INFOFRAME_CONTROL1 + dig->afmt->offset, tmp);\n\n\tWREG32(mmHDMI_GC + dig->afmt->offset, 0); /* unset HDMI_GC_AVMUTE */\n\n\ttmp = RREG32(mmHDMI_AUDIO_PACKET_CONTROL + dig->afmt->offset);\n\t/* set the default audio delay */\n\ttmp = REG_SET_FIELD(tmp, HDMI_AUDIO_PACKET_CONTROL, HDMI_AUDIO_DELAY_EN, 1);\n\t/* should be suffient for all audio modes and small enough for all hblanks */\n\ttmp = REG_SET_FIELD(tmp, HDMI_AUDIO_PACKET_CONTROL, HDMI_AUDIO_PACKETS_PER_LINE, 3);\n\tWREG32(mmHDMI_AUDIO_PACKET_CONTROL + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmAFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset);\n\t/* allow 60958 channel status fields to be updated */\n\ttmp = REG_SET_FIELD(tmp, AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);\n\tWREG32(mmAFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmHDMI_ACR_PACKET_CONTROL + dig->afmt->offset);\n\tif (bpc > 8)\n\t\t/* clear SW CTS value */\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_ACR_PACKET_CONTROL, HDMI_ACR_SOURCE, 0);\n\telse\n\t\t/* select SW CTS value */\n\t\ttmp = REG_SET_FIELD(tmp, HDMI_ACR_PACKET_CONTROL, HDMI_ACR_SOURCE, 1);\n\t/* allow hw to sent ACR packets when required */\n\ttmp = REG_SET_FIELD(tmp, HDMI_ACR_PACKET_CONTROL, HDMI_ACR_AUTO_SEND, 1);\n\tWREG32(mmHDMI_ACR_PACKET_CONTROL + dig->afmt->offset, tmp);\n\n\tdce_v11_0_afmt_update_ACR(encoder, mode->clock);\n\n\ttmp = RREG32(mmAFMT_60958_0 + dig->afmt->offset);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_0, AFMT_60958_CS_CHANNEL_NUMBER_L, 1);\n\tWREG32(mmAFMT_60958_0 + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmAFMT_60958_1 + dig->afmt->offset);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_1, AFMT_60958_CS_CHANNEL_NUMBER_R, 2);\n\tWREG32(mmAFMT_60958_1 + dig->afmt->offset, tmp);\n\n\ttmp = RREG32(mmAFMT_60958_2 + dig->afmt->offset);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_2, 3);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_3, 4);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_4, 5);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_5, 6);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_6, 7);\n\ttmp = REG_SET_FIELD(tmp, AFMT_60958_2, AFMT_60958_CS_CHANNEL_NUMBER_7, 8);\n\tWREG32(mmAFMT_60958_2 + dig->afmt->offset, tmp);\n\n\tdce_v11_0_audio_write_speaker_allocation(encoder);\n\n\tWREG32(mmAFMT_AUDIO_PACKET_CONTROL2 + dig->afmt->offset,\n\t       (0xff << AFMT_AUDIO_PACKET_CONTROL2__AFMT_AUDIO_CHANNEL_ENABLE__SHIFT));\n\n\tdce_v11_0_afmt_audio_select_pin(encoder);\n\tdce_v11_0_audio_write_sad_regs(encoder);\n\tdce_v11_0_audio_write_latency_fields(encoder, mode);\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, false);\n\tif (err < 0) {\n\t\tDRM_ERROR("failed to setup AVI infoframe: %zd\\n", err);\n\t\treturn;\n\t}\n\n\terr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n	t
24820	300	ata_acpi_gtm	drivers/ata/libata-acpi.c	status	0	11	\N	\N	\tstruct acpi_buffer output = { .length = ACPI_ALLOCATE_BUFFER };\n\tunion acpi_object *out_obj;\n\tacpi_status status;\n\tint rc = 0;\n\tacpi_handle handle = ACPI_HANDLE(&ap->tdev);\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_object(handle, "_GTM", NULL, &output);\n\n\trc = -ENOENT;\n\tif (status == AE_NOT_FOUND)\n	f
31151	311	async_syndrome_val	crypto/async_tx/async_pq.c	async_syndrome_val_	0	11	\N	\N	\tstruct dma_chan *chan = pq_val_chan(submit, blocks, disks, len);\n\tstruct dma_device *device = chan ? chan->device : NULL;\n\tstruct dma_async_tx_descriptor *tx;\n\tunsigned char coefs[disks-2];\n\tenum dma_ctrl_flags dma_flags = submit->cb_fn ? DMA_PREP_INTERRUPT : 0;\n\tstruct dmaengine_unmap_data *unmap = NULL;\n\n\tBUG_ON(disks < 4);\n\n\tif (device)\n\t\tunmap = dmaengine_get_unmap_data(device->dev, disks, GFP_NOWAIT);\n\n\tif (unmap && disks <= dma_maxpq(device, 0) &&\n	f
27433	694	i40iw_create_qp	drivers/infiniband/hw/i40iw/i40iw_verbs.c	req.user_wqe_buffers	1	-1	\N	\N	\tstruct i40iw_pd *iwpd = to_iwpd(ibpd);\n\tstruct i40iw_device *iwdev = to_iwdev(ibpd->device);\n\tstruct i40iw_cqp *iwcqp = &iwdev->cqp;\n\tstruct i40iw_qp *iwqp;\n\tstruct i40iw_ucontext *ucontext;\n\tstruct i40iw_create_qp_req req;\n\tstruct i40iw_create_qp_resp uresp;\n\tu32 qp_num = 0;\n\tvoid *mem;\n\tenum i40iw_status_code ret;\n\tint err_code;\n\tint sq_size;\n\tint rq_size;\n\tstruct i40iw_sc_qp *qp;\n\tstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\n\tstruct i40iw_qp_init_info init_info;\n\tstruct i40iw_create_qp_info *qp_info;\n\tstruct i40iw_cqp_request *cqp_request;\n\tstruct cqp_commands_info *cqp_info;\n\n\tstruct i40iw_qp_host_ctx_info *ctx_info;\n\tstruct i40iwarp_offload_info *iwarp_info;\n\tunsigned long flags;\n\n\tif (iwdev->closing)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (init_attr->create_flags)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (init_attr->cap.max_inline_data > I40IW_MAX_INLINE_DATA_SIZE)\n\t\tinit_attr->cap.max_inline_data = I40IW_MAX_INLINE_DATA_SIZE;\n\n\tif (init_attr->cap.max_send_sge > I40IW_MAX_WQ_FRAGMENT_COUNT)\n\t\tinit_attr->cap.max_send_sge = I40IW_MAX_WQ_FRAGMENT_COUNT;\n\n\tif (init_attr->cap.max_recv_sge > I40IW_MAX_WQ_FRAGMENT_COUNT)\n\t\tinit_attr->cap.max_recv_sge = I40IW_MAX_WQ_FRAGMENT_COUNT;\n\n\tmemset(&init_info, 0, sizeof(init_info));\n\n\tsq_size = init_attr->cap.max_send_wr;\n\trq_size = init_attr->cap.max_recv_wr;\n\n\tinit_info.vsi = &iwdev->vsi;\n\tinit_info.qp_uk_init_info.sq_size = sq_size;\n\tinit_info.qp_uk_init_info.rq_size = rq_size;\n\tinit_info.qp_uk_init_info.max_sq_frag_cnt = init_attr->cap.max_send_sge;\n\tinit_info.qp_uk_init_info.max_rq_frag_cnt = init_attr->cap.max_recv_sge;\n\tinit_info.qp_uk_init_info.max_inline_data = init_attr->cap.max_inline_data;\n\n\tmem = kzalloc(sizeof(*iwqp), GFP_KERNEL);\n\tif (!mem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiwqp = (struct i40iw_qp *)mem;\n\tqp = &iwqp->sc_qp;\n\tqp->back_qp = (void *)iwqp;\n\tqp->push_idx = I40IW_INVALID_PUSH_PAGE_INDEX;\n\n\tiwqp->ctx_info.iwarp_info = &iwqp->iwarp_info;\n\n\tif (i40iw_allocate_dma_mem(dev->hw,\n\t\t\t\t   &iwqp->q2_ctx_mem,\n\t\t\t\t   I40IW_Q2_BUFFER_SIZE + I40IW_QP_CTX_SIZE,\n\t\t\t\t   256)) {\n\t\ti40iw_pr_err("dma_mem failed\\n");\n\t\terr_code = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_info.q2 = iwqp->q2_ctx_mem.va;\n\tinit_info.q2_pa = iwqp->q2_ctx_mem.pa;\n\n\tinit_info.host_ctx = (void *)init_info.q2 + I40IW_Q2_BUFFER_SIZE;\n\tinit_info.host_ctx_pa = init_info.q2_pa + I40IW_Q2_BUFFER_SIZE;\n\n\terr_code = i40iw_alloc_resource(iwdev, iwdev->allocated_qps, iwdev->max_qp,\n\t\t\t\t\t&qp_num, &iwdev->next_qp);\n\tif (err_code) {\n\t\ti40iw_pr_err("qp resource\\n");\n\t\tgoto error;\n\t}\n\n\tiwqp->allocated_buffer = mem;\n\tiwqp->iwdev = iwdev;\n\tiwqp->iwpd = iwpd;\n\tiwqp->ibqp.qp_num = qp_num;\n\tqp = &iwqp->sc_qp;\n\tiwqp->iwscq = to_iwcq(init_attr->send_cq);\n\tiwqp->iwrcq = to_iwcq(init_attr->recv_cq);\n\n\tiwqp->host_ctx.va = init_info.host_ctx;\n\tiwqp->host_ctx.pa = init_info.host_ctx_pa;\n\tiwqp->host_ctx.size = I40IW_QP_CTX_SIZE;\n\n\tinit_info.pd = &iwpd->sc_pd;\n\tinit_info.qp_uk_init_info.qp_id = iwqp->ibqp.qp_num;\n\tiwqp->ctx_info.qp_compl_ctx = (uintptr_t)qp;\n\n\tif (init_attr->qp_type != IB_QPT_RC) {\n\t\terr_code = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (iwdev->push_mode)\n\t\ti40iw_alloc_push_page(iwdev, qp);\n\tif (udata) {\n\t\terr_code = ib_copy_from_udata(&req, udata, sizeof(req));\n\t\tif (err_code) {\n\t\t\ti40iw_pr_err("ib_copy_from_data\\n");\n\t\t\tgoto error;\n\t\t}\n\t\tiwqp->ctx_info.qp_compl_ctx = req.user_compl_ctx;\n\t\tif (ibpd->uobject && ibpd->uobject->context) {\n\t\t\tiwqp->user_mode = 1;\n\t\t\tucontext = to_ucontext(ibpd->uobject->context);\n\n\t\t\tif (req.user_wqe_buffers) {\n	f
985	1116	e752x_init_csrows	drivers/edac/e752x_edac.c	drc_ddim	1	11	\N	\N	\tstruct csrow_info *csrow;\n\tenum edac_type edac_mode;\n\tunsigned long last_cumul_size;\n\tint index, mem_dev, drc_chan;\n\tint drc_drbg;\t\t/* DRB granularity 0=64mb, 1=128mb */\n\tint drc_ddim;\t\t/* DRAM Data Integrity Mode 0=none, 2=edac */\n\tu8 value;\n\tu32 dra, drc, cumul_size, i, nr_pages;\n\n\tdra = 0;\n\tfor (index = 0; index < 4; index++) {\n\t\tu8 dra_reg;\n\t\tpci_read_config_byte(pdev, E752X_DRA + index, &dra_reg);\n\t\tdra |= dra_reg << (index * 8);\n\t}\n\tpci_read_config_dword(pdev, E752X_DRC, &drc);\n\tdrc_chan = dual_channel_active(ddrcsr) ? 1 : 0;\n\tdrc_drbg = drc_chan + 1;\t/* 128 in dual mode, 64 in single */\n\tdrc_ddim = (drc >> 20) & 0x3;\n\n\t/* The dram row boundary (DRB) reg values are boundary address for\n\t * each DRAM row with a granularity of 64 or 128MB (single/dual\n\t * channel operation).  DRB regs are cumulative; therefore DRB7 will\n\t * contain the total memory contained in all eight rows.\n\t */\n\tfor (last_cumul_size = index = 0; index < mci->nr_csrows; index++) {\n\t\t/* mem_dev 0=x8, 1=x4 */\n\t\tmem_dev = (dra >> (index * 4 + 2)) & 0x3;\n\t\tcsrow = mci->csrows[remap_csrow_index(mci, index)];\n\n\t\tmem_dev = (mem_dev == 2);\n\t\tpci_read_config_byte(pdev, E752X_DRB + index, &value);\n\t\t/* convert a 128 or 64 MiB DRB to a page size. */\n\t\tcumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\n\t\tedac_dbg(3, "(%d) cumul_size 0x%x\\n", index, cumul_size);\n\t\tif (cumul_size == last_cumul_size)\n\t\t\tcontinue;\t/* not populated */\n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tlast_cumul_size = cumul_size;\n\n\t\t/*\n\t\t* if single channel or x8 devices then SECDED\n\t\t* if dual channel and x4 then S4ECD4ED\n\t\t*/\n\t\tif (drc_ddim) {\n	t
5321	378	nvkm_dp_train	drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c	pwr	1	-1	\N	\N	\tstruct nvkm_ior *ior = dp->outp.ior;\n\tconst u8 sink_nr = dp->dpcd[DPCD_RC02] & DPCD_RC02_MAX_LANE_COUNT;\n\tconst u8 sink_bw = dp->dpcd[DPCD_RC01_MAX_LINK_RATE];\n\tconst u8 outp_nr = dp->outp.info.dpconf.link_nr;\n\tconst u8 outp_bw = dp->outp.info.dpconf.link_bw;\n\tconst struct dp_rates *failsafe = NULL, *cfg;\n\tint ret = -EINVAL;\n\tu8  pwr;\n\n\t/* Find the lowest configuration of the OR that can support\n\t * the required link rate.\n\t *\n\t * We will refuse to program the OR to lower rates, even if\n\t * link training fails at higher rates (or even if the sink\n\t * can't support the rate at all, though the DD is supposed\n\t * to prevent such situations from happening).\n\t *\n\t * Attempting to do so can cause the entire display to hang,\n\t * and it's better to have a failed modeset than that.\n\t */\n\tfor (cfg = nvkm_dp_rates; cfg->rate; cfg++) {\n\t\tif (cfg->nr <= outp_nr && cfg->nr <= outp_bw)\n\t\t\tfailsafe = cfg;\n\t\tif (failsafe && cfg[1].rate < dataKBps)\n\t\t\tbreak;\n\t}\n\n\tif (WARN_ON(!failsafe))\n\t\treturn ret;\n\n\t/* Ensure sink is not in a low-power state. */\n\tif (!nvkm_rdaux(dp->aux, DPCD_SC00, &pwr, 1)) {\n\t\tif ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {\n	f
-9	804	ctrl_cx2341x_getv4lflags	drivers/media/usb/pvrusb2/pvrusb2-hdw.c	qctrl.flags	25	2	arg_no	\N	\tstruct v4l2_queryctrl qctrl;\n\tstruct pvr2_ctl_info *info;\n\tqctrl.id = cptr->info->v4l_id;\n\tcx2341x_ctrl_query(&cptr->hdw->enc_ctl_state,&qctrl);\n\t/* Strip out the const so we can adjust a function pointer.  It's\n\t   OK to do this here because we know this is a dynamically created\n\t   control, so the underlying storage for the info pointer is (a)\n\t   private to us, and (b) not in read-only storage.  Either we do\n\t   this or we significantly complicate the underlying control\n\t   implementation. */\n\tinfo = (struct pvr2_ctl_info *)(cptr->info);\n\tif (qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY) {\n	f
9338	715	cpu_detect	arch/x86/kernel/cpu/common.c	cap0	1	21	\N	\N	\t/* Get vendor name */\n\tcpuid(0x00000000, (unsigned int *)&c->cpuid_level,\n\t      (unsigned int *)&c->x86_vendor_id[0],\n\t      (unsigned int *)&c->x86_vendor_id[8],\n\t      (unsigned int *)&c->x86_vendor_id[4]);\n\n\tc->x86 = 4;\n\t/* Intel-defined flags: level 0x00000001 */\n\tif (c->cpuid_level >= 0x00000001) {\n\t\tu32 junk, tfms, cap0, misc;\n\n\t\tcpuid(0x00000001, &tfms, &misc, &junk, &cap0);\n\t\tc->x86\t\t= x86_family(tfms);\n\t\tc->x86_model\t= x86_model(tfms);\n\t\tc->x86_mask\t= x86_stepping(tfms);\n\n\t\tif (cap0 & (1<<19)) {\n	f
51923	376	ad7793_write_frequency	drivers/iio/adc/ad7793.c	lval	1	11	\N	\N	\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7793_state *st = iio_priv(indio_dev);\n\tlong lval;\n\tint i, ret;\n\n\tret = kstrtol(buf, 10, &lval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lval == 0)\n	f
1222	14579	bnx2x_cnic_sp_post	drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c	bp	1	11	\N	\N	\tstruct eth_spe *spe;\n\tint cxt_index, cxt_offset;\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn;\n#endif\n\n\tspin_lock_bh(&bp->spq_lock);\n\tBUG_ON(bp->cnic_spq_pending < count);\n\tbp->cnic_spq_pending -= count;\n\n\tfor (; bp->cnic_kwq_pending; bp->cnic_kwq_pending--) {\n\t\tu16 type =  (le16_to_cpu(bp->cnic_kwq_cons->hdr.type)\n\t\t\t\t& SPE_HDR_CONN_TYPE) >>\n\t\t\t\tSPE_HDR_CONN_TYPE_SHIFT;\n\t\tu8 cmd = (le32_to_cpu(bp->cnic_kwq_cons->hdr.conn_and_cmd_data)\n\t\t\t\t>> SPE_HDR_CMD_ID_SHIFT) & 0xff;\n\n\t\t/* Set validation for iSCSI L2 client before sending SETUP\n\t\t *  ramrod\n\t\t */\n\t\tif (type == ETH_CONNECTION_TYPE) {\n\t\t\tif (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP) {\n\t\t\t\tcxt_index = BNX2X_ISCSI_ETH_CID(bp) /\n\t\t\t\t\tILT_PAGE_CIDS;\n\t\t\t\tcxt_offset = BNX2X_ISCSI_ETH_CID(bp) -\n\t\t\t\t\t(cxt_index * ILT_PAGE_CIDS);\n\t\t\t\tbnx2x_set_ctx_validation(bp,\n\t\t\t\t\t&bp->context[cxt_index].\n\t\t\t\t\t\t\t vcxt[cxt_offset].eth,\n\t\t\t\t\tBNX2X_ISCSI_ETH_CID(bp));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * There may be not more than 8 L2, not more than 8 L5 SPEs\n\t\t * and in the air. We also check that number of outstanding\n\t\t * COMMON ramrods is not more than the EQ and SPQ can\n\t\t * accommodate.\n\t\t */\n\t\tif (type == ETH_CONNECTION_TYPE) {\n\t\t\tif (!atomic_read(&bp->cq_spq_left))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tatomic_dec(&bp->cq_spq_left);\n\t\t} else if (type == NONE_CONNECTION_TYPE) {\n\t\t\tif (!atomic_read(&bp->eq_spq_left))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tatomic_dec(&bp->eq_spq_left);\n\t\t} else if ((type == ISCSI_CONNECTION_TYPE) ||\n\t\t\t   (type == FCOE_CONNECTION_TYPE)) {\n\t\t\tif (bp->cnic_spq_pending >=\n\t\t\t    bp->cnic_eth_dev.max_kwqe_pending)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tbp->cnic_spq_pending++;\n\t\t} else {\n\t\t\tBNX2X_ERR("Unknown SPE type: %d\\n", type);\n\t\t\tbnx2x_panic();\n\t\t\tbreak;\n\t\t}\n\n\t\tspe = bnx2x_sp_get_next(bp);\n	t
41142	262	dccp_parse_options	net/dccp/options.c	value	2	-11	\N	\N	\tstruct dccp_sock *dp = dccp_sk(sk);\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tconst u8 pkt_type = DCCP_SKB_CB(skb)->dccpd_type;\n\tunsigned char *options = (unsigned char *)dh + dccp_hdr_len(skb);\n\tunsigned char *opt_ptr = options;\n\tconst unsigned char *opt_end = (unsigned char *)dh +\n\t\t\t\t\t(dh->dccph_doff * 4);\n\tstruct dccp_options_received *opt_recv = &dp->dccps_options_received;\n\tunsigned char opt, len;\n\tunsigned char *uninitialized_var(value);\n\tu32 elapsed_time;\n\t__be32 opt_val;\n\tint rc;\n\tint mandatory = 0;\n\n\tmemset(opt_recv, 0, sizeof(*opt_recv));\n\n\topt = len = 0;\n\twhile (opt_ptr != opt_end) {\n\t\topt   = *opt_ptr++;\n\t\tlen   = 0;\n\t\tvalue = NULL;\n\n\t\t/* Check if this isn't a single byte option */\n\t\tif (opt > DCCPO_MAX_RESERVED) {\n\t\t\tif (opt_ptr == opt_end)\n\t\t\t\tgoto out_nonsensical_length;\n\n\t\t\tlen = *opt_ptr++;\n\t\t\tif (len < 2)\n\t\t\t\tgoto out_nonsensical_length;\n\t\t\t/*\n\t\t\t * Remove the type and len fields, leaving\n\t\t\t * just the value size\n\t\t\t */\n\t\t\tlen\t-= 2;\n\t\t\tvalue\t= opt_ptr;\n\t\t\topt_ptr += len;\n\n\t\t\tif (opt_ptr > opt_end)\n\t\t\t\tgoto out_nonsensical_length;\n\t\t}\n\n\t\t/*\n\t\t * CCID-specific options are ignored during connection setup, as\n\t\t * negotiation may still be in progress (see RFC 4340, 10.3).\n\t\t * The same applies to Ack Vectors, as these depend on the CCID.\n\t\t */\n\t\tif (dreq != NULL && (opt >= DCCPO_MIN_RX_CCID_SPECIFIC ||\n\t\t    opt == DCCPO_ACK_VECTOR_0 || opt == DCCPO_ACK_VECTOR_1))\n\t\t\tgoto ignore_option;\n\n\t\tswitch (opt) {\n\t\tcase DCCPO_PADDING:\n\t\t\tbreak;\n\t\tcase DCCPO_MANDATORY:\n\t\t\tif (mandatory)\n\t\t\t\tgoto out_invalid_option;\n\t\t\tif (pkt_type != DCCP_PKT_DATA)\n\t\t\t\tmandatory = 1;\n\t\t\tbreak;\n\t\tcase DCCPO_NDP_COUNT:\n\t\t\tif (len > 6)\n\t\t\t\tgoto out_invalid_option;\n\n\t\t\topt_recv->dccpor_ndp = dccp_decode_value_var(value, len);\n\t\t\tdccp_pr_debug("%s opt: NDP count=%llu\\n", dccp_role(sk),\n\t\t\t\t      (unsigned long long)opt_recv->dccpor_ndp);\n\t\t\tbreak;\n\t\tcase DCCPO_CHANGE_L ... DCCPO_CONFIRM_R:\n\t\t\tif (pkt_type == DCCP_PKT_DATA)      /* RFC 4340, 6 */\n\t\t\t\tbreak;\n\t\t\tif (len == 0)\n\t\t\t\tgoto out_invalid_option;\n\t\t\trc = dccp_feat_parse_options(sk, dreq, mandatory, opt,\n\t\t\t\t\t\t    *value, value + 1, len - 1);\n\t\t\tif (rc)\n\t\t\t\tgoto out_featneg_failed;\n\t\t\tbreak;\n\t\tcase DCCPO_TIMESTAMP:\n\t\t\tif (len != 4)\n\t\t\t\tgoto out_invalid_option;\n\t\t\t/*\n\t\t\t * RFC 4340 13.1: "The precise time corresponding to\n\t\t\t * Timestamp Value zero is not specified". We use\n\t\t\t * zero to indicate absence of a meaningful timestamp.\n\t\t\t */\n\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\tif (unlikely(opt_val == 0)) {\n\t\t\t\tDCCP_WARN("Timestamp with zero value\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dreq != NULL) {\n\t\t\t\tdreq->dreq_timestamp_echo = ntohl(opt_val);\n\t\t\t\tdreq->dreq_timestamp_time = dccp_timestamp();\n\t\t\t} else {\n\t\t\t\topt_recv->dccpor_timestamp =\n\t\t\t\t\tdp->dccps_timestamp_echo = ntohl(opt_val);\n\t\t\t\tdp->dccps_timestamp_time = dccp_timestamp();\n\t\t\t}\n\t\t\tdccp_pr_debug("%s rx opt: TIMESTAMP=%u, ackno=%llu\\n",\n\t\t\t\t      dccp_role(sk), ntohl(opt_val),\n\t\t\t\t      (unsigned long long)\n\t\t\t\t      DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\t\t\t/* schedule an Ack in case this sender is quiescent */\n\t\t\tinet_csk_schedule_ack(sk);\n\t\t\tbreak;\n\t\tcase DCCPO_TIMESTAMP_ECHO:\n\t\t\tif (len != 4 && len != 6 && len != 8)\n\t\t\t\tgoto out_invalid_option;\n\n\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\topt_recv->dccpor_timestamp_echo = ntohl(opt_val);\n\n\t\t\tdccp_pr_debug("%s rx opt: TIMESTAMP_ECHO=%u, len=%d, "\n\t\t\t\t      "ackno=%llu", dccp_role(sk),\n\t\t\t\t      opt_recv->dccpor_timestamp_echo,\n\t\t\t\t      len + 2,\n\t\t\t\t      (unsigned long long)\n\t\t\t\t      DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\n\t\t\tvalue += 4;\n\n\t\t\tif (len == 4) {\t\t/* no elapsed time included */\n\t\t\t\tdccp_pr_debug_cat("\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (len == 6) {\t\t/* 2-byte elapsed time */\n\t\t\t\t__be16 opt_val2 = get_unaligned((__be16 *)value);\n\t\t\t\telapsed_time = ntohs(opt_val2);\n\t\t\t} else {\t\t/* 4-byte elapsed time */\n\t\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\t\telapsed_time = ntohl(opt_val);\n\t\t\t}\n\n\t\t\tdccp_pr_debug_cat(", ELAPSED_TIME=%u\\n", elapsed_time);\n\n\t\t\t/* Give precedence to the biggest ELAPSED_TIME */\n\t\t\tif (elapsed_time > opt_recv->dccpor_elapsed_time)\n\t\t\t\topt_recv->dccpor_elapsed_time = elapsed_time;\n\t\t\tbreak;\n\t\tcase DCCPO_ELAPSED_TIME:\n\t\t\tif (dccp_packet_without_ack(skb))   /* RFC 4340, 13.2 */\n\t\t\t\tbreak;\n\n\t\t\tif (len == 2) {\n\t\t\t\t__be16 opt_val2 = get_unaligned((__be16 *)value);\n\t\t\t\telapsed_time = ntohs(opt_val2);\n\t\t\t} else if (len == 4) {\n\t\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\t\telapsed_time = ntohl(opt_val);\n\t\t\t} else {\n\t\t\t\tgoto out_invalid_option;\n\t\t\t}\n\n\t\t\tif (elapsed_time > opt_recv->dccpor_elapsed_time)\n\t\t\t\topt_recv->dccpor_elapsed_time = elapsed_time;\n\n\t\t\tdccp_pr_debug("%s rx opt: ELAPSED_TIME=%d\\n",\n\t\t\t\t      dccp_role(sk), elapsed_time);\n\t\t\tbreak;\n\t\tcase DCCPO_MIN_RX_CCID_SPECIFIC ... DCCPO_MAX_RX_CCID_SPECIFIC:\n\t\t\tif (ccid_hc_rx_parse_options(dp->dccps_hc_rx_ccid, sk,\n\t\t\t\t\t\t     pkt_type, opt, value, len))\n\t\t\t\tgoto out_invalid_option;\n\t\t\tbreak;\n\t\tcase DCCPO_ACK_VECTOR_0:\n\t\tcase DCCPO_ACK_VECTOR_1:\n\t\t\tif (dccp_packet_without_ack(skb))   /* RFC 4340, 11.4 */\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Ack vectors are processed by the TX CCID if it is\n\t\t\t * interested. The RX CCID need not parse Ack Vectors,\n\t\t\t * since it is only interested in clearing old state.\n\t\t\t * Fall through.\n\t\t\t */\n\t\tcase DCCPO_MIN_TX_CCID_SPECIFIC ... DCCPO_MAX_TX_CCID_SPECIFIC:\n\t\t\tif (ccid_hc_tx_parse_options(dp->dccps_hc_tx_ccid, sk,\n\t\t\t\t\t\t     pkt_type, opt, value, len))\n\t\t\t\tgoto out_invalid_option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDCCP_CRIT("DCCP(%p): option %d(len=%d) not "\n\t\t\t\t  "implemented, ignoring", sk, opt, len);\n\t\t\tbreak;\n\t\t}\nignore_option:\n\t\tif (opt != DCCPO_MANDATORY)\n\t\t\tmandatory = 0;\n\t}\n\n\t/* mandatory was the last byte in option list -> reset connection */\n\tif (mandatory)\n\t\tgoto out_invalid_option;\n\nout_nonsensical_length:\n\t/* RFC 4340, 5.8: ignore option and all remaining option space */\n\treturn 0;\n\nout_invalid_option:\n\tDCCP_INC_STATS(DCCP_MIB_INVALIDOPT);\n\trc = DCCP_RESET_CODE_OPTION_ERROR;\nout_featneg_failed:\n\tDCCP_WARN("DCCP(%p): Option %d (len=%d) error=%u\\n", sk, opt, len, rc);\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = rc;\n\tDCCP_SKB_CB(skb)->dccpd_reset_data[0] = opt;\n\tDCCP_SKB_CB(skb)->dccpd_reset_data[1] = len > 0 ? value[0] : 0;\n	t
57741	138	lowpan_event	net/6lowpan/core.c	&addr	1	13	\N	\N	\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct inet6_dev *idev;\n\tstruct in6_addr addr;\n\tint i;\n\n\tif (dev->type != ARPHRD_6LOWPAN)\n\t\treturn NOTIFY_DONE;\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\t/* (802.15.4 6LoWPAN short address slaac handling */\n\t\tif (lowpan_is_ll(dev, LOWPAN_LLTYPE_IEEE802154) &&\n\t\t    addrconf_ifid_802154_6lowpan(addr.s6_addr + 8, dev) == 0) {\n\t\t\t__ipv6_addr_set_half(&addr.s6_addr32[0],\n\t\t\t\t\t     htonl(0xFE800000), 0);\n\t\t\taddrconf_add_linklocal(idev, &addr, 0);\n	f
-625	1609	smsc75xx_enter_suspend3	drivers/net/usb/smsc75xx.c	val	2	3	\N	\N	\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, FCT_RX_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, "Error reading FCT_RX_CTL\\n");\n\t\treturn ret;\n\t}\n\n\tif (val & FCT_RX_CTL_RXUSED) {\n	f
9097	1032	ip_rt_update_pmtu	net/ipv4/route.c	&fl4	1	21	\N	\N	\tstruct rtable *rt = (struct rtable *) dst;\n\tstruct flowi4 fl4;\n\n\tip_rt_build_flow_key(&fl4, sk, skb);\n\t__ip_rt_update_pmtu(rt, &fl4, mtu);\n	f
-621	127	cw1200_request_irq	drivers/net/wireless/st/cw1200/cw1200_sdio.c	ret	2	3	\N	\N	\tint ret;\n\tu8 cccr;\n\n\tcccr = sdio_f0_readb(self->func, SDIO_CCCR_IENx, &ret);\n\tif (WARN_ON(ret))\n	f
23940	417	add_grhead	net/ipv4/igmp.c	skb	1	11	\N	\N	\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr;\n\n\tif (!skb)\n\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\tif (!skb)\n\t\treturn NULL;\n\tpgr = skb_put(skb, sizeof(struct igmpv3_grec));\n	f
32674	355	add_mux_store	drivers/net/usb/qmi_wwan.c	mux_id	1	11	\N	\N	\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tu8 mux_id;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &mux_id))\n\t\treturn -EINVAL;\n\n\t/* mux_id [1 - 0x7f] range empirically found */\n\tif (mux_id < 1 || mux_id > 0x7f)\n	f
39862	446	acpi_ac_get_present	drivers/acpi/sbs.c	status	1	11	\N	\N	\tint result;\n\tu16 status;\n\n\tresult = acpi_smbus_read(sbs->hc, SMBUS_READ_WORD, ACPI_SBS_CHARGER,\n\t\t\t\t 0x13, (u8 *) & status);\n\n\tif (result)\n\t\treturn result;\n\n\t/*\n\t * The spec requires that bit 4 always be 1. If it's not set, assume\n\t * that the implementation doesn't support an SBS charger\n\t */\n\tif (!((status >> 4) & 0x1))\n	f
46030	298	autofs_dev_ioctl_openmount	fs/autofs4/dev-ioctl.c	fd	1	11	\N	\N	\tconst char *path;\n\tdev_t devid;\n\tint err, fd;\n\n\t/* param->path has already been checked */\n\tif (!param->openmount.devid)\n\t\treturn -EINVAL;\n\n\tparam->ioctlfd = -1;\n\n\tpath = param->path;\n\tdevid = new_decode_dev(param->openmount.devid);\n\n\terr = 0;\n\tfd = autofs_dev_ioctl_open_mountpoint(path, devid);\n\tif (unlikely(fd < 0)) {\n	f
7758	215	set_temp_max	drivers/hwmon/max6639.c	set_temp_max_$__UNIQUE_ID_min1_125$obj	0	11	\N	\N	\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(dev_attr);\n\tstruct max6639_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint res;\n\n\tres = kstrtoul(buf, 10, &val);\n\tif (res)\n\t\treturn res;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_therm[attr->index] = TEMP_LIMIT_TO_REG(val);\n	t
62609	2798	ofdpa_fib4_abort	drivers/net/ethernet/rocker/rocker_ofdpa.c	ofdpa_fib4_abort_$____ptr35$obj	0	11	\N	\N	\tstruct ofdpa *ofdpa = rocker->wpriv;\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct ofdpa_flow_tbl_entry *flow_entry;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\tint bkt;\n\n\tif (ofdpa->fib_aborted)\n\t\treturn;\n\n\tspin_lock_irqsave(&ofdpa->flow_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->flow_tbl, bkt, tmp, flow_entry, entry) {\n	t
28997	283	ThermometerRead	drivers/media/dvb-frontends/tda18271c2dd.c	Regs	1	11	\N	\N	\tint status = 0;\n\n\tdo {\n\t\tu8 Regs[16];\n\t\tstate->m_Regs[TM] |= 0x10;\n\t\tstatus = UpdateReg(state, TM);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Read(state, Regs);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (((Regs[TM] & 0x0F) == 0 && (Regs[TM] & 0x20) == 0x20) ||\n	t
35701	346	mwifiex_dnld_sleep_confirm_cmd	drivers/net/wireless/marvell/mwifiex/cmdevt.c	sleep_cfm_tmp->data	1	11	\N	\N	\tint ret;\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_opt_sleep_confirm *sleep_cfm_buf =\n\t\t\t\t(struct mwifiex_opt_sleep_confirm *)\n\t\t\t\t\t\tadapter->sleep_cfm->data;\n\tstruct sk_buff *sleep_cfm_tmp;\n\t__le32 tmp;\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\tadapter->seq_num++;\n\tsleep_cfm_buf->seq_num =\n\t\tcpu_to_le16((HostCmd_SET_SEQ_NO_BSS_INFO\n\t\t\t\t\t(adapter->seq_num, priv->bss_num,\n\t\t\t\t\t priv->bss_type)));\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    "cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\\n",\n\t\tle16_to_cpu(sleep_cfm_buf->command),\n\t\tle16_to_cpu(sleep_cfm_buf->action),\n\t\tle16_to_cpu(sleep_cfm_buf->size),\n\t\tle16_to_cpu(sleep_cfm_buf->seq_num));\n\tmwifiex_dbg_dump(adapter, CMD_D, "SLEEP_CFM buffer: ", sleep_cfm_buf,\n\t\t\t le16_to_cpu(sleep_cfm_buf->size));\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tsleep_cfm_tmp =\n\t\t\tdev_alloc_skb(sizeof(struct mwifiex_opt_sleep_confirm)\n\t\t\t\t      + MWIFIEX_TYPE_LEN);\n\t\tskb_put(sleep_cfm_tmp, sizeof(struct mwifiex_opt_sleep_confirm)\n\t\t\t+ MWIFIEX_TYPE_LEN);\n\t\ttmp = cpu_to_le32(MWIFIEX_USB_TYPE_CMD);\n\t\tmemcpy(sleep_cfm_tmp->data, &tmp, MWIFIEX_TYPE_LEN);\n	f
35857	378	mwifiex_bss_start	drivers/net/wireless/marvell/mwifiex/sta_ioctl.c	ret	1	11	\N	\N	\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bssdescriptor *bss_desc = NULL;\n\n\tpriv->scan_block = false;\n\n\tif (bss) {\n\t\tif (adapter->region_code == 0x00)\n\t\t\tmwifiex_process_country_ie(priv, bss);\n\n\t\t/* Allocate and fill new bss descriptor */\n\t\tbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!bss_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tu8 config_bands;\n\n\t\tif (!bss_desc)\n\t\t\treturn -1;\n\n\t\tif (mwifiex_band_to_radio_type(bss_desc->bss_band) ==\n\t\t\t\t\t\tHostCmd_SCAN_RADIO_TYPE_BG) {\n\t\t\tconfig_bands = BAND_B | BAND_G | BAND_GN;\n\t\t} else {\n\t\t\tconfig_bands = BAND_A | BAND_AN;\n\t\t\tif (adapter->fw_bands & BAND_AAC)\n\t\t\t\tconfig_bands |= BAND_AAC;\n\t\t}\n\n\t\tif (!((config_bands | adapter->fw_bands) & ~adapter->fw_bands))\n\t\t\tadapter->config_bands = config_bands;\n\n\t\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tif (mwifiex_11h_get_csa_closed_channel(priv) ==\n\t\t\t\t\t\t\t(u8)bss_desc->channel) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    "Attempt to reconnect on csa closed chan(%d)\\n",\n\t\t\t\t    bss_desc->channel);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    "info: SSID found in scan list ...\\t"\n\t\t\t    "associating...\\n");\n\n\t\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_off(priv->netdev);\n\n\t\t/* Clear any past association response stored for\n\t\t * application retrieval */\n\t\tpriv->assoc_rsp_size = 0;\n\t\tret = mwifiex_associate(priv, bss_desc);\n\n\t\t/* If auth type is auto and association fails using open mode,\n\t\t * try to connect using shared mode */\n\t\tif (ret == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&\n	f
37248	3176	addrconf_addr_gen	net/ipv6/addrconf.c	&addr	1	11	\N	\N	\tstruct in6_addr addr;\n\n\t/* no link local addresses on L3 master devices */\n\tif (netif_is_l3_master(idev->dev))\n\t\treturn;\n\n\tipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);\n	f
49234	4047	addrconf_dad_completed	net/ipv6/addrconf.c	&lladdr	1	11	\N	\N	\tstruct net_device *dev = ifp->idev->dev;\n\tstruct in6_addr lladdr;\n\tbool send_rs, send_mld;\n\n\taddrconf_del_dad_work(ifp);\n\n\t/*\n\t *\tConfigure the address for reception. Now it is valid.\n\t */\n\n\tipv6_ifa_notify(RTM_NEWADDR, ifp);\n\n\t/* If added prefix is link local and we are prepared to process\n\t   router advertisements, start sending router solicitations.\n\t */\n\n\tread_lock_bh(&ifp->idev->lock);\n\tsend_mld = ifp->scope == IFA_LINK && ipv6_lonely_lladdr(ifp);\n\tsend_rs = send_mld &&\n\t\t  ipv6_accept_ra(ifp->idev) &&\n\t\t  ifp->idev->cnf.rtr_solicits != 0 &&\n\t\t  (dev->flags&IFF_LOOPBACK) == 0;\n\tread_unlock_bh(&ifp->idev->lock);\n\n\t/* While dad is in progress mld report's source address is in6_addrany.\n\t * Resend with proper ll now.\n\t */\n\tif (send_mld)\n\t\tipv6_mc_dad_complete(ifp->idev);\n\n\tif (send_rs) {\n\t\t/*\n\t\t *\tIf a host as already performed a random delay\n\t\t *\t[...] as part of DAD [...] there is no need\n\t\t *\tto delay again before sending the first RS\n\t\t */\n\t\tif (ipv6_get_lladdr(dev, &lladdr, IFA_F_TENTATIVE))\n	f
49247	3864	addrconf_dad_begin	net/ipv6/addrconf.c	ifp	1	11	\N	\N	\tstruct inet6_dev *idev = ifp->idev;\n\tstruct net_device *dev = idev->dev;\n\tbool bump_id, notify = false;\n\n\taddrconf_join_solict(dev, &ifp->addr);\n\n\tprandom_seed((__force u32) ifp->addr.s6_addr32[3]);\n\n\tread_lock_bh(&idev->lock);\n\tspin_lock(&ifp->lock);\n\tif (ifp->state == INET6_IFADDR_STATE_DEAD)\n\t\tgoto out;\n\n\tif (dev->flags&(IFF_NOARP|IFF_LOOPBACK) ||\n\t    (dev_net(dev)->ipv6.devconf_all->accept_dad < 1 &&\n\t     idev->cnf.accept_dad < 1) ||\n\t    !(ifp->flags&IFA_F_TENTATIVE) ||\n\t    ifp->flags & IFA_F_NODAD) {\n\t\tbump_id = ifp->flags & IFA_F_TENTATIVE;\n\t\tifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC|IFA_F_DADFAILED);\n\t\tspin_unlock(&ifp->lock);\n\t\tread_unlock_bh(&idev->lock);\n\n\t\taddrconf_dad_completed(ifp, bump_id);\n\t\treturn;\n\t}\n\n\tif (!(idev->if_flags & IF_READY)) {\n\t\tspin_unlock(&ifp->lock);\n\t\tread_unlock_bh(&idev->lock);\n\t\t/*\n\t\t * If the device is not ready:\n\t\t * - keep it tentative if it is a permanent address.\n\t\t * - otherwise, kill it.\n\t\t */\n\t\tin6_ifa_hold(ifp);\n\t\taddrconf_dad_stop(ifp, 0);\n\t\treturn;\n\t}\n\n\t/*\n\t * Optimistic nodes can start receiving\n\t * Frames right away\n\t */\n\tif (ifp->flags & IFA_F_OPTIMISTIC) {\n\t\tip6_ins_rt(ifp->rt);\n\t\tif (ipv6_use_optimistic_addr(dev_net(dev), idev)) {\n\t\t\t/* Because optimistic nodes can use this address,\n\t\t\t * notify listeners. If DAD fails, RTM_DELADDR is sent.\n\t\t\t */\n\t\t\tnotify = true;\n\t\t}\n\t}\n\n\taddrconf_dad_kick(ifp);\n	f
56763	62	llc_sap_action_send_ui	net/llc/llc_s_ac.c	skb	1	-11	\N	\N	\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tint rc;\n\n\tllc_pdu_header_init(skb, LLC_PDU_TYPE_U, ev->saddr.lsap,\n\t\t\t    ev->daddr.lsap, LLC_PDU_CMD);\n\tllc_pdu_init_as_ui_cmd(skb);\n\trc = llc_mac_hdr_init(skb, ev->saddr.mac, ev->daddr.mac);\n\tif (likely(!rc))\n\t\trc = dev_queue_xmit(skb);\n	f
32220	265	ipq806x_gmac_probe	drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c	&stmmac_res	1	11	\N	\N	\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct ipq806x_gmac *gmac;\n\tint val;\n\tint err;\n\n\tval = stmmac_get_platform_resources(pdev, &stmmac_res);\n	t
778	399	_of_phy_get	drivers/phy/phy-core.c	args.np	1	21	\N	\N	\tint ret;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy = NULL;\n\tstruct of_phandle_args args;\n\n\tret = of_parse_phandle_with_args(np, "phys", "#phy-cells",\n\t\tindex, &args);\n\tif (ret)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&phy_provider_mutex);\n\tphy_provider = of_phy_provider_lookup(args.np);\n	f
3686	745	get_bit_error_rate_s2	drivers/media/dvb-frontends/stv0910.c	regs	1	13	\N	\N	\tu8 regs[3];\n\n\tint status = read_regs(state, RSTV0910_P2_ERRCNT12 + state->regoff,\n\t\t\t       regs, 3);\n\n\tif (status)\n\t\treturn -EINVAL;\n\n\tif ((regs[0] & 0x80) == 0) {\n	f
2640	160	inv_mpu6050_read_fifo	drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c	bytes_per_datum	1	11	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tsize_t bytes_per_datum;\n\tint result;\n\tu8 data[INV_MPU6050_OUTPUT_DATA_SIZE];\n\tu16 fifo_count;\n\ts64 timestamp;\n\n\tmutex_lock(&st->lock);\n\tif (!(st->chip_config.accl_fifo_enable |\n\t\tst->chip_config.gyro_fifo_enable))\n\t\tgoto end_session;\n\tbytes_per_datum = 0;\n\tif (st->chip_config.accl_fifo_enable)\n\t\tbytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;\n\n\tif (st->chip_config.gyro_fifo_enable)\n\t\tbytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;\n\n\t/*\n\t * read fifo_count register to know how many bytes inside FIFO\n\t * right now\n\t */\n\tresult = regmap_bulk_read(st->map, st->reg->fifo_count_h, data,\n\t\t\t\t  INV_MPU6050_FIFO_COUNT_BYTE);\n\tif (result)\n\t\tgoto end_session;\n\tfifo_count = be16_to_cpup((__be16 *)(&data[0]));\n\tif (fifo_count < bytes_per_datum)\n\t\tgoto end_session;\n\t/* fifo count can't be odd number, if it is odd, reset fifo*/\n\tif (fifo_count & 1)\n\t\tgoto flush_fifo;\n\tif (fifo_count >  INV_MPU6050_FIFO_THRESHOLD)\n\t\tgoto flush_fifo;\n\t/* Timestamp mismatch. */\n\tif (kfifo_len(&st->timestamps) >\n\t    fifo_count / bytes_per_datum + INV_MPU6050_TIME_STAMP_TOR)\n	t
26764	297	adis16400_initial_setup	drivers/iio/imu/adis16400_core.c	prod_id	1	11	\N	\N	\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tuint16_t prod_id, smp_prd;\n\tunsigned int device_id;\n\tint ret;\n\n\t/* use low spi speed for init if the device has a slow mode */\n\tif (st->variant->flags & ADIS16400_HAS_SLOW_MODE)\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;\n\telse\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\n\tst->adis.spi->mode = SPI_MODE_3;\n\tspi_setup(st->adis.spi);\n\n\tret = adis_initial_startup(&st->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->variant->flags & ADIS16400_HAS_PROD_ID) {\n\t\tret = adis_read_reg_16(&st->adis,\n\t\t\t\t\t\tADIS16400_PRODUCT_ID, &prod_id);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tret = sscanf(indio_dev->name, "adis%u\\n", &device_id);\n\t\tif (ret != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (prod_id != device_id)\n	f
46019	470	autofs_dev_ioctl_requester	fs/autofs4/dev-ioctl.c	ino->gid	1	11	\N	\N	\tstruct autofs_info *ino;\n\tstruct path path;\n\tdev_t devid;\n\tint err = -ENOENT;\n\n\tif (param->size <= AUTOFS_DEV_IOCTL_SIZE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdevid = sbi->sb->s_dev;\n\n\tparam->requester.uid = param->requester.gid = -1;\n\n\terr = find_autofs_mount(param->path, &path, test_by_dev, &devid);\n\tif (err)\n\t\tgoto out;\n\n\tino = autofs4_dentry_ino(path.dentry);\n\tif (ino) {\n\t\terr = 0;\n\t\tautofs4_expire_wait(&path, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tparam->requester.uid =\n\t\t\tfrom_kuid_munged(current_user_ns(), ino->uid);\n\t\tparam->requester.gid =\n\t\t\tfrom_kgid_munged(current_user_ns(), ino->gid);\n	f
47999	616	af9005_boot_packet	drivers/media/usb/dvb-usb/af9005.c	act_len	1	11	\N	\N	\tu16 checksum;\n\tint act_len, i, ret;\n\n\tmemset(buf, 0, size);\n\tbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\n\tbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\n\tswitch (type) {\n\tcase FW_CONFIG:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x03;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_CONFIRM:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x01;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_BOOT:\n\t\tbuf[2] = 0x10;\n\t\tbuf[3] = 0x08;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x97;\n\t\tbuf[6] = 0xaa;\n\t\tbuf[7] = 0x55;\n\t\tbuf[8] = 0xa5;\n\t\tbuf[9] = 0x5a;\n\t\tchecksum = 0;\n\t\tfor (i = 4; i <= 9; i++)\n\t\t\tchecksum += buf[i];\n\t\tbuf[10] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[11] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tdefault:\n\t\terr("boot packet invalid boot packet type");\n\t\treturn -EINVAL;\n\t}\n\tdeb_fw(">>> ");\n\tdebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\n\n\tret = usb_bulk_msg(udev,\n\t\t\t   usb_sndbulkpipe(udev, 0x02),\n\t\t\t   buf, FW_BULKOUT_SIZE + 2, &act_len, 2000);\n\tif (ret)\n\t\terr("boot packet bulk message failed: %d (%d/%d)", ret,\n	f
25822	1152	arizona_dev_init	drivers/mfd/arizona-core.c	reg	1	11	\N	TP, regmap_read	\tconst char * const mclk_name[] = { "mclk1", "mclk2" };\n\tstruct device *dev = arizona->dev;\n\tconst char *type_name = NULL;\n\tunsigned int reg, val, mask;\n\tint (*apply_patch)(struct arizona *) = NULL;\n\tconst struct mfd_cell *subdevs = NULL;\n\tint n_subdevs, ret, i;\n\n\tdev_set_drvdata(arizona->dev, arizona);\n\tmutex_init(&arizona->clk_lock);\n\n\tif (dev_get_platdata(arizona->dev)) {\n\t\tmemcpy(&arizona->pdata, dev_get_platdata(arizona->dev),\n\t\t       sizeof(arizona->pdata));\n\t} else {\n\t\tret = arizona_of_get_core_pdata(arizona);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(arizona->mclk) != ARRAY_SIZE(mclk_name));\n\tfor (i = 0; i < ARRAY_SIZE(arizona->mclk); i++) {\n\t\tarizona->mclk[i] = devm_clk_get(arizona->dev, mclk_name[i]);\n\t\tif (IS_ERR(arizona->mclk[i])) {\n\t\t\tdev_info(arizona->dev, "Failed to get %s: %ld\\n",\n\t\t\t\t mclk_name[i], PTR_ERR(arizona->mclk[i]));\n\t\t\tarizona->mclk[i] = NULL;\n\t\t}\n\t}\n\n\tregcache_cache_only(arizona->regmap, true);\n\n\tswitch (arizona->type) {\n\tcase WM5102:\n\tcase WM5110:\n\tcase WM8280:\n\tcase WM8997:\n\tcase WM8998:\n\tcase WM1814:\n\tcase WM1831:\n\tcase CS47L24:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)\n\t\t\tarizona->core_supplies[i].supply\n\t\t\t\t= wm5102_core_supplies[i];\n\t\tarizona->num_core_supplies = ARRAY_SIZE(wm5102_core_supplies);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(arizona->dev, "Unknown device type %d\\n",\n\t\t\tarizona->type);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Mark DCVDD as external, LDO1 driver will clear if internal */\n\tarizona->external_dcvdd = true;\n\n\tswitch (arizona->type) {\n\tcase WM1831:\n\tcase CS47L24:\n\t\tbreak; /* No LDO1 regulator */\n\tdefault:\n\t\tret = mfd_add_devices(arizona->dev, -1, early_devs,\n\t\t\t\t      ARRAY_SIZE(early_devs), NULL, 0, NULL);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, "Failed to add early children: %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = devm_regulator_bulk_get(dev, arizona->num_core_supplies,\n\t\t\t\t      arizona->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to request core supplies: %d\\n",\n\t\t\tret);\n\t\tgoto err_early;\n\t}\n\n\t/**\n\t * Don't use devres here because the only device we have to get\n\t * against is the MFD device and DCVDD will likely be supplied by\n\t * one of its children. Meaning that the regulator will be\n\t * destroyed by the time devres calls regulator put.\n\t */\n\tarizona->dcvdd = regulator_get(arizona->dev, "DCVDD");\n\tif (IS_ERR(arizona->dcvdd)) {\n\t\tret = PTR_ERR(arizona->dcvdd);\n\t\tdev_err(dev, "Failed to request DCVDD: %d\\n", ret);\n\t\tgoto err_early;\n\t}\n\n\tif (arizona->pdata.reset) {\n\t\t/* Start out with /RESET low to put the chip into reset */\n\t\tret = devm_gpio_request_one(arizona->dev, arizona->pdata.reset,\n\t\t\t\t\t    GPIOF_DIR_OUT | GPIOF_INIT_LOW,\n\t\t\t\t\t    "arizona /RESET");\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, "Failed to request /RESET: %d\\n", ret);\n\t\t\tgoto err_dcvdd;\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(arizona->num_core_supplies,\n\t\t\t\t    arizona->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to enable core supplies: %d\\n",\n\t\t\tret);\n\t\tgoto err_dcvdd;\n\t}\n\n\tret = regulator_enable(arizona->dcvdd);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to enable DCVDD: %d\\n", ret);\n\t\tgoto err_enable;\n\t}\n\n\tarizona_disable_reset(arizona);\n\n\tregcache_cache_only(arizona->regmap, false);\n\n\t/* Verify that this is a chip we know about */\n\tret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to read ID register: %d\\n", ret);\n\t\tgoto err_reset;\n\t}\n\n\tswitch (reg) {\n	f
-101	553	pv_eoi_get_pending	arch/x86/kvm/lapic.c	val	41	2	arg_no	TP	\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug("Can't read EOI MSR value: 0x%llx\\n",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n	f
-611	200	i40iw_puda_ce_handler	drivers/infiniband/hw/i40iw/i40iw_hw.c	compl_error	2	3	\N	\N	\tstruct blogic_probeinfo *pr_probeinfo =\n\t\t&blogic_probeinfo_list[blogic_probeinfo_count];\n\tint nonpr_mmindex = blogic_probeinfo_count + 1;\n\tint nonpr_mmcount = 0, mmcount = 0;\n\tbool force_scan_order = false;\n\tbool force_scan_order_checked = false;\n\tbool addr_seen[6];\n\tstruct pci_dev *pci_device = NULL;\n\tint i;\n\tif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\n\t\treturn 0;\n\tblogic_probeinfo_count++;\n\tfor (i = 0; i < 6; i++)\n\t\taddr_seen[i] = false;\n\t/*\n\t   Iterate over the MultiMaster PCI Host Adapters.  For each\n\t   enumerated host adapter, determine whether its ISA Compatible\n\t   I/O Port is enabled and if so, whether it is assigned the\n\t   Primary I/O Address.  A host adapter that is assigned the\n\t   Primary I/O Address will always be the preferred boot device.\n\t   The MultiMaster BIOS will first recognize a host adapter at\n\t   the Primary I/O Address, then any other PCI host adapters,\n\t   and finally any host adapters located at the remaining\n\t   standard ISA I/O Addresses.  When a PCI host adapter is found\n\t   with its ISA Compatible I/O Port enabled, a command is issued\n\t   to disable the ISA Compatible I/O Port, and it is noted that the\n\t   particular standard ISA I/O Address need not be probed.\n\t */\n\tpr_probeinfo->io_addr = 0;\n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tstruct blogic_adapter *host_adapter = adapter;\n\t\tstruct blogic_adapter_info adapter_info;\n\t\tenum blogic_isa_ioport mod_ioaddr_req;\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long base_addr0;\n\t\tunsigned long base_addr1;\n\t\tunsigned long io_addr;\n\t\tunsigned long pci_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = base_addr0 = pci_resource_start(pci_device, 0);\n\t\tpci_addr = base_addr1 = pci_resource_start(pci_device, 1);\n\n\t\tif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\n\t\t\tblogic_err("BusLogic: Base Address0 0x%X not I/O for " "MultiMaster Host Adapter\\n", NULL, base_addr0);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\n\t\t\tblogic_err("BusLogic: Base Address1 0x%X not Memory for " "MultiMaster Host Adapter\\n", NULL, base_addr1);\n\t\t\tblogic_err("at PCI Bus %d Device %d PCI Address 0x%X\\n", NULL, bus, device, pci_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (irq_ch == 0) {\n\t\t\tblogic_err("BusLogic: IRQ Channel %d invalid for " "MultiMaster Host Adapter\\n", NULL, irq_ch);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (blogic_global_options.trace_probe) {\n\t\t\tblogic_notice("BusLogic: PCI MultiMaster Host Adapter " "detected at\\n", NULL);\n\t\t\tblogic_notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\\n", NULL, bus, device, io_addr, pci_addr);\n\t\t}\n\t\t/*\n\t\t   Issue the Inquire PCI Host Adapter Information command to determine\n\t\t   the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is\n\t\t   known and enabled, note that the particular Standard ISA I/O\n\t\t   Address should not be probed.\n\t\t */\n\t\thost_adapter->io_addr = io_addr;\n\t\tblogic_intreset(host_adapter);\n\t\tif (blogic_cmd(host_adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\n\t\t\t\t&adapter_info, sizeof(adapter_info)) ==\n\t\t\t\tsizeof(adapter_info)) {\n\t\t\tif (adapter_info.isa_port < 6)\n\t\t\t\taddr_seen[adapter_info.isa_port] = true;\n\t\t} else\n\t\t\tadapter_info.isa_port = BLOGIC_IO_DISABLE;\n\t\t/*\n\t\t   Issue the Modify I/O Address command to disable the\n\t\t   ISA Compatible I/O Port. On PCI Host Adapters, the\n\t\t   Modify I/O Address command allows modification of the\n\t\t   ISA compatible I/O Address that the Host Adapter\n\t\t   responds to; it does not affect the PCI compliant\n\t\t   I/O Address assigned at system initialization.\n\t\t */\n\t\tmod_ioaddr_req = BLOGIC_IO_DISABLE;\n\t\tblogic_cmd(host_adapter, BLOGIC_MOD_IOADDR, &mod_ioaddr_req,\n\t\t\t\tsizeof(mod_ioaddr_req), NULL, 0);\n\t\t/*\n\t\t   For the first MultiMaster Host Adapter enumerated,\n\t\t   issue the Fetch Host Adapter Local RAM command to read\n\t\t   byte 45 of the AutoSCSI area, for the setting of the\n\t\t   "Use Bus And Device # For PCI Scanning Seq." option.\n\t\t   Issue the Inquire Board ID command since this option is\n\t\t   only valid for the BT-948/958/958D.\n\t\t */\n\t\tif (!force_scan_order_checked) {\n\t\t\tstruct blogic_fetch_localram fetch_localram;\n\t\t\tstruct blogic_autoscsi_byte45 autoscsi_byte45;\n\t\t\tstruct blogic_board_id id;\n\n\t\t\tfetch_localram.offset = BLOGIC_AUTOSCSI_BASE + 45;\n\t\t\tfetch_localram.count = sizeof(autoscsi_byte45);\n\t\t\tblogic_cmd(host_adapter, BLOGIC_FETCH_LOCALRAM,\n\t\t\t\t\t&fetch_localram, sizeof(fetch_localram),\n\t\t\t\t\t&autoscsi_byte45,\n\t\t\t\t\tsizeof(autoscsi_byte45));\n\t\t\tblogic_cmd(host_adapter, BLOGIC_GET_BOARD_ID, NULL, 0,\n\t\t\t\t\t&id, sizeof(id));\n\t\t\tif (id.fw_ver_digit1 == '5')\n	f
8600	1067	__skb_get_hash_symmetric	net/core/flow_dissector.c	hashrnd	1	21	\N	\N	\tstruct flow_keys keys;\n\n\t__flow_hash_secret_init();\n\n\tmemset(&keys, 0, sizeof(keys));\n\t__skb_flow_dissect(skb, &flow_keys_dissector_symmetric, &keys,\n\t\t\t   NULL, 0, 0, 0,\n\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(&keys, hashrnd);\n	f
44946	842	ak8975_fill_buffer	drivers/iio/magnetometer/ak8975.c	ak8975_fill_buffer_$__UNIQUE_ID_min1_133$obj	0	11	\N	\N	\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tconst struct i2c_client *client = data->client;\n\tconst struct ak_def *def = data->def;\n\tint ret;\n\ts16 buff[8]; /* 3 x 16 bits axis values + 1 aligned 64 bits timestamp */\n\t__le16 fval[3];\n\n\tmutex_lock(&data->lock);\n\n\tret = ak8975_start_read_axis(data, client);\n\tif (ret)\n\t\tgoto unlock;\n\n\t/*\n\t * For each axis, read the flux value from the appropriate register\n\t * (the register is specified in the iio device attributes).\n\t */\n\tret = i2c_smbus_read_i2c_block_data_or_emulated(client,\n\t\t\t\t\t\t\tdef->data_regs[0],\n\t\t\t\t\t\t\t3 * sizeof(fval[0]),\n\t\t\t\t\t\t\t(u8 *)fval);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tmutex_unlock(&data->lock);\n\n\t/* Clamp to valid range. */\n\tbuff[0] = clamp_t(s16, le16_to_cpu(fval[0]), -def->range, def->range);\n\tbuff[1] = clamp_t(s16, le16_to_cpu(fval[1]), -def->range, def->range);\n	f
3130	711	qib_send_rc_ack	drivers/infiniband/hw/qib/qib_rc.c	pbufn	1	11	\N	\N	\tstruct qib_devdata *dd = dd_from_ibdev(qp->ibqp.device);\n\tstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu64 pbc;\n\tu16 lrh0;\n\tu32 bth0;\n\tu32 hwords;\n\tu32 pbufn;\n\tu32 __iomem *piobuf;\n\tstruct ib_header hdr;\n\tstruct ib_other_headers *ohdr;\n\tu32 control;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto unlock;\n\n\t/* Don't send ACK or NAK if a RDMA read or atomic is pending. */\n\tif ((qp->s_flags & RVT_S_RESP_PENDING) || qp->s_rdma_ack_cnt)\n\t\tgoto queue_ack;\n\n\t/* Construct the header with s_lock held so APM doesn't change it. */\n\tohdr = &hdr.u.oth;\n\tlrh0 = QIB_LRH_BTH;\n\t/* header size in 32-bit words LRH+BTH+AETH = (8+12+4)/4. */\n\thwords = 6;\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t     IB_AH_GRH)) {\n\t\thwords += qib_make_grh(ibp, &hdr.u.l.grh,\n\t\t\t\t       rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t       hwords, 0);\n\t\tohdr = &hdr.u.l.oth;\n\t\tlrh0 = QIB_LRH_GRH;\n\t}\n\t/* read pkey_index w/o lock (its atomic) */\n\tbth0 = qib_get_pkey(ibp, qp->s_pkey_index) | (OP(ACKNOWLEDGE) << 24);\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth0 |= IB_BTH_MIG_REQ;\n\tif (qp->r_nak_state)\n\t\tohdr->u.aeth = cpu_to_be32((qp->r_msn & IB_MSN_MASK) |\n\t\t\t\t\t    (qp->r_nak_state <<\n\t\t\t\t\t     IB_AETH_CREDIT_SHIFT));\n\telse\n\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\tlrh0 |= ibp->sl_to_vl[rdma_ah_get_sl(&qp->remote_ah_attr)] << 12 |\n\t\trdma_ah_get_sl(&qp->remote_ah_attr) << 4;\n\thdr.lrh[0] = cpu_to_be16(lrh0);\n\thdr.lrh[1] = cpu_to_be16(rdma_ah_get_dlid(&qp->remote_ah_attr));\n\thdr.lrh[2] = cpu_to_be16(hwords + SIZE_OF_CRC);\n\thdr.lrh[3] = cpu_to_be16(ppd->lid |\n\t\t\t\t rdma_ah_get_path_bits(&qp->remote_ah_attr));\n\tohdr->bth[0] = cpu_to_be32(bth0);\n\tohdr->bth[1] = cpu_to_be32(qp->remote_qpn);\n\tohdr->bth[2] = cpu_to_be32(qp->r_ack_psn & QIB_PSN_MASK);\n\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\n\t/* Don't try to send ACKs if the link isn't ACTIVE */\n\tif (!(ppd->lflags & QIBL_LINKACTIVE))\n\t\tgoto done;\n\n\tcontrol = dd->f_setpbc_control(ppd, hwords + SIZE_OF_CRC,\n\t\t\t\t       qp->s_srate, lrh0 >> 12);\n\t/* length is + 1 for the control dword */\n\tpbc = ((u64) control << 32) | (hwords + 1);\n\n\tpiobuf = dd->f_getsendbuf(ppd, pbc, &pbufn);\n\tif (!piobuf) {\n\t\t/*\n\t\t * We are out of PIO buffers at the moment.\n\t\t * Pass responsibility for sending the ACK to the\n\t\t * send tasklet so that when a PIO buffer becomes\n\t\t * available, the ACK is sent ahead of other outgoing\n\t\t * packets.\n\t\t */\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tgoto queue_ack;\n\t}\n\n\t/*\n\t * Write the pbc.\n\t * We have to flush after the PBC for correctness\n\t * on some cpus or WC buffer can be written out of order.\n\t */\n\twriteq(pbc, piobuf);\n\n\tif (dd->flags & QIB_PIO_FLUSH_WC) {\n\t\tu32 *hdrp = (u32 *) &hdr;\n\n\t\tqib_flush_wc();\n\t\tqib_pio_copy(piobuf + 2, hdrp, hwords - 1);\n\t\tqib_flush_wc();\n\t\t__raw_writel(hdrp[hwords - 1], piobuf + hwords + 1);\n\t} else\n\t\tqib_pio_copy(piobuf + 2, (u32 *) &hdr, hwords);\n\n\tif (dd->flags & QIB_USE_SPCL_TRIG) {\n\t\tu32 spcl_off = (pbufn >= dd->piobcnt2k) ? 2047 : 1023;\n	t
42394	737	ax88772_bind	drivers/net/usb/asix_devices.c	phyid	1	11	\N	\N	\tint ret, i;\n\tu8 buf[ETH_ALEN], chipcode = 0;\n\tu32 phyid;\n\tstruct asix_common_private *priv;\n\n\tusbnet_get_endpoints(dev,intf);\n\n\t/* Get the MAC address */\n\tif (dev->driver_info->data & FLAG_EEPROM_MAC) {\n\t\tfor (i = 0; i < (ETH_ALEN >> 1); i++) {\n\t\t\tret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x04 + i,\n\t\t\t\t\t    0, 2, buf + i * 2, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,\n\t\t\t\t0, 0, ETH_ALEN, buf, 0);\n\t}\n\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, "Failed to read MAC address: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tasix_set_netdev_dev_addr(dev, buf);\n\n\t/* Initialize MII structure */\n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = asix_mdio_read;\n\tdev->mii.mdio_write = asix_mdio_write;\n\tdev->mii.phy_id_mask = 0x1f;\n\tdev->mii.reg_num_mask = 0x1f;\n\tdev->mii.phy_id = asix_get_phy_addr(dev);\n\n\tdev->net->netdev_ops = &ax88772_netdev_ops;\n\tdev->net->ethtool_ops = &ax88772_ethtool_ops;\n\tdev->net->needed_headroom = 4; /* cf asix_tx_fixup() */\n\tdev->net->needed_tailroom = 4; /* cf asix_tx_fixup() */\n\n\tasix_read_cmd(dev, AX_CMD_STATMNGSTS_REG, 0, 0, 1, &chipcode, 0);\n\tchipcode &= AX_CHIPCODE_MASK;\n\n\t(chipcode == AX_AX88772_CHIPCODE) ? ax88772_hw_reset(dev, 0) :\n\t\t\t\t\t    ax88772a_hw_reset(dev, 0);\n\n\t/* Read PHYID register *AFTER* the PHY was reset properly */\n\tphyid = asix_get_phyid(dev);\n\tnetdev_dbg(dev->net, "PHYID=0x%08x\\n", phyid);\n	f
31102	1274	ltr501_trigger_handler	drivers/iio/light/ltr501.c	ret	1	11	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tu16 buf[8];\n\t__le16 als_buf[2];\n\tu8 mask = 0;\n\tint j = 0;\n\tint ret, psdata;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\t/* figure out which data needs to be ready */\n\tif (test_bit(0, indio_dev->active_scan_mask) ||\n\t    test_bit(1, indio_dev->active_scan_mask))\n\t\tmask |= LTR501_STATUS_ALS_RDY;\n\tif (test_bit(2, indio_dev->active_scan_mask))\n\t\tmask |= LTR501_STATUS_PS_RDY;\n\n\tret = ltr501_drdy(data, mask);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (mask & LTR501_STATUS_ALS_RDY) {\n\t\tret = regmap_bulk_read(data->regmap, LTR501_ALS_DATA1,\n\t\t\t\t       (u8 *)als_buf, sizeof(als_buf));\n\t\tif (ret < 0)\n	f
54454	383	afs_fill_super	fs/afs/super.c	inode	1	11	\N	\N	\tstruct afs_super_info *as = sb->s_fs_info;\n\tstruct afs_fid fid;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter("");\n\n\t/* fill in the superblock */\n\tsb->s_blocksize\t\t= PAGE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_SHIFT;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tsb->s_xattr\t\t= afs_xattr_handlers;\n\tret = super_setup_bdi(sb);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_bdi->ra_pages\t= VM_MAX_READAHEAD * 1024 / PAGE_SIZE;\n\tstrlcpy(sb->s_id, as->volume->vlocation->vldb.name, sizeof(sb->s_id));\n\n\t/* allocate the root inode and dentry */\n\tfid.vid\t\t= as->volume->vid;\n\tfid.vnode\t= 1;\n\tfid.unique\t= 1;\n\tinode = afs_iget(sb, params->key, &fid, NULL, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (params->autocell)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n	f
61668	790	ahci_avn_hardreset	drivers/ata/ahci.c	sstatus	1	11	\N	\N	\tconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tunsigned long tmo = deadline - jiffies;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc, i;\n\n\tDPRINTK("ENTER\\n");\n\n\tahci_stop_engine(ap);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu16 val;\n\t\tu32 sstatus;\n\t\tint port = ap->port_no;\n\t\tstruct ata_host *host = ap->host;\n\t\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\n\t\t/* clear D2H reception area to properly wait for D2H FIS */\n\t\tata_tf_init(link->device, &tf);\n\t\ttf.command = ATA_BUSY;\n\t\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\t\trc = sata_link_hardreset(link, timing, deadline, &online,\n\t\t\t\tahci_check_ready);\n\n\t\tif (sata_scr_read(link, SCR_STATUS, &sstatus) != 0 ||\n\t\t\t\t(sstatus & 0xf) != 1)\n	f
62369	419	ltr501_read_ps	drivers/iio/light/ltr501.c	ret	1	11	\N	\N	\tint ret, status;\n\n\tret = ltr501_drdy(data, LTR501_STATUS_PS_RDY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, LTR501_PS_DATA,\n\t\t\t       &status, 2);\n\tif (ret < 0)\n	f
1891	166	verify_eraseblock	drivers/mtd/tests/subpagetest.c	subpgsize	1	21	\N	\N	\tsize_t read;\n\tint err = 0;\n\tloff_t addr = (loff_t)ebnum * mtd->erasesize;\n\n\tprandom_bytes_state(&rnd_state, writebuf, subpgsize);\n\tclear_data(readbuf, subpgsize);\n\terr = mtd_read(mtd, addr, subpgsize, &read, readbuf);\n\tif (unlikely(err || read != subpgsize)) {\n\t\tif (mtd_is_bitflip(err) && read == subpgsize) {\n\t\t\tpr_info("ECC correction at %#llx\\n",\n\t\t\t       (long long)addr);\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tpr_err("error: read failed at %#llx\\n",\n\t\t\t       (long long)addr);\n\t\t\treturn err ? err : -1;\n\t\t}\n\t}\n\tif (unlikely(memcmp(readbuf, writebuf, subpgsize))) {\n\t\tpr_err("error: verify failed at %#llx\\n",\n\t\t       (long long)addr);\n\t\tpr_info("------------- written----------------\\n");\n\t\tprint_subpage(writebuf);\n\t\tpr_info("------------- read ------------------\\n");\n\t\tprint_subpage(readbuf);\n\t\tpr_info("-------------------------------------\\n");\n\t\terrcnt += 1;\n\t}\n\n\taddr += subpgsize;\n\n\tprandom_bytes_state(&rnd_state, writebuf, subpgsize);\n\tclear_data(readbuf, subpgsize);\n\terr = mtd_read(mtd, addr, subpgsize, &read, readbuf);\n\tif (unlikely(err || read != subpgsize)) {\n	f
6611	565	vfio_basic_config_write	drivers/vfio/pci/vfio_pci_config.c	phys_cmd	1	21	\N	\N	\tstruct pci_dev *pdev = vdev->pdev;\n\t__le16 *virt_cmd;\n\tu16 new_cmd = 0;\n\tint ret;\n\n\tvirt_cmd = (__le16 *)&vdev->vconfig[PCI_COMMAND];\n\n\tif (offset == PCI_COMMAND) {\n\t\tbool phys_mem, virt_mem, new_mem, phys_io, virt_io, new_io;\n\t\tu16 phys_cmd;\n\n\t\tret = pci_user_read_config_word(pdev, PCI_COMMAND, &phys_cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnew_cmd = le32_to_cpu(val);\n\n\t\tphys_mem = !!(phys_cmd & PCI_COMMAND_MEMORY);\n\t\tvirt_mem = !!(le16_to_cpu(*virt_cmd) & PCI_COMMAND_MEMORY);\n\t\tnew_mem = !!(new_cmd & PCI_COMMAND_MEMORY);\n\n\t\tphys_io = !!(phys_cmd & PCI_COMMAND_IO);\n	f
39974	963	m41t80_probe	drivers/rtc/rtc-m41t80.c	m41t80_probe_$tm$1$obj	0	11	\N	\N	\tstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\n\tint rc = 0;\n\tstruct rtc_device *rtc = NULL;\n\tstruct rtc_time tm;\n\tstruct m41t80_data *m41t80_data = NULL;\n\tbool wakeup_source = false;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&adapter->dev, "doesn't support I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tm41t80_data = devm_kzalloc(&client->dev, sizeof(*m41t80_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!m41t80_data)\n\t\treturn -ENOMEM;\n\n\tm41t80_data->client = client;\n\tif (client->dev.of_node)\n\t\tm41t80_data->features = (unsigned long)\n\t\t\tof_device_get_match_data(&client->dev);\n\telse\n\t\tm41t80_data->features = id->driver_data;\n\ti2c_set_clientdata(client, m41t80_data);\n\n#ifdef CONFIG_OF\n\twakeup_source = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t      "wakeup-source");\n#endif\n\tif (client->irq > 0) {\n\t\trc = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t       NULL, m41t80_handle_irq,\n\t\t\t\t\t       IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t       "m41t80", client);\n\t\tif (rc) {\n\t\t\tdev_warn(&client->dev, "unable to request IRQ, alarms disabled\\n");\n\t\t\tclient->irq = 0;\n\t\t\twakeup_source = false;\n\t\t}\n\t}\n\tif (client->irq > 0 || wakeup_source) {\n\t\tm41t80_rtc_ops.read_alarm = m41t80_read_alarm;\n\t\tm41t80_rtc_ops.set_alarm = m41t80_set_alarm;\n\t\tm41t80_rtc_ops.alarm_irq_enable = m41t80_alarm_irq_enable;\n\t\t/* Enable the wakealarm */\n\t\tdevice_init_wakeup(&client->dev, true);\n\t}\n\n\trtc = devm_rtc_device_register(&client->dev, client->name,\n\t\t\t\t       &m41t80_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tm41t80_data->rtc = rtc;\n\tif (client->irq <= 0) {\n\t\t/* We cannot support UIE mode if we do not have an IRQ line */\n\t\trtc->uie_unsupported = 1;\n\t}\n\n\t/* Make sure HT (Halt Update) bit is cleared */\n\trc = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_HOUR);\n\n\tif (rc >= 0 && rc & M41T80_ALHOUR_HT) {\n\t\tif (m41t80_data->features & M41T80_FEATURE_HT) {\n\t\t\tm41t80_get_datetime(client, &tm);\n\t\t\tdev_info(&client->dev, "HT bit was set!\\n");\n\t\t\tdev_info(&client->dev,\n	f
3748	196	cx18_queue_get_mdl	drivers/media/pci/cx18/cx18-queue.c	tmp	1	11	\N	\N	\tstruct cx18 *cx = s->cx;\n\tstruct cx18_mdl *mdl;\n\tstruct cx18_mdl *tmp;\n\tstruct cx18_mdl *ret = NULL;\n\tLIST_HEAD(sweep_up);\n\n\t/*\n\t * We don't have to acquire multiple q locks here, because we are\n\t * serialized by the single threaded work handler.\n\t * MDLs from the firmware will thus remain in order as\n\t * they are moved from q_busy to q_full or to the dvb ring buffer.\n\t */\n\tspin_lock(&s->q_busy.lock);\n\tlist_for_each_entry_safe(mdl, tmp, &s->q_busy.list, list) {\n\t\t/*\n\t\t * We should find what the firmware told us is done,\n\t\t * right at the front of the queue.  If we don't, we likely have\n\t\t * missed an mdl done message from the firmware.\n\t\t * Once we skip an mdl repeatedly, relative to the size of\n\t\t * q_busy, we have high confidence we've missed it.\n\t\t */\n\t\tif (mdl->id != id) {\n\t\t\tmdl->skipped++;\n\t\t\tif (mdl->skipped >= atomic_read(&s->q_busy.depth)-1) {\n\t\t\t\t/* mdl must have fallen out of rotation */\n\t\t\t\tCX18_WARN("Skipped %s, MDL %d, %d times - it must have dropped out of rotation\\n",\n\t\t\t\t\t  s->name, mdl->id,\n\t\t\t\t\t  mdl->skipped);\n\t\t\t\t/* Sweep it up to put it back into rotation */\n\t\t\t\tlist_move_tail(&mdl->list, &sweep_up);\n\t\t\t\tatomic_dec(&s->q_busy.depth);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We pull the desired mdl off of the queue here.  Something\n\t\t * will have to put it back on a queue later.\n\t\t */\n\t\tlist_del_init(&mdl->list);\n\t\tatomic_dec(&s->q_busy.depth);\n\t\tret = mdl;\n\t\tbreak;\n\t}\n\tspin_unlock(&s->q_busy.lock);\n\n\t/*\n\t * We found the mdl for which we were looking.  Get it ready for\n\t * the caller to put on q_full or in the dvb ring buffer.\n\t */\n\tif (ret != NULL) {\n\t\tret->bytesused = bytesused;\n\t\tret->skipped = 0;\n\t\t/* 0'ed readpos, m_flags & curr_buf when mdl went on q_busy */\n\t\tcx18_mdl_update_bufs_for_cpu(s, ret);\n\t\tif (s->type != CX18_ENC_STREAM_TYPE_TS)\n\t\t\tset_bit(CX18_F_M_NEED_SWAP, &ret->m_flags);\n\t}\n\n\t/* Put any mdls the firmware is ignoring back into normal rotation */\n\tlist_for_each_entry_safe(mdl, tmp, &sweep_up, list) {\n	t
4235	241	at91_rtc_setalarm	drivers/rtc/rtc-at91sam9.c	rtc	1	11	\N	\N	\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned long secs;\n\tu32 offset;\n\tu32 mr;\n\tint err;\n\n\terr = rtc_tm_to_time(tm, &secs);\n\tif (err != 0)\n\t\treturn err;\n\n\toffset = gpbr_readl(rtc);\n\tif (offset == 0) {\n\t\t/* time is not set */\n\t\treturn -EILSEQ;\n\t}\n\tmr = rtt_readl(rtc, MR);\n\trtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\n\n\t/* alarm in the past? finish and leave disabled */\n\tif (secs <= offset) {\n\t\trtt_writel(rtc, AR, ALARM_DISABLED);\n\t\treturn 0;\n\t}\n\n\t/* else set alarm and maybe enable it */\n\trtt_writel(rtc, AR, secs - offset);\n	t
46585	2224	do_loopback	fs/namespace.c	old	1	11	\N	\N	\tstruct path old_path;\n\tstruct mount *mnt = NULL, *old, *parent;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (mnt_ns_loop(old_path.dentry))\n\t\tgoto out;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tparent = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old))\n	t
44557	98	arvo_sysfs_show_key_mask	drivers/hid/hid-roccat-arvo.c	arvo_sysfs_show_key_mask_$temp_buf$1$obj	0	11	\N	\N	\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_key_mask temp_buf;\n\tint retval;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_receive(usb_dev, ARVO_COMMAND_KEY_MASK,\n\t\t\t&temp_buf, sizeof(struct arvo_key_mask));\n\tmutex_unlock(&arvo->arvo_lock);\n\tif (retval)\n\t\treturn retval;\n\n\treturn snprintf(buf, PAGE_SIZE, "%d\\n", temp_buf.key_mask);\n	t
9927	1379	batadv_tt_local_purge_list	net/batman-adv/translation-table.c	batadv_tt_local_purge_list_$____ptr20$obj	0	11	\N	\N	\tstruct batadv_tt_local_entry *tt_local_entry;\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct hlist_node *node_tmp;\n\n\thlist_for_each_entry_safe(tt_common_entry, node_tmp, head,\n	t
46791	750	amdgpu_ttm_tt_unpin_userptr	drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c	ttm->sg->sgl	0	11	\N	\N	\tstruct amdgpu_device *adev = amdgpu_ttm_adev(ttm->bdev);\n\tstruct amdgpu_ttm_tt *gtt = (void *)ttm;\n\tstruct sg_page_iter sg_iter;\n\n\tint write = !(gtt->userflags & AMDGPU_GEM_USERPTR_READONLY);\n\tenum dma_data_direction direction = write ?\n\t\tDMA_BIDIRECTIONAL : DMA_TO_DEVICE;\n\n\t/* double check that we don't free the table twice */\n\tif (!ttm->sg->sgl)\n\t\treturn;\n\n\t/* free the sg table and pages again */\n\tdma_unmap_sg(adev->dev, ttm->sg->sgl, ttm->sg->nents, direction);\n\n\tfor_each_sg_page(ttm->sg->sgl, &sg_iter, ttm->sg->nents, 0) {\n	f
36595	705	m_can_handle_state_change	drivers/net/can/m_can/m_can.c	cf->data	1	11	\N	\N	\tstruct m_can_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct can_berr_counter bec;\n\tunsigned int ecr;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t/* error warning state */\n\t\tpriv->can.can_stats.error_warning++;\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t/* error passive state */\n\t\tpriv->can.can_stats.error_passive++;\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t/* bus-off state */\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tm_can_disable_all_interrupts(priv);\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* propagate the error condition to the CAN stack */\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t__m_can_get_berr_counter(dev, &bec);\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t/* error warning state */\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n	f
9092	1017	__ip_rt_update_pmtu	net/ipv4/route.c	res	1	21	\N	\N	\tstruct dst_entry *dst = &rt->dst;\n\tstruct fib_result res;\n\n\tif (dst_metric_locked(dst, RTAX_MTU))\n\t\treturn;\n\n\tif (ipv4_mtu(dst) < mtu)\n\t\treturn;\n\n\tif (mtu < ip_rt_min_pmtu)\n\t\tmtu = ip_rt_min_pmtu;\n\n\tif (rt->rt_pmtu == mtu &&\n\t    time_before(jiffies, dst->expires - ip_rt_mtu_expires / 2))\n\t\treturn;\n\n\trcu_read_lock();\n\tif (fib_lookup(dev_net(dst->dev), fl4, &res, 0) == 0) {\n\t\tstruct fib_nh *nh = &FIB_RES_NH(res);\n	f
4238	812	__bfq_entity_update_weight_prio	block/bfq-wf2q.c	root	1	11	\N	\N	\tstruct bfq_service_tree *new_st = old_st;\n\n\tif (entity->prio_changed) {\n\t\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\t\tunsigned int prev_weight, new_weight;\n\t\tstruct bfq_data *bfqd = NULL;\n\t\tstruct rb_root *root;\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t\tstruct bfq_sched_data *sd;\n\t\tstruct bfq_group *bfqg;\n#endif\n\n\t\tif (bfqq)\n\t\t\tbfqd = bfqq->bfqd;\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t\telse {\n\t\t\tsd = entity->my_sched_data;\n\t\t\tbfqg = container_of(sd, struct bfq_group, sched_data);\n\t\t\tbfqd = (struct bfq_data *)bfqg->bfqd;\n\t\t}\n#endif\n\n\t\told_st->wsum -= entity->weight;\n\n\t\tif (entity->new_weight != entity->orig_weight) {\n\t\t\tif (entity->new_weight < BFQ_MIN_WEIGHT ||\n\t\t\t    entity->new_weight > BFQ_MAX_WEIGHT) {\n\t\t\t\tpr_crit("update_weight_prio: new_weight %d\\n",\n\t\t\t\t\tentity->new_weight);\n\t\t\t\tif (entity->new_weight < BFQ_MIN_WEIGHT)\n\t\t\t\t\tentity->new_weight = BFQ_MIN_WEIGHT;\n\t\t\t\telse\n\t\t\t\t\tentity->new_weight = BFQ_MAX_WEIGHT;\n\t\t\t}\n\t\t\tentity->orig_weight = entity->new_weight;\n\t\t\tif (bfqq)\n\t\t\t\tbfqq->ioprio =\n\t\t\t\t  bfq_weight_to_ioprio(entity->orig_weight);\n\t\t}\n\n\t\tif (bfqq && update_class_too)\n\t\t\tbfqq->ioprio_class = bfqq->new_ioprio_class;\n\n\t\t/*\n\t\t * Reset prio_changed only if the ioprio_class change\n\t\t * is not pending any longer.\n\t\t */\n\t\tif (!bfqq || bfqq->ioprio_class == bfqq->new_ioprio_class)\n\t\t\tentity->prio_changed = 0;\n\n\t\t/*\n\t\t * NOTE: here we may be changing the weight too early,\n\t\t * this will cause unfairness.  The correct approach\n\t\t * would have required additional complexity to defer\n\t\t * weight changes to the proper time instants (i.e.,\n\t\t * when entity->finish <= old_st->vtime).\n\t\t */\n\t\tnew_st = bfq_entity_service_tree(entity);\n\n\t\tprev_weight = entity->weight;\n\t\tnew_weight = entity->orig_weight *\n\t\t\t     (bfqq ? bfqq->wr_coeff : 1);\n\t\t/*\n\t\t * If the weight of the entity changes, remove the entity\n\t\t * from its old weight counter (if there is a counter\n\t\t * associated with the entity), and add it to the counter\n\t\t * associated with its new weight.\n\t\t */\n\t\tif (prev_weight != new_weight) {\n\t\t\troot = bfqq ? &bfqd->queue_weights_tree :\n\t\t\t\t      &bfqd->group_weights_tree;\n\t\t\tbfq_weights_tree_remove(bfqd, entity, root);\n\t\t}\n\t\tentity->weight = new_weight;\n\t\t/*\n\t\t * Add the entity to its weights tree only if it is\n\t\t * not associated with a weight-raised queue.\n\t\t */\n\t\tif (prev_weight != new_weight &&\n\t\t    (bfqq ? bfqq->wr_coeff == 1 : 1))\n\t\t\t/* If we get here, root has been initialized. */\n\t\t\tbfq_weights_tree_add(bfqd, entity, root);\n	t
7762	232	elan_smbus_get_max	drivers/input/mouse/elan_i2c_smbus.c	ret	1	21	\N	\N	\tint ret;\n\tint error;\n\tu8 val[3];\n\n\tret = i2c_smbus_read_block_data(client, ETP_SMBUS_RANGE_CMD, val);\n\tif (ret != 3) {\n	f
5115	427	drm_lspcon_get_mode	drivers/gpu/drm/drm_dp_dual_mode_helper.c	data	1	21	\N	\N	\tu8 data;\n\tint ret = 0;\n\n\tif (!mode) {\n\t\tDRM_ERROR("NULL input\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read Status: i2c over aux */\n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_LSPCON_CURRENT_MODE,\n\t\t\t\t    &data, sizeof(data));\n\tif (ret < 0) {\n\t\tDRM_ERROR("LSPCON read(0x80, 0x41) failed\\n");\n\t\treturn -EFAULT;\n\t}\n\n\tif (data & DP_DUAL_MODE_LSPCON_MODE_PCON)\n	f
3648	163	rxe_find_route6	drivers/infiniband/sw/rxe/rxe_net.c	ndst->error	1	21	\N	\N	\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6 = { { 0 } };\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = ndev->ifindex;\n\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl6.daddr, daddr, sizeof(*daddr));\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\n\tif (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),\n\t\t\t\t\t\trecv_sockets.sk6->sk, &ndst, &fl6))) {\n\t\tpr_err_ratelimited("no route to %pI6\\n", daddr);\n\t\tgoto put;\n\t}\n\n\tif (unlikely(ndst->error)) {\n	f
41272	872	api_cmd_create_chain	drivers/net/ethernet/huawei/hinic/hinic_hw_api_cmd.c	chain	1	11	\N	\N	\tstruct hinic_hwif *hwif = attr->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_api_cmd_chain *chain;\n\tint err;\n\n\tif (attr->num_cells & (attr->num_cells - 1)) {\n\t\tdev_err(&pdev->dev, "Invalid number of cells, must be power of 2\\n");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tchain = devm_kzalloc(&pdev->dev, sizeof(*chain), GFP_KERNEL);\n\tif (!chain)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = api_chain_init(chain, attr);\n	f
7213	2227	trace_event_eval_update	kernel/trace/trace_events.c	i	1	21	\N	\N	\tstruct trace_event_call *call, *p;\n\tconst char *last_system = NULL;\n\tint last_i;\n\tint i;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\t/* events are usually grouped together with systems */\n\t\tif (!last_system || call->class->system != last_system) {\n\t\t\tlast_i = 0;\n\t\t\tlast_system = call->class->system;\n\t\t}\n\n\t\tfor (i = last_i; i < len; i++) {\n	f
7931	1228	ov5640_binning_on	drivers/media/i2c/ov5640.c	temp	1	21	\N	\N	\tu8 temp;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_TIMING_TC_REG21, &temp);\n\tif (ret)\n\t\treturn ret;\n\ttemp &= 0xfe;\n\treturn temp ? 1 : 0;\n	f
9796	3568	skx_count_chabox	arch/x86/events/intel/uncore_snbep.c	bus	1	21	\N	\N	\tstruct pci_dev *chabox_dev = NULL;\n\tint bus, count = 0;\n\n\twhile (1) {\n\t\tchabox_dev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x208d, chabox_dev);\n\t\tif (!chabox_dev)\n\t\t\tbreak;\n\t\tif (count == 0)\n\t\t\tbus = chabox_dev->bus->number;\n\t\tif (bus != chabox_dev->bus->number)\n	f
10066	949	tcm_qla2xxx_tpg_enable_store	drivers/scsi/qla2xxx/tcm_qla2xxx.c	op	1	21	\N	\N	\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\tunsigned long op;\n\tint rc;\n\n\trc = kstrtoul(page, 0, &op);\n\tif (rc < 0) {\n\t\tpr_err("kstrtoul() returned %d\\n", rc);\n\t\treturn -EINVAL;\n\t}\n\tif ((op != 1) && (op != 0)) {\n	f
4944	1906	ov5640_g_volatile_ctrl	drivers/media/i2c/ov5640.c	val	1	21	\N	TP?	\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tint val;\n\n\t/* v4l2_ctrl_lock() locks our own mutex */\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (!ctrl->val)\n\t\t\treturn 0;\n\t\tval = ov5640_get_gain(sensor);\n\t\tif (val < 0)\n	f
31015	-1	netlbl_domhsh_remove_af4	net/netlabel/netlabel_domainhash.c	netlbl_domhsh_remove_af4_$iter6	0	11	\N	\N	\N	t
5064	156	intel_dp_aux_set_pwm_freq	drivers/gpu/drm/i915/intel_dp_aux_backlight.c	pn	1	11	\N	\N	\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(&connector->encoder->base);\n\tint freq, fxp, fxp_min, fxp_max, fxp_actual, f = 1;\n\tu8 pn, pn_min, pn_max;\n\n\t/* Find desired value of (F x P)\n\t * Note that, if F x P is out of supported range, the maximum value or\n\t * minimum value will applied automatically. So no need to check that.\n\t */\n\tfreq = dev_priv->vbt.backlight.pwm_freq_hz;\n\tDRM_DEBUG_KMS("VBT defined backlight frequency %u Hz\\n", freq);\n\tif (!freq) {\n\t\tDRM_DEBUG_KMS("Use panel default backlight frequency\\n");\n\t\treturn false;\n\t}\n\n\tfxp = DIV_ROUND_CLOSEST(KHz(DP_EDP_BACKLIGHT_FREQ_BASE_KHZ), freq);\n\n\t/* Use highest possible value of Pn for more granularity of brightness\n\t * adjustment while satifying the conditions below.\n\t * - Pn is in the range of Pn_min and Pn_max\n\t * - F is in the range of 1 and 255\n\t * - FxP is within 25% of desired value.\n\t *   Note: 25% is arbitrary value and may need some tweak.\n\t */\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t       DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min) != 1) {\n\t\tDRM_DEBUG_KMS("Failed to read pwmgen bit count cap min\\n");\n\t\treturn false;\n\t}\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t       DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max) != 1) {\n\t\tDRM_DEBUG_KMS("Failed to read pwmgen bit count cap max\\n");\n\t\treturn false;\n\t}\n\tpn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\tpn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\n\tfxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);\n\tfxp_max = DIV_ROUND_CLOSEST(fxp * 5, 4);\n\tif (fxp_min < (1 << pn_min) || (255 << pn_max) < fxp_max) {\n\t\tDRM_DEBUG_KMS("VBT defined backlight frequency out of range\\n");\n\t\treturn false;\n\t}\n\n\tfor (pn = pn_max; pn >= pn_min; pn--) {\n	t
6648	2349	drm_atomic_helper_swap_state	drivers/gpu/drm/drm_atomic_helper.c	new_plane_state->state	1	11	\N	\N	\tint i, ret;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tstruct drm_crtc_commit *commit;\n\tstruct drm_private_obj *obj;\n\tstruct drm_private_state *old_obj_state, *new_obj_state;\n\n\tif (stall) {\n\t\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\t\tspin_lock(&crtc->commit_lock);\n\t\t\tcommit = list_first_entry_or_null(&crtc->commit_list,\n\t\t\t\t\tstruct drm_crtc_commit, commit_entry);\n\t\t\tif (commit)\n\t\t\t\tdrm_crtc_commit_get(commit);\n\t\t\tspin_unlock(&crtc->commit_lock);\n\n\t\t\tif (!commit)\n\t\t\t\tcontinue;\n\n\t\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\t\tdrm_crtc_commit_put(commit);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_conn_state, new_conn_state, i) {\n\t\tWARN_ON(connector->state != old_conn_state);\n\n\t\told_conn_state->state = state;\n\t\tnew_conn_state->state = NULL;\n\n\t\tstate->connectors[i].state = old_conn_state;\n\t\tconnector->state = new_conn_state;\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tWARN_ON(crtc->state != old_crtc_state);\n\n\t\told_crtc_state->state = state;\n\t\tnew_crtc_state->state = NULL;\n\n\t\tstate->crtcs[i].state = old_crtc_state;\n\t\tcrtc->state = new_crtc_state;\n\n\t\tif (state->crtcs[i].commit) {\n\t\t\tspin_lock(&crtc->commit_lock);\n\t\t\tlist_add(&state->crtcs[i].commit->commit_entry,\n\t\t\t\t &crtc->commit_list);\n\t\t\tspin_unlock(&crtc->commit_lock);\n\n\t\t\tstate->crtcs[i].commit->event = NULL;\n\t\t}\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tWARN_ON(plane->state != old_plane_state);\n\n\t\told_plane_state->state = state;\n\t\tnew_plane_state->state = NULL;\n	t
44039	231	mt2266_set_params	drivers/media/tuners/mt2266.c	b	1	11	\N	\N	\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct mt2266_priv *priv;\n\tint ret=0;\n\tu32 freq;\n\tu32 tune;\n\tu8  lnaband;\n\tu8  b[10];\n\tint i;\n\tu8 band;\n\n\tpriv = fe->tuner_priv;\n\n\tfreq = priv->frequency / 1000; /* Hz -> kHz */\n\tif (freq < 470000 && freq > 230000)\n\t\treturn -EINVAL; /* Gap between VHF and UHF bands */\n\n\tpriv->frequency = c->frequency;\n\ttune = 2 * freq * (8192/16) / (FREF/16);\n\tband = (freq < 300000) ? MT2266_VHF : MT2266_UHF;\n\tif (band == MT2266_VHF)\n\t\ttune *= 2;\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tmt2266_writeregs(priv, mt2266_init_6mhz,\n\t\t\t\t sizeof(mt2266_init_6mhz));\n\t\tbreak;\n\tcase 8000000:\n\t\tmt2266_writeregs(priv, mt2266_init_8mhz,\n\t\t\t\t sizeof(mt2266_init_8mhz));\n\t\tbreak;\n\tcase 7000000:\n\tdefault:\n\t\tmt2266_writeregs(priv, mt2266_init_7mhz,\n\t\t\t\t sizeof(mt2266_init_7mhz));\n\t\tbreak;\n\t}\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\tif (band == MT2266_VHF && priv->band == MT2266_UHF) {\n\t\tdprintk("Switch from UHF to VHF");\n\t\tmt2266_writereg(priv, 0x05, 0x04);\n\t\tmt2266_writereg(priv, 0x19, 0x61);\n\t\tmt2266_writeregs(priv, mt2266_vhf, sizeof(mt2266_vhf));\n\t} else if (band == MT2266_UHF && priv->band == MT2266_VHF) {\n\t\tdprintk("Switch from VHF to UHF");\n\t\tmt2266_writereg(priv, 0x05, 0x52);\n\t\tmt2266_writereg(priv, 0x19, 0x61);\n\t\tmt2266_writeregs(priv, mt2266_uhf, sizeof(mt2266_uhf));\n\t}\n\tmsleep(10);\n\n\tif (freq <= 495000)\n\t\tlnaband = 0xEE;\n\telse if (freq <= 525000)\n\t\tlnaband = 0xDD;\n\telse if (freq <= 550000)\n\t\tlnaband = 0xCC;\n\telse if (freq <= 580000)\n\t\tlnaband = 0xBB;\n\telse if (freq <= 605000)\n\t\tlnaband = 0xAA;\n\telse if (freq <= 630000)\n\t\tlnaband = 0x99;\n\telse if (freq <= 655000)\n\t\tlnaband = 0x88;\n\telse if (freq <= 685000)\n\t\tlnaband = 0x77;\n\telse if (freq <= 710000)\n\t\tlnaband = 0x66;\n\telse if (freq <= 735000)\n\t\tlnaband = 0x55;\n\telse if (freq <= 765000)\n\t\tlnaband = 0x44;\n\telse if (freq <= 802000)\n\t\tlnaband = 0x33;\n\telse if (freq <= 840000)\n\t\tlnaband = 0x22;\n\telse\n\t\tlnaband = 0x11;\n\n\tb[0] = REG_TUNE;\n\tb[1] = (tune >> 8) & 0x1F;\n\tb[2] = tune & 0xFF;\n\tb[3] = tune >> 13;\n\tmt2266_writeregs(priv,b,4);\n\n\tdprintk("set_parms: tune=%d band=%d %s",\n\t\t(int) tune, (int) lnaband,\n\t\t(band == MT2266_UHF) ? "UHF" : "VHF");\n\tdprintk("set_parms: [1..3]: %2x %2x %2x",\n\t\t(int) b[1], (int) b[2], (int)b[3]);\n\n\tif (band == MT2266_UHF) {\n\t\tb[0] = 0x05;\n\t\tb[1] = (priv->band == MT2266_VHF) ? 0x52 : 0x62;\n\t\tb[2] = lnaband;\n\t\tmt2266_writeregs(priv, b, 3);\n\t}\n\n\t/* Wait for pll lock or timeout */\n\ti = 0;\n\tdo {\n\t\tmt2266_readreg(priv,REG_LOCK,b);\n\t\tif (b[0] & 0x40)\n	f
9336	752	fpu__init_system_xstate	arch/x86/kernel/fpu/xstate.c	fpu__init_system_xstate_@xfeatures_mask $obj$and$3	0	21	\N	\N	\N	f
8775	216	hash_netportnet4_uadt	net/netfilter/ipset/ip_set_hash_netportnet.c	hash_netportnet4_uadt_$e$2$0$obj	0	21	\N	\N	\tconst struct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 ip = 0, ip_to = 0, ip_last, p = 0, port, port_to;\n\tu32 ip2_from = 0, ip2_to = 0, ip2_last, ip2;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet4_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2], &ip2_from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (!e.cidr[0] || e.cidr[0] > HOST_MASK)\n	f
66	2641	cancel_dirty_page	mm/page-writeback.c	locked	1	21	\N	\N	\tstruct address_space *mapping = page_mapping(page);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tbool locked;\n\n\t\tlock_page_memcg(page);\n\t\twb = unlocked_inode_to_wb_begin(inode, &locked);\n\n\t\tif (TestClearPageDirty(page))\n\t\t\taccount_page_cleaned(page, mapping, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, locked);\n	f
2870	284	o2nm_node_ipv4_address_store	fs/ocfs2/cluster/nodemanager.c	octets	1	21	\N	\N	\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, "%3u.%3u.%3u.%3u", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n	f
4323	943	set_l3_qos_cfg	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c	cpu_mask	1	21	\N	\N	\tcpumask_var_t cpu_mask;\n\tstruct rdt_domain *d;\n\tint cpu;\n\n\tif (!zalloc_cpumask_var(&cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(d, &r->domains, list) {\n\t\t/* Pick one CPU from each domain instance to update MSR */\n\t\tcpumask_set_cpu(cpumask_any(&d->cpu_mask), cpu_mask);\n	f
9633	1131	trace_event_raw_event_kvm_hv_stimer_set_config	arch/x86/kvm/x86.c	vcpu	1	21	\N	\N	\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n	f
8526	1064	decode_write_chunk	net/sunrpc/xprtrdma/rpc_rdma.c	length	1	11	\N	\N	\tu32 segcount, seglength;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, sizeof(*p));\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\t*length = 0;\n\tsegcount = be32_to_cpup(p);\n\twhile (segcount--) {\n\t\tif (decode_rdma_segment(xdr, &seglength))\n\t\t\treturn -EIO;\n\t\t*length += seglength;\n\t}\n\n\tdprintk("RPC:       %s: segcount=%u, %u bytes\\n",\n	t
9339	889	early_identify_cpu	arch/x86/kernel/cpu/common.c	c	1	21	\N	\N	#ifdef CONFIG_X86_64\n\tc->x86_clflush_size = 64;\n\tc->x86_phys_bits = 36;\n\tc->x86_virt_bits = 48;\n#else\n\tc->x86_clflush_size = 32;\n\tc->x86_phys_bits = 32;\n\tc->x86_virt_bits = 32;\n#endif\n\tc->x86_cache_alignment = c->x86_clflush_size;\n\n\tmemset(&c->x86_capability, 0, sizeof c->x86_capability);\n\tc->extended_cpuid_level = 0;\n\n\t/* cyrix could have cpuid enabled via c_identify()*/\n\tif (have_cpuid_p()) {\n\t\tcpu_detect(c);\n\t\tget_cpu_vendor(c);\n\t\tget_cpu_cap(c);\n	f
7738	873	add_secret_dac_path	sound/pci/hda/patch_via.c	conn[i]	1	21	\N	\N	\tstruct via_spec *spec = codec->spec;\n\tint i, nums;\n\thda_nid_t conn[8];\n\thda_nid_t nid;\n\n\tif (!spec->gen.mixer_nid)\n\t\treturn 0;\n\tnums = snd_hda_get_connections(codec, spec->gen.mixer_nid, conn,\n\t\t\t\t       ARRAY_SIZE(conn) - 1);\n\tfor (i = 0; i < nums; i++) {\n\t\tif (get_wcaps_type(get_wcaps(codec, conn[i])) == AC_WID_AUD_OUT)\n	f
3071	967	applesmc_key_count_show	drivers/hwmon/applesmc.c	count	1	21	\N	\N	\tint ret;\n\tu8 buffer[4];\n\tu32 count;\n\n\tret = applesmc_read_key(KEY_COUNT_KEY, buffer, 4);\n\tcount = ((u32)buffer[0]<<24) + ((u32)buffer[1]<<16) +\n\t\t\t\t\t\t((u32)buffer[2]<<8) + buffer[3];\n\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn snprintf(sysfsbuf, PAGE_SIZE, "%d\\n", count);\n	f
9473	502	__do_cpuid_ent	arch/x86/kvm/cpuid.c	cap.version	1	21	\N	\N	\tint r;\n\tunsigned f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)\n\t\t\t\t? F(GBPAGES) : 0;\n\tunsigned f_lm = F(LM);\n#else\n\tunsigned f_gbpages = 0;\n\tunsigned f_lm = 0;\n#endif\n\tunsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;\n\tunsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;\n\tunsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;\n\tunsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;\n\n\t/* cpuid 1.edx */\n\tconst u32 kvm_cpuid_1_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */;\n\t/* cpuid 0x80000001.edx */\n\tconst u32 kvm_cpuid_8000_0001_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);\n\t/* cpuid 1.ecx */\n\tconst u32 kvm_cpuid_1_ecx_x86_features =\n\t\t/* NOTE: MONITOR (and MWAIT) are emulated as NOP,\n\t\t * but *not* advertised to guests via CPUID ! */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND);\n\t/* cpuid 0x80000001.ecx */\n\tconst u32 kvm_cpuid_8000_0001_ecx_x86_features =\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);\n\n\t/* cpuid 0xC0000001.edx */\n\tconst u32 kvm_cpuid_C000_0001_edx_x86_features =\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN);\n\n\t/* cpuid 7.0.ebx */\n\tconst u32 kvm_cpuid_7_0_ebx_x86_features =\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |\n\t\tF(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |\n\t\tF(SHA_NI) | F(AVX512BW) | F(AVX512VL);\n\n\t/* cpuid 0xD.1.eax */\n\tconst u32 kvm_cpuid_D_1_eax_x86_features =\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;\n\n\t/* cpuid 7.0.ecx*/\n\tconst u32 kvm_cpuid_7_0_ecx_x86_features =\n\t\tF(AVX512VBMI) | F(LA57) | F(PKU) |\n\t\t0 /*OSPKE*/ | F(AVX512_VPOPCNTDQ);\n\n\t/* cpuid 7.0.edx*/\n\tconst u32 kvm_cpuid_7_0_edx_x86_features =\n\t\tKF(AVX512_4VNNIW) | KF(AVX512_4FMAPS);\n\n\t/* all calls to cpuid_count() should be made on the same cpu */\n\tget_cpu();\n\n\tr = -E2BIG;\n\n\tif (*nent >= maxnent)\n\t\tgoto out;\n\n\tdo_cpuid_1_ent(entry, function, index);\n\t++*nent;\n\n\tswitch (function) {\n\tcase 0:\n\t\tentry->eax = min(entry->eax, (u32)0xd);\n\t\tbreak;\n\tcase 1:\n\t\tentry->edx &= kvm_cpuid_1_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_1_EDX);\n\t\tentry->ecx &= kvm_cpuid_1_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_1_ECX);\n\t\t/* we support x2apic emulation even if host does not support\n\t\t * it since we emulate x2apic in software */\n\t\tentry->ecx |= F(X2APIC);\n\t\tbreak;\n\t/* function 2 entries are STATEFUL. That is, repeated cpuid commands\n\t * may return different values. This forces us to get_cpu() before\n\t * issuing the first command, and also to emulate this annoying behavior\n\t * in kvm_emulate_cpuid() using KVM_CPUID_FLAG_STATE_READ_NEXT */\n\tcase 2: {\n\t\tint t, times = entry->eax & 0xff;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\tentry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\tfor (t = 1; t < times; ++t) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[t], function, 0);\n\t\t\tentry[t].flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\t/* function 4 has additional index. */\n\tcase 4: {\n\t\tint i, cache_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until cache_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tcache_type = entry[i - 1].eax & 0x1f;\n\t\t\tif (!cache_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 6: /* Thermal management */\n\t\tentry->eax = 0x4; /* allow ARAT */\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 7: {\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* Mask ebx against host capability word 9 */\n\t\tif (index == 0) {\n\t\t\tentry->ebx &= kvm_cpuid_7_0_ebx_x86_features;\n\t\t\tcpuid_mask(&entry->ebx, CPUID_7_0_EBX);\n\t\t\t// TSC_ADJUST is emulated\n\t\t\tentry->ebx |= F(TSC_ADJUST);\n\t\t\tentry->ecx &= kvm_cpuid_7_0_ecx_x86_features;\n\t\t\tcpuid_mask(&entry->ecx, CPUID_7_ECX);\n\t\t\t/* PKU is not yet implemented for shadow paging. */\n\t\t\tif (!tdp_enabled || !boot_cpu_has(X86_FEATURE_OSPKE))\n\t\t\t\tentry->ecx &= ~F(PKU);\n\t\t\tentry->edx &= kvm_cpuid_7_0_edx_x86_features;\n\t\t\tentry->edx &= get_scattered_cpuid_leaf(7, 0, CPUID_EDX);\n\t\t} else {\n\t\t\tentry->ebx = 0;\n\t\t\tentry->ecx = 0;\n\t\t\tentry->edx = 0;\n\t\t}\n\t\tentry->eax = 0;\n\t\tbreak;\n\t}\n\tcase 9:\n\t\tbreak;\n\tcase 0xa: { /* Architectural Performance Monitoring */\n\t\tstruct x86_pmu_capability cap;\n\t\tunion cpuid10_eax eax;\n\t\tunion cpuid10_edx edx;\n\n\t\tperf_get_x86_pmu_capability(&cap);\n\n\t\t/*\n\t\t * Only support guest architectural pmu on a host\n\t\t * with architectural pmu.\n\t\t */\n\t\tif (!cap.version)\n	f
7841	469	get_irq_affinity	drivers/infiniband/hw/hfi1/affinity.c	diff	1	21	\N	\N	\tint ret;\n\tcpumask_var_t diff;\n\tstruct hfi1_affinity_node *entry;\n\tstruct cpu_mask_set *set = NULL;\n\tstruct sdma_engine *sde = NULL;\n\tstruct hfi1_ctxtdata *rcd = NULL;\n\tchar extra[64];\n\tint cpu = -1;\n\n\textra[0] = '\\0';\n\tcpumask_clear(&msix->mask);\n\n\tret = zalloc_cpumask_var(&diff, GFP_KERNEL);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\tentry = node_affinity_lookup(dd->node);\n\n\tswitch (msix->type) {\n\tcase IRQ_SDMA:\n\t\tsde = (struct sdma_engine *)msix->arg;\n\t\tscnprintf(extra, 64, "engine %u", sde->this_idx);\n\t\tset = &entry->def_intr;\n\t\tbreak;\n\tcase IRQ_GENERAL:\n\t\tcpu = cpumask_first(&entry->general_intr_mask);\n\t\tbreak;\n\tcase IRQ_RCVCTXT:\n\t\trcd = (struct hfi1_ctxtdata *)msix->arg;\n\t\tif (rcd->ctxt == HFI1_CTRL_CTXT)\n\t\t\tcpu = cpumask_first(&entry->general_intr_mask);\n\t\telse\n\t\t\tset = &entry->rcv_intr;\n\t\tscnprintf(extra, 64, "ctxt %u", rcd->ctxt);\n\t\tbreak;\n\tdefault:\n\t\tdd_dev_err(dd, "Invalid IRQ type %d\\n", msix->type);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * The general and control contexts are placed on a particular\n\t * CPU, which is set above. Skip accounting for it. Everything else\n\t * finds its CPU here.\n\t */\n\tif (cpu == -1 && set) {\n\t\tif (cpumask_equal(&set->mask, &set->used)) {\n\t\t\t/*\n\t\t\t * We've used up all the CPUs, bump up the generation\n\t\t\t * and reset the 'used' map\n\t\t\t */\n\t\t\tset->gen++;\n\t\t\tcpumask_clear(&set->used);\n\t\t}\n\t\tcpumask_andnot(diff, &set->mask, &set->used);\n	f
9198	833	matroxfb_set_par	drivers/video/fbdev/matrox/matroxfb_base.c	minfo	1	11	\N	\N	\tint err;\n\tint visual;\n\tint cmap_len;\n\tunsigned int ydstorg;\n\tstruct fb_var_screeninfo *var;\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG(__func__)\n\n\tif (minfo->dead) {\n\t\treturn -ENXIO;\n\t}\n\n\tvar = &info->var;\n\tif ((err = matroxfb_decode_var(minfo, var, &visual, &cmap_len, &ydstorg)) != 0)\n\t\treturn err;\n\tminfo->fbcon.screen_base = vaddr_va(minfo->video.vbase) + ydstorg;\n\tmatroxfb_update_fix(minfo);\n\tminfo->fbcon.fix.visual = visual;\n\tminfo->fbcon.fix.type = FB_TYPE_PACKED_PIXELS;\n\tminfo->fbcon.fix.type_aux = 0;\n\tminfo->fbcon.fix.line_length = (var->xres_virtual * var->bits_per_pixel) >> 3;\n\t{\n\t\tunsigned int pos;\n\n\t\tminfo->curr.cmap_len = cmap_len;\n\t\tydstorg += minfo->devflags.ydstorg;\n\t\tminfo->curr.ydstorg.bytes = ydstorg;\n\t\tminfo->curr.ydstorg.chunks = ydstorg >> (isInterleave(minfo) ? 3 : 2);\n\t\tif (var->bits_per_pixel == 4)\n\t\t\tminfo->curr.ydstorg.pixels = ydstorg;\n\t\telse\n\t\t\tminfo->curr.ydstorg.pixels = (ydstorg * 8) / var->bits_per_pixel;\n\t\tminfo->curr.final_bppShift = matroxfb_get_final_bppShift(minfo, var->bits_per_pixel);\n\t\t{\tstruct my_timming mt;\n\t\t\tstruct matrox_hw_state* hw;\n\t\t\tint out;\n\n\t\t\tmatroxfb_var2my(var, &mt);\n\t\t\tmt.crtc = MATROXFB_SRC_CRTC1;\n\t\t\t/* CRTC1 delays */\n\t\t\tswitch (var->bits_per_pixel) {\n\t\t\t\tcase  0:\tmt.delay = 31 + 0; break;\n\t\t\t\tcase 16:\tmt.delay = 21 + 8; break;\n\t\t\t\tcase 24:\tmt.delay = 17 + 8; break;\n\t\t\t\tcase 32:\tmt.delay = 16 + 8; break;\n\t\t\t\tdefault:\tmt.delay = 31 + 8; break;\n\t\t\t}\n\n\t\t\thw = &minfo->hw;\n\n\t\t\tdown_read(&minfo->altout.lock);\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->compute) {\n\t\t\t\t\tminfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tup_read(&minfo->altout.lock);\n\t\t\tminfo->crtc1.pixclock = mt.pixclock;\n\t\t\tminfo->crtc1.mnp = mt.mnp;\n\t\t\tminfo->hw_switch->init(minfo, &mt);\n\t\t\tpos = (var->yoffset * var->xres_virtual + var->xoffset) * minfo->curr.final_bppShift / 32;\n\t\t\tpos += minfo->curr.ydstorg.chunks;\n\n\t\t\thw->CRTC[0x0D] = pos & 0xFF;\n\t\t\thw->CRTC[0x0C] = (pos & 0xFF00) >> 8;\n\t\t\thw->CRTCEXT[0] = (hw->CRTCEXT[0] & 0xF0) | ((pos >> 16) & 0x0F) | ((pos >> 14) & 0x40);\n\t\t\thw->CRTCEXT[8] = pos >> 21;\n\t\t\tminfo->hw_switch->restore(minfo);\n\t\t\tupdate_crtc2(minfo, pos);\n\t\t\tdown_read(&minfo->altout.lock);\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->program) {\n\t\t\t\t\tminfo->outputs[out].output->program(minfo->outputs[out].data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->start) {\n\t\t\t\t\tminfo->outputs[out].output->start(minfo->outputs[out].data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tup_read(&minfo->altout.lock);\n\t\t\tmatrox_cfbX_init(minfo);\n	t
20241	1109	cfs_hash_destroy	drivers/staging/lustre/lnet/libcfs/hash.c	bd.bd_bucket->hsb_count	1	11	\N	\N	\tstruct hlist_node *hnode;\n\tstruct hlist_node *pos;\n\tstruct cfs_hash_bd bd;\n\tint i;\n\n\tLASSERT(hs);\n\tLASSERT(!cfs_hash_is_exiting(hs) &&\n\t\t!cfs_hash_is_iterating(hs));\n\n\t/**\n\t * prohibit further rehashes, don't need any lock because\n\t * I'm the only (last) one can change it.\n\t */\n\ths->hs_exiting = 1;\n\tif (cfs_hash_with_rehash(hs))\n\t\tcfs_hash_rehash_cancel(hs);\n\n\tcfs_hash_depth_wi_cancel(hs);\n\t/* rehash should be done/canceled */\n\tLASSERT(hs->hs_buckets && !hs->hs_rehash_buckets);\n\n\tcfs_hash_for_each_bucket(hs, &bd, i) {\n\t\tstruct hlist_head *hhead;\n\n\t\tLASSERT(bd.bd_bucket);\n\t\t/* no need to take this lock, just for consistent code */\n\t\tcfs_hash_bd_lock(hs, &bd, 1);\n\n\t\tcfs_hash_bd_for_each_hlist(hs, &bd, hhead) {\n\t\t\thlist_for_each_safe(hnode, pos, hhead) {\n\t\t\t\tLASSERTF(!cfs_hash_with_assert_empty(hs),\n\t\t\t\t\t "hash %s bucket %u(%u) is not empty: %u items left\\n",\n\t\t\t\t\t hs->hs_name, bd.bd_bucket->hsb_index,\n\t\t\t\t\t bd.bd_offset, bd.bd_bucket->hsb_count);\n\t\t\t\t/* can't assert key valicate, because we\n\t\t\t\t * can interrupt rehash\n\t\t\t\t */\n\t\t\t\tcfs_hash_bd_del_locked(hs, &bd, hnode);\n\t\t\t\tcfs_hash_exit(hs, hnode);\n\t\t\t}\n\t\t}\n\t\tLASSERT(!bd.bd_bucket->hsb_count);\n	t
2558	180	of_usb_get_dr_mode_by_phy	drivers/usb/common/common.c	dr_mode	1	21	\N	\N	\tstruct device_node *controller = NULL;\n\tstruct of_phandle_args args;\n\tconst char *dr_mode;\n\tint index;\n\tint err;\n\n\tdo {\n\t\tcontroller = of_find_node_with_property(controller, "phys");\n\t\tindex = 0;\n\t\tdo {\n\t\t\tif (arg0 == -1) {\n\t\t\t\targs.np = of_parse_phandle(controller, "phys",\n\t\t\t\t\t\t\tindex);\n\t\t\t\targs.args_count = 0;\n\t\t\t} else {\n\t\t\t\terr = of_parse_phandle_with_args(controller,\n\t\t\t\t\t\t\t"phys", "#phy-cells",\n\t\t\t\t\t\t\tindex, &args);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tof_node_put(args.np);\n\t\t\tif (args.np == np && (args.args_count == 0 ||\n\t\t\t\t\t      args.args[0] == arg0))\n\t\t\t\tgoto finish;\n\t\t\tindex++;\n\t\t} while (args.np);\n\t} while (controller);\n\nfinish:\n\terr = of_property_read_string(controller, "dr_mode", &dr_mode);\n\tof_node_put(controller);\n\n\tif (err < 0)\n\t\treturn USB_DR_MODE_UNKNOWN;\n\n\treturn usb_get_dr_mode_from_string(dr_mode);\n	f
8308	2899	slot_store	drivers/md/md.c	slot	1	21	\N	\N	\tint slot;\n\tint err;\n\n\tif (test_bit(Journal, &rdev->flags))\n\t\treturn -EBUSY;\n\tif (strncmp(buf, "none", 4)==0)\n\t\tslot = -1;\n\telse {\n\t\terr = kstrtouint(buf, 10, (unsigned int *)&slot);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (rdev->mddev->pers && slot == -1) {\n	f
8530	138	trace_event_raw_event_skip_task_reaping	mm/oom_kill.c	struct oom_control *oc	1	21	\N	\N	\treturn oc->order == -1;\n}\n\n	f
20667	779	handle_transaction_done	drivers/char/ipmi/ipmi_si_intf.c	msg	1	11	\N	\N	\tstruct ipmi_smi_msg *msg;\n\n\tdebug_timestamp("Done");\n\tswitch (smi_info->si_state) {\n\tcase SI_NORMAL:\n\t\tif (!smi_info->curr_msg)\n\t\t\tbreak;\n\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tdeliver_recv_msg(smi_info, msg);\n\t\tbreak;\n\n\tcase SI_GETTING_FLAGS:\n\t{\n\t\tunsigned char msg[4];\n\t\tunsigned int  len;\n\n\t\t/* We got the flags from the SMI, now handle them. */\n\t\tlen = smi_info->handlers->get_result(smi_info->si_sm, msg, 4);\n\t\tif (msg[2] != 0) {\n\t\t\t/* Error fetching flags, just give up for now. */\n\t\t\tsmi_info->si_state = SI_NORMAL;\n\t\t} else if (len < 4) {\n\t\t\t/*\n\t\t\t * Hmm, no flags.  That's technically illegal, but\n\t\t\t * don't use uninitialized data.\n\t\t\t */\n\t\t\tsmi_info->si_state = SI_NORMAL;\n\t\t} else {\n\t\t\tsmi_info->msg_flags = msg[3];\n\t\t\thandle_flags(smi_info);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_CLEARING_FLAGS:\n\t{\n\t\tunsigned char msg[3];\n\n\t\t/* We cleared the flags. */\n\t\tsmi_info->handlers->get_result(smi_info->si_sm, msg, 3);\n\t\tif (msg[2] != 0) {\n\t\t\t/* Error clearing flags */\n\t\t\tdev_warn(smi_info->dev,\n\t\t\t\t "Error clearing flags: %2.2x\\n", msg[2]);\n\t\t}\n\t\tsmi_info->si_state = SI_NORMAL;\n\t\tbreak;\n\t}\n\n\tcase SI_GETTING_EVENTS:\n\t{\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tif (msg->rsp[2] != 0) {\n\t\t\t/* Error getting event, probably done. */\n\t\t\tmsg->done(msg);\n\n\t\t\t/* Take off the event flag. */\n\t\t\tsmi_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\n\t\t\thandle_flags(smi_info);\n\t\t} else {\n\t\t\tsmi_inc_stat(smi_info, events);\n\n\t\t\t/*\n\t\t\t * Do this before we deliver the message\n\t\t\t * because delivering the message releases the\n\t\t\t * lock and something else can mess with the\n\t\t\t * state.\n\t\t\t */\n\t\t\thandle_flags(smi_info);\n\n\t\t\tdeliver_recv_msg(smi_info, msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_GETTING_MESSAGES:\n\t{\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tif (msg->rsp[2] != 0) {\n\t\t\t/* Error getting event, probably done. */\n\t\t\tmsg->done(msg);\n\n\t\t\t/* Take off the msg flag. */\n\t\t\tsmi_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\n\t\t\thandle_flags(smi_info);\n\t\t} else {\n\t\t\tsmi_inc_stat(smi_info, incoming_messages);\n\n\t\t\t/*\n\t\t\t * Do this before we deliver the message\n\t\t\t * because delivering the message releases the\n\t\t\t * lock and something else can mess with the\n\t\t\t * state.\n\t\t\t */\n\t\t\thandle_flags(smi_info);\n\n\t\t\tdeliver_recv_msg(smi_info, msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_CHECKING_ENABLES:\n\t{\n\t\tunsigned char msg[4];\n\t\tu8 enables;\n\t\tbool irq_on;\n\n\t\t/* We got the flags from the SMI, now handle them. */\n\t\tsmi_info->handlers->get_result(smi_info->si_sm, msg, 4);\n\t\tif (msg[2] != 0) {\n\t\t\tdev_warn(smi_info->dev,\n\t\t\t\t "Couldn't get irq info: %x.\\n", msg[2]);\n\t\t\tdev_warn(smi_info->dev,\n\t\t\t\t "Maybe ok, but ipmi might run very slowly.\\n");\n\t\t\tsmi_info->si_state = SI_NORMAL;\n\t\t\tbreak;\n\t\t}\n\t\tenables = current_global_enables(smi_info, 0, &irq_on);\n\t\tif (smi_info->si_type == SI_BT)\n\t\t\t/* BT has its own interrupt enable bit. */\n\t\t\tcheck_bt_irq(smi_info, irq_on);\n\t\tif (enables != (msg[3] & GLOBAL_ENABLES_MASK)) {\n	t
201	502	hfsplus_cat_read_inode	fs/hfsplus/inode.c	folder->flags	1	21	\N	\N	\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n	f
74	2527	account_page_redirty	mm/page-writeback.c	locked	1	21	\N	\N	\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tbool locked;\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &locked);\n\t\tcurrent->nr_dirtied--;\n\t\tdec_node_page_state(page, NR_DIRTIED);\n\t\tdec_wb_stat(wb, WB_DIRTIED);\n\t\tunlocked_inode_to_wb_end(inode, locked);\n	f
24078	1506	t4vf_alloc_mac_filt	drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c	index	1	11	\N	\N	\tint offset, ret = 0;\n\tunsigned nfilters = 0;\n\tunsigned int rem = naddr;\n\tstruct fw_vi_mac_cmd cmd, rpl;\n\tunsigned int max_naddr = adapter->params.arch.mps_tcam_size;\n\n\tif (naddr > max_naddr)\n\t\treturn -EINVAL;\n\n\tfor (offset = 0; offset < naddr; /**/) {\n\t\tunsigned int fw_naddr = (rem < ARRAY_SIZE(cmd.u.exact)\n\t\t\t\t\t ? rem\n\t\t\t\t\t : ARRAY_SIZE(cmd.u.exact));\n\t\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t\t     u.exact[fw_naddr]), 16);\n\t\tstruct fw_vi_mac_exact *p;\n\t\tint i;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t\t     (free ? FW_CMD_EXEC_F : 0) |\n\t\t\t\t\t     FW_VI_MAC_CMD_VIID_V(viid));\n\t\tcmd.freemacs_to_len16 =\n\t\t\tcpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |\n\t\t\t\t    FW_CMD_LEN16_V(len16));\n\n\t\tfor (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tp->valid_to_idx = cpu_to_be16(\n\t\t\t\tFW_VI_MAC_CMD_VALID_F |\n\t\t\t\tFW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));\n\t\t\tmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\n\t\t}\n\n\n\t\tret = t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), &rpl,\n\t\t\t\t\tsleep_ok);\n\t\tif (ret && ret != -ENOMEM)\n\t\t\tbreak;\n\n\t\tfor (i = 0, p = rpl.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tu16 index = FW_VI_MAC_CMD_IDX_G(\n\t\t\t\tbe16_to_cpu(p->valid_to_idx));\n\n\t\t\tif (idx)\n\t\t\t\tidx[offset+i] =\n\t\t\t\t\t(index >= max_naddr\n	t
3999	413	sctp_make_init_ack	net/sctp/sm_make_chunk.c	addrs_len	1	21	\N	\N	\tstruct sctp_supported_ext_param ext_param;\n\tstruct sctp_adaptation_ind_param aiparam;\n\tstruct sctp_paramhdr *auth_chunks = NULL;\n\tstruct sctp_paramhdr *auth_random = NULL;\n\tstruct sctp_paramhdr *auth_hmacs = NULL;\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_cookie_param *cookie;\n\tstruct sctp_inithdr initack;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\t__u8 extensions[4];\n\tsize_t chunksize;\n\tint num_ext = 0;\n\tint cookie_len;\n\tint addrs_len;\n\n\t/* Note: there may be no addresses to embed. */\n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t/* FIXME:  We really ought to build the cookie right\n\t * into the packet instead of allocating more fresh memory.\n\t */\n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n	f
4388	568	store_boost	drivers/cpufreq/cpufreq.c	enable	1	21	\N	\N	\tint ret, enable;\n\n\tret = sscanf(buf, "%d", &enable);\n\tif (ret != 1 || enable < 0 || enable > 1)\n	f
20005	1226	dvb_dmxdev_init	drivers/media/dvb-core/dmxdev.c	&dmxdev->filter[i]	1	11	\N	\N	\tint i;\n\n\tif (dmxdev->demux->open(dmxdev->demux) < 0)\n\t\treturn -EUSERS;\n\n\tdmxdev->filter = vmalloc(dmxdev->filternum * sizeof(struct dmxdev_filter));\n\tif (!dmxdev->filter)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dmxdev->mutex);\n\tspin_lock_init(&dmxdev->lock);\n\tfor (i = 0; i < dmxdev->filternum; i++) {\n\t\tdmxdev->filter[i].dev = dmxdev;\n\t\tdmxdev->filter[i].buffer.data = NULL;\n\t\tdvb_dmxdev_filter_state_set(&dmxdev->filter[i],\n	f
20119	371	get_ctl_value_v2	sound/usb/mixer.c	ret	1	11	\N	\N	\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4 + 3 * sizeof(__u32)]; /* enough space for one range */\n\tunsigned char *val;\n\tint idx = 0, ret, size;\n\t__u8 bRequest;\n\n\tif (request == UAC_GET_CUR) {\n\t\tbRequest = UAC2_CS_CUR;\n\t\tsize = uac2_ctl_value_size(cval->val_type);\n\t} else {\n\t\tbRequest = UAC2_CS_RANGE;\n\t\tsize = sizeof(buf);\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tret = snd_usb_lock_shutdown(chip) ? -EIO : 0;\n\tif (ret)\n\t\tgoto error;\n\n\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      validx, idx, buf, size);\n\tsnd_usb_unlock_shutdown(chip);\n\n\tif (ret < 0) {\n	f
20268	448	devpts_fill_super	fs/devpts/inode.c	inode	1	11	\N	\N	\tstruct inode *inode;\n\tint error;\n\n\ts->s_iflags &= ~SB_I_NODEV;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_time_gran = 1;\n\n\terror = -ENOMEM;\n\ts->s_fs_info = new_pts_fs_info(s);\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\terror = parse_mount_options(data, PARSE_MOUNT, &DEVPTS_SB(s)->mount_opts);\n\tif (error)\n\t\tgoto fail;\n\n\terror = -ENOMEM;\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n	f
9595	7710	handle_vmwrite	arch/x86/kvm/vmx.c	&e	1	21	\N	\N	\tunsigned long field;\n\tgva_t gva;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\t/* The value to write might be 32 or 64 bits, depending on L1's long\n\t * mode, and eventually we need to write that into a field of several\n\t * possible lengths. The code below first zero-extends the value to 64\n\t * bit (field_value), and then copies only the appropriate number of\n\t * bits into the vmcs12 field.\n\t */\n\tu64 field_value = 0;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tif (vmx_instruction_info & (1u << 10))\n\t\tfield_value = kvm_register_readl(vcpu,\n\t\t\t(((vmx_instruction_info) >> 3) & 0xf));\n\telse {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, false, &gva))\n\t\t\treturn 1;\n\t\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t   &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {\n\t\t\tkvm_inject_page_fault(vcpu, &e);\n	f
146	5616	ext4_writepage_trans_blocks	fs/ext4/inode.c	ext4_writepage_trans_blocks_	8	12	\N	\N	\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n	t
9901	1411	asd_update_port_links	drivers/scsi/aic94xx/aic94xx_seq.c	err	1	21	\N	\N	\tconst u8 phy_mask = (u8) phy->asd_port->phy_mask;\n\tu8  phy_is_up;\n\tu8  mask;\n\tint i, err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\n\tfor_each_phy(phy_mask, mask, i)\n\t\tasd_ddbsite_write_byte(asd_ha, 0,\n\t\t\t\t       offsetof(struct asd_ddb_seq_shared,\n\t\t\t\t\t\tport_map_by_links)+i,phy_mask);\n\n\tfor (i = 0; i < 12; i++) {\n\t\tphy_is_up = asd_ddbsite_read_byte(asd_ha, 0,\n\t\t\t  offsetof(struct asd_ddb_seq_shared, phy_is_up));\n\t\terr = asd_ddbsite_update_byte(asd_ha, 0,\n\t\t\t\toffsetof(struct asd_ddb_seq_shared, phy_is_up),\n\t\t\t\tphy_is_up,\n\t\t\t\tphy_is_up | phy_mask);\n\t\tif (!err)\n\t\t\tbreak;\n\t\telse if (err == -EFAULT) {\n\t\t\tasd_printk("phy_is_up: parity error in DDB 0\\n");\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\n\n\tif (err)\n	f
9283	158	elan_smbus_get_version	drivers/input/mouse/elan_i2c_smbus.c	error	1	21	\N	\N	\tint error;\n\tu8 val[3];\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  iap ? ETP_SMBUS_IAP_VERSION_CMD :\n\t\t\t\t\t\tETP_SMBUS_FW_VERSION_CMD,\n\t\t\t\t\t  val);\n\tif (error < 0) {\n	f
7663	572	btt_freelist_init	drivers/nvdimm/btt.c	btt_freelist_init_$log_new$1$obj	0	21	\N	\N	\tint old, new, ret;\n\tu32 i, map_entry;\n\tstruct log_entry log_new, log_old;\n\n\tarena->freelist = kcalloc(arena->nfree, sizeof(struct free_entry),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!arena->freelist)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < arena->nfree; i++) {\n\t\told = btt_log_read(arena, i, &log_old, LOG_OLD_ENT);\n\t\tif (old < 0)\n\t\t\treturn old;\n\n\t\tnew = btt_log_read(arena, i, &log_new, LOG_NEW_ENT);\n\t\tif (new < 0)\n\t\t\treturn new;\n\n\t\t/* sub points to the next one to be overwritten */\n\t\tarena->freelist[i].sub = 1 - new;\n\t\tarena->freelist[i].seq = nd_inc_seq(le32_to_cpu(log_new.seq));\n\t\tarena->freelist[i].block = le32_to_cpu(log_new.old_map);\n\n\t\t/*\n\t\t * FIXME: if error clearing fails during init, we want to make\n\t\t * the BTT read-only\n\t\t */\n\t\tif (ent_e_flag(log_new.old_map)) {\n\t\t\tret = arena_clear_freelist_error(arena, i);\n\t\t\tif (ret)\n\t\t\t\tdev_err_ratelimited(to_dev(arena),\n\t\t\t\t\t"Unable to clear known errors\\n");\n\t\t}\n\n\t\t/* This implies a newly created or untouched flog entry */\n\t\tif (log_new.old_map == log_new.new_map)\n	f
121	1727	ext4_mb_check_limits	fs/ext4/mballoc.c	max	1	11	\N	\N	\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n	t
336	450	snd_seq_timer_get_cur_time	sound/core/seq/seq_timer.c	tmr->last_update	1	21	\N	\N	\tsnd_seq_real_time_t cur_time;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tcur_time = tmr->cur_time;\n\tif (tmr->running) { \n\t\tstruct timespec64 tm;\n\n\t\tktime_get_ts64(&tm);\n\t\ttm = timespec64_sub(tm, tmr->last_update);\n	f
518	155	trusted_read	security/keys/trusted.c	data	1	21	\N	\N	\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info("trusted_key: can't alloc %s\\n", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n	f
4929	553	pv_eoi_get_pending	arch/x86/kvm/lapic.c	val	1	21	\N	\N	\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug("Can't read EOI MSR value: 0x%llx\\n",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n	f
9830	225	trace_event_raw_event_block_bio_bounce	block/blk-core.c	work	1	21	\N	\N	\tstruct request_queue *q;\n\n\tq = container_of(work, struct request_queue, delay_work.work);\n	f
2371	260	pcf8523_rtc_ioctl	drivers/rtc/rtc-pcf8523.c	value	1	21	\N	postcondition	\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 value;\n\tint ret = 0, err;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\terr = pcf8523_read(client, REG_CONTROL3, &value);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (value & REG_CONTROL3_BLF)\n	f
229	153	acpi_ps_alloc_op	drivers/acpi/acpica/psutils.c	op	1	11	\N	\N	\tunion acpi_parse_object *op;\n\tconst struct acpi_opcode_info *op_info;\n\tu8 flags = ACPI_PARSEOP_GENERIC;\n\n\tACPI_FUNCTION_ENTRY();\n\n\top_info = acpi_ps_get_opcode_info(opcode);\n\n\t/* Determine type of parse_op required */\n\n\tif (op_info->flags & AML_DEFER) {\n\t\tflags = ACPI_PARSEOP_DEFERRED;\n\t} else if (op_info->flags & AML_NAMED) {\n\t\tflags = ACPI_PARSEOP_NAMED_OBJECT;\n\t} else if (opcode == AML_INT_BYTELIST_OP) {\n\t\tflags = ACPI_PARSEOP_BYTELIST;\n\t}\n\n\t/* Allocate the minimum required size object */\n\n\tif (flags == ACPI_PARSEOP_GENERIC) {\n\n\t\t/* The generic op (default) is by far the most common (16 to 1) */\n\n\t\top = acpi_os_acquire_object(acpi_gbl_ps_node_cache);\n\t} else {\n\t\t/* Extended parseop */\n\n\t\top = acpi_os_acquire_object(acpi_gbl_ps_node_ext_cache);\n\t}\n\n\t/* Initialize the Op */\n\n\tif (op) {\n\t\tacpi_ps_init_op(op, opcode);\n	t
8400	2039	hv_pci_protocol_negotiation	drivers/pci/host/pci-hyperv.c	comp_pkt.completion_status	1	21	\N	\N	\tstruct pci_version_request *version_req;\n\tstruct hv_pci_compl comp_pkt;\n\tstruct pci_packet *pkt;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Initiate the handshake with the host and negotiate\n\t * a version that the host can support. We start with the\n\t * highest version number and go down if the host cannot\n\t * support it.\n\t */\n\tpkt = kzalloc(sizeof(*pkt) + sizeof(*version_req), GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&comp_pkt.host_event);\n\tpkt->completion_func = hv_pci_generic_compl;\n\tpkt->compl_ctxt = &comp_pkt;\n\tversion_req = (struct pci_version_request *)&pkt->message;\n\tversion_req->message_type.type = PCI_QUERY_PROTOCOL_VERSION;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci_protocol_versions); i++) {\n\t\tversion_req->protocol_version = pci_protocol_versions[i];\n\t\tret = vmbus_sendpacket(hdev->channel, version_req,\n\t\t\t\tsizeof(struct pci_version_request),\n\t\t\t\t(unsigned long)pkt, VM_PKT_DATA_INBAND,\n\t\t\t\tVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->device,\n\t\t\t\t"PCI Pass-through VSP failed sending version reqquest: %#x",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twait_for_completion(&comp_pkt.host_event);\n\n\t\tif (comp_pkt.completion_status >= 0) {\n	f
52091	1453	cx24120_init	drivers/media/dvb-frontends/cx24120.c	vers	1	11	\N	\N	\tconst struct firmware *fw;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\tu8 reg;\n\tint ret, i;\n\tunsigned char vers[4];\n\n\tif (state->cold_init)\n\t\treturn 0;\n\n\t/* ???? */\n\tcx24120_writereg(state, 0xea, 0x00);\n\tcx24120_test_rom(state);\n\treg = cx24120_readreg(state, 0xfb) & 0xfe;\n\tcx24120_writereg(state, 0xfb, reg);\n\treg = cx24120_readreg(state, 0xfc) & 0xfe;\n\tcx24120_writereg(state, 0xfc, reg);\n\tcx24120_writereg(state, 0xc3, 0x04);\n\tcx24120_writereg(state, 0xc4, 0x04);\n\tcx24120_writereg(state, 0xce, 0x00);\n\tcx24120_writereg(state, 0xcf, 0x00);\n\treg = cx24120_readreg(state, 0xea) & 0xfe;\n\tcx24120_writereg(state, 0xea, reg);\n\tcx24120_writereg(state, 0xeb, 0x0c);\n\tcx24120_writereg(state, 0xec, 0x06);\n\tcx24120_writereg(state, 0xed, 0x05);\n\tcx24120_writereg(state, 0xee, 0x03);\n\tcx24120_writereg(state, 0xef, 0x05);\n\tcx24120_writereg(state, 0xf3, 0x03);\n\tcx24120_writereg(state, 0xf4, 0x44);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcx24120_writereg(state, 0xf0 + i, 0x04);\n\t\tcx24120_writereg(state, 0xe6 + i, 0x02);\n\t}\n\n\tcx24120_writereg(state, 0xea, (reg | 0x01));\n\tfor (i = 0; i < 6; i += 2) {\n\t\tcx24120_writereg(state, 0xc5 + i, 0x00);\n\t\tcx24120_writereg(state, 0xc6 + i, 0x00);\n\t}\n\n\tcx24120_writereg(state, 0xe4, 0x03);\n\tcx24120_writereg(state, 0xeb, 0x0a);\n\n\tdev_dbg(&state->i2c->dev, "requesting firmware (%s) to download...\\n",\n\t\tCX24120_FIRMWARE);\n\n\tret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);\n\tif (ret) {\n\t\terr("Could not load firmware (%s): %d\\n", CX24120_FIRMWARE,\n\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->i2c->dev,\n\t\t"Firmware found, size %d bytes (%02x %02x .. %02x %02x)\\n",\n\t\t(int)fw->size,\t\t\t/* firmware_size in bytes */\n\t\tfw->data[0],\t\t\t/* fw 1st byte */\n\t\tfw->data[1],\t\t\t/* fw 2d byte */\n\t\tfw->data[fw->size - 2],\t\t/* fw before last byte */\n\t\tfw->data[fw->size - 1]);\t/* fw last byte */\n\n\tcx24120_test_rom(state);\n\treg = cx24120_readreg(state, 0xfb) & 0xfe;\n\tcx24120_writereg(state, 0xfb, reg);\n\tcx24120_writereg(state, 0xe0, 0x76);\n\tcx24120_writereg(state, 0xf7, 0x81);\n\tcx24120_writereg(state, 0xf8, 0x00);\n\tcx24120_writereg(state, 0xf9, 0x00);\n\tcx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);\n\tcx24120_writereg(state, 0xf7, 0xc0);\n\tcx24120_writereg(state, 0xe0, 0x00);\n\treg = (fw->size - 2) & 0x00ff;\n\tcx24120_writereg(state, 0xf8, reg);\n\treg = ((fw->size - 2) >> 8) & 0x00ff;\n\tcx24120_writereg(state, 0xf9, reg);\n\tcx24120_writereg(state, 0xf7, 0x00);\n\tcx24120_writereg(state, 0xdc, 0x00);\n\tcx24120_writereg(state, 0xdc, 0x07);\n\tmsleep(500);\n\n\t/* Check final byte matches final byte of firmware */\n\treg = cx24120_readreg(state, 0xe1);\n\tif (reg == fw->data[fw->size - 1]) {\n\t\tdev_dbg(&state->i2c->dev, "Firmware uploaded successfully\\n");\n\t\tret = 0;\n\t} else {\n\t\terr("Firmware upload failed. Last byte returned=0x%x\\n", ret);\n\t\tret = -EREMOTEIO;\n\t}\n\tcx24120_writereg(state, 0xdc, 0x00);\n\trelease_firmware(fw);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Start tuner */\n\tcmd.id = CMD_START_TUNER;\n\tcmd.len = 3;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x00;\n\n\tif (cx24120_message_send(state, &cmd) != 0) {\n\t\terr("Error tuner start! :(\\n");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t/* Set VCO */\n\tret = cx24120_set_vco(state);\n\tif (ret != 0) {\n\t\terr("Error set VCO! :(\\n");\n\t\treturn ret;\n\t}\n\n\t/* set bandwidth */\n\tcmd.id = CMD_BANDWIDTH;\n\tcmd.len = 12;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x00;\n\tcmd.arg[3] = 0x00;\n\tcmd.arg[4] = 0x05;\n\tcmd.arg[5] = 0x02;\n\tcmd.arg[6] = 0x02;\n\tcmd.arg[7] = 0x00;\n\tcmd.arg[8] = 0x05;\n\tcmd.arg[9] = 0x02;\n\tcmd.arg[10] = 0x02;\n\tcmd.arg[11] = 0x00;\n\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr("Error set bandwidth!\\n");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treg = cx24120_readreg(state, 0xba);\n\tif (reg > 3) {\n\t\tdev_dbg(&state->i2c->dev, "Reset-readreg 0xba: %x\\n", ret);\n\t\terr("Error initialising tuner!\\n");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tdev_dbg(&state->i2c->dev, "Tuner initialised correctly.\\n");\n\n\t/* Initialise mpeg outputs */\n\tcx24120_writereg(state, 0xeb, 0x0a);\n\tif (cx24120_msg_mpeg_output_global_config(state, 0) ||\n\t    cx24120_msg_mpeg_output_config(state, 0) ||\n\t    cx24120_msg_mpeg_output_config(state, 1) ||\n\t    cx24120_msg_mpeg_output_config(state, 2)) {\n\t\terr("Error initialising mpeg output. :(\\n");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t/* Set size of BER window */\n\tcmd.id = CMD_BER_CTRL;\n\tcmd.len = 3;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = CX24120_BER_WINDOW;\n\tcmd.arg[2] = CX24120_BER_WINDOW;\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr("Error setting ber window\\n");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t/* Firmware CMD 35: Get firmware version */\n\tcmd.id = CMD_FWVERSION;\n\tcmd.len = 1;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.arg[0] = i;\n\t\tret = cx24120_message_send(state, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tvers[i] = cx24120_readreg(state, CX24120_REG_MAILBOX);\n\t}\n\tinfo("FW version %i.%i.%i.%i\\n", vers[0], vers[1], vers[2], vers[3]);\n	t
9651	868	gcmaes_decrypt	arch/x86/crypto/aesni-intel_glue.c	&src_sg_walk	1	21	\N	\N	\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 authTag[16];\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk dst_sg_walk = {};\n\tint retval = 0;\n\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\n\tif (sg_is_last(req->src) &&\n\t    (!PageHighMem(sg_page(req->src)) ||\n\t    req->src->offset + req->src->length <= PAGE_SIZE) &&\n\t    sg_is_last(req->dst) &&\n\t    (!PageHighMem(sg_page(req->dst)) ||\n\t    req->dst->offset + req->dst->length <= PAGE_SIZE)) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tassoc = scatterwalk_map(&src_sg_walk);\n\t\tsrc = assoc + req->assoclen;\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk) + req->assoclen;\n\t\t}\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n\t\tassoc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n\t\tif (!assoc)\n\t\t\treturn -ENOMEM;\n\t\tscatterwalk_map_and_copy(assoc, req->src, 0,\n\t\t\t\t\t req->assoclen + req->cryptlen, 0);\n\t\tsrc = assoc + req->assoclen;\n\t\tdst = src;\n\t}\n\n\n\tkernel_fpu_begin();\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\t\t  hash_subkey, assoc, assoclen,\n\t\t\t  authTag, auth_tag_len);\n\tkernel_fpu_end();\n\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst - req->assoclen);\n\t\t\tscatterwalk_advance(&dst_sg_walk, req->dst->length);\n\t\t\tscatterwalk_done(&dst_sg_walk, 1, 0);\n\t\t}\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_advance(&src_sg_walk, req->src->length);\n\t\tscatterwalk_done(&src_sg_walk, req->src == req->dst, 0);\n	f
259	634	pud_set_huge	arch/x86/mm/pgtable.c	uniform	1	21	\N	\N	\tu8 mtrr, uniform;\n\n\tmtrr = mtrr_type_lookup(addr, addr + PUD_SIZE, &uniform);\n\tif ((mtrr != MTRR_TYPE_INVALID) && (!uniform) &&\n	f
1816	185	tracefs_parse_options	fs/tracefs/inode.c	option	1	21	\N	\N	\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = TRACEFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, ",")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n	f
56711	248	net_prio_attach	net/core/netprio_cgroup.c	v	1	11	\N	\N	\tstruct task_struct *p;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(p, css, tset) {\n\t\tvoid *v = (void *)(unsigned long)css->cgroup->id;\n\n\t\ttask_lock(p);\n\t\titerate_fd(p->files, 0, update_netprio, v);\n	t
256	159	clear_page_presence	arch/x86/mm/kmmio.c	level	8	12	\N	\N	\tunsigned int level;\n\tpte_t *pte = lookup_address(f->addr, &level);\n\n\tif (!pte) {\n\t\tpr_err("no pte for addr 0x%08lx\\n", f->addr);\n\t\treturn -1;\n\t}\n\n\tswitch (level) {\n	t
3832	145	zip_compress	drivers/crypto/cavium/zip/zip_crypto.c	&zip_state	1	-1	\N	\N	\tstruct zip_operation  *zip_ops   = NULL;\n\tstruct zip_state      zip_state;\n\tstruct zip_device     *zip = NULL;\n\tint ret;\n\n\tif (!zip_ctx || !src || !dst || !dlen)\n\t\treturn -ENOMEM;\n\n\tzip = zip_get_device(zip_get_node_id());\n\tif (!zip)\n\t\treturn -ENODEV;\n\n\tmemset(&zip_state, 0, sizeof(struct zip_state));\n\tzip_ops = &zip_ctx->zip_comp;\n\n\tzip_ops->input_len  = slen;\n\tzip_ops->output_len = *dlen;\n\tmemcpy(zip_ops->input, src, slen);\n\n\tret = zip_deflate(zip_ops, &zip_state, zip);\n	f
2225	1755	aa_label_seq_xprint	security/apparmor/label.c	f	0	21	\N	\N	\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG("label print error");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, "%s", str);\n	f
10160	979	ipv4_pdp_add	drivers/net/gtp.c	pctx->u.v0.tid	1	21	\N	\N	\tstruct net_device *dev = gtp->dev;\n\tu32 hash_ms, hash_tid = 0;\n\tstruct pdp_ctx *pctx;\n\tbool found = false;\n\t__be32 ms_addr;\n\n\tms_addr = nla_get_be32(info->attrs[GTPA_MS_ADDRESS]);\n\thash_ms = ipv4_hashfn(ms_addr) % gtp->hash_size;\n\n\thlist_for_each_entry_rcu(pctx, &gtp->addr_hash[hash_ms], hlist_addr) {\n\t\tif (pctx->ms_addr_ip4.s_addr == ms_addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tif (info->nlhdr->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\t\tif (info->nlhdr->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tipv4_pdp_fill(pctx, info);\n\n\t\tif (pctx->gtp_version == GTP_V0)\n\t\t\tnetdev_dbg(dev, "GTPv0-U: update tunnel id = %llx (pdp %p)\\n",\n\t\t\t\t   pctx->u.v0.tid, pctx);\n\t\telse if (pctx->gtp_version == GTP_V1)\n\t\t\tnetdev_dbg(dev, "GTPv1-U: update tunnel id = %x/%x (pdp %p)\\n",\n\t\t\t\t   pctx->u.v1.i_tei, pctx->u.v1.o_tei, pctx);\n\n\t\treturn 0;\n\n\t}\n\n\tpctx = kmalloc(sizeof(struct pdp_ctx), GFP_KERNEL);\n\tif (pctx == NULL)\n\t\treturn -ENOMEM;\n\n\tsock_hold(sk);\n\tpctx->sk = sk;\n\tpctx->dev = gtp->dev;\n\tipv4_pdp_fill(pctx, info);\n\tatomic_set(&pctx->tx_seq, 0);\n\n\tswitch (pctx->gtp_version) {\n\tcase GTP_V0:\n\t\t/* TS 09.60: "The flow label identifies unambiguously a GTP\n\t\t * flow.". We use the tid for this instead, I cannot find a\n\t\t * situation in which this doesn't unambiguosly identify the\n\t\t * PDP context.\n\t\t */\n\t\thash_tid = gtp0_hashfn(pctx->u.v0.tid) % gtp->hash_size;\n\t\tbreak;\n\tcase GTP_V1:\n\t\thash_tid = gtp1u_hashfn(pctx->u.v1.i_tei) % gtp->hash_size;\n\t\tbreak;\n\t}\n\n\thlist_add_head_rcu(&pctx->hlist_addr, &gtp->addr_hash[hash_ms]);\n\thlist_add_head_rcu(&pctx->hlist_tid, &gtp->tid_hash[hash_tid]);\n\n\tswitch (pctx->gtp_version) {\n\tcase GTP_V0:\n\t\tnetdev_dbg(dev, "GTPv0-U: new PDP ctx id=%llx ssgn=%pI4 ms=%pI4 (pdp=%p)\\n",\n	f
7836	989	c4iw_post_send	drivers/infiniband/hw/cxgb4/qp.c	len16	1	21	\N	\N	\tint err = 0;\n\tu8 len16 = 0;\n\tenum fw_wr_opcodes fw_opcode = 0;\n\tenum fw_ri_wr_flags fw_flags;\n\tstruct c4iw_qp *qhp;\n\tunion t4_wr *wqe = NULL;\n\tu32 num_wrs;\n\tstruct t4_swsqe *swsqe;\n\tunsigned long flag;\n\tu16 idx = 0;\n\n\tqhp = to_c4iw_qp(ibqp);\n\tspin_lock_irqsave(&qhp->lock, flag);\n\tif (t4_wq_in_error(&qhp->wq)) {\n\t\tspin_unlock_irqrestore(&qhp->lock, flag);\n\t\tcomplete_sq_drain_wr(qhp, wr);\n\t\treturn err;\n\t}\n\tnum_wrs = t4_sq_avail(&qhp->wq);\n\tif (num_wrs == 0) {\n\t\tspin_unlock_irqrestore(&qhp->lock, flag);\n\t\t*bad_wr = wr;\n\t\treturn -ENOMEM;\n\t}\n\twhile (wr) {\n\t\tif (num_wrs == 0) {\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tbreak;\n\t\t}\n\t\twqe = (union t4_wr *)((u8 *)qhp->wq.sq.queue +\n\t\t      qhp->wq.sq.wq_pidx * T4_EQ_ENTRY_SIZE);\n\n\t\tfw_flags = 0;\n\t\tif (wr->send_flags & IB_SEND_SOLICITED)\n\t\t\tfw_flags |= FW_RI_SOLICITED_EVENT_FLAG;\n\t\tif (wr->send_flags & IB_SEND_SIGNALED || qhp->sq_sig_all)\n\t\t\tfw_flags |= FW_RI_COMPLETION_FLAG;\n\t\tswsqe = &qhp->wq.sq.sw_sq[qhp->wq.sq.pidx];\n\t\tswitch (wr->opcode) {\n\t\tcase IB_WR_SEND_WITH_INV:\n\t\tcase IB_WR_SEND:\n\t\t\tif (wr->send_flags & IB_SEND_FENCE)\n\t\t\t\tfw_flags |= FW_RI_READ_FENCE_FLAG;\n\t\t\tfw_opcode = FW_RI_SEND_WR;\n\t\t\tif (wr->opcode == IB_WR_SEND)\n\t\t\t\tswsqe->opcode = FW_RI_SEND;\n\t\t\telse\n\t\t\t\tswsqe->opcode = FW_RI_SEND_WITH_INV;\n\t\t\terr = build_rdma_send(&qhp->wq.sq, wqe, wr, &len16);\n\t\t\tbreak;\n\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tfw_opcode = FW_RI_RDMA_WRITE_WR;\n\t\t\tswsqe->opcode = FW_RI_RDMA_WRITE;\n\t\t\terr = build_rdma_write(&qhp->wq.sq, wqe, wr, &len16);\n\t\t\tbreak;\n\t\tcase IB_WR_RDMA_READ:\n\t\tcase IB_WR_RDMA_READ_WITH_INV:\n\t\t\tfw_opcode = FW_RI_RDMA_READ_WR;\n\t\t\tswsqe->opcode = FW_RI_READ_REQ;\n\t\t\tif (wr->opcode == IB_WR_RDMA_READ_WITH_INV) {\n\t\t\t\tc4iw_invalidate_mr(qhp->rhp,\n\t\t\t\t\t\t   wr->sg_list[0].lkey);\n\t\t\t\tfw_flags = FW_RI_RDMA_READ_INVALIDATE;\n\t\t\t} else {\n\t\t\t\tfw_flags = 0;\n\t\t\t}\n\t\t\terr = build_rdma_read(wqe, wr, &len16);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tswsqe->read_len = wr->sg_list[0].length;\n\t\t\tif (!qhp->wq.sq.oldest_read)\n\t\t\t\tqhp->wq.sq.oldest_read = swsqe;\n\t\t\tbreak;\n\t\tcase IB_WR_REG_MR: {\n\t\t\tstruct c4iw_mr *mhp = to_c4iw_mr(reg_wr(wr)->mr);\n\n\t\t\tswsqe->opcode = FW_RI_FAST_REGISTER;\n\t\t\tif (qhp->rhp->rdev.lldi.fr_nsmr_tpte_wr_support &&\n\t\t\t    !mhp->attr.state && mhp->mpl_len <= 2) {\n\t\t\t\tfw_opcode = FW_RI_FR_NSMR_TPTE_WR;\n\t\t\t\tbuild_tpte_memreg(&wqe->fr_tpte, reg_wr(wr),\n\t\t\t\t\t\t  mhp, &len16);\n\t\t\t} else {\n\t\t\t\tfw_opcode = FW_RI_FR_NSMR_WR;\n\t\t\t\terr = build_memreg(&qhp->wq.sq, wqe, reg_wr(wr),\n\t\t\t\t       mhp, &len16,\n\t\t\t\t       qhp->rhp->rdev.lldi.ulptx_memwrite_dsgl);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmhp->attr.state = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase IB_WR_LOCAL_INV:\n\t\t\tif (wr->send_flags & IB_SEND_FENCE)\n\t\t\t\tfw_flags |= FW_RI_LOCAL_FENCE_FLAG;\n\t\t\tfw_opcode = FW_RI_INV_LSTAG_WR;\n\t\t\tswsqe->opcode = FW_RI_LOCAL_INV;\n\t\t\terr = build_inv_stag(wqe, wr, &len16);\n\t\t\tc4iw_invalidate_mr(qhp->rhp, wr->ex.invalidate_rkey);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug("%s post of type=%d TBD!\\n", __func__,\n\t\t\t\t wr->opcode);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err) {\n\t\t\t*bad_wr = wr;\n\t\t\tbreak;\n\t\t}\n\t\tswsqe->idx = qhp->wq.sq.pidx;\n\t\tswsqe->complete = 0;\n\t\tswsqe->signaled = (wr->send_flags & IB_SEND_SIGNALED) ||\n\t\t\t\t  qhp->sq_sig_all;\n\t\tswsqe->flushed = 0;\n\t\tswsqe->wr_id = wr->wr_id;\n\t\tif (c4iw_wr_log) {\n\t\t\tswsqe->sge_ts = cxgb4_read_sge_timestamp(\n\t\t\t\t\tqhp->rhp->rdev.lldi.ports[0]);\n\t\t\tgetnstimeofday(&swsqe->host_ts);\n\t\t}\n\n\t\tinit_wr_hdr(wqe, qhp->wq.sq.pidx, fw_opcode, fw_flags, len16);\n\n\t\tpr_debug("%s cookie 0x%llx pidx 0x%x opcode 0x%x read_len %u\\n",\n\t\t\t __func__,\n\t\t\t (unsigned long long)wr->wr_id, qhp->wq.sq.pidx,\n\t\t\t swsqe->opcode, swsqe->read_len);\n\t\twr = wr->next;\n\t\tnum_wrs--;\n\t\tt4_sq_produce(&qhp->wq, len16);\n	f
5301	397	bmi160_trigger_handler	drivers/iio/imu/bmi160/bmi160_core.c	ret	1	21	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\t__le16 buf[16];\n\t/* 3 sens x 3 axis x __le16 + 3 x __le16 pad + 4 x __le16 tstamp */\n\tint i, ret, j = 0, base = BMI160_REG_DATA_MAGN_XOUT_L;\n\t__le16 sample;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = regmap_bulk_read(data->regmap, base + i * sizeof(sample),\n\t\t\t\t       &sample, sizeof(sample));\n\t\tif (ret < 0)\n	f
335	143	snd_seq_fifo_event_in	sound/core/seq/seq_fifo.c	snd_seq_fifo_event_in_$cell$obj	0	21	\N	\N	\tstruct snd_seq_event_cell *cell;\n\tunsigned long flags;\n\tint err;\n\n\tif (snd_BUG_ON(!f))\n\t\treturn -EINVAL;\n\n\tsnd_use_lock_use(&f->use_lock);\n\terr = snd_seq_event_dup(f->pool, event, &cell, 1, NULL); /* always non-blocking */\n\tif (err < 0) {\n\t\tif ((err == -ENOMEM) || (err == -EAGAIN))\n\t\t\tatomic_inc(&f->overflow);\n\t\tsnd_use_lock_free(&f->use_lock);\n\t\treturn err;\n\t}\n\t\t\n\t/* append new cells to fifo */\n\tspin_lock_irqsave(&f->lock, flags);\n\tif (f->tail != NULL)\n\t\tf->tail->next = cell;\n\tf->tail = cell;\n\tif (f->head == NULL)\n\t\tf->head = cell;\n\tcell->next = NULL;\n	f
3073	287	ccs811_trigger_handler	drivers/iio/chemical/ccs811.c	ret	1	21	\N	hard to say	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\ts16 buf[8]; /* s16 eCO2 + s16 TVOC + padding + 8 byte timestamp */\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, CCS811_ALG_RESULT_DATA, 4,\n\t\t\t\t\t    (u8 *)&buf);\n\tif (ret != 4) {\n	f
43471	1782	control_work_handler	drivers/char/virtio_console.c	buf	1	11	\N	\N	\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n	f
288	674	__split_large_page	arch/x86/mm/pageattr.c	level	2	-11	\N	\N	\tpte_t *pbase = (pte_t *)page_address(base);\n\tunsigned long ref_pfn, pfn, pfninc = 1;\n\tunsigned int i, level;\n\tpte_t *tmp;\n\tpgprot_t ref_prot;\n\n\tspin_lock(&pgd_lock);\n\t/*\n\t * Check for races, another CPU might have split this page\n\t * up for us already:\n\t */\n\ttmp = _lookup_address_cpa(cpa, address, &level);\n\tif (tmp != kpte) {\n\t\tspin_unlock(&pgd_lock);\n\t\treturn 1;\n\t}\n\n\tparavirt_alloc_pte(&init_mm, page_to_pfn(base));\n\n\tswitch (level) {\n	t
2795	919	input_set_keycode	drivers/input/input.c	old_keycode	0	21	\N	\N	\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t/* Make sure KEY_RESERVED did not get enabled. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/*\n\t * Simulate keyup event if keycode is not present\n\t * in the keymap anymore\n\t */\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n	t
9603	7817	handle_vmptrst	arch/x86/kvm/vmx.c	&e	1	21	\N	\N	\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\t/* ok to use *_system, as hardware has verified cpl=0 */\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n	f
9494	4031	em_fxrstor	arch/x86/kvm/emulate.c	fx_state.mxcsr	1	21	\N	\N	\tstruct fxregs_state fx_state;\n\tint rc;\n\tsize_t size;\n\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->ops->get_fpu(ctxt);\n\n\tsize = fxstate_size(ctxt);\n\tif (size < __fxstate_size(16)) {\n\t\trc = asm_safe("fxsave %[fx]", , [fx] "+m"(fx_state));\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto out;\n\t}\n\n\trc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto out;\n\n\tif (fx_state.mxcsr >> 16) {\n	f
27150	1217	do_action	drivers/isdn/gigaset/ev-layer.c	at_state->str_var	1	13	\N	\N	\tstruct at_state_t *at_state = *p_at_state;\n\tstruct bc_state *bcs2;\n\tunsigned long flags;\n\n\tint channel;\n\n\tunsigned char *s, *e;\n\tint i;\n\tunsigned long val;\n\n\tswitch (action) {\n\tcase ACT_NOTHING:\n\t\tbreak;\n\tcase ACT_TIMEOUT:\n\t\tat_state->waiting = 1;\n\t\tbreak;\n\tcase ACT_INIT:\n\t\tcs->at_state.pending_commands &= ~PC_INIT;\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tcs->mode = M_UNIMODEM;\n\t\tspin_lock_irqsave(&cs->lock, flags);\n\t\tif (!cs->cidmode) {\n\t\t\tspin_unlock_irqrestore(&cs->lock, flags);\n\t\t\tgigaset_free_channels(cs);\n\t\t\tcs->mstate = MS_READY;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&cs->lock, flags);\n\t\tcs->at_state.pending_commands |= PC_CIDMODE;\n\t\tgig_dbg(DEBUG_EVENT, "Scheduling PC_CIDMODE");\n\t\tcs->commands_pending = 1;\n\t\tbreak;\n\tcase ACT_FAILINIT:\n\t\tdev_warn(cs->dev, "Could not initialize the device.\\n");\n\t\tcs->dle = 0;\n\t\tinit_failed(cs, M_UNKNOWN);\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tbreak;\n\tcase ACT_CONFIGMODE:\n\t\tinit_failed(cs, M_CONFIG);\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tbreak;\n\tcase ACT_SETDLE1:\n\t\tcs->dle = 1;\n\t\t/* cs->inbuf[0].inputstate |= INS_command | INS_DLE_command; */\n\t\tcs->inbuf[0].inputstate &=\n\t\t\t~(INS_command | INS_DLE_command);\n\t\tbreak;\n\tcase ACT_SETDLE0:\n\t\tcs->dle = 0;\n\t\tcs->inbuf[0].inputstate =\n\t\t\t(cs->inbuf[0].inputstate & ~INS_DLE_command)\n\t\t\t| INS_command;\n\t\tbreak;\n\tcase ACT_CMODESET:\n\t\tif (cs->mstate == MS_INIT || cs->mstate == MS_RECOVER) {\n\t\t\tgigaset_free_channels(cs);\n\t\t\tcs->mstate = MS_READY;\n\t\t}\n\t\tcs->mode = M_CID;\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tbreak;\n\tcase ACT_UMODESET:\n\t\tcs->mode = M_UNIMODEM;\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tbreak;\n\tcase ACT_FAILCMODE:\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tif (cs->mstate == MS_INIT || cs->mstate == MS_RECOVER) {\n\t\t\tinit_failed(cs, M_UNKNOWN);\n\t\t\tbreak;\n\t\t}\n\t\tif (reinit_and_retry(cs, -1) < 0)\n\t\t\tschedule_init(cs, MS_RECOVER);\n\t\tbreak;\n\tcase ACT_FAILUMODE:\n\t\tcs->cur_at_seq = SEQ_NONE;\n\t\tschedule_init(cs, MS_RECOVER);\n\t\tbreak;\n\tcase ACT_HUPMODEM:\n\t\t/* send "+++" (hangup in unimodem mode) */\n\t\tif (cs->connected) {\n\t\t\tstruct cmdbuf_t *cb;\n\n\t\t\tcb = kmalloc(sizeof(struct cmdbuf_t) + 3, GFP_ATOMIC);\n\t\t\tif (!cb) {\n\t\t\t\tdev_err(cs->dev, "%s: out of memory\\n",\n\t\t\t\t\t__func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(cb->buf, "+++", 3);\n\t\t\tcb->len = 3;\n\t\t\tcb->offset = 0;\n\t\t\tcb->next = NULL;\n\t\t\tcb->wake_tasklet = NULL;\n\t\t\tcs->ops->write_cmd(cs, cb);\n\t\t}\n\t\tbreak;\n\tcase ACT_RING:\n\t\t/* get fresh AT state structure for new CID */\n\t\tat_state = get_free_channel(cs, ev->parameter);\n\t\tif (!at_state) {\n\t\t\tdev_warn(cs->dev,\n\t\t\t\t "RING ignored: could not allocate channel structure\\n");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* initialize AT state structure\n\t\t * note that bcs may be NULL if no B channel is free\n\t\t */\n\t\tat_state->ConState = 700;\n\t\tfor (i = 0; i < STR_NUM; ++i) {\n\t\t\tkfree(at_state->str_var[i]);\n	f
1564	274	do_match_mnt	security/apparmor/mount.c	perms->allow	1	21	\N	\N	\tunsigned int state;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(dfa, state, devname);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(dfa, state, type);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = compute_mnt_perms(dfa, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n	f
5054	977	store_max_perf_pct	drivers/cpufreq/intel_pstate.c	store_max_perf_pct_$__UNIQUE_ID_min1_246$obj	0	21	\N	\N	\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, "%u", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tglobal.max_perf_pct = clamp_t(int, input, global.min_perf_pct, 100);\n	f
4896	1672	dm_pool_block_is_used	drivers/md/dm-thin-metadata.c	ref_count	1	21	\N	imprecise due to indirect call	\tint r;\n\tuint32_t ref_count;\n\n\tdown_read(&pmd->root_lock);\n\tr = dm_sm_get_count(pmd->data_sm, b, &ref_count);\n\tif (!r)\n\t\t*result = (ref_count != 0);\n	f
2876	1103	asus_wmi_set_xusb2pr	drivers/platform/x86/asus-wmi.c	orig_ports_available	1	21	\N	\N	\tstruct pci_dev *xhci_pdev;\n\tu32 orig_ports_available;\n\tu32 ports_available = asus->driver->quirks->xusb2pr;\n\n\txhci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI,\n\t\t\tNULL);\n\n\tif (!xhci_pdev)\n\t\treturn;\n\n\tpci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\t\t&orig_ports_available);\n\n\tpci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\t\tcpu_to_le32(ports_available));\n\n\tpr_info("set USB_INTEL_XUSB2PR old: 0x%04x, new: 0x%04x\\n",\n	f
5050	1380	zs_map_object	mm/zsmalloc.c	pages	1	21	\N	\N	\tstruct zspage *zspage;\n\tstruct page *page;\n\tunsigned long obj, off;\n\tunsigned int obj_idx;\n\n\tunsigned int class_idx;\n\tenum fullness_group fg;\n\tstruct size_class *class;\n\tstruct mapping_area *area;\n\tstruct page *pages[2];\n\tvoid *ret;\n\n\t/*\n\t * Because we use per-cpu mapping areas shared among the\n\t * pools/users, we can't allow mapping in interrupt context\n\t * because it can corrupt another users mappings.\n\t */\n\tWARN_ON_ONCE(in_interrupt());\n\n\t/* From now on, migration cannot move the object */\n\tpin_tag(handle);\n\n\tobj = handle_to_obj(handle);\n\tobj_to_location(obj, &page, &obj_idx);\n\tzspage = get_zspage(page);\n\n\t/* migration cannot move any subpage in this zspage */\n\tmigrate_read_lock(zspage);\n\n\tget_zspage_mapping(zspage, &class_idx, &fg);\n\tclass = pool->size_class[class_idx];\n\toff = (class->size * obj_idx) & ~PAGE_MASK;\n\n\tarea = &get_cpu_var(zs_map_area);\n\tarea->vm_mm = mm;\n\tif (off + class->size <= PAGE_SIZE) {\n\t\t/* this object is contained entirely within a page */\n\t\tarea->vm_addr = kmap_atomic(page);\n\t\tret = area->vm_addr + off;\n\t\tgoto out;\n\t}\n\n\t/* this object spans two pages */\n\tpages[0] = page;\n\tpages[1] = get_next_page(page);\n\tBUG_ON(!pages[1]);\n	f
5466	188	nvkm_cstate_prog	drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c	ret	1	21	\N	\N	\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_therm *therm = device->therm;\n\tstruct nvkm_volt *volt = device->volt;\n\tstruct nvkm_cstate *cstate;\n\tint ret;\n\n\tif (!list_empty(&pstate->list)) {\n\t\tcstate = nvkm_cstate_get(clk, pstate, cstatei);\n\t\tcstate = nvkm_cstate_find_best(clk, pstate, cstate);\n\t} else {\n\t\tcstate = &pstate->base;\n\t}\n\n\tif (therm) {\n\t\tret = nvkm_therm_cstate(therm, pstate->fanspeed, +1);\n\t\tif (ret && ret != -ENODEV) {\n\t\t\tnvkm_error(subdev, "failed to raise fan speed: %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (volt) {\n\t\tret = nvkm_volt_set_id(volt, cstate->voltage,\n\t\t\t\t       pstate->base.voltage, clk->temp, +1);\n\t\tif (ret && ret != -ENODEV) {\n	f
45830	117	mlx5e_dcbnl_ieee_getets	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c	tc_group	1	11	\N	\N	\tstruct mlx5e_priv *priv = netdev_priv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu8 tc_group[IEEE_8021QAZ_MAX_TCS];\n\tbool is_tc_group_6_exist = false;\n\tbool is_zero_bw_ets_tc = false;\n\tint err = 0;\n\tint i;\n\n\tif (!MLX5_CAP_GEN(priv->mdev, ets))\n\t\treturn -EOPNOTSUPP;\n\n\tets->ets_cap = mlx5_max_tc(priv->mdev) + 1;\n\tfor (i = 0; i < ets->ets_cap; i++) {\n\t\terr = mlx5_query_port_prio_tc(mdev, i, &ets->prio_tc[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_query_port_tc_group(mdev, i, &tc_group[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_query_port_tc_bw_alloc(mdev, i, &ets->tc_tx_bw[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (ets->tc_tx_bw[i] < MLX5E_MAX_BW_ALLOC &&\n\t\t    tc_group[i] == (MLX5E_LOWEST_PRIO_GROUP + 1))\n	f
529	347	lp5523_update_program_memory	drivers/leds/leds-lp5523.c	offset	1	11	\N	\N	\tu8 pattern[LP5523_PROGRAM_LENGTH] = {0};\n\tunsigned cmd;\n\tchar c[3];\n\tint nrchars;\n\tint ret;\n\tint offset = 0;\n\tint i = 0;\n\n\twhile ((offset < size - 1) && (i < LP5523_PROGRAM_LENGTH)) {\n	t
8605	302	_rtl92d_get_txpower_writeval_by_regulatory	drivers/net/wireless/realtek/rtlwifi/rtl8192de/rf.c	customer_limit	1	11	\N	\N	\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 i, chnlgroup = 0, pwr_diff_limit[4];\n\tu32 writeval = 0, customer_limit, rf;\n\n\tfor (rf = 0; rf < 2; rf++) {\n\t\tswitch (rtlefuse->eeprom_regulatory) {\n\t\tcase 0:\n\t\t\tchnlgroup = 0;\n\t\t\twriteval = rtlphy->mcs_offset\n\t\t\t\t\t[chnlgroup][index +\n\t\t\t\t\t(rf ? 8 : 0)] + ((index < 2) ?\n\t\t\t\t\tpowerbase0[rf] :\n\t\t\t\t\tpowerbase1[rf]);\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t"RTK better performance, writeval(%c) = 0x%x\\n",\n\t\t\t\trf == 0 ? 'A' : 'B', writeval);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (rtlphy->pwrgroup_cnt == 1)\n\t\t\t\tchnlgroup = 0;\n\t\t\tif (rtlphy->pwrgroup_cnt >= MAX_PG_GROUP) {\n\t\t\t\tchnlgroup = _rtl92d_phy_get_chnlgroup_bypg(\n\t\t\t\t\t\t\t\tchannel - 1);\n\t\t\t\tif (rtlphy->current_chan_bw ==\n\t\t\t\t    HT_CHANNEL_WIDTH_20)\n\t\t\t\t\tchnlgroup++;\n\t\t\t\telse\n\t\t\t\t\tchnlgroup += 4;\n\t\t\t\twriteval = rtlphy->mcs_offset\n\t\t\t\t\t\t[chnlgroup][index +\n\t\t\t\t\t\t(rf ? 8 : 0)] + ((index < 2) ?\n\t\t\t\t\t\tpowerbase0[rf] :\n\t\t\t\t\t\tpowerbase1[rf]);\n\t\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\t"Realtek regulatory, 20MHz, writeval(%c) = 0x%x\\n",\n\t\t\t\t\trf == 0 ? 'A' : 'B', writeval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\twriteval = ((index < 2) ? powerbase0[rf] :\n\t\t\t\t   powerbase1[rf]);\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t"Better regulatory, writeval(%c) = 0x%x\\n",\n\t\t\t\trf == 0 ? 'A' : 'B', writeval);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tchnlgroup = 0;\n\t\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\t"customer's limit, 40MHz rf(%c) = 0x%x\\n",\n\t\t\t\t\trf == 0 ? 'A' : 'B',\n\t\t\t\t\trtlefuse->pwrgroup_ht40[rf]\n\t\t\t\t\t[channel - 1]);\n\t\t\t} else {\n\t\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\t"customer's limit, 20MHz rf(%c) = 0x%x\\n",\n\t\t\t\t\trf == 0 ? 'A' : 'B',\n\t\t\t\t\trtlefuse->pwrgroup_ht20[rf]\n\t\t\t\t\t[channel - 1]);\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpwr_diff_limit[i] = (u8)((rtlphy->mcs_offset\n\t\t\t\t\t[chnlgroup][index + (rf ? 8 : 0)] &\n\t\t\t\t\t(0x7f << (i * 8))) >> (i * 8));\n\t\t\t\tif (rtlphy->current_chan_bw ==\n\t\t\t\t    HT_CHANNEL_WIDTH_20_40) {\n\t\t\t\t\tif (pwr_diff_limit[i] >\n\t\t\t\t\t    rtlefuse->pwrgroup_ht40[rf]\n\t\t\t\t\t   [channel - 1])\n\t\t\t\t\t\tpwr_diff_limit[i] =\n\t\t\t\t\t\t\trtlefuse->pwrgroup_ht40\n\t\t\t\t\t\t\t[rf][channel - 1];\n\t\t\t\t} else {\n\t\t\t\t\tif (pwr_diff_limit[i] >\n\t\t\t\t\t    rtlefuse->pwrgroup_ht20[rf][\n\t\t\t\t\t\tchannel - 1])\n\t\t\t\t\t\tpwr_diff_limit[i] =\n\t\t\t\t\t\t   rtlefuse->pwrgroup_ht20[rf]\n\t\t\t\t\t\t   [channel - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcustomer_limit = (pwr_diff_limit[3] << 24) |\n\t\t\t\t\t (pwr_diff_limit[2] << 16) |\n\t\t\t\t\t (pwr_diff_limit[1] << 8) |\n\t\t\t\t\t (pwr_diff_limit[0]);\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n	t
27217	3151	ocfs2_do_extend_dir	fs/ocfs2/dir.c	p_blkno	1	13	\N	\N	\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n	f
24660	2754	load_copy_binary	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css.c	&copy_descr	1	11	\N	\N	\tstruct ia_css_frame_info copy_out_info, copy_in_info, copy_vf_info;\n\tunsigned int left_padding;\n\tenum ia_css_err err;\n\tstruct ia_css_binary_descr copy_descr;\n\n\t/* next_binary can be NULL */\n\tassert(pipe != NULL);\n\tassert(copy_binary != NULL);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t"load_copy_binary() enter:\\n");\n\n\tif (next_binary != NULL) {\n\t\tcopy_out_info = next_binary->in_frame_info;\n\t\tleft_padding = next_binary->left_padding;\n\t} else {\n\t\tcopy_out_info = pipe->output_info[0];\n\t\tcopy_vf_info = pipe->vf_output_info[0];\n\t\tia_css_frame_info_set_format(&copy_vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);\n\t\tleft_padding = 0;\n\t}\n\n\tia_css_pipe_get_copy_binarydesc(pipe, &copy_descr,\n\t\t&copy_in_info, &copy_out_info, (next_binary != NULL) ? NULL : NULL/*TODO: &copy_vf_info*/);\n\terr = ia_css_binary_find(&copy_descr, copy_binary);\n	t
54945	335	autofs4_mountpoint_changed	fs/autofs4/root.c	autofs4_mountpoint_changed_$ino$obj	0	11	\N	\N	\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\n\t/*\n\t * If this is an indirect mount the dentry could have gone away\n\t * as a result of an expire and a new one created.\n\t */\n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct dentry *new;\n\n\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tif (new == dentry)\n\t\t\tdput(new);\n\t\telse {\n\t\t\tstruct autofs_info *ino;\n\n\t\t\tino = autofs4_dentry_ino(new);\n\t\t\tino->last_used = jiffies;\n	f
33915	1620	ath10k_mac_setup_prb_tmpl	drivers/net/wireless/ath/ath10k/mac.c	prb	1	11	\N	\N	\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct sk_buff *prb;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn 0;\n\n\tprb = ieee80211_proberesp_get(hw, vif);\n\tif (!prb) {\n\t\tath10k_warn(ar, "failed to get probe resp template from mac80211\\n");\n\t\treturn -EPERM;\n\t}\n\n\tret = ath10k_wmi_prb_tmpl(ar, arvif->vdev_id, prb);\n	f
49393	2648	ath6kl_wmi_delete_pstream_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_delete_pstream_cmd_$cmd$obj	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class > 3) {\n\t\tath6kl_err("invalid traffic class: %d\\n", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n	t
53519	425	audit_add_watch	kernel/audit_watch.c	&parent_path	0	-11	\N	\N	\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n	f
53546	372	audit_get_nd	kernel/audit_watch.c	d	1	11	\N	\N	\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n	f
-205	320	gemini_clk_probe	drivers/clk/clk-gemini.c	val	4	20	\N	\N	\t/* Gives the fracions 1x, 1.5x, 1.85x and 2x */\n\tunsigned int cpu_ahb_mult[4] = { 1, 3, 24, 2 };\n\tunsigned int cpu_ahb_div[4] = { 1, 2, 13, 1 };\n\tvoid __iomem *base;\n\tstruct gemini_reset *gr;\n\tstruct regmap *map;\n\tstruct clk_hw *hw;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int mult, div;\n\tstruct resource *res;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tgr = devm_kzalloc(dev, sizeof(*gr), GFP_KERNEL);\n\tif (!gr)\n\t\treturn -ENOMEM;\n\n\t/* Remap the system controller for the exclusive register */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, "no syscon regmap\\n");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tgr->map = map;\n\tgr->rcdev.owner = THIS_MODULE;\n\tgr->rcdev.nr_resets = 32;\n\tgr->rcdev.ops = &gemini_reset_ops;\n\tgr->rcdev.of_node = np;\n\n\tret = devm_reset_controller_register(dev, &gr->rcdev);\n\tif (ret) {\n\t\tdev_err(dev, "could not register reset controller\\n");\n\t\treturn ret;\n\t}\n\n\t/* RTC clock 32768 Hz */\n\thw = clk_hw_register_fixed_rate(NULL, "rtc", NULL, 0, 32768);\n\tgemini_clk_data->hws[GEMINI_CLK_RTC] = hw;\n\n\t/* CPU clock derived as a fixed ratio from the AHB clock */\n\tregmap_read(map, GEMINI_GLOBAL_STATUS, &val);\n\tval >>= CPU_AHB_RATIO_SHIFT;\n\tval &= CPU_AHB_RATIO_MASK;\n\thw = clk_hw_register_fixed_factor(NULL, "cpu", "ahb", 0,\n	f
27243	332	ath3k_load_fwfile	drivers/bluetooth/ath3k.c	ret	1	13	\N	\N	\tu8 *send_buf;\n\tint len = 0;\n\tint err, pipe, size, count, sent = 0;\n\tint ret;\n\n\tcount = firmware->size;\n\n\tsend_buf = kmalloc(BULK_SIZE, GFP_KERNEL);\n\tif (!send_buf) {\n\t\tBT_ERR("Can't allocate memory chunk for firmware");\n\t\treturn -ENOMEM;\n\t}\n\n\tsize = min_t(uint, count, FW_HDR_SIZE);\n\tmemcpy(send_buf, firmware->data, size);\n\n\tpipe = usb_sndctrlpipe(udev, 0);\n\tret = usb_control_msg(udev, pipe, ATH3K_DNLOAD,\n\t\t\tUSB_TYPE_VENDOR, 0, 0, send_buf,\n\t\t\tsize, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n	f
25501	179	rtw_mlcst2unicst	drivers/staging/rtl8723bs/os_dep/xmit_linux.c	chk_alive_list[i]	1	11	\N	\N	\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct list_head\t*phead, *plist;\n\tstruct sk_buff *newskb;\n\tstruct sta_info *psta = NULL;\n\tu8 chk_alive_num = 0;\n\tchar chk_alive_list[NUM_STA];\n\tu8 bc_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tu8 null_addr[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n\tint i;\n\ts32\tres;\n\n\tDBG_COUNTER(padapter->tx_logs.os_tx_m2u);\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\tphead = &pstapriv->asoc_list;\n\tplist = get_next(phead);\n\n\t/* free sta asoc_queue */\n\twhile (phead != plist) {\n\t\tint stainfo_offset;\n\t\tpsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\n\t\tplist = get_next(plist);\n\n\t\tstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\n\t\tif (stainfo_offset_valid(stainfo_offset)) {\n\t\t\tchk_alive_list[chk_alive_num++] = stainfo_offset;\n\t\t}\n\t}\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tfor (i = 0; i < chk_alive_num; i++) {\n\t\tpsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\n	t
53166	320	batadv_mcast_mla_tt_add	net/batman-adv/multicast.c	batadv_mcast_mla_tt_add_$__mptr43$obj	0	11	\N	\N	\tstruct batadv_hw_addr *mcast_entry;\n\tstruct hlist_node *tmp;\n\n\tWARN_ON(delayed_work_pending(&bat_priv->mcast.work));\n\n\tif (!mcast_list)\n\t\treturn;\n\n\thlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {\n	f
55580	283	batadv_mcast_mla_tt_retract	net/batman-adv/multicast.c	batadv_mcast_mla_tt_retract_$____ptr33$obj	0	11	\N	\N	\tstruct batadv_hw_addr *mcast_entry;\n\tstruct hlist_node *tmp;\n\n\tWARN_ON(delayed_work_pending(&bat_priv->mcast.work));\n\n\thlist_for_each_entry_safe(mcast_entry, tmp, &bat_priv->mcast.mla_list,\n	f
49431	1610	ext4_get_parent	fs/ext4/namei.c	de->inode	7	12	\N	\N	\t__u32 ino;\n\tstatic const struct qstr dotdot = QSTR_INIT("..", 2);\n\tstruct ext4_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext4_find_entry(d_inode(child), &dotdot, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn (struct dentry *) bh;\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext4_valid_inum(child->d_sb, ino)) {\n	t
27270	2716	btusb_setup_qca	drivers/bluetooth/btusb.c	&ver	1	11	\N	\N	\tconst struct qca_device_info *info = NULL;\n\tstruct qca_version ver;\n\tu32 ver_rom;\n\tu8 status;\n\tint i, err;\n\n\terr = btusb_qca_send_vendor_req(hdev, QCA_GET_TARGET_VERSION, &ver,\n\t\t\t\t\tsizeof(ver));\n\tif (err < 0)\n\t\treturn err;\n\n\tver_rom = le32_to_cpu(ver.rom_version);\n\tfor (i = 0; i < ARRAY_SIZE(qca_devices_table); i++) {\n\t\tif (ver_rom == qca_devices_table[i].rom_version)\n\t\t\tinfo = &qca_devices_table[i];\n\t}\n\tif (!info) {\n\t\tBT_ERR("%s: don't support firmware rome 0x%x", hdev->name,\n\t\t       ver_rom);\n\t\treturn -ENODEV;\n\t}\n\n\terr = btusb_qca_send_vendor_req(hdev, QCA_CHECK_STATUS, &status,\n\t\t\t\t\tsizeof(status));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(status & QCA_PATCH_UPDATED)) {\n\t\terr = btusb_setup_qca_load_rampatch(hdev, &ver, info);\n	f
48123	348	batadv_v_elp_iface_enable	net/batman-adv/bat_v_elp.c	hard_iface->bat_v.elp_skb	1	11	\N	\N	\tstruct batadv_elp_packet *elp_packet;\n\tunsigned char *elp_buff;\n\tu32 random_seqno;\n\tsize_t size;\n\tint res = -ENOMEM;\n\n\tsize = ETH_HLEN + NET_IP_ALIGN + BATADV_ELP_HLEN;\n\thard_iface->bat_v.elp_skb = dev_alloc_skb(size);\n\tif (!hard_iface->bat_v.elp_skb)\n\t\tgoto out;\n\n\tskb_reserve(hard_iface->bat_v.elp_skb, ETH_HLEN + NET_IP_ALIGN);\n	f
32763	806	jffs2_build_xattr_subsystem	fs/jffs2/xattr.c	jffs2_build_xattr_subsystem_$tmp$obj$7	0	13	\N	\N	\tstruct jffs2_xattr_ref *ref, *_ref;\n\tstruct jffs2_xattr_ref *xref_tmphash[XREF_TMPHASH_SIZE];\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_raw_node_ref *raw;\n\tint i, xdatum_count = 0, xdatum_unchecked_count = 0, xref_count = 0;\n\tint xdatum_orphan_count = 0, xref_orphan_count = 0, xref_dead_count = 0;\n\n\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_BUILDING));\n\n\t/* Phase.1 : Merge same xref */\n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++)\n\t\txref_tmphash[i] = NULL;\n\tfor (ref=c->xref_temp; ref; ref=_ref) {\n\t\tstruct jffs2_xattr_ref *tmp;\n\n\t\t_ref = ref->next;\n\t\tif (ref_flags(ref->node) != REF_PRISTINE) {\n\t\t\tif (verify_xattr_ref(c, ref)) {\n\t\t\t\tBUG_ON(ref->node->next_in_ino != (void *)ref);\n\t\t\t\tref->node->next_in_ino = NULL;\n\t\t\t\tjffs2_mark_node_obsolete(c, ref->node);\n\t\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ti = (ref->ino ^ ref->xid) % XREF_TMPHASH_SIZE;\n\t\tfor (tmp=xref_tmphash[i]; tmp; tmp=tmp->next) {\n\t\t\tif (tmp->ino == ref->ino && tmp->xid == ref->xid)\n	f
40689	331	l2tp_debugfs_init	net/l2tp/l2tp_debugfs.c	l2tp_debugfs_init_@tunnels $obj	0	11	\N	\N	\tint rc = 0;\n\n\trootdir = debugfs_create_dir("l2tp", NULL);\n\tif (IS_ERR(rootdir)) {\n\t\trc = PTR_ERR(rootdir);\n\t\trootdir = NULL;\n\t\tgoto out;\n\t}\n\n\ttunnels = debugfs_create_file("tunnels", 0600, rootdir, NULL, &l2tp_dfs_fops);\n\tif (tunnels == NULL)\n	t
56075	236	batadv_v_elp_wifi_neigh_probe	net/batman-adv/bat_v_elp.c	skb	1	11	\N	\N	\tstruct batadv_hard_iface *hard_iface = neigh->if_incoming;\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tunsigned long last_tx_diff;\n\tstruct sk_buff *skb;\n\tint probe_len, i;\n\tint elp_skb_len;\n\n\t/* this probing routine is for Wifi neighbours only */\n\tif (!batadv_is_wifi_hardif(hard_iface))\n\t\treturn true;\n\n\t/* probe the neighbor only if no unicast packets have been sent\n\t * to it in the last 100 milliseconds: this is the rate control\n\t * algorithm sampling interval (minstrel). In this way, if not\n\t * enough traffic has been sent to the neighbor, batman-adv can\n\t * generate 2 probe packets and push the RC algorithm to perform\n\t * the sampling\n\t */\n\tlast_tx_diff = jiffies_to_msecs(jiffies - neigh->bat_v.last_unicast_tx);\n\tif (last_tx_diff <= BATADV_ELP_PROBE_MAX_TX_DIFF)\n\t\treturn true;\n\n\tprobe_len = max_t(int, sizeof(struct batadv_elp_packet),\n\t\t\t  BATADV_ELP_MIN_PROBE_SIZE);\n\n\tfor (i = 0; i < BATADV_ELP_PROBES_PER_NODE; i++) {\n\t\telp_skb_len = hard_iface->bat_v.elp_skb->len;\n\t\tskb = skb_copy_expand(hard_iface->bat_v.elp_skb, 0,\n\t\t\t\t      probe_len - elp_skb_len,\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn false;\n\n\t\t/* Tell the skb to get as big as the allocated space (we want\n\t\t * the packet to be exactly of that size to make the link\n\t\t * throughput estimation effective.\n\t\t */\n\t\tskb_put(skb, probe_len - hard_iface->bat_v.elp_skb->len);\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   "Sending unicast (probe) ELP packet on interface %s to %pM\\n",\n\t\t\t   hard_iface->net_dev->name, neigh->addr);\n\n\t\tbatadv_send_skb_packet(skb, hard_iface, neigh->addr);\n	f
30962	666	__bch_cache_set_store	drivers/md/bcache/sysfs.c	__bch_cache_set_store_$_v202$obj	0	11	\N	\N	\tstruct cache_set *c = container_of(kobj, struct cache_set, kobj);\n\n\tif (attr == &sysfs_unregister)\n\t\tbch_cache_set_unregister(c);\n\n\tif (attr == &sysfs_stop)\n\t\tbch_cache_set_stop(c);\n\n\tif (attr == &sysfs_synchronous) {\n\t\tbool sync = strtoul_or_return(buf);\n\n\t\tif (sync != CACHE_SYNC(&c->sb)) {\n\t\t\tSET_CACHE_SYNC(&c->sb, sync);\n\t\t\tbcache_write_super(c);\n\t\t}\n\t}\n\n\tif (attr == &sysfs_flash_vol_create) {\n\t\tint r;\n\t\tuint64_t v;\n\t\tstrtoi_h_or_return(buf, v);\n\n\t\tr = bch_flash_dev_create(c, v);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (attr == &sysfs_clear_stats) {\n\t\tatomic_long_set(&c->writeback_keys_done,\t0);\n\t\tatomic_long_set(&c->writeback_keys_failed,\t0);\n\n\t\tmemset(&c->gc_stats, 0, sizeof(struct gc_stat));\n\t\tbch_cache_accounting_clear(&c->accounting);\n\t}\n\n\tif (attr == &sysfs_trigger_gc) {\n\t\t/*\n\t\t * Garbage collection thread only works when sectors_to_gc < 0,\n\t\t * when users write to sysfs entry trigger_gc, most of time\n\t\t * they want to forcibly triger gargage collection. Here -1 is\n\t\t * set to c->sectors_to_gc, to make gc_should_run() give a\n\t\t * chance to permit gc thread to run. "give a chance" means\n\t\t * before going into gc_should_run(), there is still chance\n\t\t * that c->sectors_to_gc being set to other positive value. So\n\t\t * writing sysfs entry trigger_gc won't always make sure gc\n\t\t * thread takes effect.\n\t\t */\n\t\tatomic_set(&c->sectors_to_gc, -1);\n\t\twake_up_gc(c);\n\t}\n\n\tif (attr == &sysfs_prune_cache) {\n\t\tstruct shrink_control sc;\n\t\tsc.gfp_mask = GFP_KERNEL;\n\t\tsc.nr_to_scan = strtoul_or_return(buf);\n\t\tc->shrink.scan_objects(&c->shrink, &sc);\n\t}\n\n\tsysfs_strtoul(congested_read_threshold_us,\n\t\t      c->congested_read_threshold_us);\n\tsysfs_strtoul(congested_write_threshold_us,\n\t\t      c->congested_write_threshold_us);\n\n\tif (attr == &sysfs_errors) {\n\t\tssize_t v = bch_read_string_list(buf, error_actions);\n\n\t\tif (v < 0)\n\t\t\treturn v;\n\n\t\tc->on_error = v;\n\t}\n\n\tif (attr == &sysfs_io_error_limit)\n\t\tc->error_limit = strtoul_or_return(buf) << IO_ERROR_SHIFT;\n\n\t/* See count_io_errors() for why 88 */\n\tif (attr == &sysfs_io_error_halflife)\n\t\tc->error_decay = strtoul_or_return(buf) / 88;\n\n\tsysfs_strtoul(journal_delay_ms,\t\tc->journal_delay_ms);\n\tsysfs_strtoul(verify,\t\t\tc->verify);\n\tsysfs_strtoul(key_merging_disabled,\tc->key_merging_disabled);\n\tsysfs_strtoul(expensive_debug_checks,\tc->expensive_debug_checks);\n	f
31602	845	__bch_cache_show	drivers/md/bcache/sysfs.c	__bch_cache_show_$q$0$obj	0	11	\N	\N	\tstruct cache *ca = container_of(kobj, struct cache, kobj);\n\n\tsysfs_hprint(bucket_size,\tbucket_bytes(ca));\n\tsysfs_hprint(block_size,\tblock_bytes(ca));\n\tsysfs_print(nbuckets,\t\tca->sb.nbuckets);\n\tsysfs_print(discard,\t\tca->discard);\n\tsysfs_hprint(written, atomic_long_read(&ca->sectors_written) << 9);\n\tsysfs_hprint(btree_written,\n\t\t     atomic_long_read(&ca->btree_sectors_written) << 9);\n\tsysfs_hprint(metadata_written,\n\t\t     (atomic_long_read(&ca->meta_sectors_written) +\n\t\t      atomic_long_read(&ca->btree_sectors_written)) << 9);\n\n\tsysfs_print(io_errors,\n\t\t    atomic_read(&ca->io_errors) >> IO_ERROR_SHIFT);\n\n\tif (attr == &sysfs_cache_replacement_policy)\n\t\treturn bch_snprint_string_list(buf, PAGE_SIZE,\n\t\t\t\t\t       cache_replacement_policies,\n\t\t\t\t\t       CACHE_REPLACEMENT(&ca->sb));\n\n\tif (attr == &sysfs_priority_stats) {\n\t\tint cmp(const void *l, const void *r)\n\t\t{\treturn *((uint16_t *) r) - *((uint16_t *) l); }\n\n\t\tstruct bucket *b;\n\t\tsize_t n = ca->sb.nbuckets, i;\n\t\tsize_t unused = 0, available = 0, dirty = 0, meta = 0;\n\t\tuint64_t sum = 0;\n\t\t/* Compute 31 quantiles */\n\t\tuint16_t q[31], *p, *cached;\n\t\tssize_t ret;\n\n\t\tcached = p = vmalloc(ca->sb.nbuckets * sizeof(uint16_t));\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_lock(&ca->set->bucket_lock);\n\t\tfor_each_bucket(b, ca) {\n\t\t\tif (!GC_SECTORS_USED(b))\n\t\t\t\tunused++;\n\t\t\tif (GC_MARK(b) == GC_MARK_RECLAIMABLE)\n\t\t\t\tavailable++;\n\t\t\tif (GC_MARK(b) == GC_MARK_DIRTY)\n\t\t\t\tdirty++;\n\t\t\tif (GC_MARK(b) == GC_MARK_METADATA)\n\t\t\t\tmeta++;\n\t\t}\n\n\t\tfor (i = ca->sb.first_bucket; i < n; i++)\n\t\t\tp[i] = ca->buckets[i].prio;\n\t\tmutex_unlock(&ca->set->bucket_lock);\n\n\t\tsort(p, n, sizeof(uint16_t), cmp, NULL);\n\n\t\twhile (n &&\n\t\t       !cached[n - 1])\n\t\t\t--n;\n\n\t\tunused = ca->sb.nbuckets - n;\n\n\t\twhile (cached < p + n &&\n\t\t       *cached == BTREE_PRIO)\n\t\t\tcached++, n--;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tsum += INITIAL_PRIO - cached[i];\n\n\t\tif (n)\n\t\t\tdo_div(sum, n);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(q); i++)\n\t\t\tq[i] = INITIAL_PRIO - cached[n * (i + 1) /\n\t\t\t\t(ARRAY_SIZE(q) + 1)];\n\n\t\tvfree(p);\n\n\t\tret = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t"Unused:\t\t%zu%%\\n"\n\t\t\t\t"Clean:\t\t%zu%%\\n"\n\t\t\t\t"Dirty:\t\t%zu%%\\n"\n\t\t\t\t"Metadata:\t%zu%%\\n"\n\t\t\t\t"Average:\t%llu\\n"\n\t\t\t\t"Sectors per Q:\t%zu\\n"\n\t\t\t\t"Quantiles:\t[",\n\t\t\t\tunused * 100 / (size_t) ca->sb.nbuckets,\n\t\t\t\tavailable * 100 / (size_t) ca->sb.nbuckets,\n\t\t\t\tdirty * 100 / (size_t) ca->sb.nbuckets,\n\t\t\t\tmeta * 100 / (size_t) ca->sb.nbuckets, sum,\n\t\t\t\tn * ca->sb.bucket_size / (ARRAY_SIZE(q) + 1));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(q); i++)\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t "%u ", q[i]);\n\t\tret--;\n	f
26353	327	socket_shutdown	drivers/pcmcia/cs.c	status	1	11	\N	\N	\tint status;\n\n\tdev_dbg(&s->dev, "shutdown\\n");\n\n\tif (s->callback)\n\t\ts->callback->remove(s);\n\n\tmutex_lock(&s->ops_mutex);\n\ts->state &= SOCKET_INUSE | SOCKET_PRESENT;\n\tmsleep(shutdown_delay * 10);\n\ts->state &= SOCKET_INUSE;\n\n\t/* Blank out the socket state */\n\ts->socket = dead_socket;\n\ts->ops->init(s);\n\ts->ops->set_socket(s, &s->socket);\n\ts->lock_count = 0;\n\tkfree(s->fake_cis);\n\ts->fake_cis = NULL;\n\ts->functions = 0;\n\n\t/* From here on we can be sure that only we (that is, the\n\t * pccardd thread) accesses this socket, and all (16-bit)\n\t * PCMCIA interactions are gone. Therefore, release\n\t * ops_mutex so that we don't get a sysfs-related lockdep\n\t * warning.\n\t */\n\tmutex_unlock(&s->ops_mutex);\n\n#ifdef CONFIG_CARDBUS\n\tcb_free(s);\n#endif\n\n\t/* give socket some time to power down */\n\tmsleep(100);\n\n\ts->ops->get_status(s, &status);\n\tif (status & SS_POWERON) {\n	t
36515	924	bind_interdomain_evtchn_to_irq	drivers/xen/events/events_base.c	bind_interdomain.local_port	1	11	\N	unknown	\tstruct evtchn_bind_interdomain bind_interdomain;\n\tint err;\n\n\tbind_interdomain.remote_dom  = remote_domain;\n\tbind_interdomain.remote_port = remote_port;\n\n\terr = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,\n\t\t\t\t\t  &bind_interdomain);\n\n\treturn err ? : bind_evtchn_to_irq(bind_interdomain.local_port);\n	f
29120	1329	be_get_module_info	drivers/net/ethernet/emulex/benet/be_ethtool.c	page_data	1	11	\N	\N	\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu8 page_data[PAGE_DATA_LEN];\n\tint status;\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\n\t\t\t\t\t\t   page_data);\n\tif (!status) {\n\t\tif (!page_data[SFP_PLUS_SFF_8472_COMP]) {\n	f
41289	281	bcm_can_tx	net/can/bcm.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * op->currframe;\n\n\t/* no target device? => exit */\n\tif (!op->ifindex)\n\t\treturn;\n\n\tdev = dev_get_by_index(sock_net(op->sk), op->ifindex);\n\tif (!dev) {\n\t\t/* RFC: should this bcm_op remove itself here? */\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(op->cfsiz + sizeof(struct can_skb_priv), gfp_any());\n\tif (!skb)\n\t\tgoto out;\n\n\tcan_skb_reserve(skb);\n	f
42564	661	bcm_sysport_rx_refill	drivers/net/ethernet/broadcom/bcmsysport.c	skb->data	1	11	\N	\N	\tstruct device *kdev = &priv->pdev->dev;\n\tstruct net_device *ndev = priv->netdev;\n\tstruct sk_buff *skb, *rx_skb;\n\tdma_addr_t mapping;\n\n\t/* Allocate a new SKB for a new packet */\n\tskb = netdev_alloc_skb(priv->netdev, RX_BUF_LENGTH);\n\tif (!skb) {\n\t\tpriv->mib.alloc_rx_buff_failed++;\n\t\tnetif_err(priv, rx_err, ndev, "SKB alloc failed\\n");\n\t\treturn NULL;\n\t}\n\n\tmapping = dma_map_single(kdev, skb->data,\n	f
43631	1684	bcmgenet_rx_refill	drivers/net/ethernet/broadcom/genet/bcmgenet.c	skb->data	1	11	\N	\N	\tstruct device *kdev = &priv->pdev->dev;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *rx_skb;\n\tdma_addr_t mapping;\n\n\t/* Allocate a new Rx skb */\n\tskb = netdev_alloc_skb(priv->dev, priv->rx_buf_len + SKB_ALIGNMENT);\n\tif (!skb) {\n\t\tpriv->mib.alloc_rx_buff_failed++;\n\t\tnetif_err(priv, rx_err, priv->dev,\n\t\t\t  "%s: Rx skb allocation failed\\n", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* DMA-map the new Rx skb */\n\tmapping = dma_map_single(kdev, skb->data, priv->rx_buf_len,\n	f
30408	846	acpi_match_platform_list	drivers/acpi/utils.c	acpi_match_platform_list_$hdr$6$obj	0	11	\N	\N	\tstruct acpi_table_header hdr;\n\tint idx = 0;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tfor (; plat->oem_id[0]; plat++, idx++) {\n\t\tif (ACPI_FAILURE(acpi_get_table_header(plat->table, 0, &hdr)))\n\t\t\tcontinue;\n\n\t\tif (strncmp(plat->oem_id, hdr.oem_id, ACPI_OEM_ID_SIZE))\n\t\t\tcontinue;\n\n\t\tif (strncmp(plat->oem_table_id, hdr.oem_table_id, ACPI_OEM_TABLE_ID_SIZE))\n\t\t\tcontinue;\n\n\t\tif ((plat->pred == all_versions) ||\n\t\t    (plat->pred == less_than_or_equal && hdr.oem_revision <= plat->oem_revision) ||\n	t
23444	346	blkdev_reset_zones_ioctl	block/blk-zoned.c	zrange.sector	1	-1	\N	\N	\tvoid __user *argp = (void __user *)arg;\n\tstruct request_queue *q;\n\tstruct blk_zone_range zrange;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tif (!blk_queue_is_zoned(q))\n\t\treturn -ENOTTY;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (copy_from_user(&zrange, argp, sizeof(struct blk_zone_range)))\n\t\treturn -EFAULT;\n\n\treturn blkdev_reset_zones(bdev, zrange.sector, zrange.nr_sectors,\n	f
26664	1802	uvc_xu_ctrl_query	drivers/media/usb/uvc/uvc_ctrl.c	size	1	11	\N	\N	\tstruct uvc_entity *entity;\n\tstruct uvc_control *ctrl;\n\tunsigned int i, found = 0;\n\t__u32 reqflags;\n\t__u16 size;\n\t__u8 *data = NULL;\n\tint ret;\n\n\t/* Find the extension unit. */\n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tif (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT &&\n\t\t    entity->id == xqry->unit)\n\t\t\tbreak;\n\t}\n\n\tif (entity->id != xqry->unit) {\n\t\tuvc_trace(UVC_TRACE_CONTROL, "Extension unit %u not found.\\n",\n\t\t\txqry->unit);\n\t\treturn -ENOENT;\n\t}\n\n\t/* Find the control and perform delayed initialization if needed. */\n\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\tctrl = &entity->controls[i];\n\t\tif (ctrl->index == xqry->selector - 1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tuvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u not found.\\n",\n\t\t\tentity->extension.guidExtensionCode, xqry->selector);\n\t\treturn -ENOENT;\n\t}\n\n\tif (mutex_lock_interruptible(&chain->ctrl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = uvc_ctrl_init_xu_ctrl(chain->dev, ctrl);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t/* Validate the required buffer size and flags for the request */\n\treqflags = 0;\n\tsize = ctrl->info.size;\n\n\tswitch (xqry->query) {\n\tcase UVC_GET_CUR:\n\t\treqflags = UVC_CTRL_FLAG_GET_CUR;\n\t\tbreak;\n\tcase UVC_GET_MIN:\n\t\treqflags = UVC_CTRL_FLAG_GET_MIN;\n\t\tbreak;\n\tcase UVC_GET_MAX:\n\t\treqflags = UVC_CTRL_FLAG_GET_MAX;\n\t\tbreak;\n\tcase UVC_GET_DEF:\n\t\treqflags = UVC_CTRL_FLAG_GET_DEF;\n\t\tbreak;\n\tcase UVC_GET_RES:\n\t\treqflags = UVC_CTRL_FLAG_GET_RES;\n\t\tbreak;\n\tcase UVC_SET_CUR:\n\t\treqflags = UVC_CTRL_FLAG_SET_CUR;\n\t\tbreak;\n\tcase UVC_GET_LEN:\n\t\tsize = 2;\n\t\tbreak;\n\tcase UVC_GET_INFO:\n\t\tsize = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (size != xqry->size) {\n	t
28930	1267	dib7000p_spur_protect	drivers/media/dvb-frontends/dib7000p.c	coef_im	1	11	\N	\N	\tstatic s16 notch[] = { 16143, 14402, 12238, 9713, 6902, 3888, 759, -2392 };\n\tstatic u8 sine[] = { 0, 2, 3, 5, 6, 8, 9, 11, 13, 14, 16, 17, 19, 20, 22,\n\t\t24, 25, 27, 28, 30, 31, 33, 34, 36, 38, 39, 41, 42, 44, 45, 47, 48, 50, 51,\n\t\t53, 55, 56, 58, 59, 61, 62, 64, 65, 67, 68, 70, 71, 73, 74, 76, 77, 79, 80,\n\t\t82, 83, 85, 86, 88, 89, 91, 92, 94, 95, 97, 98, 99, 101, 102, 104, 105,\n\t\t107, 108, 109, 111, 112, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126,\n\t\t128, 129, 130, 132, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146,\n\t\t147, 149, 150, 151, 152, 154, 155, 156, 157, 159, 160, 161, 162, 164, 165,\n\t\t166, 167, 168, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182,\n\t\t183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,\n\t\t199, 200, 201, 202, 203, 204, 205, 206, 207, 207, 208, 209, 210, 211, 212,\n\t\t213, 214, 215, 215, 216, 217, 218, 219, 220, 220, 221, 222, 223, 224, 224,\n\t\t225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235,\n\t\t235, 236, 237, 237, 238, 238, 239, 239, 240, 241, 241, 242, 242, 243, 243,\n\t\t244, 244, 245, 245, 245, 246, 246, 247, 247, 248, 248, 248, 249, 249, 249,\n\t\t250, 250, 250, 251, 251, 251, 252, 252, 252, 252, 253, 253, 253, 253, 254,\n\t\t254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t\t255, 255, 255, 255, 255, 255\n\t};\n\n\tu32 xtal = state->cfg.bw->xtal_hz / 1000;\n\tint f_rel = DIV_ROUND_CLOSEST(rf_khz, xtal) * xtal - rf_khz;\n\tint k;\n\tint coef_re[8], coef_im[8];\n\tint bw_khz = bw;\n\tu32 pha;\n\n\tdprintk("relative position of the Spur: %dk (RF: %dk, XTAL: %dk)\\n", f_rel, rf_khz, xtal);\n\n\tif (f_rel < -bw_khz / 2 || f_rel > bw_khz / 2)\n\t\treturn;\n\n\tbw_khz /= 100;\n\n\tdib7000p_write_word(state, 142, 0x0610);\n\n\tfor (k = 0; k < 8; k++) {\n\t\tpha = ((f_rel * (k + 1) * 112 * 80 / bw_khz) / 1000) & 0x3ff;\n\n\t\tif (pha == 0) {\n\t\t\tcoef_re[k] = 256;\n\t\t\tcoef_im[k] = 0;\n\t\t} else if (pha < 256) {\n\t\t\tcoef_re[k] = sine[256 - (pha & 0xff)];\n\t\t\tcoef_im[k] = sine[pha & 0xff];\n\t\t} else if (pha == 256) {\n\t\t\tcoef_re[k] = 0;\n\t\t\tcoef_im[k] = 256;\n\t\t} else if (pha < 512) {\n\t\t\tcoef_re[k] = -sine[pha & 0xff];\n\t\t\tcoef_im[k] = sine[256 - (pha & 0xff)];\n\t\t} else if (pha == 512) {\n\t\t\tcoef_re[k] = -256;\n\t\t\tcoef_im[k] = 0;\n\t\t} else if (pha < 768) {\n\t\t\tcoef_re[k] = -sine[256 - (pha & 0xff)];\n\t\t\tcoef_im[k] = -sine[pha & 0xff];\n\t\t} else if (pha == 768) {\n\t\t\tcoef_re[k] = 0;\n\t\t\tcoef_im[k] = -256;\n\t\t} else {\n\t\t\tcoef_re[k] = sine[pha & 0xff];\n\t\t\tcoef_im[k] = -sine[256 - (pha & 0xff)];\n\t\t}\n\n\t\tcoef_re[k] *= notch[k];\n\t\tcoef_re[k] += (1 << 14);\n\t\tif (coef_re[k] >= (1 << 24))\n\t\t\tcoef_re[k] = (1 << 24) - 1;\n\t\tcoef_re[k] /= (1 << 15);\n\n\t\tcoef_im[k] *= notch[k];\n\t\tcoef_im[k] += (1 << 14);\n\t\tif (coef_im[k] >= (1 << 24))\n	t
57874	1610	bnxt_flash_package_from_file	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c	fw->size	1	11	\N	\N	\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct hwrm_nvm_install_update_output *resp = bp->hwrm_cmd_resp_addr;\n\tstruct hwrm_nvm_install_update_input install = {0};\n\tconst struct firmware *fw;\n\tu32 item_len;\n\tu16 index;\n\tint rc;\n\n\tbnxt_hwrm_fw_set_time(bp);\n\n\tif (bnxt_find_nvram_item(dev, BNX_DIR_TYPE_UPDATE,\n\t\t\t\t BNX_DIR_ORDINAL_FIRST, BNX_DIR_EXT_NONE,\n\t\t\t\t &index, &item_len, NULL) != 0) {\n\t\tnetdev_err(dev, "PKG update area not created in nvram\\n");\n\t\treturn -ENOBUFS;\n\t}\n\n\trc = request_firmware(&fw, filename, &dev->dev);\n\tif (rc != 0) {\n\t\tnetdev_err(dev, "PKG error %d requesting file: %s\\n",\n\t\t\t   rc, filename);\n\t\treturn rc;\n\t}\n\n\tif (fw->size > item_len) {\n	f
31255	1891	bm2835_mmal_init	drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c	dev	1	11	\N	\N	\tint ret;\n\tstruct bm2835_mmal_dev *dev;\n\tstruct vb2_queue *q;\n\tint camera;\n\tunsigned int num_cameras;\n\tstruct vchiq_mmal_instance *instance;\n\tunsigned int resolutions[MAX_BCM2835_CAMERAS][2];\n\tint i;\n\n\tret = vchiq_mmal_init(&instance);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_cameras = get_num_cameras(instance,\n\t\t\t\t      resolutions,\n\t\t\t\t      MAX_BCM2835_CAMERAS);\n\tif (num_cameras > MAX_BCM2835_CAMERAS)\n\t\tnum_cameras = MAX_BCM2835_CAMERAS;\n\n\tfor (camera = 0; camera < num_cameras; camera++) {\n\t\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\t\tif (!dev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup_gdev;\n\t\t}\n\n\t\tdev->camera_num = camera;\n\t\tdev->max_width = resolutions[camera][0];\n\t\tdev->max_height = resolutions[camera][1];\n\n\t\t/* setup device defaults */\n\t\tdev->overlay.w.left = 150;\n\t\tdev->overlay.w.top = 50;\n\t\tdev->overlay.w.width = 1024;\n\t\tdev->overlay.w.height = 768;\n\t\tdev->overlay.clipcount = 0;\n\t\tdev->overlay.field = V4L2_FIELD_NONE;\n\t\tdev->overlay.global_alpha = 255;\n\n\t\tdev->capture.fmt = &formats[3]; /* JPEG */\n\n\t\t/* v4l device registration */\n\t\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t\t "%s", BM2835_MMAL_MODULE_NAME);\n\t\tret = v4l2_device_register(NULL, &dev->v4l2_dev);\n\t\tif (ret)\n\t\t\tgoto free_dev;\n\n\t\t/* setup v4l controls */\n\t\tret = bm2835_mmal_init_controls(dev, &dev->ctrl_handler);\n\t\tif (ret < 0)\n\t\t\tgoto unreg_dev;\n\t\tdev->v4l2_dev.ctrl_handler = &dev->ctrl_handler;\n\n\t\t/* mmal init */\n\t\tdev->instance = instance;\n\t\tret = mmal_init(dev);\n	f
46878	5985	megasas_probe_one	drivers/scsi/megaraid/megaraid_sas_base.c	pos	2	-11	\N	\N	\tint rval, pos;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu16 control = 0;\n\tstruct fusion_context *fusion = NULL;\n\n\t/* Reset MSI-X in the kdump kernel */\n\tif (reset_devices) {\n\t\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\t\tif (pos) {\n	f
42332	1267	mesh_fwd_csa_frame	net/mac80211/mesh.c	skb	1	11	\N	\N	\tstruct ieee80211_mgmt *mgmt_fwd;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_local *local = sdata->local;\n\tu8 *pos = mgmt->u.action.u.chan_switch.variable;\n\tsize_t offset_ttl;\n\n\tskb = dev_alloc_skb(local->tx_headroom + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, local->tx_headroom);\n	f
31281	1036	snapshot_merge_next_chunks	drivers/md/dm-snap.c	old_chunk + i	1	11	\N	\N	\tint i, linear_chunks;\n\tchunk_t old_chunk, new_chunk;\n\tstruct dm_io_region src, dest;\n\tsector_t io_size;\n\tuint64_t previous_count;\n\n\tBUG_ON(!test_bit(RUNNING_MERGE, &s->state_bits));\n\tif (unlikely(test_bit(SHUTDOWN_MERGE, &s->state_bits)))\n\t\tgoto shut;\n\n\t/*\n\t * valid flag never changes during merge, so no lock required.\n\t */\n\tif (!s->valid) {\n\t\tDMERR("Snapshot is invalid: can't merge");\n\t\tgoto shut;\n\t}\n\n\tlinear_chunks = s->store->type->prepare_merge(s->store, &old_chunk,\n\t\t\t\t\t\t      &new_chunk);\n\tif (linear_chunks <= 0) {\n\t\tif (linear_chunks < 0) {\n\t\t\tDMERR("Read error in exception store: "\n\t\t\t      "shutting down merge");\n\t\t\tdown_write(&s->lock);\n\t\t\ts->merge_failed = 1;\n\t\t\tup_write(&s->lock);\n\t\t}\n\t\tgoto shut;\n\t}\n\n\t/* Adjust old_chunk and new_chunk to reflect start of linear region */\n\told_chunk = old_chunk + 1 - linear_chunks;\n\tnew_chunk = new_chunk + 1 - linear_chunks;\n\n\t/*\n\t * Use one (potentially large) I/O to copy all 'linear_chunks'\n\t * from the exception store to the origin\n\t */\n\tio_size = linear_chunks * s->store->chunk_size;\n\n\tdest.bdev = s->origin->bdev;\n\tdest.sector = chunk_to_sector(s->store, old_chunk);\n\tdest.count = min(io_size, get_dev_size(dest.bdev) - dest.sector);\n\n\tsrc.bdev = s->cow->bdev;\n\tsrc.sector = chunk_to_sector(s->store, new_chunk);\n\tsrc.count = dest.count;\n\n\t/*\n\t * Reallocate any exceptions needed in other snapshots then\n\t * wait for the pending exceptions to complete.\n\t * Each time any pending exception (globally on the system)\n\t * completes we are woken and repeat the process to find out\n\t * if we can proceed.  While this may not seem a particularly\n\t * efficient algorithm, it is not expected to have any\n\t * significant impact on performance.\n\t */\n\tprevious_count = read_pending_exceptions_done_count();\n\twhile (origin_write_extent(s, dest.sector, io_size)) {\n\t\twait_event(_pending_exceptions_done,\n\t\t\t   (read_pending_exceptions_done_count() !=\n\t\t\t    previous_count));\n\t\t/* Retry after the wait, until all exceptions are done. */\n\t\tprevious_count = read_pending_exceptions_done_count();\n\t}\n\n\tdown_write(&s->lock);\n\ts->first_merging_chunk = old_chunk;\n\ts->num_merging_chunks = linear_chunks;\n\tup_write(&s->lock);\n\n\t/* Wait until writes to all 'linear_chunks' drain */\n\tfor (i = 0; i < linear_chunks; i++)\n\t\t__check_for_conflicting_io(s, old_chunk + i);\n	t
693	888	acpi_turn_off_unused_power_resources	drivers/acpi/power.c	state	1	11	\N	\N	\tstruct acpi_power_resource *resource;\n\n\tmutex_lock(&power_resource_list_lock);\n\n\tlist_for_each_entry_reverse(resource, &acpi_power_resource_list, list_node) {\n\t\tint result, state;\n\n\t\tmutex_lock(&resource->resource_lock);\n\n\t\tresult = acpi_power_get_state(resource->device.handle, &state);\n\t\tif (result) {\n\t\t\tmutex_unlock(&resource->resource_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state == ACPI_POWER_RESOURCE_STATE_ON\n	t
34011	7146	md_ioctl	drivers/md/md.c	&info	1	11	\N	\N	\tint err = 0;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct mddev *mddev = NULL;\n\tint ro;\n\tbool did_set_md_closing = false;\n\n\tif (!md_ioctl_valid(cmd))\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase RAID_VERSION:\n\tcase GET_ARRAY_INFO:\n\tcase GET_DISK_INFO:\n\t\tbreak;\n\tdefault:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Commands dealing with the RAID driver but not any\n\t * particular array:\n\t */\n\tswitch (cmd) {\n\tcase RAID_VERSION:\n\t\terr = get_version(argp);\n\t\tgoto out;\n\n#ifndef MODULE\n\tcase RAID_AUTORUN:\n\t\terr = 0;\n\t\tautostart_arrays(arg);\n\t\tgoto out;\n#endif\n\tdefault:;\n\t}\n\n\t/*\n\t * Commands creating/starting a new array:\n\t */\n\n\tmddev = bdev->bd_disk->private_data;\n\n\tif (!mddev) {\n\t\tBUG();\n\t\tgoto out;\n\t}\n\n\t/* Some actions do not requires the mutex */\n\tswitch (cmd) {\n\tcase GET_ARRAY_INFO:\n\t\tif (!mddev->raid_disks && !mddev->external)\n\t\t\terr = -ENODEV;\n\t\telse\n\t\t\terr = get_array_info(mddev, argp);\n\t\tgoto out;\n\n\tcase GET_DISK_INFO:\n\t\tif (!mddev->raid_disks && !mddev->external)\n\t\t\terr = -ENODEV;\n\t\telse\n\t\t\terr = get_disk_info(mddev, argp);\n\t\tgoto out;\n\n\tcase SET_DISK_FAULTY:\n\t\terr = set_disk_faulty(mddev, new_decode_dev(arg));\n\t\tgoto out;\n\n\tcase GET_BITMAP_FILE:\n\t\terr = get_bitmap_file(mddev, argp);\n\t\tgoto out;\n\n\t}\n\n\tif (cmd == ADD_NEW_DISK)\n\t\t/* need to ensure md_delayed_delete() has completed */\n\t\tflush_workqueue(md_misc_wq);\n\n\tif (cmd == HOT_REMOVE_DISK)\n\t\t/* need to ensure recovery thread has run */\n\t\twait_event_interruptible_timeout(mddev->sb_wait,\n\t\t\t\t\t\t !test_bit(MD_RECOVERY_NEEDED,\n\t\t\t\t\t\t\t   &mddev->recovery),\n\t\t\t\t\t\t msecs_to_jiffies(5000));\n\tif (cmd == STOP_ARRAY || cmd == STOP_ARRAY_RO) {\n\t\t/* Need to flush page cache, and ensure no-one else opens\n\t\t * and writes\n\t\t */\n\t\tmutex_lock(&mddev->open_mutex);\n\t\tif (mddev->pers && atomic_read(&mddev->openers) > 1) {\n\t\t\tmutex_unlock(&mddev->open_mutex);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tWARN_ON_ONCE(test_bit(MD_CLOSING, &mddev->flags));\n\t\tset_bit(MD_CLOSING, &mddev->flags);\n\t\tdid_set_md_closing = true;\n\t\tmutex_unlock(&mddev->open_mutex);\n\t\tsync_blockdev(bdev);\n\t}\n\terr = mddev_lock(mddev);\n\tif (err) {\n\t\tpr_debug("md: ioctl lock interrupted, reason %d, cmd %d\\n",\n\t\t\t err, cmd);\n\t\tgoto out;\n\t}\n\n\tif (cmd == SET_ARRAY_INFO) {\n\t\tmdu_array_info_t info;\n\t\tif (!arg)\n\t\t\tmemset(&info, 0, sizeof(info));\n\t\telse if (copy_from_user(&info, argp, sizeof(info))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (mddev->pers) {\n\t\t\terr = update_array_info(mddev, &info);\n	t
34175	3761	rs_start_reshape	drivers/md/dm-raid.c	rs	1	11	\N	\N	\tint r;\n\tstruct mddev *mddev = &rs->md;\n\tstruct md_personality *pers = mddev->pers;\n\n\tr = rs_setup_reshape(rs);\n	t
38502	1097	debug_objects_replace_static_objects	lib/debugobjects.c	debug_objects_replace_static_objects_$____ptr14$obj	0	11	\N	\N	\tstruct debug_bucket *db = obj_hash;\n\tstruct hlist_node *tmp;\n\tstruct debug_obj *obj, *new;\n\tHLIST_HEAD(objects);\n\tint i, cnt = 0;\n\n\tfor (i = 0; i < ODEBUG_POOL_SIZE; i++) {\n\t\tobj = kmem_cache_zalloc(obj_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\tgoto free;\n\t\tkmemleak_ignore(obj);\n\t\thlist_add_head(&obj->node, &objects);\n\t}\n\n\t/*\n\t * When debug_objects_mem_init() is called we know that only\n\t * one CPU is up, so disabling interrupts is enough\n\t * protection. This avoids the lockdep hell of lock ordering.\n\t */\n\tlocal_irq_disable();\n\n\t/* Remove the statically allocated objects from the pool */\n\thlist_for_each_entry_safe(obj, tmp, &obj_pool, node)\n	f
28623	637	btree_split_beneath	drivers/md/persistent-data/dm-btree.c	left	1	11	\N	\N	\tint r;\n\tsize_t size;\n\tunsigned nr_left, nr_right;\n\tstruct dm_block *left, *right, *new_parent;\n\tstruct btree_node *pn, *ln, *rn;\n\t__le64 val;\n\n\tnew_parent = shadow_current(s);\n\n\tr = new_block(s->info, &left);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = new_block(s->info, &right);\n\tif (r < 0) {\n\t\tunlock_block(s->info, left);\n	f
48964	458	bt878_probe	drivers/media/pci/bt8xx/bt878.c	lat	1	11	\N	\N	\tint result = 0;\n\tunsigned char lat;\n\tstruct bt878 *bt;\n\tunsigned int cardid;\n\n\tprintk(KERN_INFO "bt878: Bt878 AUDIO function found (%d).\\n",\n\t       bt878_num);\n\tif (bt878_num >= BT878_MAX) {\n\t\tprintk(KERN_ERR "bt878: Too many devices inserted\\n");\n\t\tresult = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\tif (pci_enable_device(dev))\n\t\treturn -EIO;\n\n\tcardid = dev->subsystem_device << 16;\n\tcardid |= dev->subsystem_vendor;\n\n\tprintk(KERN_INFO "%s: card id=[0x%x],[ %s ] has DVB functions.\\n",\n\t\t\t\t__func__, cardid, card_name(pci_id));\n\n\tbt = &bt878[bt878_num];\n\tbt->dev = dev;\n\tbt->nr = bt878_num;\n\tbt->shutdown = 0;\n\n\tbt->id = dev->device;\n\tbt->irq = dev->irq;\n\tbt->bt878_adr = pci_resource_start(dev, 0);\n\tif (!request_mem_region(pci_resource_start(dev, 0),\n\t\t\t\tpci_resource_len(dev, 0), "bt878")) {\n\t\tresult = -EBUSY;\n\t\tgoto fail0;\n\t}\n\n\tbt->revision = dev->revision;\n\tpci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\n\n\n\tprintk(KERN_INFO "bt878(%d): Bt%x (rev %d) at %02x:%02x.%x, ",\n\t       bt878_num, bt->id, bt->revision, dev->bus->number,\n\t       PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));\n\tprintk("irq: %d, latency: %d, memory: 0x%lx\\n",\n	f
52759	187	bfs_unlink	fs/bfs/dir.c	de->ino	7	12	\N	\N	\tint error = -ENOENT;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len, &de);\n\tif (!bh || (le16_to_cpu(de->ino) != inode->i_ino))\n	t
37900	364	brcmf_rx_event	drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c	ifp->drvr	1	-3	\N	may need points to analysis	\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(EVENT, "Enter: %s: rxp=%p\\n", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb);\n	f
59296	556	carl9170_debugfs_hw_ioread32_write	drivers/net/wireless/ath/carl9170/debug.c	&reg	6	12	\N	\N	\tint err = 0, i, n = 0, max_len = 32, res;\n\tunsigned int reg, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > max_len)\n\t\treturn -E2BIG;\n\n\tres = sscanf(buf, "0x%X %d", &reg, &n);\n	t
36894	1021	vmxnet3_tq_xmit	drivers/net/vmxnet3/vmxnet3_drv.c	&ctx	1	11	\N	\N	\tint ret;\n\tu32 count;\n\tunsigned long flags;\n\tstruct vmxnet3_tx_ctx ctx;\n\tunion Vmxnet3_GenericDesc *gdesc;\n#ifdef __BIG_ENDIAN_BITFIELD\n\t/* Use temporary descriptor to avoid touching bits multiple times */\n\tunion Vmxnet3_GenericDesc tempTxDesc;\n#endif\n\n\tcount = txd_estimate(skb);\n\n\tctx.ipv4 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IP));\n\tctx.ipv6 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IPV6));\n\n\tctx.mss = skb_shinfo(skb)->gso_size;\n\tif (ctx.mss) {\n\t\tif (skb_header_cloned(skb)) {\n\t\t\tif (unlikely(pskb_expand_head(skb, 0, 0,\n\t\t\t\t\t\t      GFP_ATOMIC) != 0)) {\n\t\t\t\ttq->stats.drop_tso++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t\ttq->stats.copy_skb_header++;\n\t\t}\n\t\tvmxnet3_prepare_tso(skb, &ctx);\n\t} else {\n\t\tif (unlikely(count > VMXNET3_MAX_TXD_PER_PKT)) {\n\n\t\t\t/* non-tso pkts must not use more than\n\t\t\t * VMXNET3_MAX_TXD_PER_PKT entries\n\t\t\t */\n\t\t\tif (skb_linearize(skb) != 0) {\n\t\t\t\ttq->stats.drop_too_many_frags++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t\ttq->stats.linearized++;\n\n\t\t\t/* recalculate the # of descriptors to use */\n\t\t\tcount = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\n\t\t}\n\t}\n\n\tret = vmxnet3_parse_hdr(skb, tq, &ctx, adapter);\n	t
38060	722	a3700_spi_transfer_one	drivers/spi/spi-armada-3700.c	val	1	11	\N	\N	\tstruct a3700_spi *a3700_spi = spi_master_get_devdata(master);\n\tint ret = 0, timeout = A3700_SPI_TIMEOUT;\n\tunsigned int nbits = 0;\n\tu32 val;\n\n\ta3700_spi_transfer_setup(spi, xfer);\n\n\ta3700_spi->tx_buf  = xfer->tx_buf;\n\ta3700_spi->rx_buf  = xfer->rx_buf;\n\ta3700_spi->buf_len = xfer->len;\n\n\tif (xfer->tx_buf)\n\t\tnbits = xfer->tx_nbits;\n\telse if (xfer->rx_buf)\n\t\tnbits = xfer->rx_nbits;\n\n\ta3700_spi_pin_mode_set(a3700_spi, nbits, xfer->rx_buf ? true : false);\n\n\t/* Flush the FIFOs */\n\ta3700_spi_fifo_flush(a3700_spi);\n\n\t/* Transfer first bytes of data when buffer is not 4-byte aligned */\n\ta3700_spi_header_set(a3700_spi);\n\n\tif (xfer->rx_buf) {\n\t\t/* Set read data length */\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_DIN_CNT_REG,\n\t\t\t     a3700_spi->buf_len);\n\t\t/* Start READ transfer */\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval &= ~A3700_SPI_RW_EN;\n\t\tval |= A3700_SPI_XFER_START;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t} else if (xfer->tx_buf) {\n\t\t/* Start Write transfer */\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= (A3700_SPI_XFER_START | A3700_SPI_RW_EN);\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\t\t/*\n\t\t * If there are data to be written to the SPI device, xmit_data\n\t\t * flag is set true; otherwise the instruction in SPI_INSTR does\n\t\t * not require data to be written to the SPI device, then\n\t\t * xmit_data flag is set false.\n\t\t */\n\t\ta3700_spi->xmit_data = (a3700_spi->buf_len != 0);\n\t}\n\n\twhile (a3700_spi->buf_len) {\n\t\tif (a3700_spi->tx_buf) {\n\t\t\t/* Wait wfifo ready */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t"wait wfifo ready timed out\\n");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Fill up the wfifo */\n\t\t\tret = a3700_spi_fifo_write(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (a3700_spi->rx_buf) {\n\t\t\t/* Wait rfifo ready */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_RFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t"wait rfifo ready timed out\\n");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Drain out the rfifo */\n\t\t\tret = a3700_spi_fifo_read(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/*\n\t * Stop a write transfer in fifo mode:\n\t *\t- wait all the bytes in wfifo to be shifted out\n\t *\t - set XFER_STOP bit\n\t *\t- wait XFER_START bit clear\n\t *\t- clear XFER_STOP bit\n\t * Stop a read transfer in fifo mode:\n\t *\t- the hardware is to reset the XFER_START bit\n\t *\t   after the number of bytes indicated in DIN_CNT\n\t *\t   register\n\t *\t- just wait XFER_START bit clear\n\t */\n\tif (a3700_spi->tx_buf) {\n\t\tif (a3700_spi->xmit_data) {\n\t\t\t/*\n\t\t\t * If there are data written to the SPI device, wait\n\t\t\t * until SPI_WFIFO_EMPTY is 1 to wait for all data to\n\t\t\t * transfer out of write FIFO.\n\t\t\t */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_EMPTY)) {\n\t\t\t\tdev_err(&spi->dev, "wait wfifo empty timed out\\n");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\tif (!a3700_spi_transfer_wait(spi, A3700_SPI_XFER_RDY)) {\n\t\t\tdev_err(&spi->dev, "wait xfer ready timed out\\n");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= A3700_SPI_XFER_STOP;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t}\n\n\twhile (--timeout) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tif (!(val & A3700_SPI_XFER_START))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(&spi->dev, "wait transfer start clear timed out\\n");\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tval &= ~A3700_SPI_XFER_STOP;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n	t
39192	91	nv05_devinit_meminit	drivers/gpu/drm/nouveau/nvkm/subdev/devinit/nv05.c	ramcfg	1	11	\N	\N	\tstatic const u8 default_config_tab[][2] = {\n\t\t{ 0x24, 0x00 },\n\t\t{ 0x28, 0x00 },\n\t\t{ 0x24, 0x01 },\n\t\t{ 0x1f, 0x00 },\n\t\t{ 0x0f, 0x00 },\n\t\t{ 0x17, 0x00 },\n\t\t{ 0x06, 0x00 },\n\t\t{ 0x00, 0x00 }\n\t};\n\tstruct nvkm_subdev *subdev = &init->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct io_mapping *fb;\n\tu32 patt = 0xdeadbeef;\n\tu16 data;\n\tu8 strap, ramcfg[2];\n\tint i, v;\n\n\t/* Map the framebuffer aperture */\n\tfb = fbmem_init(device);\n\tif (!fb) {\n\t\tnvkm_error(subdev, "failed to map fb\\n");\n\t\treturn;\n\t}\n\n\tstrap = (nvkm_rd32(device, 0x101000) & 0x0000003c) >> 2;\n\tif ((data = bmp_mem_init_table(bios))) {\n\t\tramcfg[0] = nvbios_rd08(bios, data + 2 * strap + 0);\n\t\tramcfg[1] = nvbios_rd08(bios, data + 2 * strap + 1);\n\t} else {\n\t\tramcfg[0] = default_config_tab[strap][0];\n\t\tramcfg[1] = default_config_tab[strap][1];\n\t}\n\n\t/* Sequencer off */\n\tnvkm_wrvgas(device, 0, 1, nvkm_rdvgas(device, 0, 1) | 0x20);\n\n\tif (nvkm_rd32(device, NV04_PFB_BOOT_0) & NV04_PFB_BOOT_0_UMA_ENABLE)\n\t\tgoto out;\n\n\tnvkm_mask(device, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);\n\n\t/* If present load the hardcoded scrambling table */\n\tif (data) {\n\t\tfor (i = 0, data += 0x10; i < 8; i++, data += 4) {\n\t\t\tu32 scramble = nvbios_rd32(bios, data);\n\t\t\tnvkm_wr32(device, NV04_PFB_SCRAMBLE(i), scramble);\n\t\t}\n\t}\n\n\t/* Set memory type/width/length defaults depending on the straps */\n\tnvkm_mask(device, NV04_PFB_BOOT_0, 0x3f, ramcfg[0]);\n\n\tif (ramcfg[1] & 0x80)\n	t
48949	1953	btrfs_file_write_iter	fs/btrfs/file.c	err	1	11	\N	\N	\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 start_pos;\n\tu64 end_pos;\n\tssize_t num_written = 0;\n\tbool sync = (file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host);\n\tssize_t err;\n\tloff_t pos;\n\tsize_t count = iov_iter_count(from);\n\tloff_t oldsize;\n\tint clean_page = 0;\n\n\tif (!(iocb->ki_flags & IOCB_DIRECT) &&\n\t    (iocb->ki_flags & IOCB_NOWAIT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!inode_trylock(inode)) {\n\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\treturn -EAGAIN;\n\t\tinode_lock(inode);\n\t}\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0) {\n\t\tinode_unlock(inode);\n\t\treturn err;\n\t}\n\n\tpos = iocb->ki_pos;\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t/*\n\t\t * We will allocate space in case nodatacow is not set,\n\t\t * so bail\n\t\t */\n\t\tif (!(BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC)) ||\n\t\t    check_can_nocow(BTRFS_I(inode), pos, &count) <= 0) {\n\t\t\tinode_unlock(inode);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = file_remove_privs(file);\n\tif (err) {\n\t\tinode_unlock(inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If BTRFS flips readonly due to some impossible error\n\t * (fs_info->fs_state now has BTRFS_SUPER_FLAG_ERROR),\n\t * although we have opened a file as writable, we have\n\t * to stop this write operation to ensure FS consistency.\n\t */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tinode_unlock(inode);\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We reserve space for updating the inode when we reserve space for the\n\t * extent we are going to write, so we will enospc out there.  We don't\n\t * need to start yet another transaction to update the inode as we will\n\t * update the inode when we finish writing whatever data we write.\n\t */\n\tupdate_time_for_write(inode);\n\n\tstart_pos = round_down(pos, fs_info->sectorsize);\n\toldsize = i_size_read(inode);\n\tif (start_pos > oldsize) {\n\t\t/* Expand hole size to cover write data, preventing empty gap */\n\t\tend_pos = round_up(pos + count,\n\t\t\t\t   fs_info->sectorsize);\n\t\terr = btrfs_cont_expand(inode, oldsize, end_pos);\n\t\tif (err) {\n	f
745	479	__assign_resources_sorted	drivers/pci/setup-bus.c	&save_head	1	11	\N	\N	\t/*\n\t * Should not assign requested resources at first.\n\t *   they could be adjacent, so later reassign can not reallocate\n\t *   them one by one in parent resource window.\n\t * Try to assign requested + add_size at beginning\n\t *  if could do that, could get out early.\n\t *  if could not do that, we still try to assign requested at first,\n\t *    then try to reassign add_size for some resources.\n\t *\n\t * Separate three resource type checking if we need to release\n\t * assigned resource after requested + add_size try.\n\t *\t1. if there is io port assign fail, will release assigned\n\t *\t   io port.\n\t *\t2. if there is pref mmio assign fail, release assigned\n\t *\t   pref mmio.\n\t *\t   if assigned pref mmio's parent is non-pref mmio and there\n\t *\t   is non-pref mmio assign fail, will release that assigned\n\t *\t   pref mmio.\n\t *\t3. if there is non-pref mmio assign fail or pref mmio\n\t *\t   assigned fail, will release assigned non-pref mmio.\n\t */\n\tLIST_HEAD(save_head);\n\tLIST_HEAD(local_fail_head);\n\tstruct pci_dev_resource *save_res;\n\tstruct pci_dev_resource *dev_res, *tmp_res, *dev_res2;\n\tunsigned long fail_type;\n\tresource_size_t add_align, align;\n\n\t/* Check if optional add_size is there */\n\tif (!realloc_head || list_empty(realloc_head))\n\t\tgoto requested_and_reassign;\n\n\t/* Save original start, end, flags etc at first */\n\tlist_for_each_entry(dev_res, head, list) {\n\t\tif (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {\n\t\t\tfree_list(&save_head);\n\t\t\tgoto requested_and_reassign;\n\t\t}\n\t}\n\n\t/* Update res in head list with add_size in realloc_head list */\n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list) {\n\t\tdev_res->res->end += get_res_add_size(realloc_head,\n\t\t\t\t\t\t\tdev_res->res);\n\n\t\t/*\n\t\t * There are two kinds of additional resources in the list:\n\t\t * 1. bridge resource  -- IORESOURCE_STARTALIGN\n\t\t * 2. SR-IOV resource   -- IORESOURCE_SIZEALIGN\n\t\t * Here just fix the additional alignment for bridge\n\t\t */\n\t\tif (!(dev_res->res->flags & IORESOURCE_STARTALIGN))\n\t\t\tcontinue;\n\n\t\tadd_align = get_res_add_align(realloc_head, dev_res->res);\n\n\t\t/*\n\t\t * The "head" list is sorted by the alignment to make sure\n\t\t * resources with bigger alignment will be assigned first.\n\t\t * After we change the alignment of a dev_res in "head" list,\n\t\t * we need to reorder the list by alignment to make it\n\t\t * consistent.\n\t\t */\n\t\tif (add_align > dev_res->res->start) {\n\t\t\tresource_size_t r_size = resource_size(dev_res->res);\n\n\t\t\tdev_res->res->start = add_align;\n\t\t\tdev_res->res->end = add_align + r_size - 1;\n\n\t\t\tlist_for_each_entry(dev_res2, head, list) {\n\t\t\t\talign = pci_resource_alignment(dev_res2->dev,\n\t\t\t\t\t\t\t       dev_res2->res);\n\t\t\t\tif (add_align > align) {\n\t\t\t\t\tlist_move_tail(&dev_res->list,\n\t\t\t\t\t\t       &dev_res2->list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* Try updated head list with add_size added */\n\tassign_requested_resources_sorted(head, &local_fail_head);\n\n\t/* all assigned with add_size ? */\n\tif (list_empty(&local_fail_head)) {\n\t\t/* Remove head list from realloc_head list */\n\t\tlist_for_each_entry(dev_res, head, list)\n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\tfree_list(&save_head);\n\t\tfree_list(head);\n\t\treturn;\n\t}\n\n\t/* check failed type */\n\tfail_type = pci_fail_res_type_mask(&local_fail_head);\n\t/* remove not need to be released assigned res from head list etc */\n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list)\n\t\tif (dev_res->res->parent &&\n\t\t    !pci_need_to_release(fail_type, dev_res->res)) {\n\t\t\t/* remove it from realloc_head list */\n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\t\tremove_from_list(&save_head, dev_res->res);\n\t\t\tlist_del(&dev_res->list);\n\t\t\tkfree(dev_res);\n\t\t}\n\n\tfree_list(&local_fail_head);\n\t/* Release assigned resource */\n\tlist_for_each_entry(dev_res, head, list)\n\t\tif (dev_res->res->parent)\n\t\t\trelease_resource(dev_res->res);\n\t/* Restore start/end/flags from saved list */\n\tlist_for_each_entry(save_res, &save_head, list) {\n\t\tstruct resource *res = save_res->res;\n\n\t\tres->start = save_res->start;\n\t\tres->end = save_res->end;\n\t\tres->flags = save_res->flags;\n\t}\n\tfree_list(&save_head);\n	t
54226	3010	btrfs_sync_log	fs/btrfs/tree-log.c	ret	1	11	\N	\N	\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = fs_info->log_root_tree;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(fs_info, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(fs_info, trans)) {\n\t\tret = -EAGAIN;\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, &log->dirty_log_pages, mark);\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tbtrfs_set_log_full_commit(fs_info, trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx, NULL);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tatomic_inc(&log_root_tree->log_batch);\n\tatomic_inc(&log_root_tree->log_writers);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tret = update_log_root(trans, log);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tif (atomic_dec_and_test(&log_root_tree->log_writers)) {\n\t\t/*\n\t\t * Implicit memory barrier after atomic_dec_and_test\n\t\t */\n\t\tif (waitqueue_active(&log_root_tree->log_writer_wait))\n\t\t\twake_up(&log_root_tree->log_writer_wait);\n\t}\n\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(fs_info, trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tlist_del_init(&root_log_ctx.list);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_tree_log_extents(log, mark);\n\t\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\twait_for_writer(log_root_tree);\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(fs_info, trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(fs_info,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_tree_log_extents(log, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_tree_log_extents(log_root_tree,\n\t\t\t\t\t\t  EXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(fs_info, trans);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\n\tbtrfs_set_super_log_root(fs_info->super_for_commit,\n\t\t\t\t log_root_tree->node->start);\n\tbtrfs_set_super_log_root_level(fs_info->super_for_commit,\n\t\t\t\t       btrfs_header_level(log_root_tree->node));\n\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * nobody else is going to jump in and write the the ctree\n\t * super here because the log_commit atomic below is protecting\n\t * us.  We must be called with a transaction handle pinning\n\t * the running transaction open, so a full commit can't hop\n\t * in and cause problems either.\n\t */\n\tret = write_all_supers(fs_info, 1);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\tmutex_lock(&log_root_tree->log_mutex);\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * The barrier before waitqueue_active is implied by mutex_unlock\n\t */\n\tif (waitqueue_active(&log_root_tree->log_commit_wait[index2]))\n\t\twake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\tmutex_lock(&root->log_mutex);\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n	f
56807	2238	btrfs_sync_file	fs/btrfs/file.c	ctx.io_err	1	11	\N	\N	\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_log_ctx ctx;\n\tint ret = 0, err;\n\tbool full_sync = 0;\n\tu64 len;\n\n\t/*\n\t * The range length can be represented by u64, we have to do the typecasts\n\t * to avoid signed overflow if it's [0, LLONG_MAX] eg. from fsync()\n\t */\n\tlen = (u64)end - (u64)start + 1;\n\ttrace_btrfs_sync_file(file, datasync);\n\n\t/*\n\t * We write the dirty pages in the range and wait until they complete\n\t * out of the ->i_mutex. If so, we can flush the dirty pages by\n\t * multi-task, and make the performance up.  See\n\t * btrfs_wait_ordered_range for an explanation of the ASYNC check.\n\t */\n\tret = start_ordered_ops(inode, start, end);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_lock(inode);\n\tatomic_inc(&root->log_batch);\n\tfull_sync = test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags);\n\t/*\n\t * We might have have had more pages made dirty after calling\n\t * start_ordered_ops and before acquiring the inode's i_mutex.\n\t */\n\tif (full_sync) {\n\t\t/*\n\t\t * For a full sync, we need to make sure any ordered operations\n\t\t * start and finish before we start logging the inode, so that\n\t\t * all extents are persisted and the respective file extent\n\t\t * items are in the fs/subvol btree.\n\t\t */\n\t\tret = btrfs_wait_ordered_range(inode, start, len);\n\t} else {\n\t\t/*\n\t\t * Start any new ordered operations before starting to log the\n\t\t * inode. We will wait for them to finish in btrfs_sync_log().\n\t\t *\n\t\t * Right before acquiring the inode's mutex, we might have new\n\t\t * writes dirtying pages, which won't immediately start the\n\t\t * respective ordered operations - that is done through the\n\t\t * fill_delalloc callbacks invoked from the writepage and\n\t\t * writepages address space operations. So make sure we start\n\t\t * all ordered operations before starting to log our inode. Not\n\t\t * doing this means that while logging the inode, writeback\n\t\t * could start and invoke writepage/writepages, which would call\n\t\t * the fill_delalloc callbacks (cow_file_range,\n\t\t * submit_compressed_extents). These callbacks add first an\n\t\t * extent map to the modified list of extents and then create\n\t\t * the respective ordered operation, which means in\n\t\t * tree-log.c:btrfs_log_inode() we might capture all existing\n\t\t * ordered operations (with btrfs_get_logged_extents()) before\n\t\t * the fill_delalloc callback adds its ordered operation, and by\n\t\t * the time we visit the modified list of extent maps (with\n\t\t * btrfs_log_changed_extents()), we see and process the extent\n\t\t * map they created. We then use the extent map to construct a\n\t\t * file extent item for logging without waiting for the\n\t\t * respective ordered operation to finish - this file extent\n\t\t * item points to a disk location that might not have yet been\n\t\t * written to, containing random data - so after a crash a log\n\t\t * replay will make our inode have file extent items that point\n\t\t * to disk locations containing invalid data, as we returned\n\t\t * success to userspace without waiting for the respective\n\t\t * ordered operation to finish, because it wasn't captured by\n\t\t * btrfs_get_logged_extents().\n\t\t */\n\t\tret = start_ordered_ops(inode, start, end);\n\t}\n\tif (ret) {\n\t\tinode_unlock(inode);\n\t\tgoto out;\n\t}\n\tatomic_inc(&root->log_batch);\n\n\t/*\n\t * If the last transaction that changed this file was before the current\n\t * transaction and we have the full sync flag set in our inode, we can\n\t * bail out now without any syncing.\n\t *\n\t * Note that we can't bail out if the full sync flag isn't set. This is\n\t * because when the full sync flag is set we start all ordered extents\n\t * and wait for them to fully complete - when they complete they update\n\t * the inode's last_trans field through:\n\t *\n\t *     btrfs_finish_ordered_io() ->\n\t *         btrfs_update_inode_fallback() ->\n\t *             btrfs_update_inode() ->\n\t *                 btrfs_set_inode_last_trans()\n\t *\n\t * So we are sure that last_trans is up to date and can do this check to\n\t * bail out safely. For the fast path, when the full sync flag is not\n\t * set in our inode, we can not do it because we start only our ordered\n\t * extents and don't wait for them to complete (that is when\n\t * btrfs_finish_ordered_io runs), so here at this point their last_trans\n\t * value might be less than or equals to fs_info->last_trans_committed,\n\t * and setting a speculative last_trans for an inode when a buffered\n\t * write is made (such as fs_info->generation + 1 for example) would not\n\t * be reliable since after setting the value and before fsync is called\n\t * any number of transactions can start and commit (transaction kthread\n\t * commits the current transaction periodically), and a transaction\n\t * commit does not start nor waits for ordered extents to complete.\n\t */\n\tsmp_mb();\n\tif (btrfs_inode_in_log(BTRFS_I(inode), fs_info->generation) ||\n\t    (full_sync && BTRFS_I(inode)->last_trans <=\n\t     fs_info->last_trans_committed) ||\n\t    (!btrfs_have_ordered_extents_in_range(inode, start, len) &&\n\t     BTRFS_I(inode)->last_trans\n\t     <= fs_info->last_trans_committed)) {\n\t\t/*\n\t\t * We've had everything committed since the last time we were\n\t\t * modified so clear this flag in case it was set for whatever\n\t\t * reason, it's no longer relevant.\n\t\t */\n\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t/*\n\t\t * An ordered extent might have started before and completed\n\t\t * already with io errors, in which case the inode was not\n\t\t * updated and we end up here. So check the inode's mapping\n\t\t * for any errors that might have happened since we last\n\t\t * checked called fsync.\n\t\t */\n\t\tret = filemap_check_wb_err(inode->i_mapping, file->f_wb_err);\n\t\tinode_unlock(inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ok we haven't committed the transaction yet, lets do a commit\n\t */\n\tif (file->private_data)\n\t\tbtrfs_ioctl_trans_end(file);\n\n\t/*\n\t * We use start here because we will need to wait on the IO to complete\n\t * in btrfs_sync_log, which could require joining a transaction (for\n\t * example checking cross references in the nocow path).  If we use join\n\t * here we could get into a situation where we're waiting on IO to\n\t * happen that is blocked on a transaction trying to commit.  With start\n\t * we inc the extwriter counter, so we wait for all extwriters to exit\n\t * before we start blocking join'ers.  This comment is to keep somebody\n\t * from thinking they are super smart and changing this to\n\t * btrfs_join_transaction *cough*Josef*cough*.\n\t */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tinode_unlock(inode);\n\t\tgoto out;\n\t}\n\ttrans->sync = true;\n\n\tbtrfs_init_log_ctx(&ctx, inode);\n\n\tret = btrfs_log_dentry_safe(trans, root, dentry, start, end, &ctx);\n\tif (ret < 0) {\n\t\t/* Fallthrough and commit/free transaction. */\n\t\tret = 1;\n\t}\n\n\t/* we've logged all the items and now have a consistent\n\t * version of the file in the log.  It is possible that\n\t * someone will come in and modify the file, but that's\n\t * fine because the log is consistent on disk, and we\n\t * have references to all of the file's extents\n\t *\n\t * It is possible that someone will come in and log the\n\t * file again, but that will end up using the synchronization\n\t * inside btrfs_sync_log to keep things safe.\n\t */\n\tinode_unlock(inode);\n\n\t/*\n\t * If any of the ordered extents had an error, just return it to user\n\t * space, so that the application knows some writes didn't succeed and\n\t * can take proper action (retry for e.g.). Blindly committing the\n\t * transaction in this case, would fool userspace that everything was\n\t * successful. And we also want to make sure our log doesn't contain\n\t * file extent items pointing to extents that weren't fully written to -\n\t * just like in the non fast fsync path, where we check for the ordered\n\t * operation's error flag before writing to the log tree and return -EIO\n\t * if any of them had this flag set (btrfs_wait_ordered_range) -\n\t * therefore we need to check for errors in the ordered operations,\n\t * which are indicated by ctx.io_err.\n\t */\n\tif (ctx.io_err) {\n	f
39613	6722	btrfs_read_sys_array	fs/btrfs/volumes.c	type	1	11	\N	\N	\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct extent_buffer *sb;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *array_ptr;\n\tunsigned long sb_array_offset;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur_offset;\n\tu64 type;\n\tstruct btrfs_key key;\n\n\tASSERT(BTRFS_SUPER_INFO_SIZE <= fs_info->nodesize);\n\t/*\n\t * This will create extent buffer of nodesize, superblock size is\n\t * fixed to BTRFS_SUPER_INFO_SIZE. If nodesize > sb size, this will\n\t * overallocate but we can keep it as-is, only the first page is used.\n\t */\n\tsb = btrfs_find_create_tree_block(fs_info, BTRFS_SUPER_INFO_OFFSET);\n\tif (IS_ERR(sb))\n\t\treturn PTR_ERR(sb);\n\tset_extent_buffer_uptodate(sb);\n\tbtrfs_set_buffer_lockdep_class(root->root_key.objectid, sb, 0);\n\t/*\n\t * The sb extent buffer is artificial and just used to read the system array.\n\t * set_extent_buffer_uptodate() call does not properly mark all it's\n\t * pages up-to-date when the page is larger: extent does not cover the\n\t * whole page and consequently check_page_uptodate does not find all\n\t * the page's extents up-to-date (the hole beyond sb),\n\t * write_extent_buffer then triggers a WARN_ON.\n\t *\n\t * Regular short extents go through mark_extent_buffer_dirty/writeback cycle,\n\t * but sb spans only this function. Add an explicit SetPageUptodate call\n\t * to silence the warning eg. on PowerPC 64.\n\t */\n\tif (PAGE_SIZE > BTRFS_SUPER_INFO_SIZE)\n\t\tSetPageUptodate(sb->pages[0]);\n\n\twrite_extent_buffer(sb, super_copy, 0, BTRFS_SUPER_INFO_SIZE);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tarray_ptr = super_copy->sys_chunk_array;\n\tsb_array_offset = offsetof(struct btrfs_super_block, sys_chunk_array);\n\tcur_offset = 0;\n\n\twhile (cur_offset < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)array_ptr;\n\t\tlen = sizeof(*disk_key);\n\t\tif (cur_offset + len > array_size)\n\t\t\tgoto out_short_read;\n\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)sb_array_offset;\n\t\t\t/*\n\t\t\t * At least one btrfs_chunk with one stripe must be\n\t\t\t * present, exact stripe count check comes afterwards\n\t\t\t */\n\t\t\tlen = btrfs_chunk_item_size(1);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tnum_stripes = btrfs_chunk_num_stripes(sb, chunk);\n\t\t\tif (!num_stripes) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t"invalid number of stripes %u in sys_array at offset %u",\n\t\t\t\t\tnum_stripes, cur_offset);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttype = btrfs_chunk_type(sb, chunk);\n\t\t\tif ((type & BTRFS_BLOCK_GROUP_SYSTEM) == 0) {\n\t\t\t\tbtrfs_err(fs_info,\n	t
56754	211	__cached_dev_store	drivers/md/bcache/sysfs.c	__cached_dev_store_$__UNIQUE_ID_min1_269$obj	0	11	\N	\N	\tstruct cached_dev *dc = container_of(kobj, struct cached_dev,\n\t\t\t\t\t     disk.kobj);\n\tssize_t v = size;\n\tstruct cache_set *c;\n\tstruct kobj_uevent_env *env;\n\n#define d_strtoul(var)\t\tsysfs_strtoul(var, dc->var)\n#define d_strtoul_nonzero(var)\tsysfs_strtoul_clamp(var, dc->var, 1, INT_MAX)\n#define d_strtoi_h(var)\t\tsysfs_hatoi(var, dc->var)\n\n\tsysfs_strtoul(data_csum,\tdc->disk.data_csum);\n\td_strtoul(verify);\n\td_strtoul(bypass_torture_test);\n\td_strtoul(writeback_metadata);\n\td_strtoul(writeback_running);\n\td_strtoul(writeback_delay);\n\n\tsysfs_strtoul_clamp(writeback_percent, dc->writeback_percent, 0, 40);\n	f
33434	1264	calipso_req_delattr	net/ipv6/calipso.c	new	1	11	\N	\N	\tstruct inet_request_sock *req_inet = inet_rsk(req);\n\tstruct ipv6_opt_hdr *new;\n\tstruct ipv6_txoptions *txopts;\n\tstruct sock *sk = sk_to_full_sk(req_to_sk(req));\n\n\tif (!req_inet->ipv6_opt || !req_inet->ipv6_opt->hopopt)\n\t\treturn;\n\n\tif (calipso_opt_del(req_inet->ipv6_opt->hopopt, &new))\n\t\treturn; /* Nothing to do */\n\n\ttxopts = ipv6_renew_options_kern(sk, req_inet->ipv6_opt, IPV6_HOPOPTS,\n\t\t\t\t\t new, new ? ipv6_optlen(new) : 0);\n	f
779	77	axp20x_battery_get_max_voltage	drivers/power/supply/axp20x_battery.c	reg	1	11	\N	\N	\tint ret, reg;\n\n\tret = regmap_read(axp20x_batt->regmap, AXP20X_CHRG_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & AXP20X_CHRG_CTRL1_TGT_VOLT) {\n	t
38040	1504	mkdir_mondata_all	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c	kn	1	11	\N	\N	\tstruct rdt_resource *r;\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\t/*\n\t * Create the mon_data directory first.\n\t */\n\tret = mongroup_create_dir(parent_kn, NULL, "mon_data", &kn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dest_kn)\n\t\t*dest_kn = kn;\n\n\t/*\n\t * Create the subdirectories for each domain. Note that all events\n\t * in a domain like L3 are grouped into a resource whose domain is L3\n\t */\n\tfor_each_mon_enabled_rdt_resource(r) {\n\t\tret = mkdir_mondata_subdir_alldom(kn, r, prgrp);\n	f
45522	176	i1480_phy_fw_upload	drivers/uwb/i1480/dfu/phy.c	i1480_phy_fw_upload_$fw$obj	0	11	\N	\N	\tint result;\n\tconst struct firmware *fw;\n\tconst char *data_itr, *data_top;\n\tconst size_t MAX_BLK_SIZE = 480;\t/* 160 triads */\n\tsize_t data_size;\n\tu8 phy_stat;\n\n\tresult = request_firmware(&fw, i1480->phy_fw_name, i1480->dev);\n\tif (result < 0)\n\t\tgoto out;\n\t/* Loop writing data in chunks as big as possible until done. */\n\tfor (data_itr = fw->data, data_top = data_itr + fw->size;\n	t
58180	143	can_rx_offload_offload_one	drivers/net/can/rx-offload.c	skb	1	11	\N	\N	\tstruct sk_buff *skb = NULL;\n\tstruct can_rx_offload_cb *cb;\n\tstruct can_frame *cf;\n\tint ret;\n\n\t/* If queue is full or skb not available, read to discard mailbox */\n\tif (likely(skb_queue_len(&offload->skb_queue) <=\n\t\t   offload->skb_queue_len_max))\n\t\tskb = alloc_can_skb(offload->dev, &cf);\n\n\tif (!skb) {\n\t\tstruct can_frame cf_overflow;\n\t\tu32 timestamp;\n\n\t\tret = offload->mailbox_read(offload, &cf_overflow,\n\t\t\t\t\t    &timestamp, n);\n\t\tif (ret)\n\t\t\toffload->dev->stats.rx_dropped++;\n\n\t\treturn NULL;\n\t}\n\n\tcb = can_rx_offload_get_cb(skb);\n	f
62011	297	efivar_ssdt_load	drivers/firmware/efi/efi.c	ret	0	11	\N	\N	\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info("loading SSDT from variable %s-%pUl\\n", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\n\t\tlist_del(&entry->list);\n\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err("failed to get var size\\n");\n\t\t\tgoto free_entry;\n\t\t}\n\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err("failed to get var data\\n");\n\t\t\tgoto free_data;\n\t\t}\n\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n	f
62098	645	calibrate_store	drivers/input/mouse/elan_i2c_core.c	val	0	11	\N	\N	\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint tries = 20;\n\tint retval;\n\tint error;\n\tu8 val[3];\n\n\tretval = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tdisable_irq(client->irq);\n\n\tdata->mode |= ETP_ENABLE_CALIBRATE;\n\tretval = data->ops->set_mode(client, data->mode);\n\tif (retval) {\n\t\tdev_err(dev, "failed to enable calibration mode: %d\\n",\n\t\t\tretval);\n\t\tgoto out;\n\t}\n\n\tretval = data->ops->calibrate(client);\n\tif (retval) {\n\t\tdev_err(dev, "failed to start calibration: %d\\n",\n\t\t\tretval);\n\t\tgoto out_disable_calibrate;\n\t}\n\n\tval[0] = 0xff;\n\tdo {\n\t\t/* Wait 250ms before checking if calibration has completed. */\n\t\tmsleep(250);\n\n\t\tretval = data->ops->calibrate_result(client, val);\n\t\tif (retval)\n\t\t\tdev_err(dev, "failed to check calibration result: %d\\n",\n\t\t\t\tretval);\n\t\telse if (val[0] == 0)\n	f
27280	1751	btusb_setup_intel	drivers/bluetooth/btusb.c	fw	1	13	\N	\N	\tstruct sk_buff *skb;\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tint disable_patch, err;\n\tstruct intel_version ver;\n\n\tBT_DBG("%s", hdev->name);\n\n\t/* The controller has a bug with the first HCI command sent to it\n\t * returning number of completed commands as zero. This would stall the\n\t * command processing in the Bluetooth core.\n\t *\n\t * As a workaround, send HCI Reset command first which will reset the\n\t * number of completed commands and allow normal command processing\n\t * from now on.\n\t */\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR("%s sending initial HCI reset command failed (%ld)",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\t/* Read Intel specific controller version first to allow selection of\n\t * which firmware file to load.\n\t *\n\t * The returned information are hardware variant and revision plus\n\t * firmware variant, revision and build number.\n\t */\n\terr = btintel_read_version(hdev, &ver);\n\tif (err)\n\t\treturn err;\n\n\tBT_INFO("%s: read Intel version: %02x%02x%02x%02x%02x%02x%02x%02x%02x",\n\t\thdev->name, ver.hw_platform, ver.hw_variant, ver.hw_revision,\n\t\tver.fw_variant,  ver.fw_revision, ver.fw_build_num,\n\t\tver.fw_build_ww, ver.fw_build_yy, ver.fw_patch_num);\n\n\t/* fw_patch_num indicates the version of patch the device currently\n\t * have. If there is no patch data in the device, it is always 0x00.\n\t * So, if it is other than 0x00, no need to patch the device again.\n\t */\n\tif (ver.fw_patch_num) {\n\t\tBT_INFO("%s: Intel device is already patched. patch num: %02x",\n\t\t\thdev->name, ver.fw_patch_num);\n\t\tgoto complete;\n\t}\n\n\t/* Opens the firmware patch file based on the firmware version read\n\t * from the controller. If it fails to open the matching firmware\n\t * patch file, it tries to open the default firmware patch file.\n\t * If no patch file is found, allow the device to operate without\n\t * a patch.\n\t */\n\tfw = btusb_setup_intel_get_fw(hdev, &ver);\n\tif (!fw)\n	f
46009	466	iscsi_login_zero_tsih_s2	drivers/target/iscsi/iscsi_target_login.c	off	1	11	\N	\N	\tstruct iscsi_node_attrib *na;\n\tstruct iscsi_session *sess = conn->sess;\n\tbool iser = false;\n\n\tsess->tpg = conn->tpg;\n\n\t/*\n\t * Assign a new TPG Session Handle.  Note this is protected with\n\t * struct iscsi_portal_group->np_login_sem from iscsit_access_np().\n\t */\n\tsess->tsih = ++sess->tpg->ntsih;\n\tif (!sess->tsih)\n\t\tsess->tsih = ++sess->tpg->ntsih;\n\n\t/*\n\t * Create the default params from user defined values..\n\t */\n\tif (iscsi_copy_param_list(&conn->param_list,\n\t\t\t\tconn->tpg->param_list, 1) < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\treturn -1;\n\t}\n\n\tif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\n\t\tiser = true;\n\n\tiscsi_set_keys_to_negotiate(conn->param_list, iser);\n\n\tif (sess->sess_ops->SessionType)\n\t\treturn iscsi_set_keys_irrelevant_for_discovery(\n\t\t\t\tconn->param_list);\n\n\tna = iscsit_tpg_get_node_attrib(sess);\n\n\t/*\n\t * Need to send TargetPortalGroupTag back in first login response\n\t * on any iSCSI connection where the Initiator provides TargetName.\n\t * See 5.3.1.  Login Phase Start\n\t *\n\t * In our case, we have already located the struct iscsi_tiqn at this point.\n\t */\n\tif (iscsi_change_param_sprintf(conn, "TargetPortalGroupTag=%hu", sess->tpg->tpgt))\n\t\treturn -1;\n\n\t/*\n\t * Workaround for Initiators that have broken connection recovery logic.\n\t *\n\t * "We would really like to get rid of this." Linux-iSCSI.org team\n\t */\n\tif (iscsi_change_param_sprintf(conn, "ErrorRecoveryLevel=%d", na->default_erl))\n\t\treturn -1;\n\n\t/*\n\t * Set RDMAExtensions=Yes by default for iSER enabled network portals\n\t */\n\tif (iser) {\n\t\tstruct iscsi_param *param;\n\t\tunsigned long mrdsl, off;\n\t\tint rc;\n\n\t\tif (iscsi_change_param_sprintf(conn, "RDMAExtensions=Yes"))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Make MaxRecvDataSegmentLength PAGE_SIZE aligned for\n\t\t * Immediate Data + Unsolicited Data-OUT if necessary..\n\t\t */\n\t\tparam = iscsi_find_param_from_key("MaxRecvDataSegmentLength",\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\t\treturn -1;\n\t\t}\n\t\trc = kstrtoul(param->value, 0, &mrdsl);\n\t\tif (rc < 0) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\t\treturn -1;\n\t\t}\n\t\toff = mrdsl % PAGE_SIZE;\n\t\tif (!off)\n	t
853	144	fuel_gauge_reg_readb	drivers/power/supply/axp288_fuel_gauge.c	ret	1	11	\N	\N	\tint ret, i;\n\tunsigned int val;\n\n\tfor (i = 0; i < NR_RETRY_CNT; i++) {\n\t\tret = regmap_read(info->regmap, reg, &val);\n\t\tif (ret == -EBUSY)\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n	t
56292	914	cifs_demultiplex_thread	fs/cifs/connect.c	cifs_demultiplex_thread_$mid_entry$obj$15$obj$and$1	0	11	\N	\N	\tint length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcifs_dbg(FYI, "Demultiplex PID: %d\\n", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read = length;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, "RFC1002 header 0x%x\\n", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\n\t\t\tcifs_dbg(VFS, "SMB response too short (%u bytes)\\n",\n\t\t\t\t pdu_length);\n\t\t\tcifs_reconnect(server);\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server, buf + 4,\n\t\t\t\t\t       HEADER_SIZE(server) - 1 - 4);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tif (server->ops->is_transform_hdr &&\n\t\t    server->ops->receive_transform &&\n\t\t    server->ops->is_transform_hdr(buf)) {\n\t\t\tlength = server->ops->receive_transform(server,\n\t\t\t\t\t\t\t\t&mid_entry);\n\t\t} else {\n\t\t\tmid_entry = server->ops->find_mid(server, buf);\n\n\t\t\tif (!mid_entry || !mid_entry->receive)\n\t\t\t\tlength = standard_receive3(server, mid_entry);\n\t\t\telse\n\t\t\t\tlength = mid_entry->receive(server, mid_entry);\n\t\t}\n\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (server->large_buf)\n\t\t\tbuf = server->bigbuf;\n\n\t\tserver->lstrp = jiffies;\n\t\tif (mid_entry != NULL) {\n\t\t\tif ((mid_entry->mid_flags & MID_WAIT_CANCELLED) &&\n	f
40765	610	ch341_reset_resume	drivers/usb/serial/ch341.c	ret	1	11	\N	\N	\tstruct usb_serial_port *port = serial->port[0];\n\tstruct ch341_private *priv = usb_get_serial_port_data(port);\n\tint ret;\n\n\t/* reconfigure ch341 serial port after bus-reset */\n\tch341_configure(serial->dev, priv);\n\n\tif (tty_port_initialized(&port->port)) {\n\t\tret = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\n\t\tif (ret) {\n\t\t\tdev_err(&port->dev, "failed to submit interrupt urb: %d\\n",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ch341_get_status(port->serial->dev, priv);\n\t\tif (ret < 0) {\n	f
43045	329	ccp5_debugfs_setup	drivers/crypto/ccp/ccp-debugfs.c	debugfs_q_instance	1	11	\N	\N	\tstruct ccp_cmd_queue *cmd_q;\n\tchar name[MAX_NAME_LEN + 1];\n\tstruct dentry *debugfs_info;\n\tstruct dentry *debugfs_stats;\n\tstruct dentry *debugfs_q_instance;\n\tstruct dentry *debugfs_q_stats;\n\tunsigned long flags;\n\tint i;\n\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\twrite_lock_irqsave(&ccp_debugfs_lock, flags);\n\tif (!ccp_debugfs_dir)\n\t\tccp_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\twrite_unlock_irqrestore(&ccp_debugfs_lock, flags);\n\tif (!ccp_debugfs_dir)\n\t\treturn;\n\n\tccp->debugfs_instance = debugfs_create_dir(ccp->name, ccp_debugfs_dir);\n\tif (!ccp->debugfs_instance)\n\t\tgoto err;\n\n\tdebugfs_info = debugfs_create_file("info", 0400,\n\t\t\t\t\t   ccp->debugfs_instance, ccp,\n\t\t\t\t\t   &ccp_debugfs_info_ops);\n\tif (!debugfs_info)\n\t\tgoto err;\n\n\tdebugfs_stats = debugfs_create_file("stats", 0600,\n\t\t\t\t\t    ccp->debugfs_instance, ccp,\n\t\t\t\t\t    &ccp_debugfs_stats_ops);\n\tif (!debugfs_stats)\n\t\tgoto err;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\tsnprintf(name, MAX_NAME_LEN - 1, "q%d", cmd_q->id);\n\n\t\tdebugfs_q_instance =\n\t\t\tdebugfs_create_dir(name, ccp->debugfs_instance);\n\t\tif (!debugfs_q_instance)\n	f
47390	339	mlx5_alloc_irq_vectors	drivers/net/ethernet/mellanox/mlx5/core/main.c	nvec	1	11	\N	\N	\tstruct mlx5_priv *priv = &dev->priv;\n\tstruct mlx5_eq_table *table = &priv->eq_table;\n\tstruct irq_affinity irqdesc = {\n\t\t.pre_vectors = MLX5_EQ_VEC_COMP_BASE,\n\t};\n\tint num_eqs = 1 << MLX5_CAP_GEN(dev, log_max_eq);\n\tint nvec;\n\n\tnvec = MLX5_CAP_GEN(dev, num_ports) * num_online_cpus() +\n\t       MLX5_EQ_VEC_COMP_BASE;\n\tnvec = min_t(int, nvec, num_eqs);\n\tif (nvec <= MLX5_EQ_VEC_COMP_BASE)\n\t\treturn -ENOMEM;\n\n\tpriv->irq_info = kcalloc(nvec, sizeof(*priv->irq_info), GFP_KERNEL);\n\tif (!priv->irq_info)\n\t\tgoto err_free_msix;\n\n\tnvec = pci_alloc_irq_vectors_affinity(dev->pdev,\n\t\t\tMLX5_EQ_VEC_COMP_BASE + 1, nvec,\n\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY,\n\t\t\t&irqdesc);\n\tif (nvec < 0)\n	f
876	95	max77693_get_charge_type	drivers/power/supply/max77693_charger.c	data	1	11	\N	\N	\tint ret;\n\tunsigned int data;\n\n\tret = regmap_read(regmap, MAX77693_CHG_REG_CHG_DETAILS_01, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata &= CHG_DETAILS_01_CHG_MASK;\n\tdata >>= CHG_DETAILS_01_CHG_SHIFT;\n\n\tswitch (data) {\n	t
62800	82	cgrp_attach	net/core/netclassid_cgroup.c	css)->classid	0	11	\N	\N	\tstruct cgroup_subsys_state *css;\n\tstruct task_struct *p;\n\n\tcgroup_taskset_for_each(p, css, tset) {\n\t\ttask_lock(p);\n\t\titerate_fd(p->files, 0, update_classid_sock,\n\t\t\t   (void *)(unsigned long)css_cls_state(css)->classid);\n	f
31928	861	compose_entry_fh	fs/nfsd/nfs3xdr.c	dchild->d_inode->i_ino	1	-1	\N	\N	\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for ".." */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n	f
63356	51	cm_write	drivers/acpi/custom_method.c	cm_write_@cm_write.uncopied_bytes $obj	0	11	\N	\N	\tstatic char *buf;\n\tstatic u32 max_size;\n\tstatic u32 uncopied_bytes;\n\n\tstruct acpi_table_header table;\n\tacpi_status status;\n\n\tif (!(*ppos)) {\n\t\t/* parse the table header to get the table length */\n\t\tif (count <= sizeof(struct acpi_table_header))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&table, user_buf,\n\t\t\t\t   sizeof(struct acpi_table_header)))\n\t\t\treturn -EFAULT;\n\t\tuncopied_bytes = max_size = table.length;\n\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tif ((*ppos > max_size) ||\n\t    (*ppos + count > max_size) ||\n\t    (*ppos + count < count) ||\n\t    (count > uncopied_bytes))\n	f
48381	2416	cont_expand_zero	fs/buffer.c	page	1	11	\N	\N	\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_SHIFT;\n\toffset = pos & ~PAGE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n	f
26272	1806	mptctl_mpt_command	drivers/message/fusion/mptctl.c	karg	1	11	\N	\N	\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM "%s@%d::mptctl_mpt_command - "\n\t\t\t"Unable to read in mpt_ioctl_command struct @ %p\\n",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM "%s::mptctl_mpt_command() @%d - ioc%d not found!\\n",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n	f
39077	1966	cma_req_handler	drivers/infiniband/core/cma.c	net_dev	1	11	\N	\N	\tstruct rdma_id_private *listen_id, *conn_id = NULL;\n\tstruct rdma_cm_event event;\n\tstruct net_device *net_dev;\n\tint offset, ret;\n\n\tlisten_id = cma_id_from_event(cm_id, ib_event, &net_dev);\n\tif (IS_ERR(listen_id))\n\t\treturn PTR_ERR(listen_id);\n\n\tif (!cma_check_req_qp_type(&listen_id->id, ib_event)) {\n\t\tret = -EINVAL;\n\t\tgoto net_dev_put;\n\t}\n\n\tmutex_lock(&listen_id->handler_mutex);\n\tif (listen_id->state != RDMA_CM_LISTEN) {\n\t\tret = -ECONNABORTED;\n\t\tgoto err1;\n\t}\n\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event, net_dev);\n	f
50883	160	configfs_symlink	fs/configfs/symlink.c	&path	2	-11	\N	\N	\tint ret;\n\tstruct path path;\n\tstruct configfs_dirent *sd;\n\tstruct config_item *parent_item;\n\tstruct config_item *target_item = NULL;\n\tstruct config_item_type *type;\n\n\tsd = dentry->d_parent->d_fsdata;\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t */\n\tret = -ENOENT;\n\tif (!configfs_dirent_is_ready(sd))\n\t\tgoto out;\n\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\n\tret = -EPERM;\n\tif (!type || !type->ct_item_ops ||\n\t    !type->ct_item_ops->allow_link)\n\t\tgoto out_put;\n\n\tret = get_target(symname, &path, &target_item, dentry->d_sb);\n	f
27355	123	wm8350_rtc_settime	drivers/rtc/rtc-wm8350.c	rtc_ctrl	1	13	\N	\N	\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tu16 time[4];\n\tu16 rtc_ctrl;\n\tint ret, retries = WM8350_SET_TIME_RETRIES;\n\n\ttime[0] = tm->tm_sec;\n\ttime[0] |= tm->tm_min << WM8350_RTC_MINS_SHIFT;\n\ttime[1] = tm->tm_hour;\n\ttime[1] |= (tm->tm_wday + 1) << WM8350_RTC_DAY_SHIFT;\n\ttime[2] = tm->tm_mday;\n\ttime[2] |= (tm->tm_mon + 1) << WM8350_RTC_MTH_SHIFT;\n\ttime[3] = ((tm->tm_year + 1900) / 100) << WM8350_RTC_YHUNDREDS_SHIFT;\n\ttime[3] |= (tm->tm_year + 1900) % 100;\n\n\tdev_dbg(dev, "Setting: %04x %04x %04x %04x\\n",\n\t\ttime[0], time[1], time[2], time[3]);\n\n\t/* Set RTC_SET to stop the clock */\n\tret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL, WM8350_RTC_SET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Wait until confirmation of stopping */\n\tdo {\n\t\trtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(1));\n\t} while (--retries && !(rtc_ctrl & WM8350_RTC_STS));\n	f
26761	164	mpl3115_trigger_handler	drivers/iio/pressure/mpl3115.c	ret	1	11	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mpl3115_data *data = iio_priv(indio_dev);\n\tu8 buffer[16]; /* 32-bit channel + 16-bit channel + padding + ts */\n\tint ret, pos = 0;\n\n\tmutex_lock(&data->lock);\n\tret = mpl3115_request(data);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (test_bit(0, indio_dev->active_scan_mask)) {\n\t\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\tMPL3115_OUT_PRESS, 3, &buffer[pos]);\n\t\tif (ret < 0) {\n	f
27552	178	get_link_speed_and_width	drivers/infiniband/hw/ocrdma/ocrdma_verbs.c	speed	1	13	\N	\N	\tint status;\n\tu8 speed;\n\n\tstatus = ocrdma_mbx_get_link_speed(dev, &speed, NULL);\n\tif (status)\n\t\tspeed = OCRDMA_PHYS_LINK_SPEED_ZERO;\n\n\tswitch (speed) {\n	f
33085	1781	mlx5e_open_channel	drivers/net/ethernet/mellanox/mlx5/core/en_main.c	irq	1	11	\N	\N	\tstruct mlx5e_cq_moder icocq_moder = {0, 0};\n\tstruct net_device *netdev = priv->netdev;\n\tstruct mlx5e_channel *c;\n\tunsigned int irq;\n\tint err;\n\tint eqn;\n\n\tc = kzalloc_node(sizeof(*c), GFP_KERNEL, mlx5e_get_node(priv, ix));\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->priv     = priv;\n\tc->mdev     = priv->mdev;\n\tc->tstamp   = &priv->tstamp;\n\tc->ix       = ix;\n\tc->pdev     = &priv->mdev->pdev->dev;\n\tc->netdev   = priv->netdev;\n\tc->mkey_be  = cpu_to_be32(priv->mdev->mlx5e_res.mkey.key);\n\tc->num_tc   = params->num_tc;\n\tc->xdp      = !!params->xdp_prog;\n\n\tmlx5_vector2eqn(priv->mdev, ix, &eqn, &irq);\n\tc->irq_desc = irq_to_desc(irq);\n	f
918	117	gpio_nand_get_config_of	drivers/mtd/nand/gpio.c	gpio_nand_get_config_of_	1	11	\N	\N	\tu32 val;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tif (!of_property_read_u32(dev->of_node, "bank-width", &val)) {\n	t
30715	2409	mmc_blk_add_debugfs	drivers/mmc/core/block.c	mmc_blk_add_debugfs_	0	11	\N	\N	\tstruct dentry *root;\n\n\tif (!card->debugfs_root)\n\t\treturn 0;\n\n\troot = card->debugfs_root;\n\n\tif (mmc_card_mmc(card) || mmc_card_sd(card)) {\n\t\tif (!debugfs_create_file("status", S_IRUSR, root, card,\n	f
46283	627	acpi_evalf	drivers/platform/x86/thinkpad_acpi.c	success	1	11	\N	\N	\tchar *fmt0 = fmt;\n\tstruct acpi_object_list params;\n\tunion acpi_object in_objs[TPACPI_MAX_ACPI_ARGS];\n\tstruct acpi_buffer result, *resultp;\n\tunion acpi_object out_obj;\n\tacpi_status status;\n\tva_list ap;\n\tchar res_type;\n\tint success;\n\tint quiet;\n\n\tif (!*fmt) {\n\t\tpr_err("acpi_evalf() called with empty format\\n");\n\t\treturn 0;\n\t}\n\n\tif (*fmt == 'q') {\n\t\tquiet = 1;\n\t\tfmt++;\n\t} else\n\t\tquiet = 0;\n\n\tres_type = *(fmt++);\n\n\tparams.count = 0;\n\tparams.pointer = &in_objs[0];\n\n\tva_start(ap, fmt);\n\twhile (*fmt) {\n\t\tchar c = *(fmt++);\n\t\tswitch (c) {\n\t\tcase 'd':\t/* int */\n\t\t\tin_objs[params.count].integer.value = va_arg(ap, int);\n\t\t\tin_objs[params.count++].type = ACPI_TYPE_INTEGER;\n\t\t\tbreak;\n\t\t\t/* add more types as needed */\n\t\tdefault:\n\t\t\tpr_err("acpi_evalf() called with invalid format character '%c'\\n",\n\t\t\t       c);\n\t\t\tva_end(ap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (res_type != 'v') {\n\t\tresult.length = sizeof(out_obj);\n\t\tresult.pointer = &out_obj;\n\t\tresultp = &result;\n\t} else\n\t\tresultp = NULL;\n\n\tstatus = acpi_evaluate_object(handle, method, &params, resultp);\n\n\tswitch (res_type) {\n\tcase 'd':\t\t/* int */\n\t\tsuccess = (status == AE_OK &&\n\t\t\t   out_obj.type == ACPI_TYPE_INTEGER);\n\t\tif (success && res)\n\t\t\t*res = out_obj.integer.value;\n\t\tbreak;\n\tcase 'v':\t\t/* void */\n\t\tsuccess = status == AE_OK;\n\t\tbreak;\n\t\t/* add more types as needed */\n\tdefault:\n\t\tpr_err("acpi_evalf() called with invalid format character '%c'\\n",\n\t\t       res_type);\n\t\treturn 0;\n\t}\n\n\tif (!success && !quiet)\n	t
60244	4974	cpu_partial_store	mm/slub.c	cpu_partial_store_$objects$obj	0	11	\N	\N	\tunsigned long objects;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &objects);\n\tif (err)\n\t\treturn err;\n\tif (objects && !kmem_cache_has_cpu_partial(s))\n	f
7203	822	cdv_intel_dp_i2c_aux_ch	drivers/gpu/drm/gma500/cdv_intel_dp.c	reply	1	11	\N	\N	\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tstruct cdv_intel_dp *intel_dp = container_of(adapter,\n\t\t\t\t\t\tstruct cdv_intel_dp,\n\t\t\t\t\t\tadapter);\n\tstruct gma_encoder *encoder = intel_dp->encoder;\n\tuint16_t address = algo_data->address;\n\tuint8_t msg[5];\n\tuint8_t reply[2];\n\tunsigned retry;\n\tint msg_bytes;\n\tint reply_bytes;\n\tint ret;\n\n\t/* Set up the command byte */\n\tif (mode & MODE_I2C_READ)\n\t\tmsg[0] = DP_AUX_I2C_READ << 4;\n\telse\n\t\tmsg[0] = DP_AUX_I2C_WRITE << 4;\n\n\tif (!(mode & MODE_I2C_STOP))\n\t\tmsg[0] |= DP_AUX_I2C_MOT << 4;\n\n\tmsg[1] = address >> 8;\n\tmsg[2] = address;\n\n\tswitch (mode) {\n\tcase MODE_I2C_WRITE:\n\t\tmsg[3] = 0;\n\t\tmsg[4] = write_byte;\n\t\tmsg_bytes = 5;\n\t\treply_bytes = 1;\n\t\tbreak;\n\tcase MODE_I2C_READ:\n\t\tmsg[3] = 0;\n\t\tmsg_bytes = 4;\n\t\treply_bytes = 2;\n\t\tbreak;\n\tdefault:\n\t\tmsg_bytes = 3;\n\t\treply_bytes = 1;\n\t\tbreak;\n\t}\n\n\tfor (retry = 0; retry < 5; retry++) {\n\t\tret = cdv_intel_dp_aux_ch(encoder,\n\t\t\t\t      msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEBUG_KMS("aux_ch failed %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK) {\n\t\tcase DP_AUX_NATIVE_REPLY_ACK:\n\t\t\t/* I2C-over-AUX Reply field is only valid\n\t\t\t * when paired with AUX ACK.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase DP_AUX_NATIVE_REPLY_NACK:\n\t\t\tDRM_DEBUG_KMS("aux_ch native nack\\n");\n\t\t\treturn -EREMOTEIO;\n\t\tcase DP_AUX_NATIVE_REPLY_DEFER:\n\t\t\tudelay(100);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tDRM_ERROR("aux_ch invalid native reply 0x%02x\\n",\n\t\t\t\t  reply[0]);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_I2C_REPLY_MASK) {\n	t
44439	3880	copy_items	fs/btrfs/tree-log.c	&last_key)	2	-11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->vfs_inode.i_sb);\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tstruct btrfs_key first_key, last_key, key;\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = inode->flags & BTRFS_INODE_NODATASUM;\n\tbool has_extents = false;\n\tbool need_find_last_extent = true;\n\tbool done = false;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tfirst_key.objectid = (u64)-1;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif (i == nr - 1)\n\t\t\tlast_key = ins_keys[i];\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\t&inode->vfs_inode,\n\t\t\t\t\tinode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/*\n\t\t * We set need_find_last_extent here in case we know we were\n\t\t * processing other items and then walk into the first extent in\n\t\t * the inode.  If we don't hit an extent then nothing changes,\n\t\t * we'll do the last search the next time around.\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\thas_extents = true;\n\t\t\tif (first_key.objectid == (u64)-1)\n\t\t\t\tfirst_key = ins_keys[i];\n\t\t} else {\n\t\t\tneed_find_last_extent = false;\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tfs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_release_path(dst_path);\n\t\t\t\t\tkfree(ins_data);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\tret = 0;\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\tif (!has_extents)\n\t\treturn ret;\n\n\tif (need_find_last_extent && *last_extent == first_key.offset) {\n\t\t/*\n\t\t * We don't have any leafs between our current one and the one\n\t\t * we processed before that can have file extent items for our\n\t\t * inode (and have a generation number smaller than our current\n\t\t * transaction id).\n\t\t */\n\t\tneed_find_last_extent = false;\n\t}\n\n\t/*\n\t * Because we use btrfs_search_forward we could skip leaves that were\n\t * not modified and then assume *last_extent is valid when it really\n\t * isn't.  So back up to the previous leaf and read the end of the last\n\t * extent before we go and fill in holes.\n\t */\n\tif (need_find_last_extent) {\n\t\tu64 len;\n\n\t\tret = btrfs_prev_leaf(inode->root, src_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\tgoto fill_holes;\n\t\tif (src_path->slots[0])\n\t\t\tsrc_path->slots[0]--;\n\t\tsrc = src_path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(src, &key, src_path->slots[0]);\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto fill_holes;\n\t\textent = btrfs_item_ptr(src, src_path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src,\n\t\t\t\t\t\t\t   src_path->slots[0],\n\t\t\t\t\t\t\t   extent);\n\t\t\t*last_extent = ALIGN(key.offset + len,\n\t\t\t\t\t     fs_info->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\t*last_extent = key.offset + len;\n\t\t}\n\t}\nfill_holes:\n\t/* So we did prev_leaf, now we need to move to the next leaf, but a few\n\t * things could have happened\n\t *\n\t * 1) A merge could have happened, so we could currently be on a leaf\n\t * that holds what we were copying in the first place.\n\t * 2) A split could have happened, and now not all of the items we want\n\t * are on the same leaf.\n\t *\n\t * So we need to adjust how we search for holes, we need to drop the\n\t * path and re-search for the first extent key we found, and then walk\n\t * forward until we hit the last one we copied.\n\t */\n\tif (need_find_last_extent) {\n\t\t/* btrfs_prev_leaf could return 1 without releasing the path */\n\t\tbtrfs_release_path(src_path);\n\t\tret = btrfs_search_slot(NULL, inode->root, &first_key,\n\t\t\t\tsrc_path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tASSERT(ret == 0);\n\t\tsrc = src_path->nodes[0];\n\t\ti = src_path->slots[0];\n\t} else {\n\t\ti = start_slot;\n\t}\n\n\t/*\n\t * Ok so here we need to go through and fill in any holes we may have\n\t * to make sure that holes are punched for those areas in case they had\n\t * extents previously.\n\t */\n\twhile (!done) {\n\t\tu64 offset, len;\n\t\tu64 extent_end;\n\n\t\tif (i >= btrfs_header_nritems(src_path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(inode->root, src_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tASSERT(ret == 0);\n\t\t\tsrc = src_path->nodes[0];\n\t\t\ti = 0;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\t\tif (!btrfs_comp_cpu_keys(&key, &last_key))\n	f
33299	619	cpcap_usb_phy_probe	drivers/phy/motorola/phy-cpcap-usb.c	ddata	1	11	\N	\N	\tstruct cpcap_phy_ddata *ddata;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct usb_otg *otg;\n\tconst struct of_device_id *of_id;\n\tint error;\n\n\tof_id = of_match_device(of_match_ptr(cpcap_usb_phy_id_table),\n\t\t\t\t&pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tddata->dev = &pdev->dev;\n\tddata->phy.dev = ddata->dev;\n\tddata->phy.label = "cpcap_usb_phy";\n\tddata->phy.otg = otg;\n\tddata->phy.type = USB_PHY_TYPE_USB2;\n\totg->set_host = cpcap_usb_phy_set_host;\n\totg->set_peripheral = cpcap_usb_phy_set_peripheral;\n\totg->usb_phy = &ddata->phy;\n\tINIT_DELAYED_WORK(&ddata->detect_work, cpcap_usb_detect);\n\tplatform_set_drvdata(pdev, ddata);\n\n\tddata->vusb = devm_regulator_get(&pdev->dev, "vusb");\n\tif (IS_ERR(ddata->vusb))\n\t\treturn PTR_ERR(ddata->vusb);\n\n\terror = regulator_enable(ddata->vusb);\n\tif (error)\n\t\treturn error;\n\n\tgeneric_phy = devm_phy_create(ddata->dev, NULL, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\terror = PTR_ERR(generic_phy);\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, ddata);\n\n\tphy_provider = devm_of_phy_provider_register(ddata->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\terror = cpcap_usb_init_optional_pins(ddata);\n	f
47876	984	cow_file_range	fs/btrfs/inode.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 alloc_hint = 0;\n\tu64 num_bytes;\n\tunsigned long ram_size;\n\tu64 disk_num_bytes;\n\tu64 cur_alloc_size = 0;\n\tu64 blocksize = fs_info->sectorsize;\n\tstruct btrfs_key ins;\n\tstruct extent_map *em;\n\tunsigned clear_bits;\n\tunsigned long page_ops;\n\tbool extent_reserved = false;\n\tint ret = 0;\n\n\tif (btrfs_is_free_space_inode(BTRFS_I(inode))) {\n\t\tWARN_ON_ONCE(1);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tnum_bytes = ALIGN(end - start + 1, blocksize);\n\tnum_bytes = max(blocksize,  num_bytes);\n\tdisk_num_bytes = num_bytes;\n\n\tinode_should_defrag(BTRFS_I(inode), start, end, num_bytes, SZ_64K);\n\n\tif (start == 0) {\n\t\t/* lets try to make an inline extent */\n\t\tret = cow_file_range_inline(root, inode, start, end, 0,\n\t\t\t\t\tBTRFS_COMPRESS_NONE, NULL);\n\t\tif (ret == 0) {\n	f
44522	323	mpu3050_read_raw	drivers/iio/gyro/mpu3050-core.c	ret	1	11	\N	\N	\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tint ret;\n\t__be16 raw_val;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t/* The temperature scaling is (x+23000)/280 Celsius */\n\t\t\t*val = 23000;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = mpu3050->calibration[chan->scan_index-1];\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = mpu3050_get_freq(mpu3050);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t/* Millidegrees, see about temperature scaling above */\n\t\t\t*val = 1000;\n\t\t\t*val2 = 280;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_ANGL_VEL:\n\t\t\t/*\n\t\t\t * Convert to the corresponding full scale in\n\t\t\t * radians. All 16 bits are used with sign to\n\t\t\t * span the available scale: to account for the one\n\t\t\t * missing value if we multiply by 1/S16_MAX, instead\n\t\t\t * multiply with 2/U16_MAX.\n\t\t\t */\n\t\t\t*val = mpu3050_fs_precision[mpu3050->fullscale] * 2;\n\t\t\t*val2 = U16_MAX;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\t/* Resume device */\n\t\tpm_runtime_get_sync(mpu3050->dev);\n\t\tmutex_lock(&mpu3050->lock);\n\n\t\tret = mpu3050_set_8khz_samplerate(mpu3050);\n\t\tif (ret)\n\t\t\tgoto out_read_raw_unlock;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = regmap_bulk_read(mpu3050->map, MPU3050_TEMP_H,\n\t\t\t\t\t       &raw_val, sizeof(raw_val));\n\t\t\tif (ret) {\n	f
55765	4156	receive_uuids	drivers/block/drbd/drbd_receiver.c	p_uuid	1	11	\N	\N	\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_uuids *p = pi->data;\n\tu64 *p_uuid;\n\tint i, updated_uuids = 0;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\tp_uuid = kmalloc_array(UI_EXTENDED_SIZE, sizeof(*p_uuid), GFP_NOIO);\n\tif (!p_uuid) {\n\t\tdrbd_err(device, "kmalloc of p_uuid failed\\n");\n\t\treturn false;\n\t}\n\n\tfor (i = UI_CURRENT; i < UI_EXTENDED_SIZE; i++)\n\t\tp_uuid[i] = be64_to_cpu(p->uuid[i]);\n\n\tkfree(device->p_uuid);\n\tdevice->p_uuid = p_uuid;\n\n\tif (device->state.conn < C_CONNECTED &&\n\t    device->state.disk < D_INCONSISTENT &&\n\t    device->state.role == R_PRIMARY &&\n\t    (device->ed_uuid & ~((u64)1)) != (p_uuid[UI_CURRENT] & ~((u64)1))) {\n\t\tdrbd_err(device, "Can only connect to data with current UUID=%016llX\\n",\n\t\t    (unsigned long long)device->ed_uuid);\n\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\treturn -EIO;\n\t}\n\n\tif (get_ldev(device)) {\n\t\tint skip_initial_sync =\n\t\t\tdevice->state.conn == C_CONNECTED &&\n\t\t\tpeer_device->connection->agreed_pro_version >= 90 &&\n\t\t\tdevice->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED &&\n\t\t\t(p_uuid[UI_FLAGS] & 8);\n	t
9044	62	uwb_rc_start_beacon	drivers/uwb/beacon.c	reply.bResultCode	1	11	\N	\N	\tint result;\n\tstruct uwb_rc_cmd_start_beacon *cmd;\n\tstruct uwb_rc_evt_confirm reply;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\tcmd->rccb.bCommandType = UWB_RC_CET_GENERAL;\n\tcmd->rccb.wCommand = cpu_to_le16(UWB_RC_CMD_START_BEACON);\n\tcmd->wBPSTOffset = cpu_to_le16(bpst_offset);\n\tcmd->bChannelNumber = channel;\n\treply.rceb.bEventType = UWB_RC_CET_GENERAL;\n\treply.rceb.wEvent = UWB_RC_CMD_START_BEACON;\n\tresult = uwb_rc_cmd(rc, "START-BEACON", &cmd->rccb, sizeof(*cmd),\n\t\t\t    &reply.rceb, sizeof(reply));\n\tif (result < 0)\n\t\tgoto error_cmd;\n\tif (reply.bResultCode != UWB_RC_RES_SUCCESS) {\n	t
20703	751	radeon_uvd_send_msg	drivers/gpu/drm/radeon/radeon_uvd.c	ib.ptr	1	11	\N	\N	\tstruct radeon_ib ib;\n\tint i, r;\n\n\tr = radeon_ib_get(rdev, ring, &ib, NULL, 64);\n\tif (r)\n\t\treturn r;\n\n\tib.ptr[0] = PACKET0(UVD_GPCOM_VCPU_DATA0, 0);\n	t
58356	294	trace_event_raw_event_f2fs_unlink_enter	fs/f2fs/super.c	struct super_block *sb	1	11	\N	\N	\t/*\n\t * We do the test below only for project quotas. 'usrquota' and\n\t * 'grpquota' mount options are allowed even without quota feature\n\t * to support legacy quotas in quota files.\n\t */\n\tif (test_opt(sbi, PRJQUOTA) && !f2fs_sb_has_project_quota(sbi->sb)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, "Project quota feature not enabled. "\n\t\t\t "Cannot enable project quota enforcement.");\n\t\treturn -1;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA] ||\n\t\t\tsbi->s_qf_names[PRJQUOTA]) {\n\t\tif (test_opt(sbi, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi, USRQUOTA);\n\n\t\tif (test_opt(sbi, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi, GRPQUOTA);\n\n\t\tif (test_opt(sbi, PRJQUOTA) && sbi->s_qf_names[PRJQUOTA])\n\t\t\tclear_opt(sbi, PRJQUOTA);\n\n\t\tif (test_opt(sbi, GRPQUOTA) || test_opt(sbi, USRQUOTA) ||\n\t\t\t\ttest_opt(sbi, PRJQUOTA)) {\n\t\t\tf2fs_msg(sbi->sb, KERN_ERR, "old and new quota "\n\t\t\t\t\t"format mixing");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\tf2fs_msg(sbi->sb, KERN_ERR, "journaled quota format "\n\t\t\t\t\t"not specified");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int parse_options(struct super_block *sb, char *options)\n	t
40159	757	cxgbit_set_params	drivers/target/iscsi/cxgbit/cxgbit_target.c	erl	1	11	\N	\N	\tstruct cxgbit_sock *csk = conn->context;\n\tstruct cxgbit_device *cdev = csk->com.cdev;\n\tstruct cxgbi_ppm *ppm = *csk->com.cdev->lldi.iscsi_ppm;\n\tstruct iscsi_conn_ops *conn_ops = conn->conn_ops;\n\tstruct iscsi_param *param;\n\tu8 erl;\n\n\tif (conn_ops->MaxRecvDataSegmentLength > cdev->mdsl)\n\t\tconn_ops->MaxRecvDataSegmentLength = cdev->mdsl;\n\n\tif (conn->login->leading_connection) {\n\t\tparam = iscsi_find_param_from_key(ERRORRECOVERYLEVEL,\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tpr_err("param not found key %s\\n", ERRORRECOVERYLEVEL);\n\t\t\treturn -1;\n\t\t}\n\t\tif (kstrtou8(param->value, 0, &erl) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\terl = conn->sess->sess_ops->ErrorRecoveryLevel;\n\t}\n\n\tif (!erl) {\n	f
47703	2191	vmw_cmd_shader_define	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c	val->res	1	11	\N	\N	\tstruct vmw_shader_define_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineShader body;\n\t} *cmd;\n\tint ret;\n\tsize_t size;\n\tstruct vmw_resource_val_node *val;\n\n\tcmd = container_of(header, struct vmw_shader_define_cmd,\n\t\t\t   header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tuser_context_converter, &cmd->body.cid,\n\t\t\t\t&val);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (unlikely(!dev_priv->has_mob))\n\t\treturn 0;\n\n\tsize = cmd->header.size - sizeof(cmd->body);\n\tret = vmw_compat_shader_add(dev_priv,\n\t\t\t\t    vmw_context_res_man(val->res),\n	t
57172	291	crypto_report	crypto/crypto_user.c	skb	1	11	\N	\N	\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n	f
63160	700	llc_conn_ac_send_ack_rsp_f_set_1	net/llc/llc_c_ac.c	nskb	1	11	\N	\N	\tint rc = -ENOBUFS;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct sk_buff *nskb = llc_alloc_frame(sk, llc->dev, LLC_PDU_TYPE_S, 0);\n\n\tif (nskb) {\n\t\tstruct llc_sap *sap = llc->sap;\n\n\t\tllc_pdu_header_init(nskb, LLC_PDU_TYPE_S, sap->laddr.lsap,\n	t
51868	413	device_create_lockspace	fs/dlm/user.c	lockspace	1	11	\N	\N	\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_lockspace(params->name, NULL, params->flags,\n\t\t\t\t  DLM_USER_LVB_LEN, NULL, NULL, NULL,\n\t\t\t\t  &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n	f
57857	250	digitv_rc_query	drivers/media/usb/dvb-usb/digitv.c	key	1	11	\N	\N	\tint i;\n\tu8 key[5];\n\tu8 b[4] = { 0 };\n\n\t*event = 0;\n\t*state = REMOTE_NO_KEY_PRESSED;\n\n\tdigitv_ctrl_msg(d,USB_READ_REMOTE,0,NULL,0,&key[1],4);\n\n\t/* Tell the device we've read the remote. Not sure how necessary\n\t   this is, but the Nebula SDK does it. */\n\tdigitv_ctrl_msg(d,USB_WRITE_REMOTE,0,b,4,NULL,0);\n\n\t/* if something is inside the buffer, simulate key press */\n\tif (key[1] != 0)\n	f
62395	1250	ath10k_pci_process_htt_rx_cb	drivers/net/wireless/ath/ath10k/pci.c	skb	1	11	\N	\N	\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_pci *ar_pci = ath10k_pci_priv(ar);\n\tstruct ath10k_pci_pipe *pipe_info =  &ar_pci->pipe_info[ce_state->id];\n\tstruct ath10k_ce_pipe *ce_pipe = pipe_info->ce_hdl;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head list;\n\tvoid *transfer_context;\n\tunsigned int nbytes, max_nbytes, nentries;\n\tint orig_len;\n\n\t/* No need to aquire ce_lock for CE5, since this is the only place CE5\n\t * is processed other than init and deinit. Before releasing CE5\n\t * buffers, interrupts are disabled. Thus CE5 access is serialized.\n\t */\n\t__skb_queue_head_init(&list);\n\twhile (ath10k_ce_completed_recv_next_nolock(ce_state, &transfer_context,\n\t\t\t\t\t\t    &nbytes) == 0) {\n\t\tskb = transfer_context;\n\t\tmax_nbytes = skb->len + skb_tailroom(skb);\n	t
56374	643	cifs_get_root	fs/cifs/cifsfs.c	dir->i_mode	6	12	\N	\N	\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)\n\t\treturn dget(sb->s_root);\n\n\tfull_path = cifs_build_path_to_root(vol, cifs_sb,\n\t\t\t\tcifs_sb_master_tcon(cifs_sb), 0);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, "Get root dentry for %s\\n", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\tp = s = full_path;\n\n\tdo {\n\t\tstruct inode *dir = d_inode(dentry);\n\t\tstruct dentry *child;\n\n\t\tif (!dir) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(dir->i_mode)) {\n	t
30842	735	dmz_flush_metadata	drivers/md/dm-zoned-metadata.c	ret	1	11	\N	\N	\tstruct dmz_mblock *mblk;\n\tstruct list_head write_list;\n\tint ret;\n\n\tif (WARN_ON(!zmd))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&write_list);\n\n\t/*\n\t * Make sure that metadata blocks are stable before logging: take\n\t * the write lock on the metadata semaphore to prevent target BIOs\n\t * from modifying metadata.\n\t */\n\tdown_write(&zmd->mblk_sem);\n\n\t/*\n\t * This is called from the target flush work and reclaim work.\n\t * Concurrent execution is not allowed.\n\t */\n\tdmz_lock_flush(zmd);\n\n\t/* Get dirty blocks */\n\tspin_lock(&zmd->mblk_lock);\n\tlist_splice_init(&zmd->mblk_dirty_list, &write_list);\n\tspin_unlock(&zmd->mblk_lock);\n\n\t/* If there are no dirty metadata blocks, just flush the device cache */\n\tif (list_empty(&write_list)) {\n\t\tret = blkdev_issue_flush(zmd->dev->bdev, GFP_NOIO, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The primary metadata set is still clean. Keep it this way until\n\t * all updates are successful in the secondary set. That is, use\n\t * the secondary set as a log.\n\t */\n\tret = dmz_log_dirty_mblocks(zmd, &write_list);\n\tif (ret)\n	f
63034	1184	macsec_handle_frame	drivers/net/macsec.c	rxsc_stats->stats.InPktsUnusedSA	1	11	\N	\N	\tstruct sk_buff *skb = *pskb;\n\tstruct net_device *dev = skb->dev;\n\tstruct macsec_eth_header *hdr;\n\tstruct macsec_secy *secy = NULL;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\tstruct macsec_rxh_data *rxd;\n\tstruct macsec_dev *macsec;\n\tsci_t sci;\n\tu32 pn;\n\tbool cbit;\n\tstruct pcpu_rx_sc_stats *rxsc_stats;\n\tstruct pcpu_secy_stats *secy_stats;\n\tbool pulled_sci;\n\tint ret;\n\n\tif (skb_headroom(skb) < ETH_HLEN)\n\t\tgoto drop_direct;\n\n\thdr = macsec_ethhdr(skb);\n\tif (hdr->eth.h_proto != htons(ETH_P_MACSEC)) {\n\t\thandle_not_macsec(skb);\n\n\t\t/* and deliver to the uncontrolled port */\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\t*pskb = NULL;\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tpulled_sci = pskb_may_pull(skb, macsec_extra_len(true));\n\tif (!pulled_sci) {\n\t\tif (!pskb_may_pull(skb, macsec_extra_len(false)))\n\t\t\tgoto drop_direct;\n\t}\n\n\thdr = macsec_ethhdr(skb);\n\n\t/* Frames with a SecTAG that has the TCI E bit set but the C\n\t * bit clear are discarded, as this reserved encoding is used\n\t * to identify frames with a SecTAG that are not to be\n\t * delivered to the Controlled Port.\n\t */\n\tif ((hdr->tci_an & (MACSEC_TCI_C | MACSEC_TCI_E)) == MACSEC_TCI_E)\n\t\treturn RX_HANDLER_PASS;\n\n\t/* now, pull the extra length */\n\tif (hdr->tci_an & MACSEC_TCI_SC) {\n\t\tif (!pulled_sci)\n\t\t\tgoto drop_direct;\n\t}\n\n\t/* ethernet header is part of crypto processing */\n\tskb_push(skb, ETH_HLEN);\n\n\tmacsec_skb_cb(skb)->has_sci = !!(hdr->tci_an & MACSEC_TCI_SC);\n\tmacsec_skb_cb(skb)->assoc_num = hdr->tci_an & MACSEC_AN_MASK;\n\tsci = macsec_frame_sci(hdr, macsec_skb_cb(skb)->has_sci);\n\n\trcu_read_lock();\n\trxd = macsec_data_rcu(skb->dev);\n\n\tlist_for_each_entry_rcu(macsec, &rxd->secys, secys) {\n\t\tstruct macsec_rx_sc *sc = find_rx_sc(&macsec->secy, sci);\n\t\tsc = sc ? macsec_rxsc_get(sc) : NULL;\n\n\t\tif (sc) {\n\t\t\tsecy = &macsec->secy;\n\t\t\trx_sc = sc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!secy)\n\t\tgoto nosci;\n\n\tdev = secy->netdev;\n\tmacsec = macsec_priv(dev);\n\tsecy_stats = this_cpu_ptr(macsec->stats);\n\trxsc_stats = this_cpu_ptr(rx_sc->stats);\n\n\tif (!macsec_validate_skb(skb, secy->icv_len)) {\n\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\tsecy_stats->stats.InPktsBadTag++;\n\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\tgoto drop_nosa;\n\t}\n\n\trx_sa = macsec_rxsa_get(rx_sc->sa[macsec_skb_cb(skb)->assoc_num]);\n\tif (!rx_sa) {\n\t\t/* 10.6.1 if the SA is not in use */\n\n\t\t/* If validateFrames is Strict or the C bit in the\n\t\t * SecTAG is set, discard\n\t\t */\n\t\tif (hdr->tci_an & MACSEC_TCI_C ||\n\t\t    secy->validate_frames == MACSEC_VALIDATE_STRICT) {\n\t\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\t\trxsc_stats->stats.InPktsNotUsingSA++;\n\t\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\t\tgoto drop_nosa;\n\t\t}\n\n\t\t/* not Strict, the frame (with the SecTAG and ICV\n\t\t * removed) is delivered to the Controlled Port.\n\t\t */\n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\trxsc_stats->stats.InPktsUnusedSA++;\n	t
46612	521	dmz_flush_work	drivers/md/dm-zoned-target.c	bio	1	11	\N	\N	\tstruct dmz_target *dmz = container_of(work, struct dmz_target, flush_work.work);\n\tstruct bio *bio;\n\tint ret;\n\n\t/* Flush dirty metadata blocks */\n\tret = dmz_flush_metadata(dmz->metadata);\n\n\t/* Process queued flush requests */\n\twhile (1) {\n\t\tspin_lock(&dmz->flush_lock);\n\t\tbio = bio_list_pop(&dmz->flush_list);\n\t\tspin_unlock(&dmz->flush_lock);\n\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tdmz_bio_endio(bio, errno_to_blk_status(ret));\n	f
42823	2069	devlink_dpipe_entries_fill	net/core/devlink.c	dump_ctx.hdr	0	11	\N	\N	\tstruct devlink_dpipe_dump_ctx dump_ctx;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tdump_ctx.skb = NULL;\n\tdump_ctx.cmd = cmd;\n\tdump_ctx.info = info;\n\n\terr = table->table_ops->entries_dump(table->priv,\n\t\t\t\t\t     table->counters_enabled,\n\t\t\t\t\t     &dump_ctx);\n\tif (err)\n\t\tgoto err_entries_dump;\n\nsend_done:\n\tnlh = nlmsg_put(dump_ctx.skb, info->snd_portid, info->snd_seq,\n\t\t\tNLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = devlink_dpipe_send_and_alloc_skb(&dump_ctx.skb, info);\n\t\tif (err)\n\t\t\tgoto err_skb_send_alloc;\n\t\tgoto send_done;\n\t}\n\treturn genlmsg_reply(dump_ctx.skb, info);\n\nerr_entries_dump:\nerr_skb_send_alloc:\n\tgenlmsg_cancel(dump_ctx.skb, dump_ctx.hdr);\n	f
400	325	shmem_undo_range	mm/shmem.c	shmem_undo_range_$addr.addr.i.i$obj$0	0	11	\N	\N	\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced -= pages;\n\tinode->i_blocks -= pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tshmem_inode_unacct_blocks(inode, pages);\n}\n\n/*\n * Replace item expected in radix tree by a new item, while holding tree lock.\n */\n	t
4045	52	nfcmrvl_i2c_read	drivers/nfc/nfcmrvl/i2c.c	nci_hdr.plen	1	11	\N	\N	\tint ret;\n\tstruct nci_ctrl_hdr nci_hdr;\n\n\t/* Read NCI header to know the payload size */\n\tret = i2c_master_recv(drv_data->i2c, (u8 *)&nci_hdr, NCI_CTRL_HDR_SIZE);\n\tif (ret != NCI_CTRL_HDR_SIZE) {\n\t\tnfc_err(&drv_data->i2c->dev, "cannot read NCI header\\n");\n\t\treturn -EBADMSG;\n\t}\n\n\tif (nci_hdr.plen > NCI_MAX_PAYLOAD_SIZE) {\n	t
55188	815	gmux_probe	drivers/platform/x86/apple-gmux.c	gmux_data->gpe	1	11	\N	\N	\tstruct apple_gmux_data *gmux_data;\n\tstruct resource *res;\n\tstruct backlight_properties props;\n\tstruct backlight_device *bdev;\n\tu8 ver_major, ver_minor, ver_release;\n\tint ret = -ENXIO;\n\tacpi_status status;\n\tunsigned long long gpe;\n\tstruct pci_dev *pdev = NULL;\n\n\tif (apple_gmux_data)\n\t\treturn -EBUSY;\n\n\tgmux_data = kzalloc(sizeof(*gmux_data), GFP_KERNEL);\n\tif (!gmux_data)\n\t\treturn -ENOMEM;\n\tpnp_set_drvdata(pnp, gmux_data);\n\n\tres = pnp_get_resource(pnp, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tpr_err("Failed to find gmux I/O resource\\n");\n\t\tgoto err_free;\n\t}\n\n\tgmux_data->iostart = res->start;\n\tgmux_data->iolen = res->end - res->start;\n\n\tif (gmux_data->iolen < GMUX_MIN_IO_LEN) {\n\t\tpr_err("gmux I/O region too small (%lu < %u)\\n",\n\t\t       gmux_data->iolen, GMUX_MIN_IO_LEN);\n\t\tgoto err_free;\n\t}\n\n\tif (!request_region(gmux_data->iostart, gmux_data->iolen,\n\t\t\t    "Apple gmux")) {\n\t\tpr_err("gmux I/O already in use\\n");\n\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Invalid version information may indicate either that the gmux\n\t * device isn't present or that it's a new one that uses indexed\n\t * io\n\t */\n\n\tver_major = gmux_read8(gmux_data, GMUX_PORT_VERSION_MAJOR);\n\tver_minor = gmux_read8(gmux_data, GMUX_PORT_VERSION_MINOR);\n\tver_release = gmux_read8(gmux_data, GMUX_PORT_VERSION_RELEASE);\n\tif (ver_major == 0xff && ver_minor == 0xff && ver_release == 0xff) {\n\t\tif (gmux_is_indexed(gmux_data)) {\n\t\t\tu32 version;\n\t\t\tmutex_init(&gmux_data->index_lock);\n\t\t\tgmux_data->indexed = true;\n\t\t\tversion = gmux_read32(gmux_data,\n\t\t\t\tGMUX_PORT_VERSION_MAJOR);\n\t\t\tver_major = (version >> 24) & 0xff;\n\t\t\tver_minor = (version >> 16) & 0xff;\n\t\t\tver_release = (version >> 8) & 0xff;\n\t\t} else {\n\t\t\tpr_info("gmux device not present or IO disabled\\n");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_release;\n\t\t}\n\t}\n\tpr_info("Found gmux version %d.%d.%d [%s]\\n", ver_major, ver_minor,\n\t\tver_release, (gmux_data->indexed ? "indexed" : "classic"));\n\n\t/*\n\t * Apple systems with gmux are EFI based and normally don't use\n\t * VGA. In addition changing IO+MEM ownership between IGP and dGPU\n\t * disables IO/MEM used for backlight control on some systems.\n\t * Lock IO+MEM to GPU with active IO to prevent switch.\n\t */\n\tpdev = gmux_get_io_pdev();\n\tif (pdev && vga_tryget(pdev,\n\t\t\t       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM)) {\n\t\tpr_err("IO+MEM vgaarb-locking for PCI:%s failed\\n",\n\t\t\tpci_name(pdev));\n\t\tret = -EBUSY;\n\t\tgoto err_release;\n\t} else if (pdev)\n\t\tpr_info("locked IO for PCI:%s\\n", pci_name(pdev));\n\tgmux_data->pdev = pdev;\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = gmux_read32(gmux_data, GMUX_PORT_MAX_BRIGHTNESS);\n\n\t/*\n\t * Currently it's assumed that the maximum brightness is less than\n\t * 2^24 for compatibility with old gmux versions. Cap the max\n\t * brightness at this value, but print a warning if the hardware\n\t * reports something higher so that it can be fixed.\n\t */\n\tif (WARN_ON(props.max_brightness > GMUX_MAX_BRIGHTNESS))\n\t\tprops.max_brightness = GMUX_MAX_BRIGHTNESS;\n\n\tbdev = backlight_device_register("gmux_backlight", &pnp->dev,\n\t\t\t\t\t gmux_data, &gmux_bl_ops, &props);\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto err_release;\n\t}\n\n\tgmux_data->bdev = bdev;\n\tbdev->props.brightness = gmux_get_brightness(bdev);\n\tbacklight_update_status(bdev);\n\n\t/*\n\t * The backlight situation on Macs is complicated. If the gmux is\n\t * present it's the best choice, because it always works for\n\t * backlight control and supports more levels than other options.\n\t * Disable the other backlight choices.\n\t */\n\tacpi_video_set_dmi_backlight_type(acpi_backlight_vendor);\n\tapple_bl_unregister();\n\n\tgmux_data->power_state = VGA_SWITCHEROO_ON;\n\n\tgmux_data->dhandle = ACPI_HANDLE(&pnp->dev);\n\tif (!gmux_data->dhandle) {\n\t\tpr_err("Cannot find acpi handle for pnp device %s\\n",\n\t\t       dev_name(&pnp->dev));\n\t\tret = -ENODEV;\n\t\tgoto err_notify;\n\t}\n\n\tstatus = acpi_evaluate_integer(gmux_data->dhandle, "GMGP", NULL, &gpe);\n\tif (ACPI_SUCCESS(status)) {\n\t\tgmux_data->gpe = (int)gpe;\n\n\t\tstatus = acpi_install_notify_handler(gmux_data->dhandle,\n\t\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t\t     &gmux_notify_handler, pnp);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err("Install notify handler failed: %s\\n",\n\t\t\t       acpi_format_exception(status));\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_notify;\n\t\t}\n\n\t\tstatus = acpi_enable_gpe(NULL, gmux_data->gpe);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err("Cannot enable gpe: %s\\n",\n\t\t\t       acpi_format_exception(status));\n\t\t\tgoto err_enable_gpe;\n\t\t}\n\t} else {\n\t\tpr_warn("No GPE found for gmux\\n");\n\t\tgmux_data->gpe = -1;\n\t}\n\n\t/*\n\t * If Thunderbolt is present, the external DP port is not fully\n\t * switchable. Force its AUX channel to the discrete GPU.\n\t */\n\tgmux_data->external_switchable =\n\t\t!bus_for_each_dev(&pci_bus_type, NULL, NULL, is_thunderbolt);\n\tif (!gmux_data->external_switchable)\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 3);\n\n\tapple_gmux_data = gmux_data;\n\tinit_completion(&gmux_data->powerchange_done);\n\tgmux_enable_interrupts(gmux_data);\n\tgmux_read_switch_state(gmux_data);\n\n\t/*\n\t * Retina MacBook Pros cannot switch the panel's AUX separately\n\t * and need eDP pre-calibration. They are distinguishable from\n\t * pre-retinas by having an "indexed" gmux.\n\t *\n\t * Pre-retina MacBook Pros can switch the panel's DDC separately.\n\t */\n\tif (gmux_data->indexed)\n\t\tret = vga_switcheroo_register_handler(&gmux_handler_indexed,\n\t\t\t\t\t      VGA_SWITCHEROO_NEEDS_EDP_CONFIG);\n\telse\n\t\tret = vga_switcheroo_register_handler(&gmux_handler_classic,\n\t\t\t\t\t      VGA_SWITCHEROO_CAN_SWITCH_DDC);\n\tif (ret) {\n\t\tpr_err("Failed to register vga_switcheroo handler\\n");\n\t\tgoto err_register_handler;\n\t}\n\n\treturn 0;\n\nerr_register_handler:\n\tgmux_disable_interrupts(gmux_data);\n\tapple_gmux_data = NULL;\n\tif (gmux_data->gpe >= 0)\n	f
29968	533	do_task_stat	fs/proc/array.c	sigcatch.sig[0] & 0x7fffffffUL	1	11	\N	\N	\tunsigned long vsize, eip, esp, wchan = 0;\n\tint priority, nice;\n\tint tty_pgrp = -1, tty_nr = 0;\n\tsigset_t sigign, sigcatch;\n\tchar state;\n\tpid_t ppid = 0, pgid = -1, sid = -1;\n\tint num_threads = 0;\n\tint permitted;\n\tstruct mm_struct *mm;\n\tunsigned long long start_time;\n\tunsigned long cmin_flt = 0, cmaj_flt = 0;\n\tunsigned long  min_flt = 0,  maj_flt = 0;\n\tu64 cutime, cstime, utime, stime;\n\tu64 cgtime, gtime;\n\tunsigned long rsslim = 0;\n\tchar tcomm[sizeof(task->comm)];\n\tunsigned long flags;\n\n\tstate = *get_task_state(task);\n\tvsize = eip = esp = 0;\n\tpermitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tvsize = task_vsize(mm);\n\t\t/*\n\t\t * esp and eip are intentionally zeroed out.  There is no\n\t\t * non-racy way to read them without freezing the task.\n\t\t * Programs that need reliable values can use ptrace(2).\n\t\t *\n\t\t * The only exception is if the task is core dumping because\n\t\t * a program is not able to use ptrace(2) in that case. It is\n\t\t * safe because the task has stopped executing permanently.\n\t\t */\n\t\tif (permitted && (task->flags & PF_DUMPCORE)) {\n\t\t\teip = KSTK_EIP(task);\n\t\t\tesp = KSTK_ESP(task);\n\t\t}\n\t}\n\n\tget_task_comm(tcomm, task);\n\n\tsigemptyset(&sigign);\n\tsigemptyset(&sigcatch);\n\tcutime = cstime = utime = stime = 0;\n\tcgtime = gtime = 0;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\tstruct signal_struct *sig = task->signal;\n\n\t\tif (sig->tty) {\n\t\t\tstruct pid *pgrp = tty_get_pgrp(sig->tty);\n\t\t\ttty_pgrp = pid_nr_ns(pgrp, ns);\n\t\t\tput_pid(pgrp);\n\t\t\ttty_nr = new_encode_dev(tty_devnum(sig->tty));\n\t\t}\n\n\t\tnum_threads = get_nr_threads(task);\n\t\tcollect_sigign_sigcatch(task, &sigign, &sigcatch);\n\n\t\tcmin_flt = sig->cmin_flt;\n\t\tcmaj_flt = sig->cmaj_flt;\n\t\tcutime = sig->cutime;\n\t\tcstime = sig->cstime;\n\t\tcgtime = sig->cgtime;\n\t\trsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\n\n\t\t/* add up live thread stats at the group level */\n\t\tif (whole) {\n\t\t\tstruct task_struct *t = task;\n\t\t\tdo {\n\t\t\t\tmin_flt += t->min_flt;\n\t\t\t\tmaj_flt += t->maj_flt;\n\t\t\t\tgtime += task_gtime(t);\n\t\t\t} while_each_thread(task, t);\n\n\t\t\tmin_flt += sig->min_flt;\n\t\t\tmaj_flt += sig->maj_flt;\n\t\t\tthread_group_cputime_adjusted(task, &utime, &stime);\n\t\t\tgtime += sig->gtime;\n\t\t}\n\n\t\tsid = task_session_nr_ns(task, ns);\n\t\tppid = task_tgid_nr_ns(task->real_parent, ns);\n\t\tpgid = task_pgrp_nr_ns(task, ns);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tif (permitted && (!whole || num_threads < 2))\n\t\twchan = get_wchan(task);\n\tif (!whole) {\n\t\tmin_flt = task->min_flt;\n\t\tmaj_flt = task->maj_flt;\n\t\ttask_cputime_adjusted(task, &utime, &stime);\n\t\tgtime = task_gtime(task);\n\t}\n\n\t/* scale priority and nice values from timeslices to -20..20 */\n\t/* to make it look like a "normal" Unix priority/nice value  */\n\tpriority = task_prio(task);\n\tnice = task_nice(task);\n\n\t/* convert nsec -> ticks */\n\tstart_time = nsec_to_clock_t(task->real_start_time);\n\n\tseq_printf(m, "%d (%s) %c", pid_nr_ns(pid, ns), tcomm, state);\n\tseq_put_decimal_ll(m, " ", ppid);\n\tseq_put_decimal_ll(m, " ", pgid);\n\tseq_put_decimal_ll(m, " ", sid);\n\tseq_put_decimal_ll(m, " ", tty_nr);\n\tseq_put_decimal_ll(m, " ", tty_pgrp);\n\tseq_put_decimal_ull(m, " ", task->flags);\n\tseq_put_decimal_ull(m, " ", min_flt);\n\tseq_put_decimal_ull(m, " ", cmin_flt);\n\tseq_put_decimal_ull(m, " ", maj_flt);\n\tseq_put_decimal_ull(m, " ", cmaj_flt);\n\tseq_put_decimal_ull(m, " ", nsec_to_clock_t(utime));\n\tseq_put_decimal_ull(m, " ", nsec_to_clock_t(stime));\n\tseq_put_decimal_ll(m, " ", nsec_to_clock_t(cutime));\n\tseq_put_decimal_ll(m, " ", nsec_to_clock_t(cstime));\n\tseq_put_decimal_ll(m, " ", priority);\n\tseq_put_decimal_ll(m, " ", nice);\n\tseq_put_decimal_ll(m, " ", num_threads);\n\tseq_put_decimal_ull(m, " ", 0);\n\tseq_put_decimal_ull(m, " ", start_time);\n\tseq_put_decimal_ull(m, " ", vsize);\n\tseq_put_decimal_ull(m, " ", mm ? get_mm_rss(mm) : 0);\n\tseq_put_decimal_ull(m, " ", rsslim);\n\tseq_put_decimal_ull(m, " ", mm ? (permitted ? mm->start_code : 1) : 0);\n\tseq_put_decimal_ull(m, " ", mm ? (permitted ? mm->end_code : 1) : 0);\n\tseq_put_decimal_ull(m, " ", (permitted && mm) ? mm->start_stack : 0);\n\tseq_put_decimal_ull(m, " ", esp);\n\tseq_put_decimal_ull(m, " ", eip);\n\t/* The signal information here is obsolete.\n\t * It must be decimal for Linux 2.0 compatibility.\n\t * Use /proc/#/status for real-time signals.\n\t */\n\tseq_put_decimal_ull(m, " ", task->pending.signal.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, " ", task->blocked.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, " ", sigign.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, " ", sigcatch.sig[0] & 0x7fffffffUL);\n	f
-526	1771	get_memory_layout	drivers/edac/sb_edac.c	reg	1000	3	\N	\N	\tstruct sbridge_pvt *pvt = mci->pvt_info;\n\tint i, j, k, n_sads, n_tads, sad_interl;\n\tu32 reg;\n\tu64 limit, prv = 0;\n\tu64 tmp_mb;\n\tu32 gb, mb;\n\tu32 rir_way;\n\n\t/*\n\t * Step 1) Get TOLM/TOHM ranges\n\t */\n\n\tpvt->tolm = pvt->info.get_tolm(pvt);\n\ttmp_mb = (1 + pvt->tolm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tolm);\n\n\t/* Address range is already 45:25 */\n\tpvt->tohm = pvt->info.get_tohm(pvt);\n\ttmp_mb = (1 + pvt->tohm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tohm);\n\n\t/*\n\t * Step 2) Get SAD range and SAD Interleave list\n\t * TAD registers contain the interleave wayness. However, it\n\t * seems simpler to just discover it indirectly, with the\n\t * algorithm bellow.\n\t */\n\tprv = 0;\n\tfor (n_sads = 0; n_sads < pvt->info.max_sad; n_sads++) {\n\t\t/* SAD_LIMIT Address range is 45:26 */\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.dram_rule[n_sads],\n\t\t\t\t      &reg);\n\t\tlimit = pvt->info.sad_limit(reg);\n\n\t\tif (!DRAM_RULE_ENABLE(reg))\n	f
31191	1154	dmz_init_zones	drivers/md/dm-zoned-metadata.c	&blkz[i]	1	11	\N	\N	\tstruct dmz_dev *dev = zmd->dev;\n\tstruct dm_zone *zone;\n\tstruct blk_zone *blkz;\n\tunsigned int nr_blkz;\n\tsector_t sector = 0;\n\tint i, ret = 0;\n\n\t/* Init */\n\tzmd->zone_bitmap_size = dev->zone_nr_blocks >> 3;\n\tzmd->zone_nr_bitmap_blocks = zmd->zone_bitmap_size >> DMZ_BLOCK_SHIFT;\n\n\t/* Allocate zone array */\n\tzmd->zones = kcalloc(dev->nr_zones, sizeof(struct dm_zone), GFP_KERNEL);\n\tif (!zmd->zones)\n\t\treturn -ENOMEM;\n\n\tdmz_dev_info(dev, "Using %zu B for zone information",\n\t\t     sizeof(struct dm_zone) * dev->nr_zones);\n\n\t/* Get zone information */\n\tnr_blkz = DMZ_REPORT_NR_ZONES;\n\tblkz = kcalloc(nr_blkz, sizeof(struct blk_zone), GFP_KERNEL);\n\tif (!blkz) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get zone information and initialize zone descriptors.\n\t * At the same time, determine where the super block\n\t * should be: first block of the first randomly writable\n\t * zone.\n\t */\n\tzone = zmd->zones;\n\twhile (sector < dev->capacity) {\n\t\t/* Get zone information */\n\t\tnr_blkz = DMZ_REPORT_NR_ZONES;\n\t\tret = blkdev_report_zones(dev->bdev, sector, blkz,\n\t\t\t\t\t  &nr_blkz, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdmz_dev_err(dev, "Report zones failed %d", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Process report */\n\t\tfor (i = 0; i < nr_blkz; i++) {\n\t\t\tret = dmz_init_zone(zmd, zone, &blkz[i]);\n	f
41273	1642	dmz_get_chunk_mapping	drivers/md/dm-zoned-metadata.c	ret	1	11	\N	\N	\tstruct dmz_mblock *dmap_mblk = zmd->map_mblk[chunk >> DMZ_MAP_ENTRIES_SHIFT];\n\tstruct dmz_map *dmap = (struct dmz_map *) dmap_mblk->data;\n\tint dmap_idx = chunk & DMZ_MAP_ENTRIES_MASK;\n\tunsigned int dzone_id;\n\tstruct dm_zone *dzone = NULL;\n\tint ret = 0;\n\n\tdmz_lock_map(zmd);\nagain:\n\t/* Get the chunk mapping */\n\tdzone_id = le32_to_cpu(dmap[dmap_idx].dzone_id);\n\tif (dzone_id == DMZ_MAP_UNMAPPED) {\n\t\t/*\n\t\t * Read or discard in unmapped chunks are fine. But for\n\t\t * writes, we need a mapping, so get one.\n\t\t */\n\t\tif (op != REQ_OP_WRITE)\n\t\t\tgoto out;\n\n\t\t/* Alloate a random zone */\n\t\tdzone = dmz_alloc_zone(zmd, DMZ_ALLOC_RND);\n\t\tif (!dzone) {\n\t\t\tdmz_wait_for_free_zones(zmd);\n\t\t\tgoto again;\n\t\t}\n\n\t\tdmz_map_zone(zmd, dzone, chunk);\n\n\t} else {\n\t\t/* The chunk is already mapped: get the mapping zone */\n\t\tdzone = dmz_get(zmd, dzone_id);\n\t\tif (dzone->chunk != chunk) {\n\t\t\tdzone = ERR_PTR(-EIO);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Repair write pointer if the sequential dzone has error */\n\t\tif (dmz_seq_write_err(dzone)) {\n\t\t\tret = dmz_handle_seq_write_err(zmd, dzone);\n\t\t\tif (ret) {\n	f
43849	3380	drbd_sync_handshake	drivers/block/drbd/drbd_receiver.c	rule_nr	1	11	\N	\N	\tstruct drbd_device *device = peer_device->device;\n\tenum drbd_conns rv = C_MASK;\n\tenum drbd_disk_state mydisk;\n\tstruct net_conf *nc;\n\tint hg, rule_nr, rr_conflict, tentative;\n\n\tmydisk = device->state.disk;\n\tif (mydisk == D_NEGOTIATING)\n\t\tmydisk = device->new_state_tmp.disk;\n\n\tdrbd_info(device, "drbd_sync_handshake:\\n");\n\n\tspin_lock_irq(&device->ldev->md.uuid_lock);\n\tdrbd_uuid_dump(device, "self", device->ldev->md.uuid, device->comm_bm_set, 0);\n\tdrbd_uuid_dump(device, "peer", device->p_uuid,\n\t\t       device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\n\thg = drbd_uuid_compare(device, peer_role, &rule_nr);\n\tspin_unlock_irq(&device->ldev->md.uuid_lock);\n\n\tdrbd_info(device, "uuid_compare()=%d by rule %d\\n", hg, rule_nr);\n	f
25492	837	drm_ioctl	drivers/gpu/drm/drm_ioctl.c	file_priv->authenticated	0	11	\N	\N	\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tconst struct drm_ioctl_desc *ioctl = NULL;\n\tdrm_ioctl_t *func;\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\tint retcode = -EINVAL;\n\tchar stack_kdata[128];\n\tchar *kdata = NULL;\n\tunsigned int in_size, out_size, drv_size, ksize;\n\tbool is_driver_ioctl;\n\n\tdev = file_priv->minor->dev;\n\n\tif (drm_dev_is_unplugged(dev))\n\t\treturn -ENODEV;\n\n\tis_driver_ioctl = nr >= DRM_COMMAND_BASE && nr < DRM_COMMAND_END;\n\n\tif (is_driver_ioctl) {\n\t\t/* driver ioctl */\n\t\tif (nr - DRM_COMMAND_BASE >= dev->driver->num_ioctls)\n\t\t\tgoto err_i1;\n\t\tioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];\n\t} else {\n\t\t/* core ioctl */\n\t\tif (nr >= DRM_CORE_IOCTL_COUNT)\n\t\t\tgoto err_i1;\n\t\tioctl = &drm_ioctls[nr];\n\t}\n\n\tdrv_size = _IOC_SIZE(ioctl->cmd);\n\tout_size = in_size = _IOC_SIZE(cmd);\n\tif ((cmd & ioctl->cmd & IOC_IN) == 0)\n\t\tin_size = 0;\n\tif ((cmd & ioctl->cmd & IOC_OUT) == 0)\n\t\tout_size = 0;\n\tksize = max(max(in_size, out_size), drv_size);\n\n\tDRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\\n",\n\t\t  task_pid_nr(current),\n\t\t  (long)old_encode_dev(file_priv->minor->kdev->devt),\n\t\t  file_priv->authenticated, ioctl->name);\n\n\t/* Do not trust userspace, use our own definition */\n\tfunc = ioctl->func;\n\n\tif (unlikely(!func)) {\n\t\tDRM_DEBUG("no function\\n");\n\t\tretcode = -EINVAL;\n\t\tgoto err_i1;\n\t}\n\n\tif (ksize <= sizeof(stack_kdata)) {\n\t\tkdata = stack_kdata;\n\t} else {\n\t\tkdata = kmalloc(ksize, GFP_KERNEL);\n\t\tif (!kdata) {\n\t\t\tretcode = -ENOMEM;\n\t\t\tgoto err_i1;\n\t\t}\n\t}\n\n\tif (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {\n\t\tretcode = -EFAULT;\n\t\tgoto err_i1;\n\t}\n\n\tif (ksize > in_size)\n\t\tmemset(kdata + in_size, 0, ksize - in_size);\n\n\tretcode = drm_ioctl_kernel(filp, func, kdata, ioctl->flags);\n\tif (copy_to_user((void __user *)arg, kdata, out_size) != 0)\n\t\tretcode = -EFAULT;\n\n      err_i1:\n\tif (!ioctl)\n\t\tDRM_DEBUG("invalid ioctl: pid=%d, dev=0x%lx, auth=%d, cmd=0x%02x, nr=0x%02x\\n",\n	f
31158	5655	do_md_run	drivers/md/md.c	mddev	1	-1	\N	also, field-sensitivity	\tint err;\n\n\terr = md_run(mddev);\n\tif (err)\n\t\tgoto out;\n\terr = bitmap_load(mddev);\n	f
20402	65	trace_event_raw_event_percpu_alloc_percpu_fail	mm/percpu.c	fmt	0	11	\N	\N	\N	t
27673	194	efi_runtime_get_variable	drivers/firmware/efi/test/efi_test.c	vd	1	13	\N	\N	\tstruct efi_getvariable __user *getvariable_user;\n\tstruct efi_getvariable getvariable;\n\tunsigned long datasize = 0, prev_datasize, *dz;\n\tefi_guid_t vendor_guid, *vd = NULL;\n\tefi_status_t status;\n\tefi_char16_t *name = NULL;\n\tu32 attr, *at;\n\tvoid *data = NULL;\n\tint rv = 0;\n\n\tgetvariable_user = (struct efi_getvariable __user *)arg;\n\n\tif (copy_from_user(&getvariable, getvariable_user,\n\t\t\t   sizeof(getvariable)))\n\t\treturn -EFAULT;\n\tif (getvariable.data_size &&\n\t    get_user(datasize, getvariable.data_size))\n\t\treturn -EFAULT;\n\tif (getvariable.vendor_guid) {\n\t\tif (copy_from_user(&vendor_guid, getvariable.vendor_guid,\n\t\t\t\t\tsizeof(vendor_guid)))\n\t\t\treturn -EFAULT;\n\t\tvd = &vendor_guid;\n\t}\n\n\tif (getvariable.variable_name) {\n\t\trv = copy_ucs2_from_user(&name, getvariable.variable_name);\n\t\tif (rv)\n\t\t\treturn rv;\n\t}\n\n\tat = getvariable.attributes ? &attr : NULL;\n\tdz = getvariable.data_size ? &datasize : NULL;\n\n\tif (getvariable.data_size && getvariable.data) {\n\t\tdata = kmalloc(datasize, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tkfree(name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tprev_datasize = datasize;\n\tstatus = efi.get_variable(name, vd, at, dz, data);\n	f
56395	149	active_show	drivers/char/tpm/tpm-sysfs.c	active_show_$cap$0$obj$icmp$0$xor$-1	0	-11	\N	\N	\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(to_tpm_chip(dev), TPM_CAP_FLAG_PERM, &cap,\n\t\t\t"attempting to determine the permanent active state",\n\t\t\tsizeof(cap.perm_flags));\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, "%d\\n", !cap.perm_flags.deactivated);\n	f
39827	2674	dump_sp	net/key/af_key.c	dump_sp_$out_hdr$obj	0	11	\N	\N	\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n	f
56739	272	e2i_init	drivers/input/touchscreen/usbtouchscreen.c	ret	1	11	\N	\N	\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t                      0x01, 0x02, 0x0000, 0x0081,\n\t                      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\n\tdev_dbg(&usbtouch->interface->dev,\n	f
62568	256	e1000e_systim_overflow_work	drivers/net/ethernet/intel/e1000e/ptp.c	e1000e_systim_overflow_work_$ts$0$obj	0	11	\N	\N	\tstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\n\t\t\t\t\t\t     systim_overflow_work.work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct timespec64 ts;\n\n\tadapter->ptp_clock_info.gettime64(&adapter->ptp_clock_info, &ts);\n\n\te_dbg("SYSTIM overflow check at %lld.%09lu\\n",\n	f
29809	1766	e1000e_phy_has_link_generic	drivers/net/ethernet/intel/e1000e/phy.c	phy_status	1	11	\N	\N	\ts32 ret_val = 0;\n\tu16 i, phy_status;\n\n\tfor (i = 0; i < iterations; i++) {\n\t\t/* Some PHYs require the MII_BMSR register to be read\n\t\t * twice due to the link bit being sticky.  No harm doing\n\t\t * it across the board.\n\t\t */\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val) {\n\t\t\t/* If the first read fails, another entity may have\n\t\t\t * ownership of the resources, wait and try again to\n\t\t\t * see if they have relinquished the resources yet.\n\t\t\t */\n\t\t\tif (usec_interval >= 1000)\n\t\t\t\tmsleep(usec_interval / 1000);\n\t\t\telse\n\t\t\t\tudelay(usec_interval);\n\t\t}\n\t\tret_val = e1e_rphy(hw, MII_BMSR, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & BMSR_LSTATUS)\n	f
32365	2598	amdgpu_vm_fini	drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c	&mapping->list	1	-11	\N	\N	\tstruct amdgpu_bo_va_mapping *mapping, *tmp;\n\tbool prt_fini_needed = !!adev->gart.gart_funcs->set_prt;\n\tint i;\n\n\tamd_sched_entity_fini(vm->entity.sched, &vm->entity);\n\n\tif (!RB_EMPTY_ROOT(&vm->va.rb_root)) {\n\t\tdev_err(adev->dev, "still active bo inside vm\\n");\n\t}\n\trbtree_postorder_for_each_entry_safe(mapping, tmp,\n\t\t\t\t\t     &vm->va.rb_root, rb) {\n\t\tlist_del(&mapping->list);\n	f
33682	1193	go7007_usb_probe	drivers/media/usb/go7007/go7007-usb.c	&data	1	11	\N	\N	\tstruct go7007 *go;\n\tstruct go7007_usb *usb;\n\tconst struct go7007_usb_board *board;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tunsigned num_i2c_devs;\n\tchar *name;\n\tint video_pipe, i, v_urb_len;\n\n\tpr_debug("probing new GO7007 USB board\\n");\n\n\tswitch (id->driver_info) {\n\tcase GO7007_BOARDID_MATRIX_II:\n\t\tname = "WIS Matrix II or compatible";\n\t\tboard = &board_matrix_ii;\n\t\tbreak;\n\tcase GO7007_BOARDID_MATRIX_RELOAD:\n\t\tname = "WIS Matrix Reloaded or compatible";\n\t\tboard = &board_matrix_reload;\n\t\tbreak;\n\tcase GO7007_BOARDID_MATRIX_REV:\n\t\tname = "WIS Matrix Revolution or compatible";\n\t\tboard = &board_matrix_revolution;\n\t\tbreak;\n\tcase GO7007_BOARDID_STAR_TREK:\n\t\tname = "WIS Star Trek or compatible";\n\t\tboard = &board_star_trek;\n\t\tbreak;\n\tcase GO7007_BOARDID_XMEN:\n\t\tname = "WIS XMen or compatible";\n\t\tboard = &board_xmen;\n\t\tbreak;\n\tcase GO7007_BOARDID_XMEN_II:\n\t\tname = "WIS XMen II or compatible";\n\t\tboard = &board_xmen;\n\t\tbreak;\n\tcase GO7007_BOARDID_XMEN_III:\n\t\tname = "WIS XMen III or compatible";\n\t\tboard = &board_xmen;\n\t\tbreak;\n\tcase GO7007_BOARDID_PX_M402U:\n\t\tname = "Plextor PX-M402U";\n\t\tboard = &board_matrix_ii;\n\t\tbreak;\n\tcase GO7007_BOARDID_PX_TV402U:\n\t\tname = "Plextor PX-TV402U (unknown tuner)";\n\t\tboard = &board_px_tv402u;\n\t\tbreak;\n\tcase GO7007_BOARDID_LIFEVIEW_LR192:\n\t\tdev_err(&intf->dev, "The Lifeview TV Walker Ultra is not supported. Sorry!\\n");\n\t\treturn -ENODEV;\n#if 0\n\t\tname = "Lifeview TV Walker Ultra";\n\t\tboard = &board_lifeview_lr192;\n#endif\n\t\tbreak;\n\tcase GO7007_BOARDID_SENSORAY_2250:\n\t\tdev_info(&intf->dev, "Sensoray 2250 found\\n");\n\t\tname = "Sensoray 2250/2251";\n\t\tboard = &board_sensoray_2250;\n\t\tbreak;\n\tcase GO7007_BOARDID_ADS_USBAV_709:\n\t\tname = "ADS Tech DVD Xpress DX2";\n\t\tboard = &board_ads_usbav_709;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&intf->dev, "unknown board ID %d!\\n",\n\t\t\t\t(unsigned int)id->driver_info);\n\t\treturn -ENODEV;\n\t}\n\n\tgo = go7007_alloc(&board->main_info, &intf->dev);\n\tif (go == NULL)\n\t\treturn -ENOMEM;\n\n\tusb = kzalloc(sizeof(struct go7007_usb), GFP_KERNEL);\n\tif (usb == NULL) {\n\t\tkfree(go);\n\t\treturn -ENOMEM;\n\t}\n\n\tusb->board = board;\n\tusb->usbdev = usbdev;\n\tusb_make_path(usbdev, go->bus_info, sizeof(go->bus_info));\n\tgo->board_id = id->driver_info;\n\tstrncpy(go->name, name, sizeof(go->name));\n\tif (board->flags & GO7007_USB_EZUSB)\n\t\tgo->hpi_ops = &go7007_usb_ezusb_hpi_ops;\n\telse\n\t\tgo->hpi_ops = &go7007_usb_onboard_hpi_ops;\n\tgo->hpi_context = usb;\n\n\t/* Allocate the URB and buffer for receiving incoming interrupts */\n\tusb->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (usb->intr_urb == NULL)\n\t\tgoto allocfail;\n\tusb->intr_urb->transfer_buffer = kmalloc(2*sizeof(u16), GFP_KERNEL);\n\tif (usb->intr_urb->transfer_buffer == NULL)\n\t\tgoto allocfail;\n\n\tif (go->board_id == GO7007_BOARDID_SENSORAY_2250)\n\t\tusb_fill_bulk_urb(usb->intr_urb, usb->usbdev,\n\t\t\tusb_rcvbulkpipe(usb->usbdev, 4),\n\t\t\tusb->intr_urb->transfer_buffer, 2*sizeof(u16),\n\t\t\tgo7007_usb_readinterrupt_complete, go);\n\telse\n\t\tusb_fill_int_urb(usb->intr_urb, usb->usbdev,\n\t\t\tusb_rcvintpipe(usb->usbdev, 4),\n\t\t\tusb->intr_urb->transfer_buffer, 2*sizeof(u16),\n\t\t\tgo7007_usb_readinterrupt_complete, go, 8);\n\tusb_set_intfdata(intf, &go->v4l2_dev);\n\n\t/* Boot the GO7007 */\n\tif (go7007_boot_encoder(go, go->board_info->flags &\n\t\t\t\t\tGO7007_BOARD_USE_ONBOARD_I2C) < 0)\n\t\tgoto allocfail;\n\n\t/* Register the EZ-USB I2C adapter, if we're using it */\n\tif (board->flags & GO7007_USB_EZUSB_I2C) {\n\t\tmemcpy(&go->i2c_adapter, &go7007_usb_adap_templ,\n\t\t\t\tsizeof(go7007_usb_adap_templ));\n\t\tmutex_init(&usb->i2c_lock);\n\t\tgo->i2c_adapter.dev.parent = go->dev;\n\t\ti2c_set_adapdata(&go->i2c_adapter, go);\n\t\tif (i2c_add_adapter(&go->i2c_adapter) < 0) {\n\t\t\tdev_err(go->dev, "error: i2c_add_adapter failed\\n");\n\t\t\tgoto allocfail;\n\t\t}\n\t\tgo->i2c_adapter_online = 1;\n\t}\n\n\t/* Pelco and Adlink reused the XMen and XMen-III vendor and product\n\t * IDs for their own incompatible designs.  We can detect XMen boards\n\t * by probing the sensor, but there is no way to probe the sensors on\n\t * the Pelco and Adlink designs so we default to the Adlink.  If it\n\t * is actually a Pelco, the user must set the assume_endura module\n\t * parameter. */\n\tif ((go->board_id == GO7007_BOARDID_XMEN ||\n\t\t\t\tgo->board_id == GO7007_BOARDID_XMEN_III) &&\n\t\t\tgo->i2c_adapter_online) {\n\t\tunion i2c_smbus_data data;\n\n\t\t/* Check to see if register 0x0A is 0x76 */\n\t\ti2c_smbus_xfer(&go->i2c_adapter, 0x21, I2C_CLIENT_SCCB,\n	f
45378	61	dwc3_of_simple_clk_init	drivers/usb/dwc3/dwc3-of-simple.c	simple->clks[i]	1	11	\N	\N	\tstruct device\t\t*dev = simple->dev;\n\tstruct device_node\t*np = dev->of_node;\n\tint\t\t\ti;\n\n\tsimple->num_clocks = count;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsimple->clks = devm_kcalloc(dev, simple->num_clocks,\n\t\t\tsizeof(struct clk *), GFP_KERNEL);\n\tif (!simple->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < simple->num_clocks; i++) {\n\t\tstruct clk\t*clk;\n\t\tint\t\tret;\n\n\t\tclk = of_clk_get(np, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_put(simple->clks[i]);\n	f
39067	1039	ms_lib_process_bootblock	drivers/usb/storage/ene_ub6250.c	phyblk	0	11	\N	\N	\tstruct ms_bootblock_sysent *SysEntry;\n\tstruct ms_bootblock_sysinf *SysInfo;\n\tu32 i, result;\n\tu8 PageNumber;\n\tu8 *PageBuffer;\n\tstruct ms_lib_type_extdat ExtraData;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n\tif (PageBuffer == NULL)\n\t\treturn (u32)-1;\n\n\tresult = (u32)-1;\n\n\tSysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);\n\n\tif ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||\n\t\t(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||\n\t\t((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||\n\t\t(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||\n\t\t(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||\n\t\t(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||\n\t\t(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))\n\t\tgoto exit;\n\t\t/* */\n\tswitch (info->MS_Lib.cardType = SysInfo->bCardType) {\n\tcase MS_SYSINF_CARDTYPE_RDONLY:\n\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_RDWR:\n\t\tms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_HYBRID:\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tinfo->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);\n\tinfo->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);\n\tinfo->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;\n\tinfo->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;\n\tinfo->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\tinfo->MS_Model = be16_to_cpu(SysInfo->wMemorySize);\n\n\t/*Allocate to all number of logicalblock and physicalblock */\n\tif (ms_lib_alloc_logicalmap(us))\n\t\tgoto exit;\n\n\t/* Mark the book block */\n\tms_lib_set_bootblockmark(us, PhyBlock);\n\n\tSysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);\n\n\tfor (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {\n\t\tu32  EntryOffset, EntrySize;\n\n\t\tEntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);\n\n\t\tif (EntryOffset == 0xffffff)\n\t\t\tcontinue;\n\t\tEntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);\n\n\t\tif (EntrySize == 0)\n\t\t\tcontinue;\n\n\t\tif (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)\n\t\t\tcontinue;\n\n\t\tif (i == 0) {\n\t\t\tu8 PrevPageNumber = 0;\n\t\t\tu16 phyblk;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)\n\t\t\t\tgoto exit;\n\n\t\t\twhile (EntrySize > 0) {\n\n\t\t\t\tPageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);\n\t\t\t\tif (PageNumber != PrevPageNumber) {\n\t\t\t\t\tswitch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {\n\t\t\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tPrevPageNumber = PageNumber;\n\t\t\t\t}\n\n\t\t\t\tphyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));\n\t\t\t\tif (phyblk < 0x0fff)\n	f
41858	332	cros_ec_create_panicinfo	drivers/platform/chrome/cros_ec_debugfs.c	msg	2	-11	\N	\N	\tstruct cros_ec_device *ec_dev = debug_info->ec->ec_dev;\n\tint ret;\n\tstruct cros_ec_command *msg;\n\tint insize;\n\n\tinsize = ec_dev->max_response;\n\n\tmsg = devm_kzalloc(debug_info->ec->dev,\n\t\t\tsizeof(*msg) + insize, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_GET_PANIC_INFO;\n\tmsg->insize = insize;\n\n\tret = cros_ec_cmd_xfer(ec_dev, msg);\n	t
56069	288	batadv_v_elp_periodic_work	net/batman-adv/bat_v_elp.c	skb	1	-11	\N	\N	\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_hard_iface_bat_v *bat_v;\n\tstruct batadv_elp_packet *elp_packet;\n\tstruct batadv_priv *bat_priv;\n\tstruct sk_buff *skb;\n\tu32 elp_interval;\n\n\tbat_v = container_of(work, struct batadv_hard_iface_bat_v, elp_wq.work);\n\thard_iface = container_of(bat_v, struct batadv_hard_iface, bat_v);\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\n\t\tgoto out;\n\n\t/* we are in the process of shutting this interface down */\n\tif ((hard_iface->if_status == BATADV_IF_NOT_IN_USE) ||\n\t    (hard_iface->if_status == BATADV_IF_TO_BE_REMOVED))\n\t\tgoto out;\n\n\t/* the interface was enabled but may not be ready yet */\n\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\tgoto restart_timer;\n\n\tskb = skb_copy(hard_iface->bat_v.elp_skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto restart_timer;\n\n\telp_packet = (struct batadv_elp_packet *)skb->data;\n\telp_packet->seqno = htonl(atomic_read(&hard_iface->bat_v.elp_seqno));\n\telp_interval = atomic_read(&hard_iface->bat_v.elp_interval);\n\telp_packet->elp_interval = htonl(elp_interval);\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   "Sending broadcast ELP packet on interface %s, seqno %u\\n",\n\t\t   hard_iface->net_dev->name,\n\t\t   atomic_read(&hard_iface->bat_v.elp_seqno));\n\n\tbatadv_send_broadcast_skb(skb, hard_iface);\n	f
883	748	bq2415x_set_mode	drivers/power/supply/bq2415x_charger.c	ret	2	-11	\N	\N	\tint ret = 0;\n\tint charger = 0;\n\tint boost = 0;\n\n\tif (mode == BQ2415X_MODE_BOOST)\n\t\tboost = 1;\n\telse if (mode != BQ2415X_MODE_OFF)\n\t\tcharger = 1;\n\n\tif (!charger)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\n\n\tif (!boost)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\n\n\tif (ret < 0)\n	t
23939	571	igmpv3_send_report	net/ipv4/igmp.c	skb	1	11	\N	\N	\tstruct sk_buff *skb = NULL;\n\tstruct net *net = dev_net(in_dev->dev);\n\tint type;\n\n\tif (!pmc) {\n\t\trcu_read_lock();\n\t\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\t\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\t\t\tcontinue;\n\t\t\tif (ipv4_is_local_multicast(pmc->multiaddr) &&\n\t\t\t     !net->ipv4.sysctl_igmp_llm_reports)\n\t\t\t\tcontinue;\n\t\t\tspin_lock_bh(&pmc->lock);\n\t\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n	f
40311	65	edac_set_poll_msec	drivers/edac/edac_mc_sysfs.c	l	1	11	\N	\N	\tunsigned long l;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(val, 0, &l);\n\tif (ret)\n\t\treturn ret;\n\n\tif (l < 1000)\n	f
42201	962	edt_ft5x06_ts_probe	drivers/input/touchscreen/edt-ft5x06.c	tsdata	1	11	\N	\N	\tconst struct edt_i2c_chip_data *chip_data;\n\tstruct edt_ft5x06_ts_data *tsdata;\n\tstruct input_dev *input;\n\tunsigned long irq_flags;\n\tint error;\n\tchar fw_version[EDT_NAME_LEN];\n\n\tdev_dbg(&client->dev, "probing for EDT FT5x06 I2C\\n");\n\n\ttsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);\n\tif (!tsdata) {\n\t\tdev_err(&client->dev, "failed to allocate driver data.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tchip_data = of_device_get_match_data(&client->dev);\n\tif (!chip_data)\n\t\tchip_data = (const struct edt_i2c_chip_data *)id->driver_data;\n\tif (!chip_data || !chip_data->max_support_points) {\n\t\tdev_err(&client->dev, "invalid or missing chip data\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ttsdata->max_support_points = chip_data->max_support_points;\n\n\ttsdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t     "reset", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tsdata->reset_gpio)) {\n\t\terror = PTR_ERR(tsdata->reset_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t"Failed to request GPIO reset pin, error %d\\n", error);\n\t\treturn error;\n\t}\n\n\ttsdata->wake_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t    "wake", GPIOD_OUT_LOW);\n\tif (IS_ERR(tsdata->wake_gpio)) {\n\t\terror = PTR_ERR(tsdata->wake_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t"Failed to request GPIO wake pin, error %d\\n", error);\n\t\treturn error;\n\t}\n\n\tif (tsdata->wake_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->wake_gpio, 1);\n\t}\n\n\tif (tsdata->reset_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->reset_gpio, 0);\n\t\tmsleep(300);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input) {\n\t\tdev_err(&client->dev, "failed to allocate input device.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tsdata->mutex);\n\ttsdata->client = client;\n\ttsdata->input = input;\n\ttsdata->factory_mode = false;\n\n\terror = edt_ft5x06_ts_identify(client, tsdata, fw_version);\n\tif (error) {\n\t\tdev_err(&client->dev, "touchscreen probe failed\\n");\n\t\treturn error;\n\t}\n\n\tedt_ft5x06_ts_set_regs(tsdata);\n\tedt_ft5x06_ts_get_defaults(&client->dev, tsdata);\n\tedt_ft5x06_ts_get_parameters(tsdata);\n	f
24563	231	__btrfs_lookup_bio_sums	fs/btrfs/file-item.c	bvec.bv_page	2	-11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu64 page_bytes_left;\n\tu32 diff;\n\tint nblocks;\n\tint count = 0;\n\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn BLK_STS_RESOURCE;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc_array(nblocks,\n\t\t\t\t\tcsum_size, GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn BLK_STS_RESOURCE;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_SIZE * 8)\n\t\tpath->reada = READA_FORWARD;\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(BTRFS_I(inode))) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tpage_bytes_left = bvec.bv_len;\n\t\tif (count)\n\t\t\tgoto next;\n\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec.bv_page) + bvec.bv_offset;\n	t
27682	282	trace_event_raw_event_hfi1_sdma_user_tid_info	drivers/infiniband/hw/hfi1/trace.c	RC	1	13	\N	\N	\tunion ib_ehdrs *eh = ehdrs;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tswitch (opcode) {\n\t/* imm */\n\tcase OP(RC, SEND_LAST_WITH_IMMEDIATE):\n\tcase OP(UC, SEND_LAST_WITH_IMMEDIATE):\n\tcase OP(RC, SEND_ONLY_WITH_IMMEDIATE):\n\tcase OP(UC, SEND_ONLY_WITH_IMMEDIATE):\n\tcase OP(RC, RDMA_WRITE_LAST_WITH_IMMEDIATE):\n\tcase OP(UC, RDMA_WRITE_LAST_WITH_IMMEDIATE):\n\t\ttrace_seq_printf(p, IMM_PRN,\n\t\t\t\t be32_to_cpu(eh->imm_data));\n\t\tbreak;\n\t/* reth + imm */\n\tcase OP(RC, RDMA_WRITE_ONLY_WITH_IMMEDIATE):\n	f
52135	1780	empty_inline_dir	fs/ext4/inline.c	&iloc	1	11	\N	\N	\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tbool ret = true;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(dir, "error %d getting inode %lu block",\n\t\t\t\t err, dir->i_ino);\n\t\treturn true;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n	t
61722	587	cdc_ncm_set_dgram_size	drivers/net/usb/cdc_ncm.c	max_datagram_size	1	-11	\N	\N	\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\n\t__le16 max_datagram_size;\n\tu16 mbim_mtu;\n\tint err;\n\n\t/* set default based on descriptors */\n\tctx->max_datagram_size = clamp_t(u32, new_size,\n\t\t\t\t\t cdc_ncm_min_dgram_size(dev),\n\t\t\t\t\t CDC_NCM_MAX_DATAGRAM_SIZE);\n\n\t/* inform the device about the selected Max Datagram Size? */\n\tif (!(cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE))\n\t\tgoto out;\n\n\t/* read current mtu value from device */\n\terr = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,\n\t\t\t      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t      0, iface_no, &max_datagram_size, 2);\n\tif (err < 0) {\n\t\tdev_dbg(&dev->intf->dev, "GET_MAX_DATAGRAM_SIZE failed\\n");\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(max_datagram_size) == ctx->max_datagram_size)\n	f
41579	2140	enic_dev_wait	drivers/net/ethernet/cisco/enic/enic_main.c	done	0	11	\N	\N	\tunsigned long time;\n\tint done;\n\tint err;\n\n\tBUG_ON(in_interrupt());\n\n\terr = start(vdev, arg);\n\tif (err)\n\t\treturn err;\n\n\t/* Wait for func to complete...2 seconds max\n\t */\n\n\ttime = jiffies + (HZ * 2);\n\tdo {\n\n\t\terr = finished(vdev, &done);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (done)\n	f
-511	236	i915_gem_render_state_emit	drivers/gpu/drm/i915/i915_gem_render_state.c	ret	1000	3	\N	\N	\tstruct intel_render_state *so;\n\tint ret;\n\n\tlockdep_assert_held(&req->i915->drm.struct_mutex);\n\n\tso = req->engine->render_state;\n\tif (!so)\n\t\treturn 0;\n\n\t/* Recreate the page after shrinking */\n\tif (!so->vma->obj->mm.pages)\n\t\tso->batch_offset = -1;\n\n\tret = i915_vma_pin(so->vma, 0, 0, PIN_GLOBAL | PIN_HIGH);\n\tif (ret)\n	f
42439	2136	azx_probe	sound/pci/hda/hda_intel.c	card	2	-11	\N	\N	\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct hda_intel *hda;\n\tstruct azx *chip;\n\tbool schedule_probe;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, "Error creating card!\\n");\n\t\treturn err;\n\t}\n\n\terr = azx_create(card, pci, dev, pci_id->driver_data, &chip);\n	t
36737	667	ena_get_rxfh	drivers/net/ethernet/amazon/ena/ena_ethtool.c	ena_func	2	-11	\N	\N	\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tenum ena_admin_hash_functions ena_func;\n\tu8 func;\n\tint rc;\n\n\trc = ena_com_indirect_table_get(adapter->ena_dev, indir);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ena_com_get_hash_function(adapter->ena_dev, &ena_func, key);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (ena_func) {\n	f
24279	3429	exit_robust_list	kernel/futex.c	entry	1	11	\N	\N	\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tunsigned long futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != &head->list) {\n	f
30059	168	em28xx_write_regs_req	drivers/media/usb/em28xx/em28xx-core.c	ret	1	11	\N	\N	\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint pipe = usb_sndctrlpipe(udev, 0);\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif ((len < 1) || (len > URB_MAX_CTRL_SIZE))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->ctrl_urb_lock);\n\tmemcpy(dev->urb_buf, buf, len);\n\tret = usb_control_msg(udev, pipe, req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x0000, reg, dev->urb_buf, len, HZ);\n\tmutex_unlock(&dev->ctrl_urb_lock);\n\n\tif (ret < 0) {\n	f
53092	294	bfad_debugfs_write_regrd	drivers/scsi/bfa/bfad_debugfs.c	len	1	11	\N	\N	\tstruct bfad_debug_info *regrd_debug = file->private_data;\n\tstruct bfad_port_s *port = (struct bfad_port_s *)regrd_debug->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfa_s *bfa = &bfad->bfa;\n\tstruct bfa_ioc_s *ioc = &bfa->ioc;\n\tint addr, len, rc, i;\n\tu32 *regbuf;\n\tvoid __iomem *rb, *reg_addr;\n\tunsigned long flags;\n\tvoid *kern_buf;\n\n\tkern_buf = memdup_user(buf, nbytes);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trc = sscanf(kern_buf, "%x:%x", &addr, &len);\n\tif (rc < 2) {\n\t\tprintk(KERN_INFO\n\t\t\t"bfad[%d]: %s failed to read user buf\\n",\n\t\t\tbfad->inst_no, __func__);\n\t\tkfree(kern_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(kern_buf);\n\tkfree(bfad->regdata);\n\tbfad->regdata = NULL;\n\tbfad->reglen = 0;\n\n\tbfad->regdata = kzalloc(len << 2, GFP_KERNEL);\n\tif (!bfad->regdata) {\n\t\tprintk(KERN_INFO "bfad[%d]: Failed to allocate regrd buffer\\n",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tbfad->reglen = len << 2;\n\trb = bfa_ioc_bar0(ioc);\n\taddr &= BFA_REG_ADDRMSK(ioc);\n\n\t/* offset and len sanity check */\n\trc = bfad_reg_offset_check(bfa, addr, len);\n	f
50576	5890	efx_ef10_mtd_probe_partition	drivers/net/ethernet/sfc/ef10.c	outlen	1	11	\N	\N	\tMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_METADATA_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_METADATA_OUT_LENMAX);\n\tconst struct efx_ef10_nvram_type_info *info;\n\tsize_t size, erase_size, outlen;\n\tbool protected;\n\tint rc;\n\n\tfor (info = efx_ef10_nvram_types; ; info++) {\n\t\tif (info ==\n\t\t    efx_ef10_nvram_types + ARRAY_SIZE(efx_ef10_nvram_types))\n\t\t\treturn -ENODEV;\n\t\tif ((type & ~info->type_mask) == info->type)\n\t\t\tbreak;\n\t}\n\tif (info->port != efx_port_num(efx))\n\t\treturn -ENODEV;\n\n\trc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);\n\tif (rc)\n\t\treturn rc;\n\tif (protected)\n\t\treturn -ENODEV; /* hide it */\n\n\tpart->nvram_type = type;\n\n\tMCDI_SET_DWORD(inbuf, NVRAM_METADATA_IN_TYPE, type);\n\trc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_METADATA, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\treturn rc;\n\tif (outlen < MC_CMD_NVRAM_METADATA_OUT_LENMIN)\n	f
41225	213	mdio_mux_iproc_probe	drivers/net/phy/mdio-mux-bcm-iproc.c	bus	1	11	\N	\N	\tstruct iproc_mdiomux_desc *md;\n\tstruct mii_bus *bus;\n\tstruct resource *res;\n\tint rc;\n\n\tmd = devm_kzalloc(&pdev->dev, sizeof(*md), GFP_KERNEL);\n\tif (!md)\n\t\treturn -ENOMEM;\n\tmd->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tmd->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(md->base)) {\n\t\tdev_err(&pdev->dev, "failed to ioremap register\\n");\n\t\treturn PTR_ERR(md->base);\n\t}\n\n\tmd->mii_bus = mdiobus_alloc();\n\tif (!md->mii_bus) {\n\t\tdev_err(&pdev->dev, "mdiomux bus alloc failed\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tbus = md->mii_bus;\n\tbus->priv = md;\n\tbus->name = "iProc MDIO mux bus";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d", pdev->name, pdev->id);\n\tbus->parent = &pdev->dev;\n\tbus->read = iproc_mdiomux_read;\n\tbus->write = iproc_mdiomux_write;\n\n\tbus->phy_mask = ~0;\n\tbus->dev.of_node = pdev->dev.of_node;\n\trc = mdiobus_register(bus);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, "mdiomux registration failed\\n");\n\t\tgoto out;\n\t}\n\n\tplatform_set_drvdata(pdev, md);\n\n\trc = mdio_mux_init(md->dev, md->dev->of_node, mdio_mux_iproc_switch_fn,\n\t\t\t   &md->mux_handle, md, md->mii_bus);\n\tif (rc) {\n\t\tdev_info(md->dev, "mdiomux initialization failed\\n");\n\t\tgoto out_register;\n\t}\n\n\tdev_info(md->dev, "iProc mdiomux registered\\n");\n\treturn 0;\n\nout_register:\n\tmdiobus_unregister(bus);\n	f
31959	158	gk20a_gr_av_to_method	drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c	gk20a_gr_av_to_method_$av$obj	0	-11	\N	\N	\tstruct gf100_gr_fuc fuc;\n\tstruct gf100_gr_init *init;\n\tstruct gf100_gr_pack *pack;\n\t/* We don't suppose we will initialize more than 16 classes here... */\n\tstatic const unsigned int max_classes = 16;\n\tu32 classidx = 0, prevclass = 0;\n\tint nent;\n\tint ret;\n\tint i;\n\n\tret = gf100_gr_ctor_fw(gr, fw_name, &fuc);\n\tif (ret)\n\t\treturn ret;\n\n\tnent = (fuc.size / sizeof(struct gk20a_fw_av));\n\n\tpack = vzalloc((sizeof(*pack) * max_classes) +\n\t\t       (sizeof(*init) * (nent + 1)));\n\tif (!pack) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tinit = (void *)(pack + max_classes);\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct gf100_gr_init *ent = &init[i];\n\t\tstruct gk20a_fw_av *av = &((struct gk20a_fw_av *)fuc.data)[i];\n\t\tu32 class = av->addr & 0xffff;\n	f
1527	631	irlan_get_provider_info	drivers/staging/irda/net/irlan/irlan_common.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\t__u8 *frame;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\n\n\tskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER,\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t/* Reserve space for TTP, LMP, and LAP header */\n\tskb_reserve(skb, self->client.max_header_size);\n	t
56183	278	ext4_evict_inode	fs/ext4/inode.c	inode->i_blocks	1	11	\N	\N	\thandle_t *handle;\n\tint err;\n\tint extra_credits = 3;\n\tstruct ext4_xattr_inode_array *ea_inode_array = NULL;\n\n\ttrace_ext4_evict_inode(inode);\n\n\tif (inode->i_nlink) {\n\t\t/*\n\t\t * When journalling data dirty buffers are tracked only in the\n\t\t * journal. So although mm thinks everything is clean and\n\t\t * ready for reaping the inode might still have some pages to\n\t\t * write in the running transaction or waiting to be\n\t\t * checkpointed. Thus calling jbd2_journal_invalidatepage()\n\t\t * (via truncate_inode_pages()) to discard these buffers can\n\t\t * cause data loss. Also even if we did not discard these\n\t\t * buffers, we would have no way to find them after the inode\n\t\t * is reaped and thus user could see stale data if he tries to\n\t\t * read them before the transaction is checkpointed. So be\n\t\t * careful and force everything to disk here... We use\n\t\t * ei->i_datasync_tid to store the newest transaction\n\t\t * containing inode's data.\n\t\t *\n\t\t * Note that directories do not have this problem because they\n\t\t * don't use page cache.\n\t\t */\n\t\tif (inode->i_ino != EXT4_JOURNAL_INO &&\n\t\t    ext4_should_journal_data(inode) &&\n\t\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t\t    inode->i_data.nrpages) {\n\t\t\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\t\t\ttid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n\n\t\t\tjbd2_complete_transaction(journal, commit_tid);\n\t\t\tfilemap_write_and_wait(&inode->i_data);\n\t\t}\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\tgoto no_delete;\n\t}\n\n\tif (is_bad_inode(inode))\n\t\tgoto no_delete;\n\tdquot_initialize(inode);\n\n\tif (ext4_should_order_data(inode))\n\t\text4_begin_ordered_truncate(inode, 0);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/*\n\t * Protect us against freezing - iput() caller didn't have to have any\n\t * protection against it\n\t */\n\tsb_start_intwrite(inode->i_sb);\n\n\tif (!IS_NOQUOTA(inode))\n\t\textra_credits += EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE,\n\t\t\t\t ext4_blocks_for_truncate(inode)+extra_credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text4_orphan_del(NULL, inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\t/*\n\t * Set inode->i_size to 0 before calling ext4_truncate(). We need\n\t * special handling of symlinks here because i_size is used to\n\t * determine whether ext4_inode_info->i_data contains symlink data or\n\t * block mappings. Setting i_size to 0 will remove its fast symlink\n\t * status. Erase i_data so that it becomes a valid empty block map.\n\t */\n\tif (ext4_inode_is_fast_symlink(inode))\n\t\tmemset(EXT4_I(inode)->i_data, 0, sizeof(EXT4_I(inode)->i_data));\n\tinode->i_size = 0;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     "couldn't mark inode dirty (err %d)", err);\n\t\tgoto stop_handle;\n\t}\n\tif (inode->i_blocks) {\n	f
41435	1265	minstrel_ht_update_caps	net/mac80211/rc80211_minstrel_ht.c	mi	0	11	\N	\N	\tstruct minstrel_priv *mp = priv;\n\tstruct minstrel_ht_sta_priv *msp = priv_sta;\n\tstruct minstrel_ht_sta *mi = &msp->ht;\n\tstruct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;\n\tu16 sta_cap = sta->ht_cap.cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;\n\tstruct sta_info *sinfo = container_of(sta, struct sta_info, sta);\n\tint use_vht;\n\tint n_supported = 0;\n\tint ack_dur;\n\tint stbc;\n\tint i;\n\n\t/* fall back to the old minstrel for legacy stations */\n\tif (!sta->ht_cap.ht_supported)\n\t\tgoto use_legacy;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);\n\n#ifdef CONFIG_MAC80211_RC_MINSTREL_VHT\n\tif (vht_cap->vht_supported)\n\t\tuse_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);\n\telse\n#endif\n\tuse_vht = 0;\n\n\tmsp->is_ht = true;\n\tmemset(mi, 0, sizeof(*mi));\n\n\tmi->sta = sta;\n\tmi->last_stats_update = jiffies;\n\n\tack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);\n\tmi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);\n\tmi->overhead += ack_dur;\n\tmi->overhead_rtscts = mi->overhead + 2 * ack_dur;\n\n\tmi->avg_ampdu_len = MINSTREL_FRAC(1, 1);\n\n\t/* When using MRR, sample more on the first attempt, without delay */\n\tif (mp->has_mrr) {\n\t\tmi->sample_count = 16;\n\t\tmi->sample_wait = 0;\n\t} else {\n\t\tmi->sample_count = 8;\n\t\tmi->sample_wait = 8;\n\t}\n\tmi->sample_tries = 4;\n\n\t/* TODO tx_flags for vht - ATM the RC API is not fine-grained enough */\n\tif (!use_vht) {\n\t\tstbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>\n\t\t\tIEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tmi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;\n\n\t\tif (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\t\tmi->tx_flags |= IEEE80211_TX_CTL_LDPC;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mi->groups); i++) {\n\t\tu32 gflags = minstrel_mcs_groups[i].flags;\n\t\tint bw, nss;\n\n\t\tmi->supported[i] = 0;\n\t\tif (i == MINSTREL_CCK_GROUP) {\n\t\t\tminstrel_ht_update_cck(mp, mi, sband, sta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (gflags & IEEE80211_TX_RC_SHORT_GI) {\n\t\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\n\t\t\t\tif (!(sta_cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(sta_cap & IEEE80211_HT_CAP_SGI_20))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH &&\n\t\t    sta->bandwidth < IEEE80211_STA_RX_BW_40)\n\t\t\tcontinue;\n\n\t\tnss = minstrel_mcs_groups[i].streams;\n\n\t\t/* Mark MCS > 7 as unsupported if STA is in static SMPS mode */\n\t\tif (sta->smps_mode == IEEE80211_SMPS_STATIC && nss > 1)\n\t\t\tcontinue;\n\n\t\t/* HT rate */\n\t\tif (gflags & IEEE80211_TX_RC_MCS) {\n#ifdef CONFIG_MAC80211_RC_MINSTREL_VHT\n\t\t\tif (use_vht && minstrel_vht_only)\n\t\t\t\tcontinue;\n#endif\n\t\t\tmi->supported[i] = mcs->rx_mask[nss - 1];\n\t\t\tif (mi->supported[i])\n\t\t\t\tn_supported++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* VHT rate */\n\t\tif (!vht_cap->vht_supported ||\n\t\t    WARN_ON(!(gflags & IEEE80211_TX_RC_VHT_MCS)) ||\n\t\t    WARN_ON(gflags & IEEE80211_TX_RC_160_MHZ_WIDTH))\n\t\t\tcontinue;\n\n\t\tif (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH) {\n\t\t\tif (sta->bandwidth < IEEE80211_STA_RX_BW_80 ||\n\t\t\t    ((gflags & IEEE80211_TX_RC_SHORT_GI) &&\n\t\t\t     !(vht_cap->cap & IEEE80211_VHT_CAP_SHORT_GI_80))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = BW_40;\n\t\telse if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\tbw = BW_80;\n\t\telse\n\t\t\tbw = BW_20;\n\n\t\tmi->supported[i] = minstrel_get_valid_vht_rates(bw, nss,\n\t\t\t\tvht_cap->vht_mcs.tx_mcs_map);\n\n\t\tif (mi->supported[i])\n\t\t\tn_supported++;\n\t}\n\n\tif (!n_supported)\n\t\tgoto use_legacy;\n\n\tif (test_sta_flag(sinfo, WLAN_STA_SHORT_PREAMBLE))\n\t\tmi->cck_supported_short |= mi->cck_supported_short << 4;\n\n\t/* create an initial rate table with the lowest supported rates */\n\tminstrel_ht_update_stats(mp, mi);\n	f
31427	947	early_drop	net/netfilter/nf_conntrack_core.c	&ct_hash[hash]	2	-11	\N	\N	\tunsigned int i;\n\n\tfor (i = 0; i < NF_CT_EVICTION_RANGE; i++) {\n\t\tstruct hlist_nulls_head *ct_hash;\n\t\tunsigned int hash, hsize, drops;\n\n\t\trcu_read_lock();\n\t\tnf_conntrack_get_ht(&ct_hash, &hsize);\n\t\thash = reciprocal_scale(_hash++, hsize);\n\n\t\tdrops = early_drop_list(net, &ct_hash[hash]);\n	f
1223	121	wm8958_micd_set_rate	sound/soc/codecs/wm8994.c	sysclk	2	-11	\N	\N	\tstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint best, i, sysclk, val;\n\tbool idle;\n\tconst struct wm8958_micd_rate *rates;\n\tint num_rates;\n\n\tidle = !wm8994->jack_mic;\n\n\tsysclk = snd_soc_read(codec, WM8994_CLOCKING_1);\n\tif (sysclk & WM8994_SYSCLK_SRC)\n	t
43778	426	nf_ct_frag6_reasm	net/ipv6/netfilter/nf_conntrack_reasm.c	clone->truesize	1	11	\N	\N	\tstruct sk_buff *fp, *head = fq->q.fragments;\n\tint    payload_len;\n\tu8 ecn;\n\n\tinet_frag_kill(&fq->q, &nf_frags);\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\n\n\tecn = ip_frag_ecn_table[fq->ecn];\n\tif (unlikely(ecn == 0xff))\n\t\treturn false;\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN) {\n\t\tnet_dbg_ratelimited("nf_ct_frag6_reasm: payload len = %d\\n",\n\t\t\t\t    payload_len);\n\t\treturn false;\n\t}\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\treturn false;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (clone == NULL)\n\t\t\treturn false;\n\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\n\t\tadd_frag_mem_limit(fq->q.net, clone->truesize);\n	f
1530	705	irlan_close_data_channel	drivers/staging/irda/net/irlan/irlan_common.c	frame	1	11	\N	\N	\tstruct sk_buff *skb;\n\t__u8 *frame;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\n\n\t/* Check if the TSAP is still there */\n\tif (self->client.tsap_ctrl == NULL)\n\t\treturn;\n\n\tskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\n\t\t\tIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN"),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, self->client.max_header_size);\n\tskb_put(skb, 2);\n\n\tframe = skb->data;\n\n\t/* Build frame */\n\tframe[0] = CMD_CLOSE_DATA_CHAN;\n	t
55221	514	f2fs_listxattr	fs/f2fs/xattr.c	entry	1	-11	\N	\N	\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_xattr(entry, base_addr) {\n	f
41169	2378	f2fs_ioc_flush_device	fs/f2fs/file.c	range.dev_num	1	11	\N	\N	\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct sit_info *sm = SIT_I(sbi);\n\tunsigned int start_segno = 0, end_segno = 0;\n\tunsigned int dev_start_segno = 0, dev_end_segno = 0;\n\tstruct f2fs_flush_device range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&range, (struct f2fs_flush_device __user *)arg,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\tif (sbi->s_ndevs <= 1 || sbi->s_ndevs - 1 <= range.dev_num ||\n	f
1538	4271	b43_nphy_tx_gain_table_upload	drivers/net/wireless/broadcom/b43/phy_n.c	rf_pwr_offset_table	1	11	\N	\N	\tstruct b43_phy *phy = &dev->phy;\n\n\tconst u32 *table = NULL;\n\tu32 rfpwr_offset;\n\tu8 pga_gain, pad_gain;\n\tint i;\n\tconst s16 *uninitialized_var(rf_pwr_offset_table);\n\n\ttable = b43_nphy_get_tx_gain_table(dev);\n\tif (!table)\n\t\treturn;\n\n\tb43_ntab_write_bulk(dev, B43_NTAB32(26, 192), 128, table);\n\tb43_ntab_write_bulk(dev, B43_NTAB32(27, 192), 128, table);\n\n\tif (phy->rev < 3)\n\t\treturn;\n\n#if 0\n\tnphy->gmval = (table[0] >> 16) & 0x7000;\n#endif\n\n\tif (phy->rev >= 19) {\n\t\treturn;\n\t} else if (phy->rev >= 7) {\n\t\trf_pwr_offset_table = b43_ntab_get_rf_pwr_offset_table(dev);\n\t\tif (!rf_pwr_offset_table)\n\t\t\treturn;\n\t\t/* TODO: Enable this once we have gains configured */\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 128; i++) {\n\t\tif (phy->rev >= 19) {\n\t\t\t/* TODO */\n\t\t\treturn;\n\t\t} else if (phy->rev >= 7) {\n\t\t\tpga_gain = (table[i] >> 24) & 0xf;\n\t\t\tpad_gain = (table[i] >> 19) & 0x1f;\n\t\t\tif (b43_current_band(dev->wl) == NL80211_BAND_2GHZ)\n\t\t\t\trfpwr_offset = rf_pwr_offset_table[pad_gain];\n	t
54991	2968	ext4_lazyinit_thread	fs/ext4/super.c	err	1	11	\N	\N	\tstruct ext4_lazy_init *eli = (struct ext4_lazy_init *)arg;\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\tunsigned long next_wakeup, cur;\n\n\tBUG_ON(NULL == eli);\n\ncont_thread:\n\twhile (true) {\n\t\tnext_wakeup = MAX_JIFFY_OFFSET;\n\n\t\tmutex_lock(&eli->li_list_mtx);\n\t\tif (list_empty(&eli->li_request_list)) {\n\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\tgoto exit_thread;\n\t\t}\n\t\tlist_for_each_safe(pos, n, &eli->li_request_list) {\n\t\t\tint err = 0;\n\t\t\tint progress = 0;\n\t\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t\t lr_request);\n\n\t\t\tif (time_before(jiffies, elr->lr_next_sched)) {\n\t\t\t\tif (time_before(elr->lr_next_sched, next_wakeup))\n\t\t\t\t\tnext_wakeup = elr->lr_next_sched;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (down_read_trylock(&elr->lr_super->s_umount)) {\n\t\t\t\tif (sb_start_write_trylock(elr->lr_super)) {\n\t\t\t\t\tprogress = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * We hold sb->s_umount, sb can not\n\t\t\t\t\t * be removed from the list, it is\n\t\t\t\t\t * now safe to drop li_list_mtx\n\t\t\t\t\t */\n\t\t\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\t\t\terr = ext4_run_li_request(elr);\n\t\t\t\t\tsb_end_write(elr->lr_super);\n\t\t\t\t\tmutex_lock(&eli->li_list_mtx);\n\t\t\t\t\tn = pos->next;\n\t\t\t\t}\n\t\t\t\tup_read((&elr->lr_super->s_umount));\n\t\t\t}\n\t\t\t/* error, remove the lazy_init job */\n\t\t\tif (err) {\n	f
-506	3472	quirk_apple_poweroff_thunderbolt	drivers/pci/quirks.c	SXIO	1000	3	\N	\N	\tacpi_handle bridge, SXIO, SXFP, SXLV;\n\n\tif (!x86_apple_machine)\n\t\treturn;\n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)\n\t\treturn;\n\tbridge = ACPI_HANDLE(&dev->dev);\n\tif (!bridge)\n\t\treturn;\n\t/*\n\t * SXIO and SXLV are present only on machines requiring this quirk.\n\t * TB bridges in external devices might have the same device id as those\n\t * on the host, but they will not have the associated ACPI methods. This\n\t * implicitly checks that we are at the right bridge.\n\t */\n\tif (ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXIO", &SXIO))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXFP", &SXFP))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXLV", &SXLV)))\n\t\treturn;\n\tdev_info(&dev->dev, "quirk: cutting power to thunderbolt controller...\\n");\n\n\t/* magic sequence */\n\tacpi_execute_simple_method(SXIO, NULL, 1);\n	f
33266	1213	fault_init_opcode_debugfs	drivers/infiniband/hw/hfi1/debugfs.c	fault_init_opcode_debugfs_$ent$obj	0	11	\N	\N	\tstruct dentry *parent = ibd->hfi1_ibdev_dbg;\n\n\tibd->fault_opcode = kzalloc(sizeof(*ibd->fault_opcode), GFP_KERNEL);\n\tif (!ibd->fault_opcode)\n\t\treturn -ENOMEM;\n\n\tibd->fault_opcode->attr.interval = 1;\n\tibd->fault_opcode->attr.require_end = ULONG_MAX;\n\tibd->fault_opcode->attr.stacktrace_depth = 32;\n\tibd->fault_opcode->attr.dname = NULL;\n\tibd->fault_opcode->attr.verbose = 0;\n\tibd->fault_opcode->fault_by_opcode = false;\n\tibd->fault_opcode->opcode = 0;\n\tibd->fault_opcode->mask = 0xff;\n\n\tibd->fault_opcode->dir =\n\t\tfault_create_debugfs_attr("fault_opcode",\n\t\t\t\t\t  parent,\n\t\t\t\t\t  &ibd->fault_opcode->attr);\n\tif (IS_ERR(ibd->fault_opcode->dir)) {\n\t\tkfree(ibd->fault_opcode);\n\t\treturn -ENOENT;\n\t}\n\n\tDEBUGFS_SEQ_FILE_CREATE(fault_stats, ibd->fault_opcode->dir, ibd);\n	f
39524	159	netvsc_destroy_buf	drivers/net/hyperv/netvsc.c	ret	1	11	\N	\N	\tstruct nvsp_message *revoke_packet;\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstruct net_device_context *ndc = netdev_priv(ndev);\n\tstruct netvsc_device *net_device = rtnl_dereference(ndc->nvdev);\n\tint ret;\n\n\t/*\n\t * If we got a section count, it means we received a\n\t * SendReceiveBufferComplete msg (ie sent\n\t * NvspMessage1TypeSendReceiveBuffer msg) therefore, we need\n\t * to send a revoke msg here\n\t */\n\tif (net_device->recv_section_cnt) {\n\t\t/* Send the revoke receive buffer */\n\t\trevoke_packet = &net_device->revoke_packet;\n\t\tmemset(revoke_packet, 0, sizeof(struct nvsp_message));\n\n\t\trevoke_packet->hdr.msg_type =\n\t\t\tNVSP_MSG1_TYPE_REVOKE_RECV_BUF;\n\t\trevoke_packet->msg.v1_msg.\n\t\trevoke_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\n\n\t\tret = vmbus_sendpacket(device->channel,\n\t\t\t\t       revoke_packet,\n\t\t\t\t       sizeof(struct nvsp_message),\n\t\t\t\t       (unsigned long)revoke_packet,\n\t\t\t\t       VM_PKT_DATA_INBAND, 0);\n\t\t/* If the failure is because the channel is rescinded;\n\t\t * ignore the failure since we cannot send on a rescinded\n\t\t * channel. This would allow us to properly cleanup\n\t\t * even when the channel is rescinded.\n\t\t */\n\t\tif (device->channel->rescind)\n\t\t\tret = 0;\n\t\t/*\n\t\t * If we failed here, we might as well return and\n\t\t * have a leak rather than continue and a bugchk\n\t\t */\n\t\tif (ret != 0) {\n\t\t\tnetdev_err(ndev, "unable to send "\n\t\t\t\t"revoke receive buffer to netvsp\\n");\n\t\t\treturn;\n\t\t}\n\t\tnet_device->recv_section_cnt = 0;\n\t}\n\n\t/* Teardown the gpadl on the vsp end */\n\tif (net_device->recv_buf_gpadl_handle) {\n\t\tret = vmbus_teardown_gpadl(device->channel,\n\t\t\t\t\t   net_device->recv_buf_gpadl_handle);\n\n\t\t/* If we failed here, we might as well return and have a leak\n\t\t * rather than continue and a bugchk\n\t\t */\n\t\tif (ret != 0) {\n	f
23952	1884	fib_table_flush	net/ipv4/fib_trie.c	fib_table_flush_$____ptr55$obj	0	11	\N	\N	\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\tint found = 0;\n\n\t/* walk trie in reverse order */\n\tfor (;;) {\n\t\tunsigned char slen = 0;\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\t/* cannot resize the trie vector */\n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\t/* update the suffix to address pulled leaves */\n\t\t\tif (pn->slen > pn->pos)\n\t\t\t\tupdate_suffix(pn);\n\n\t\t\t/* resize completed node */\n\t\t\tpn = resize(t, pn);\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab the next available node */\n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t/* record pn and cindex for leaf walking */\n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n	f
39565	1163	ffs_epfile_read_iter	drivers/usb/gadget/function/f_fs.c	p	0	11	\N	\N	\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = true;\n\tp->kiocb = kiocb;\n\tif (p->aio) {\n\t\tp->to_free = dup_iter(&p->data, to, GFP_KERNEL);\n\t\tif (!p->to_free) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tp->data = *to;\n\t\tp->to_free = NULL;\n\t}\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n	f
-617	1788	unuse_pte	mm/swapfile.c	memcg	2	3	\N	\N	\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n	f
21940	168	fat_file_fsync	fs/fat/file.c	res	1	11	\N	\N	\tstruct inode *inode = filp->f_mapping->host;\n\tint res, err;\n\n\tres = generic_file_fsync(filp, start, end, datasync);\n\terr = sync_mapping_buffers(MSDOS_SB(inode->i_sb)->fat_inode->i_mapping);\n\n\treturn res ? res : err;\n	f
42147	8888	fan_write_cmd_level	drivers/platform/x86/thinkpad_acpi.c	level	1	11	\N	\N	\tint level;\n\n\tif (strlencmp(cmd, "level auto") == 0)\n\t\tlevel = TP_EC_FAN_AUTO;\n\telse if ((strlencmp(cmd, "level disengaged") == 0) |\n\t\t\t(strlencmp(cmd, "level full-speed") == 0))\n\t\tlevel = TP_EC_FAN_FULLSPEED;\n\telse if (sscanf(cmd, "level %d", &level) != 1)\n\t\treturn 0;\n\n\t*rc = fan_set_level_safe(level);\n	f
50508	1118	ffs_epfile_write_iter	drivers/usb/gadget/function/f_fs.c	p	1	11	\N	\N	\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = false;\n\tp->kiocb = kiocb;\n\tp->data = *from;\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n	f
39232	746	p54_set_groupfilter	drivers/net/wireless/intersil/p54/fwio.c	skb	1	11	\N	\N	\tstruct p54_group_address_table *grp;\n\tstruct sk_buff *skb;\n\tbool on = false;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*grp),\n\t\t\t    P54_CONTROL_TYPE_GROUP_ADDRESS_TABLE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tgrp = skb_put(skb, sizeof(*grp));\n	t
57938	399	bcd2000_probe	sound/usb/bcd2000/bcd2000.c	card->driver	1	11	\N	\N	\tstruct snd_card *card;\n\tstruct bcd2000 *bcd2k;\n\tunsigned int card_index;\n\tchar usb_path[32];\n\tint err;\n\n\tmutex_lock(&devices_mutex);\n\n\tfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index)\n\t\tif (!test_bit(card_index, devices_used))\n\t\t\tbreak;\n\n\tif (card_index >= SNDRV_CARDS) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&interface->dev, index[card_index], id[card_index],\n\t\t\tTHIS_MODULE, sizeof(*bcd2k), &card);\n\tif (err < 0) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\n\tbcd2k = card->private_data;\n\tbcd2k->dev = interface_to_usbdev(interface);\n\tbcd2k->card = card;\n\tbcd2k->card_index = card_index;\n\tbcd2k->intf = interface;\n\n\tsnd_card_set_dev(card, &interface->dev);\n\n\tstrncpy(card->driver, "snd-bcd2000", sizeof(card->driver));\n	t
24532	2412	finish_parity_scrub	fs/btrfs/raid56.c	&bio_list	1	11	\N	\N	\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing parity and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n	f
39620	9812	find_first_block_group	fs/btrfs/extent-tree.c	found_key.offset	1	11	\N	\N	\tstruct btrfs_root *root = fs_info->extent_root;\n\tint ret = 0;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid >= key->objectid &&\n\t\t    found_key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tstruct extent_map_tree *em_tree;\n\t\t\tstruct extent_map *em;\n\n\t\t\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\t\t\tread_lock(&em_tree->lock);\n\t\t\tem = lookup_extent_mapping(em_tree, found_key.objectid,\n	f
51307	969	fuse_copy_page	fs/fuse/dev.c	err	1	11	\N	\N	\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n	f
54737	2978	mwifiex_cleanup_pcie	drivers/net/wireless/marvell/mwifiex/pcie.c	fw_status	1	11	\N	\N	\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\tu32 fw_status;\n\n\tcancel_work_sync(&card->work);\n\n\tret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\tif (fw_status == FIRMWARE_READY_PCIE) {\n	f
35180	1065	efx_siena_sriov_probe	drivers/net/ethernet/sfc/siena_sriov.c	count	1	-1	\N	stack var not null	\tunsigned count;\n\n\tif (!max_vfs)\n\t\treturn;\n\n\tif (efx_siena_sriov_cmd(efx, false, &efx->vi_scale, &count)) {\n\t\tnetif_info(efx, probe, efx->net_dev, "no SR-IOV VFs probed\\n");\n\t\treturn;\n\t}\n\tif (count > 0 && count > max_vfs)\n	f
32016	1845	futex_proxy_trylock_atomic	kernel/futex.c	ret	2	-11	\N	\N	\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Find the top_waiter and determine if there are additional waiters.\n\t * If the caller intends to requeue more than 1 waiter to pifutex,\n\t * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,\n\t * as we have means to handle the possible fault.  If not, don't set\n\t * the bit unecessarily as it will force the subsequent unlock to enter\n\t * the kernel.\n\t */\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t/* There are no waiters, nothing for us to do. */\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t/* Ensure we requeue to the expected futex. */\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in\n\t * the contended case or if set_waiters is 1.  The pi_state is returned\n\t * in ps in contended cases.\n\t */\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n	f
32003	1962	end_sync_write	drivers/md/raid10.c	repl	1	-1	\N	stack address not null	\tstruct r10bio *r10_bio = get_resync_r10bio(bio);\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\tint d;\n\tsector_t first_bad;\n\tint bad_sectors;\n\tint slot;\n\tint repl;\n\tstruct md_rdev *rdev = NULL;\n\n\td = find_bio_disk(conf, r10_bio, bio, &slot, &repl);\n\tif (repl)\n	f
55211	141	fuse_listxattr	fs/fuse/xattr.c	fuse_listxattr_$__UNIQUE_ID_min1_265$obj	0	11	\N	\N	\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (fc->no_listxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.in.h.opcode = FUSE_LISTXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\t/* This is really two different operations rolled into one */\n\targs.out.numargs = 1;\n\tif (size) {\n\t\targs.out.argvar = 1;\n\t\targs.out.args[0].size = size;\n\t\targs.out.args[0].value = list;\n\t} else {\n\t\targs.out.args[0].size = sizeof(outarg);\n\t\targs.out.args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fc, &args);\n\tif (!ret && !size)\n\t\tret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX);\n	f
1601	200	i40iw_puda_ce_handler	drivers/infiniband/hw/i40iw/i40iw_hw.c	compl_error	1	11	\N	\N	\tstruct i40iw_sc_dev *dev = (struct i40iw_sc_dev *)&iwdev->sc_dev;\n\tenum i40iw_status_code status;\n\tu32 compl_error;\n\n\tdo {\n\t\tstatus = i40iw_puda_poll_completion(dev, cq, &compl_error);\n\t\tif (status == I40IW_ERR_QUEUE_EMPTY)\n\t\t\tbreak;\n\t\tif (status) {\n\t\t\ti40iw_pr_err("puda  status = %d\\n", status);\n\t\t\tbreak;\n\t\t}\n\t\tif (compl_error) {\n	t
32018	1356	futex_lock_pi_atomic	kernel/futex.c	ret	1	11	\N	\N	\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n	f
32032	2708	futex_lock_pi	kernel/futex.c	ret	1	11	\N	\N	\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n	f
49360	1138	fuse_perform_write	fs/fuse/file.c	req	1	11	\N	\N	\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n	f
1724	1417	setup_crash_devices_work_queue	drivers/staging/unisys/visorbus/visorchipset.c	&local_crash_dev_msg	1	11	\N	\N	\tstruct controlvm_message local_crash_bus_msg;\n\tstruct controlvm_message local_crash_dev_msg;\n\tstruct controlvm_message msg;\n\tu32 local_crash_msg_offset;\n\tu16 local_crash_msg_count;\n\n\t/* send init chipset msg */\n\tmsg.hdr.id = CONTROLVM_CHIPSET_INIT;\n\tmsg.cmd.init_chipset.bus_count = 23;\n\tmsg.cmd.init_chipset.switch_count = 0;\n\n\tchipset_init(&msg);\n\n\t/* get saved message count */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      offsetof(struct visor_controlvm_channel,\n\t\t\t\t       saved_crash_message_count),\n\t\t\t      &local_crash_msg_count, sizeof(u16)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\tif (local_crash_msg_count != CONTROLVM_CRASHMSG_MAX) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"invalid count\\n");\n\t\treturn;\n\t}\n\n\t/* get saved crash message offset */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      offsetof(struct visor_controlvm_channel,\n\t\t\t\t       saved_crash_message_offset),\n\t\t\t      &local_crash_msg_offset, sizeof(u32)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* read create device message for storage bus offset */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      local_crash_msg_offset,\n\t\t\t      &local_crash_bus_msg,\n\t\t\t      sizeof(struct controlvm_message)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* read create device message for storage device */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      local_crash_msg_offset +\n\t\t\t      sizeof(struct controlvm_message),\n\t\t\t      &local_crash_dev_msg,\n\t\t\t      sizeof(struct controlvm_message)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* reuse IOVM create bus message */\n\tif (!local_crash_bus_msg.cmd.create_bus.channel_addr) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"no valid create_bus message\\n");\n\t\treturn;\n\t}\n\tvisorbus_create(&local_crash_bus_msg);\n\n\t/* reuse create device message for storage device */\n\tif (!local_crash_dev_msg.cmd.create_device.channel_addr) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"no valid create_device message\\n");\n\t\treturn;\n\t}\n\tvisorbus_device_create(&local_crash_dev_msg);\n	t
55318	381	fuse_lookup	fs/fuse/dir.c	&outarg	1	11	\N	\N	\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\n\tfuse_lock_inode(dir);\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tfuse_unlock_inode(dir);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n	f
62950	1362	gfs2_mount_meta	fs/gfs2/ops_fstype.c	path.dentry->d_sb->s_bdev	1	11	\N	\N	\tstruct super_block *s;\n\tstruct gfs2_sbd *sdp;\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW, &path);\n\tif (error) {\n\t\tpr_warn("path_lookup on %s returned error %d\\n",\n\t\t\tdev_name, error);\n\t\treturn ERR_PTR(error);\n\t}\n\ts = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,\n\t\t path.dentry->d_sb->s_bdev);\n	f
63672	907	fuse_readpages	fs/fuse/file.c	data.req->num_pages	0	11	\N	\N	\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\tint nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tif (fc->async_read)\n\t\tdata.req = fuse_get_req_for_background(fc, nr_alloc);\n\telse\n\t\tdata.req = fuse_get_req(fc, nr_alloc);\n\tdata.nr_pages = nr_pages;\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n	f
32019	317	futex_wait_requeue_pi	kernel/futex.c	futex_wait_requeue_pi_$lock.addr.i$obj$0	0	-11	\N	\N	\tumode_t mode = S_IFREG | S_IRUSR | S_IWUSR;\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr("fail_futex", NULL,\n\t\t\t\t\t&fail_futex.attr);\n	f
26849	6230	generate_filter	lib/test_bpf.c	generate_filter_$fp$obj$6$obj	0	11	\N	\N	\t__u8 test_type = tests[which].aux & TEST_TYPE_MASK;\n\tunsigned int flen = filter_length(which);\n\tvoid *fptr = filter_pointer(which);\n\tstruct sock_fprog_kern fprog;\n\tstruct bpf_prog *fp;\n\n\tswitch (test_type) {\n\tcase CLASSIC:\n\t\tfprog.filter = fptr;\n\t\tfprog.len = flen;\n\n\t\t*err = bpf_prog_create(&fp, &fprog);\n\t\tif (tests[which].aux & FLAG_EXPECTED_FAIL) {\n\t\t\tif (*err == -EINVAL) {\n\t\t\t\tpr_cont("PASS\\n");\n\t\t\t\t/* Verifier rejected filter as expected. */\n\t\t\t\t*err = 0;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tpr_cont("UNEXPECTED_PASS\\n");\n\t\t\t\t/* Verifier didn't reject the test that's\n\t\t\t\t * bad enough, just return!\n\t\t\t\t */\n\t\t\t\t*err = -EINVAL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\t/* We don't expect to fail. */\n\t\tif (*err) {\n\t\t\tpr_cont("FAIL to attach err=%d len=%d\\n",\n\t\t\t\t*err, fprog.len);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\n\tcase INTERNAL:\n\t\tfp = bpf_prog_alloc(bpf_prog_size(flen), 0);\n\t\tif (fp == NULL) {\n\t\t\tpr_cont("UNEXPECTED_FAIL no memory left\\n");\n\t\t\t*err = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfp->len = flen;\n\t\t/* Type doesn't really matter here as long as it's not unspec. */\n\t\tfp->type = BPF_PROG_TYPE_SOCKET_FILTER;\n\t\tmemcpy(fp->insnsi, fptr, fp->len * sizeof(struct bpf_insn));\n\t\tfp->aux->stack_depth = tests[which].stack_depth;\n	f
54712	154	expkey_parse	fs/nfsd/export.c	&key.ek_path	1	-11	\N	\N	\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk("found domain %s\\n", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk("found fsidtype %d\\n", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk("found fsid length %d\\n", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk("Path seems to be <%s>\\n", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk("Found the path %s\\n", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n	t
25655	1043	get_raw_socket	drivers/vhost/net.c	get_raw_socket_$uaddr$0$0$obj	0	11	\N	\N	\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint uaddr_len = sizeof uaddr, r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\n\t/* Parameter checking */\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa,\n\t\t\t       &uaddr_len, 0);\n\tif (r)\n\t\tgoto err;\n\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n	f
28822	792	get_sectorsize	drivers/scsi/sr.c	get_sectorsize_$__UNIQUE_ID_min2_289$obj	0	11	\N	\N	\tunsigned char cmd[10];\n\tunsigned char buffer[8];\n\tint the_result, retries = 3;\n\tint sector_size;\n\tstruct request_queue *queue;\n\n\tdo {\n\t\tcmd[0] = READ_CAPACITY;\n\t\tmemset((void *) &cmd[1], 0, 9);\n\t\tmemset(buffer, 0, sizeof(buffer));\n\n\t\t/* Do the command and wait.. */\n\t\tthe_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,\n\t\t\t\t\t      buffer, sizeof(buffer), NULL,\n\t\t\t\t\t      SR_TIMEOUT, MAX_RETRIES, NULL);\n\n\t\tretries--;\n\n\t} while (the_result && retries);\n\n\n\tif (the_result) {\n\t\tcd->capacity = 0x1fffff;\n\t\tsector_size = 2048;\t/* A guess, just in case */\n\t} else {\n\t\tlong last_written;\n\n\t\tcd->capacity = 1 + ((buffer[0] << 24) | (buffer[1] << 16) |\n\t\t\t\t    (buffer[2] << 8) | buffer[3]);\n\t\t/*\n\t\t * READ_CAPACITY doesn't return the correct size on\n\t\t * certain UDF media.  If last_written is larger, use\n\t\t * it instead.\n\t\t *\n\t\t * http://bugzilla.kernel.org/show_bug.cgi?id=9668\n\t\t */\n\t\tif (!cdrom_get_last_written(&cd->cdi, &last_written))\n\t\t\tcd->capacity = max_t(long, cd->capacity, last_written);\n	f
50503	820	gfs2_dirty_inode	fs/gfs2/super.c	gfs2_dirty_inode_$bh$obj$5	0	11	\N	\N	\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint need_unlock = 0;\n\tint need_endtrans = 0;\n\tint ret;\n\n\tif (!(flags & (I_DIRTY_DATASYNC|I_DIRTY_SYNC)))\n\t\treturn;\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn;\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret) {\n\t\t\tfs_err(sdp, "dirty_inode: glock %d\\n", ret);\n\t\t\treturn;\n\t\t}\n\t\tneed_unlock = 1;\n\t} else if (WARN_ON_ONCE(ip->i_gl->gl_state != LM_ST_EXCLUSIVE))\n\t\treturn;\n\n\tif (current->journal_info == NULL) {\n\t\tret = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\t\tif (ret) {\n\t\t\tfs_err(sdp, "dirty_inode: gfs2_trans_begin %d\\n", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tneed_endtrans = 1;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &bh);\n\tif (ret == 0) {\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tgfs2_dinode_out(ip, bh->b_data);\n	f
38041	856	generic_load_microcode	arch/x86/kernel/cpu/microcode/intel.c	mc_header	0	11	\N	\N	\tstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\n\tu8 *ucode_ptr = data, *new_mc = NULL, *mc = NULL;\n\tint new_rev = uci->cpu_sig.rev;\n\tunsigned int leftover = size;\n\tunsigned int curr_mc_size = 0, new_mc_size = 0;\n\tunsigned int csig, cpf;\n\n\twhile (leftover) {\n\t\tstruct microcode_header_intel mc_header;\n\t\tunsigned int mc_size;\n\n\t\tif (leftover < sizeof(mc_header)) {\n\t\t\tpr_err("error! Truncated header in microcode data file\\n");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_ucode_data(&mc_header, ucode_ptr, sizeof(mc_header)))\n\t\t\tbreak;\n\n\t\tmc_size = get_totalsize(&mc_header);\n	f
38086	759	get_interrupt_interval	drivers/net/usb/pegasus.c	data	1	11	\N	TP, bug, fixed	\tu16 data;\n\tu8 interval;\n\n\tread_eprom_word(pegasus, 4, &data);\n\tinterval = data >> 8;\n\tif (pegasus->usb->speed != USB_SPEED_HIGH) {\n\t\tif (interval < 0x80) {\n	f
47736	430	beiscsi_if_get_gw	drivers/scsi/be2iscsi/be_mgmt.c	beiscsi_if_get_gw_$req$obj	0	11	\N	\N	\tstruct be_cmd_get_def_gateway_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rc;\n\n\trc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\n\t\t\t\t OPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,\n\t\t\t\t sizeof(*resp));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\treq->ip_type = ip_type;\n	t
27838	614	hfi1_vnic_bypass_rcv	drivers/infiniband/hw/hfi1/vnic_main.c	skb->data	1	13	\N	\N	\tstruct hfi1_devdata *dd = packet->rcd->dd;\n\tstruct hfi1_vnic_vport_info *vinfo = NULL;\n\tstruct hfi1_vnic_rx_queue *rxq;\n\tstruct sk_buff *skb;\n\tint l4_type, vesw_id = -1;\n\tu8 q_idx;\n\n\tl4_type = hfi1_16B_get_l4(packet->ebuf);\n\tif (likely(l4_type == OPA_16B_L4_ETHR)) {\n\t\tvesw_id = HFI1_VNIC_GET_VESWID(packet->ebuf);\n\t\tvinfo = idr_find(&dd->vnic.vesw_idr, vesw_id);\n\n\t\t/*\n\t\t * In case of invalid vesw id, count the error on\n\t\t * the first available vport.\n\t\t */\n\t\tif (unlikely(!vinfo)) {\n\t\t\tstruct hfi1_vnic_vport_info *vinfo_tmp;\n\t\t\tint id_tmp = 0;\n\n\t\t\tvinfo_tmp =  idr_get_next(&dd->vnic.vesw_idr, &id_tmp);\n\t\t\tif (vinfo_tmp) {\n\t\t\t\tspin_lock(&vport_cntr_lock);\n\t\t\t\tvinfo_tmp->stats[0].netstats.rx_nohandler++;\n\t\t\t\tspin_unlock(&vport_cntr_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(!vinfo)) {\n\t\tdd_dev_warn(dd, "vnic rcv err: l4 %d vesw id %d ctx %d\\n",\n\t\t\t    l4_type, vesw_id, packet->rcd->ctxt);\n\t\treturn;\n\t}\n\n\tq_idx = packet->rcd->vnic_q_idx;\n\trxq = &vinfo->rxq[q_idx];\n\tif (unlikely(!netif_oper_up(vinfo->netdev))) {\n\t\tvinfo->stats[q_idx].rx_drop_state++;\n\t\tskb_queue_purge(&rxq->skbq);\n\t\treturn;\n\t}\n\n\tif (unlikely(skb_queue_len(&rxq->skbq) > HFI1_VNIC_RCV_Q_SIZE)) {\n\t\tvinfo->stats[q_idx].netstats.rx_fifo_errors++;\n\t\treturn;\n\t}\n\n\tskb = netdev_alloc_skb(vinfo->netdev, packet->tlen);\n\tif (unlikely(!skb)) {\n\t\tvinfo->stats[q_idx].netstats.rx_fifo_errors++;\n\t\treturn;\n\t}\n\n\tmemcpy(skb->data, packet->ebuf, packet->tlen);\n	f
1893	203	verify_eraseblock2	drivers/mtd/tests/subpagetest.c	subpgsize	1	11	\N	\N	\tsize_t read;\n\tint err = 0, k;\n\tloff_t addr = (loff_t)ebnum * mtd->erasesize;\n\n\tfor (k = 1; k < 33; ++k) {\n\t\tif (addr + (subpgsize * k) > (loff_t)(ebnum + 1) * mtd->erasesize)\n\t\t\tbreak;\n\t\tprandom_bytes_state(&rnd_state, writebuf, subpgsize * k);\n\t\tclear_data(readbuf, subpgsize * k);\n\t\terr = mtd_read(mtd, addr, subpgsize * k, &read, readbuf);\n\t\tif (unlikely(err || read != subpgsize * k)) {\n	t
28351	1346	ib_get_eth_speed	drivers/infiniband/core/verbs.c	netdev_speed	1	11	\N	\N	\tint rc;\n\tu32 netdev_speed;\n\tstruct net_device *netdev;\n\tstruct ethtool_link_ksettings lksettings;\n\n\tif (rdma_port_get_link_layer(dev, port_num) != IB_LINK_LAYER_ETHERNET)\n\t\treturn -EINVAL;\n\n\tif (!dev->get_netdev)\n\t\treturn -EOPNOTSUPP;\n\n\tnetdev = dev->get_netdev(dev, port_num);\n\tif (!netdev)\n\t\treturn -ENODEV;\n\n\trtnl_lock();\n\trc = __ethtool_get_link_ksettings(netdev, &lksettings);\n\trtnl_unlock();\n\n\tdev_put(netdev);\n\n\tif (!rc) {\n\t\tnetdev_speed = lksettings.base.speed;\n\t} else {\n\t\tnetdev_speed = SPEED_1000;\n\t\tpr_warn("%s speed is unknown, defaulting to %d\\n", netdev->name,\n\t\t\tnetdev_speed);\n\t}\n\n\tif (netdev_speed <= SPEED_1000) {\n	f
1920	268	of_mdiobus_link_mdiodev	drivers/net/phy/mdio_bus.c	addr	2	-11	\N	\N	\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *child;\n\n\tif (dev->of_node || !bus->dev.of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(bus->dev.of_node, child) {\n\t\tint addr;\n\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0)\n	t
39266	6569	handle_invalid_guest_state	arch/x86/kvm/vmx.c	err	1	11	\N	\N	\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tenum emulation_result err = EMULATE_DONE;\n\tint ret = 1;\n\tu32 cpu_exec_ctrl;\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tcpu_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tintr_window_requested = cpu_exec_ctrl & CPU_BASED_VIRTUAL_INTR_PENDING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\terr = emulate_instruction(vcpu, EMULTYPE_NO_REEXECUTE);\n\n\t\tif (err == EMULATE_USER_EXIT) {\n	f
38606	1674	grcan_probe	drivers/net/can/grcan.c	sysid	2	-11	\N	\N	\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct resource *res;\n\tu32 sysid, ambafreq;\n\tint irq, err;\n\tvoid __iomem *base;\n\tbool txbug = true;\n\n\t/* Compare GRLIB version number with the first that does not\n\t * have the tx bug (see start_xmit)\n\t */\n\terr = of_property_read_u32(np, "systemid", &sysid);\n\tif (!err && ((sysid & GRLIB_VERSION_MASK)\n	f
20889	818	acpi_ds_evaluate_name_path	drivers/acpi/acpica/dsutils.c	operand	6	12	\N	\N	\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *op = walk_state->op;\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *new_obj_desc;\n\tu8 type;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_evaluate_name_path, walk_state);\n\n\tif (!op->common.parent) {\n\n\t\t/* This happens after certain exception processing */\n\n\t\tgoto exit;\n\t}\n\n\tif ((op->common.parent->common.aml_opcode == AML_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_VARIABLE_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_REF_OF_OP)) {\n\n\t\t/* TBD: Should we specify this feature as a bit of op_info->Flags of these opcodes? */\n\n\t\tgoto exit;\n\t}\n\n\tstatus = acpi_ds_create_operand(walk_state, op, 0);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (op->common.flags & ACPI_PARSEOP_TARGET) {\n\t\tnew_obj_desc = *operand;\n\t\tgoto push_result;\n\t}\n\n\ttype = (*operand)->common.type;\n	t
46728	935	gs_usb_probe	drivers/net/can/usb/gs_usb.c	rc	2	-11	\N	\N	\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf->byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc < 0) {\n	f
39260	6973	nested_get_current_vmcs02	arch/x86/kvm/vmx.c	&item->vmcs02	1	11	\N	\N	\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmx->nested.current_vmptr) {\n\t\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\t\treturn &item->vmcs02;\n\t\t}\n\n\tif (vmx->nested.vmcs02_num >= max(VMCS02_POOL_SIZE, 1)) {\n\t\t/* Recycle the least recently used VMCS. */\n\t\titem = list_last_entry(&vmx->nested.vmcs02_pool,\n\t\t\t\t       struct vmcs02_list, list);\n\t\titem->vmptr = vmx->nested.current_vmptr;\n\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\treturn &item->vmcs02;\n\t}\n\n\t/* Create a new VMCS */\n\titem = kmalloc(sizeof(struct vmcs02_list), GFP_KERNEL);\n\tif (!item)\n\t\treturn NULL;\n\titem->vmcs02.vmcs = alloc_vmcs();\n\titem->vmcs02.shadow_vmcs = NULL;\n\tif (!item->vmcs02.vmcs) {\n\t\tkfree(item);\n\t\treturn NULL;\n\t}\n\tloaded_vmcs_init(&item->vmcs02);\n	f
43793	1565	ndisc_send_redirect	net/ipv6/ndisc.c	&saddr_buf	1	11	\N	\N	\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct sock *sk = net->ipv6.ndisc_sk;\n\tint optlen = 0;\n\tstruct inet_peer *peer;\n\tstruct sk_buff *buff;\n\tstruct rd_msg *msg;\n\tstruct in6_addr saddr_buf;\n\tstruct rt6_info *rt;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint rd_len;\n\tu8 ha_buf[MAX_ADDR_LEN], *ha = NULL,\n\t   ops_data_buf[NDISC_OPS_REDIRECT_DATA_SPACE], *ops_data = NULL;\n\tbool ret;\n\n\tif (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {\n	f
43796	4142	nct6775_probe	drivers/hwmon/nct6775.c	data	0	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct nct6775_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct nct6775_data *data;\n\tstruct resource *res;\n\tint i, s, err = 0;\n\tint src, mask, available;\n\tconst u16 *reg_temp, *reg_temp_over, *reg_temp_hyst, *reg_temp_config;\n\tconst u16 *reg_temp_mon, *reg_temp_alternate, *reg_temp_crit;\n\tconst u16 *reg_temp_crit_l = NULL, *reg_temp_crit_h = NULL;\n\tint num_reg_temp, num_reg_temp_mon;\n\tu8 cr2a;\n\tstruct attribute_group *group;\n\tstruct device *hwmon_dev;\n\tint num_attr_groups = 0;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(&pdev->dev, res->start, IOREGION_LENGTH,\n\t\t\t\t DRVNAME))\n\t\treturn -EBUSY;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct nct6775_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->kind = sio_data->kind;\n\tdata->sioreg = sio_data->sioreg;\n\tdata->addr = res->start;\n\tmutex_init(&data->update_lock);\n\tdata->name = nct6775_device_names[data->kind];\n\tdata->bank = 0xff;\t\t/* Force initial bank selection */\n\tplatform_set_drvdata(pdev, data);\n\n\tswitch (data->kind) {\n\tcase nct6106:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 6;\n\t\tdata->num_temp_beeps = 6;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\n\t\tdata->temp_label = nct6776_temp_label;\n\t\tdata->temp_mask = NCT6776_TEMP_MASK;\n\n\t\tdata->REG_VBAT = NCT6106_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6106_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6106_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6106_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6106_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6106_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6106_REG_TARGET;\n\t\tdata->REG_FAN = NCT6106_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6106_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6106_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6106_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6106_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6106_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6106_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6106_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_PWM[0] = NCT6106_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6106_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6106_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6106_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6106_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6106_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6106_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6106_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6106_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6106_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6106_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6106_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6106_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6106_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6106_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6106_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6106_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6106_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6106_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6106_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6106_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6106_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6106_REG_ALARM;\n\t\tdata->ALARM_BITS = NCT6106_ALARM_BITS;\n\t\tdata->REG_BEEP = NCT6106_REG_BEEP;\n\t\tdata->BEEP_BITS = NCT6106_BEEP_BITS;\n\n\t\treg_temp = NCT6106_REG_TEMP;\n\t\treg_temp_mon = NCT6106_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6106_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6106_REG_TEMP_MON);\n\t\treg_temp_over = NCT6106_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6106_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6106_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6106_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6106_REG_TEMP_CRIT;\n\t\treg_temp_crit_l = NCT6106_REG_TEMP_CRIT_L;\n\t\treg_temp_crit_h = NCT6106_REG_TEMP_CRIT_H;\n\n\t\tbreak;\n\tcase nct6775:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 6;\n\t\tdata->has_fan_div = true;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 3;\n\t\tdata->num_temp_beeps = 3;\n\n\t\tdata->ALARM_BITS = NCT6775_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6775_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg16;\n\t\tdata->fan_from_reg_min = fan_from_reg8;\n\t\tdata->target_temp_mask = 0x7f;\n\t\tdata->tolerance_mask = 0x0f;\n\t\tdata->speed_tolerance_limit = 15;\n\n\t\tdata->temp_label = nct6775_temp_label;\n\t\tdata->temp_mask = NCT6775_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6775_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6775_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6775_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6775_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[3] = NCT6775_REG_FAN_MAX_OUTPUT;\n\t\tdata->REG_PWM[4] = NCT6775_REG_FAN_STEP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6775_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6775_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6775_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6775_REG_BEEP;\n\n\t\treg_temp = NCT6775_REG_TEMP;\n\t\treg_temp_mon = NCT6775_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\n\t\treg_temp_over = NCT6775_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6775_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6775_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6775_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6775_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6776:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 3;\n\t\tdata->num_temp_beeps = 6;\n\n\t\tdata->ALARM_BITS = NCT6776_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6776_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tdata->temp_label = nct6776_temp_label;\n\t\tdata->temp_mask = NCT6776_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6775_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6775_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6776_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6775_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\n\t\treg_temp = NCT6775_REG_TEMP;\n\t\treg_temp_mon = NCT6775_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\n\t\treg_temp_over = NCT6775_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6775_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6776_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6776_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6776_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6779:\n\t\tdata->in_num = 15;\n\t\tdata->pwm_num = 5;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 6;\n\t\tdata->num_temp_alarms = 2;\n\t\tdata->num_temp_beeps = 2;\n\n\t\tdata->ALARM_BITS = NCT6779_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6779_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tdata->temp_label = nct6779_temp_label;\n\t\tdata->temp_mask = NCT6779_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6779_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6779_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6779_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6779_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\n\t\treg_temp = NCT6779_REG_TEMP;\n\t\treg_temp_mon = NCT6779_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\n\t\treg_temp_over = NCT6779_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6779_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6779_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6779_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6791:\n\tcase nct6792:\n\tcase nct6793:\n\tcase nct6795:\n\t\tdata->in_num = 15;\n\t\tdata->pwm_num = 6;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 6;\n\t\tdata->num_temp_alarms = 2;\n\t\tdata->num_temp_beeps = 2;\n\n\t\tdata->ALARM_BITS = NCT6791_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6779_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tswitch (data->kind) {\n\t\tdefault:\n\t\tcase nct6791:\n\t\t\tdata->temp_label = nct6779_temp_label;\n\t\t\tdata->temp_mask = NCT6791_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6792:\n\t\t\tdata->temp_label = nct6792_temp_label;\n\t\t\tdata->temp_mask = NCT6792_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6793:\n\t\t\tdata->temp_label = nct6793_temp_label;\n\t\t\tdata->temp_mask = NCT6793_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6795:\n\t\t\tdata->temp_label = nct6795_temp_label;\n\t\t\tdata->temp_mask = NCT6795_TEMP_MASK;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6779_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6779_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6791_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6791_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6779_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6791_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6791_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6791_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6791_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6791_REG_ALARM;\n\t\tif (data->kind == nct6791)\n\t\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\t\telse\n\t\t\tdata->REG_BEEP = NCT6792_REG_BEEP;\n\n\t\treg_temp = NCT6779_REG_TEMP;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\n\t\tif (data->kind == nct6791) {\n\t\t\treg_temp_mon = NCT6779_REG_TEMP_MON;\n\t\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\n\t\t} else {\n\t\t\treg_temp_mon = NCT6792_REG_TEMP_MON;\n\t\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6792_REG_TEMP_MON);\n\t\t}\n\t\treg_temp_over = NCT6779_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6779_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6779_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6779_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tdata->have_in = BIT(data->in_num) - 1;\n\tdata->have_temp = 0;\n\n\t/*\n\t * On some boards, not all available temperature sources are monitored,\n\t * even though some of the monitoring registers are unused.\n\t * Get list of unused monitoring registers, then detect if any fan\n\t * controls are configured to use unmonitored temperature sources.\n\t * If so, assign the unmonitored temperature sources to available\n\t * monitoring registers.\n\t */\n\tmask = 0;\n\tavailable = 0;\n\tfor (i = 0; i < num_reg_temp; i++) {\n\t\tif (reg_temp[i] == 0)\n\t\t\tcontinue;\n\n\t\tsrc = nct6775_read_value(data, data->REG_TEMP_SOURCE[i]) & 0x1f;\n\t\tif (!src || (mask & BIT(src)))\n\t\t\tavailable |= BIT(i);\n\n\t\tmask |= BIT(src);\n\t}\n\n\t/*\n\t * Now find unmonitored temperature registers and enable monitoring\n\t * if additional monitoring registers are available.\n\t */\n\tadd_temp_sensors(data, data->REG_TEMP_SEL, &available, &mask);\n\tadd_temp_sensors(data, data->REG_WEIGHT_TEMP_SEL, &available, &mask);\n\n\tmask = 0;\n\ts = NUM_TEMP_FIXED;\t/* First dynamic temperature attribute */\n\tfor (i = 0; i < num_reg_temp; i++) {\n\t\tif (reg_temp[i] == 0)\n\t\t\tcontinue;\n\n\t\tsrc = nct6775_read_value(data, data->REG_TEMP_SOURCE[i]) & 0x1f;\n\t\tif (!src || (mask & BIT(src)))\n\t\t\tcontinue;\n\n\t\tif (!(data->temp_mask & BIT(src))) {\n\t\t\tdev_info(dev,\n\t\t\t\t "Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\\n",\n\t\t\t\t src, i, data->REG_TEMP_SOURCE[i], reg_temp[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmask |= BIT(src);\n\n\t\t/* Use fixed index for SYSTIN(1), CPUTIN(2), AUXTIN(3) */\n\t\tif (src <= data->temp_fixed_num) {\n\t\t\tdata->have_temp |= BIT(src - 1);\n\t\t\tdata->have_temp_fixed |= BIT(src - 1);\n\t\t\tdata->reg_temp[0][src - 1] = reg_temp[i];\n\t\t\tdata->reg_temp[1][src - 1] = reg_temp_over[i];\n\t\t\tdata->reg_temp[2][src - 1] = reg_temp_hyst[i];\n\t\t\tif (reg_temp_crit_h && reg_temp_crit_h[i])\n\t\t\t\tdata->reg_temp[3][src - 1] = reg_temp_crit_h[i];\n\t\t\telse if (reg_temp_crit[src - 1])\n\t\t\t\tdata->reg_temp[3][src - 1]\n\t\t\t\t  = reg_temp_crit[src - 1];\n\t\t\tif (reg_temp_crit_l && reg_temp_crit_l[i])\n\t\t\t\tdata->reg_temp[4][src - 1] = reg_temp_crit_l[i];\n\t\t\tdata->reg_temp_config[src - 1] = reg_temp_config[i];\n\t\t\tdata->temp_src[src - 1] = src;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\n\t\t\tcontinue;\n\n\t\t/* Use dynamic index for other sources */\n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp[i];\n\t\tdata->reg_temp[1][s] = reg_temp_over[i];\n\t\tdata->reg_temp[2][s] = reg_temp_hyst[i];\n\t\tdata->reg_temp_config[s] = reg_temp_config[i];\n\t\tif (reg_temp_crit_h && reg_temp_crit_h[i])\n\t\t\tdata->reg_temp[3][s] = reg_temp_crit_h[i];\n\t\telse if (reg_temp_crit[src - 1])\n\t\t\tdata->reg_temp[3][s] = reg_temp_crit[src - 1];\n\t\tif (reg_temp_crit_l && reg_temp_crit_l[i])\n\t\t\tdata->reg_temp[4][s] = reg_temp_crit_l[i];\n\n\t\tdata->temp_src[s] = src;\n\t\ts++;\n\t}\n\n\t/*\n\t * Repeat with temperatures used for fan control.\n\t * This set of registers does not support limits.\n\t */\n\tfor (i = 0; i < num_reg_temp_mon; i++) {\n\t\tif (reg_temp_mon[i] == 0)\n\t\t\tcontinue;\n\n\t\tsrc = nct6775_read_value(data, data->REG_TEMP_SEL[i]) & 0x1f;\n\t\tif (!src)\n\t\t\tcontinue;\n\n\t\tif (!(data->temp_mask & BIT(src))) {\n\t\t\tdev_info(dev,\n\t\t\t\t "Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\\n",\n\t\t\t\t src, i, data->REG_TEMP_SEL[i],\n\t\t\t\t reg_temp_mon[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For virtual temperature sources, the 'virtual' temperature\n\t\t * for each fan reflects a different temperature, and there\n\t\t * are no duplicates.\n\t\t */\n\t\tif (src != TEMP_SOURCE_VIRTUAL) {\n\t\t\tif (mask & BIT(src))\n\t\t\t\tcontinue;\n\t\t\tmask |= BIT(src);\n\t\t}\n\n\t\t/* Use fixed index for SYSTIN(1), CPUTIN(2), AUXTIN(3) */\n\t\tif (src <= data->temp_fixed_num) {\n\t\t\tif (data->have_temp & BIT(src - 1))\n\t\t\t\tcontinue;\n\t\t\tdata->have_temp |= BIT(src - 1);\n\t\t\tdata->have_temp_fixed |= BIT(src - 1);\n\t\t\tdata->reg_temp[0][src - 1] = reg_temp_mon[i];\n\t\t\tdata->temp_src[src - 1] = src;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\n\t\t\tcontinue;\n\n\t\t/* Use dynamic index for other sources */\n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp_mon[i];\n\t\tdata->temp_src[s] = src;\n\t\ts++;\n\t}\n\n#ifdef USE_ALTERNATE\n\t/*\n\t * Go through the list of alternate temp registers and enable\n\t * if possible.\n\t * The temperature is already monitored if the respective bit in <mask>\n\t * is set.\n\t */\n\tfor (i = 0; i < 32; i++) {\n\t\tif (!(data->temp_mask & BIT(i + 1)))\n\t\t\tcontinue;\n\t\tif (!reg_temp_alternate[i])\n\t\t\tcontinue;\n\t\tif (mask & BIT(i + 1))\n\t\t\tcontinue;\n\t\tif (i < data->temp_fixed_num) {\n\t\t\tif (data->have_temp & BIT(i))\n\t\t\t\tcontinue;\n\t\t\tdata->have_temp |= BIT(i);\n\t\t\tdata->have_temp_fixed |= BIT(i);\n\t\t\tdata->reg_temp[0][i] = reg_temp_alternate[i];\n\t\t\tif (i < num_reg_temp) {\n\t\t\t\tdata->reg_temp[1][i] = reg_temp_over[i];\n\t\t\t\tdata->reg_temp[2][i] = reg_temp_hyst[i];\n\t\t\t}\n\t\t\tdata->temp_src[i] = i + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\t/* Abort if no more space */\n\t\t\tbreak;\n\n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp_alternate[i];\n\t\tdata->temp_src[s] = i + 1;\n\t\ts++;\n\t}\n#endif /* USE_ALTERNATE */\n\n\t/* Initialize the chip */\n\tnct6775_init_device(data);\n	f
1417	2494	get_default_free_blocks_flags	fs/ext4/extents.c	get_default_free_blocks_flags_	1	11	\N	\N	\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode) ||\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EA_INODE))\n\t\treturn EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET;\n\telse if (ext4_should_journal_data(inode))\n	t
1949	14031	bnx2x_init_mod_abs_int	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	phy.type	1	11	\N	\N	\tu8 gpio_num = 0xff, gpio_port = 0xff, phy_index;\n\tu32 val;\n\tu32 offset, aeu_mask, swap_val, swap_override, sync_offset;\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (bnx2x_get_mod_abs_int_cfg(bp, chip_id,\n\t\t\t\t\t      shmem_base,\n\t\t\t\t\t      port,\n\t\t\t\t\t      &gpio_num,\n\t\t\t\t\t      &gpio_port) != 0)\n\t\t\treturn;\n\t} else {\n\t\tstruct bnx2x_phy phy;\n\t\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t\t      phy_index++) {\n\t\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base,\n\t\t\t\t\t       shmem2_base, port, &phy)\n\t\t\t    != 0) {\n\t\t\t\tDP(NETIF_MSG_LINK, "populate phy failed\\n");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (phy.type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {\n	t
23830	278	hfsplus_create_cat	fs/hfsplus/catalog.c	&fd	1	11	\N	\N	\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, "create_cat: %s,%u(%d)\\n",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n	f
27823	573	hfi1_make_ud_req	drivers/infiniband/hw/hfi1/ud.c	ps->s_txreq	1	11	\N	\N	\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct rdma_ah_attr *ah_attr;\n\tstruct hfi1_pportdata *ppd;\n\tstruct hfi1_ibport *ibp;\n\tstruct rvt_swqe *wqe;\n\tint next_cur;\n\tu32 lid;\n\n\tps->s_txreq = get_txreq(ps->dev, qp);\n\tif (IS_ERR(ps->s_txreq))\n\t\tgoto bail_no_tx;\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_NEXT_SEND_OK)) {\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))\n\t\t\tgoto bail;\n\t\t/* We are in the error state, flush the work request. */\n\t\tsmp_read_barrier_depends(); /* see post_one_send */\n\t\tif (qp->s_last == ACCESS_ONCE(qp->s_head))\n\t\t\tgoto bail;\n\t\t/* If DMAs are in progress, we can't flush immediately. */\n\t\tif (iowait_sdma_pending(&priv->s_iowait)) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_DMA;\n\t\t\tgoto bail;\n\t\t}\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\thfi1_send_complete(qp, wqe, IB_WC_WR_FLUSH_ERR);\n\t\tgoto done_free_tx;\n\t}\n\n\t/* see post_one_send() */\n\tsmp_read_barrier_depends();\n\tif (qp->s_cur == ACCESS_ONCE(qp->s_head))\n\t\tgoto bail;\n\n\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\tnext_cur = qp->s_cur + 1;\n\tif (next_cur >= qp->s_size)\n\t\tnext_cur = 0;\n\n\t/* Construct the header. */\n\tibp = to_iport(qp->ibqp.device, qp->port_num);\n\tppd = ppd_from_ibp(ibp);\n\tah_attr = &ibah_to_rvtah(wqe->ud_wr.ah)->attr;\n\tpriv->hdr_type = hfi1_get_hdr_type(ppd->lid, ah_attr);\n\tif ((!hfi1_check_mcast(rdma_ah_get_dlid(ah_attr))) ||\n\t    (rdma_ah_get_dlid(ah_attr) == be32_to_cpu(OPA_LID_PERMISSIVE))) {\n\t\tlid = rdma_ah_get_dlid(ah_attr) & ~((1 << ppd->lmc) - 1);\n\t\tif (unlikely(!loopback &&\n\t\t\t     ((lid == ppd->lid) ||\n\t\t\t      ((lid == be32_to_cpu(OPA_LID_PERMISSIVE)) &&\n\t\t\t       (qp->ibqp.qp_type == IB_QPT_GSI))))) {\n\t\t\tunsigned long tflags = ps->flags;\n\t\t\t/*\n\t\t\t * If DMAs are in progress, we can't generate\n\t\t\t * a completion for the loopback packet since\n\t\t\t * it would be out of order.\n\t\t\t * Instead of waiting, we could queue a\n\t\t\t * zero length descriptor so we get a callback.\n\t\t\t */\n\t\t\tif (iowait_sdma_pending(&priv->s_iowait)) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_DMA;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tqp->s_cur = next_cur;\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, tflags);\n\t\t\tud_loopback(qp, wqe);\n\t\t\tspin_lock_irqsave(&qp->s_lock, tflags);\n\t\t\tps->flags = tflags;\n\t\t\thfi1_send_complete(qp, wqe, IB_WC_SUCCESS);\n\t\t\tgoto done_free_tx;\n\t\t}\n\t}\n\n\tqp->s_cur = next_cur;\n\tps->s_txreq->s_cur_size = wqe->length;\n\tps->s_txreq->ss = &qp->s_sge;\n\tqp->s_srate = rdma_ah_get_static_rate(ah_attr);\n\tqp->srate_mbps = ib_rate_to_mbps(qp->s_srate);\n\tqp->s_wqe = wqe;\n\tqp->s_sge.sge = wqe->sg_list[0];\n\tqp->s_sge.sg_list = wqe->sg_list + 1;\n\tqp->s_sge.num_sge = wqe->wr.num_sge;\n\tqp->s_sge.total_len = wqe->length;\n\n\t/* Make the appropriate header */\n\thfi1_make_ud_req_tbl[priv->hdr_type](qp, ps, qp->s_wqe);\n\tpriv->s_sde = qp_to_sdma_engine(qp, priv->s_sc);\n\tps->s_txreq->sde = priv->s_sde;\n\tpriv->s_sendcontext = qp_to_send_context(qp, priv->s_sc);\n\tps->s_txreq->psc = priv->s_sendcontext;\n\t/* disarm any ahg */\n\tpriv->s_ahg->ahgcount = 0;\n\tpriv->s_ahg->ahgidx = 0;\n\tpriv->s_ahg->tx_flags = 0;\n\t/* pbc */\n\tps->s_txreq->hdr_dwords = qp->s_hdrwords + 2;\n\n\treturn 1;\n\ndone_free_tx:\n\thfi1_put_txreq(ps->s_txreq);\n	f
40515	1749	fib_trie_unmerge	net/ipv4/fib_trie.c	local_tp	6	12	\N	\N	\tstruct trie *ot = (struct trie *)oldtb->tb_data;\n\tstruct key_vector *l, *tp = ot->kv;\n\tstruct fib_table *local_tb;\n\tstruct fib_alias *fa;\n\tstruct trie *lt;\n\tt_key key = 0;\n\n\tif (oldtb->tb_data == oldtb->__data)\n\t\treturn oldtb;\n\n\tlocal_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);\n\tif (!local_tb)\n\t\treturn NULL;\n\n\tlt = (struct trie *)local_tb->tb_data;\n\n\twhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\n\t\tstruct key_vector *local_l = NULL, *local_tp;\n\n\t\thlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\n\t\t\tstruct fib_alias *new_fa;\n\n\t\t\tif (local_tb->tb_id != fa->tb_id)\n\t\t\t\tcontinue;\n\n\t\t\t/* clone fa for new local table */\n\t\t\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\n\t\t\tif (!new_fa)\n\t\t\t\tgoto out;\n\n\t\t\tmemcpy(new_fa, fa, sizeof(*fa));\n\n\t\t\t/* insert clone into table */\n\t\t\tif (!local_l)\n\t\t\t\tlocal_l = fib_find_node(lt, &local_tp, l->key);\n\n\t\t\tif (fib_insert_alias(lt, local_tp, local_l, new_fa,\n	t
50433	136	hfs_cat_create	fs/hfs/catalog.c	&fd	1	11	\N	\N	\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, "create_cat: %s,%u(%d)\\n",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = current_time(dir);\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\n	f
37090	1528	get_firmware	drivers/media/pci/ttpci/av7110.c	fw->size	1	11	\N	\N	\tint ret;\n\tconst struct firmware *fw;\n\n\t/* request the av7110 firmware, this will block until someone uploads it */\n\tret = request_firmware(&fw, "dvb-ttpci-01.fw", &av7110->dev->pci->dev);\n\tif (ret) {\n\t\tif (ret == -ENOENT) {\n\t\t\tprintk(KERN_ERR "dvb-ttpci: could not load firmware, file not found: dvb-ttpci-01.fw\\n");\n\t\t\tprintk(KERN_ERR "dvb-ttpci: usually this should be in /usr/lib/hotplug/firmware or /lib/firmware\\n");\n\t\t\tprintk(KERN_ERR "dvb-ttpci: and can be downloaded from https://linuxtv.org/download/dvb/firmware/\\n");\n\t\t} else\n\t\t\tprintk(KERN_ERR "dvb-ttpci: cannot request firmware (error %i)\\n",\n\t\t\t       ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size <= 200000) {\n	t
31823	277	hfi1_make_uc_req	drivers/infiniband/hw/hfi1/uc.c	ohdr	0	11	\N	\N	\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct ib_other_headers *ohdr;\n\tstruct rvt_swqe *wqe;\n\tu32 hwords;\n\tu32 bth0 = 0;\n\tu32 len;\n\tu32 pmtu = qp->pmtu;\n\tint middle = 0;\n\n\tps->s_txreq = get_txreq(ps->dev, qp);\n\tif (IS_ERR(ps->s_txreq))\n\t\tgoto bail_no_tx;\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_SEND_OK)) {\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))\n\t\t\tgoto bail;\n\t\t/* We are in the error state, flush the work request. */\n\t\tsmp_read_barrier_depends(); /* see post_one_send() */\n\t\tif (qp->s_last == ACCESS_ONCE(qp->s_head))\n\t\t\tgoto bail;\n\t\t/* If DMAs are in progress, we can't flush immediately. */\n\t\tif (iowait_sdma_pending(&priv->s_iowait)) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_DMA;\n\t\t\tgoto bail;\n\t\t}\n\t\tclear_ahg(qp);\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\thfi1_send_complete(qp, wqe, IB_WC_WR_FLUSH_ERR);\n\t\tgoto done_free_tx;\n\t}\n\n\tps->s_txreq->phdr.hdr.hdr_type = priv->hdr_type;\n\tif (priv->hdr_type == HFI1_PKT_TYPE_9B) {\n\t\t/* header size in 32-bit words LRH+BTH = (8+12)/4. */\n\t\thwords = 5;\n\t\tif (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.oth;\n\t} else {\n\t\t/* header size in 32-bit words 16B LRH+BTH = (16+12)/4. */\n\t\thwords = 7;\n\t\tif ((rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&\n\t\t    (hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))))\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.oth;\n\t}\n\n\t/* Get the next send request. */\n\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\tqp->s_wqe = NULL;\n\tswitch (qp->s_state) {\n\tdefault:\n\t\tif (!(ib_rvt_state_ops[qp->state] &\n\t\t    RVT_PROCESS_NEXT_SEND_OK))\n\t\t\tgoto bail;\n\t\t/* Check if send work queue is empty. */\n\t\tsmp_read_barrier_depends(); /* see post_one_send() */\n\t\tif (qp->s_cur == ACCESS_ONCE(qp->s_head)) {\n\t\t\tclear_ahg(qp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/*\n\t\t * Local operations are processed immediately\n\t\t * after all prior requests have completed.\n\t\t */\n\t\tif (wqe->wr.opcode == IB_WR_REG_MR ||\n\t\t    wqe->wr.opcode == IB_WR_LOCAL_INV) {\n\t\t\tint local_ops = 0;\n\t\t\tint err = 0;\n\n\t\t\tif (qp->s_last != qp->s_cur)\n\t\t\t\tgoto bail;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tif (!(wqe->wr.send_flags & RVT_SEND_COMPLETION_ONLY)) {\n\t\t\t\terr = rvt_invalidate_rkey(\n\t\t\t\t\tqp, wqe->wr.ex.invalidate_rkey);\n\t\t\t\tlocal_ops = 1;\n\t\t\t}\n\t\t\thfi1_send_complete(qp, wqe, err ? IB_WC_LOC_PROT_ERR\n\t\t\t\t\t\t\t: IB_WC_SUCCESS);\n\t\t\tif (local_ops)\n\t\t\t\tatomic_dec(&qp->local_ops_pending);\n\t\t\tqp->s_hdrwords = 0;\n\t\t\tgoto done_free_tx;\n\t\t}\n\t\t/*\n\t\t * Start a new request.\n\t\t */\n\t\tqp->s_psn = wqe->psn;\n\t\tqp->s_sge.sge = wqe->sg_list[0];\n\t\tqp->s_sge.sg_list = wqe->sg_list + 1;\n\t\tqp->s_sge.num_sge = wqe->wr.num_sge;\n\t\tqp->s_sge.total_len = wqe->length;\n\t\tlen = wqe->length;\n\t\tqp->s_len = len;\n\t\tswitch (wqe->wr.opcode) {\n\t\tcase IB_WR_SEND:\n\t\tcase IB_WR_SEND_WITH_IMM:\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(SEND_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->wr.opcode == IB_WR_SEND) {\n\t\t\t\tqp->s_state = OP(SEND_ONLY);\n\t\t\t} else {\n\t\t\t\tqp->s_state =\n\t\t\t\t\tOP(SEND_ONLY_WITH_IMMEDIATE);\n\t\t\t\t/* Immediate data comes after the BTH */\n\t\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t}\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\tqp->s_wqe = wqe;\n\t\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_RDMA_WRITE:\n\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\tohdr->u.rc.reth.vaddr =\n\t\t\t\tcpu_to_be64(wqe->rdma_wr.remote_addr);\n\t\t\tohdr->u.rc.reth.rkey =\n\t\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\t\tohdr->u.rc.reth.length = cpu_to_be32(len);\n\t\t\thwords += sizeof(struct ib_reth) / 4;\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_ONLY);\n\t\t\t} else {\n\t\t\t\tqp->s_state =\n\t\t\t\t\tOP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);\n\t\t\t\t/* Immediate data comes after the RETH */\n\t\t\t\tohdr->u.rc.imm_data = wqe->wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\t}\n\t\t\tqp->s_wqe = wqe;\n\t\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto bail;\n\t\t}\n\t\tbreak;\n\n\tcase OP(SEND_FIRST):\n\t\tqp->s_state = OP(SEND_MIDDLE);\n\t\t/* FALLTHROUGH */\n\tcase OP(SEND_MIDDLE):\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_SEND) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t} else {\n\t\t\tqp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);\n\t\t\t/* Immediate data comes after the BTH */\n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t}\n\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\tqp->s_wqe = wqe;\n\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase OP(RDMA_WRITE_FIRST):\n\t\tqp->s_state = OP(RDMA_WRITE_MIDDLE);\n\t\t/* FALLTHROUGH */\n\tcase OP(RDMA_WRITE_MIDDLE):\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\n\t\t\tqp->s_state = OP(RDMA_WRITE_LAST);\n\t\t} else {\n\t\t\tqp->s_state =\n\t\t\t\tOP(RDMA_WRITE_LAST_WITH_IMMEDIATE);\n\t\t\t/* Immediate data comes after the BTH */\n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t}\n\t\tqp->s_wqe = wqe;\n\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\t}\n\tqp->s_len -= len;\n\tqp->s_hdrwords = hwords;\n\tps->s_txreq->sde = priv->s_sde;\n\tps->s_txreq->ss = &qp->s_sge;\n\tps->s_txreq->s_cur_size = len;\n\thfi1_make_ruc_header(qp, ohdr, bth0 | (qp->s_state << 24),\n	f
1957	4234	bnx2x_warpcore_set_sgmii_speed	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	val16	8	12	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu16 val16, digctrl_kx1, digctrl_kx2;\n\n\t/* Clear XFI clock comp in non-10G single lane mode. */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_RX66_CONTROL, ~(3<<13));\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\tif (always_autoneg || phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t/* SGMII Autoneg */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x1000);\n\t\tDP(NETIF_MSG_LINK, "set SGMII AUTONEG\\n");\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tval16 &= 0xcebf;\n\t\tswitch (phy->req_line_speed) {\n\t\tcase SPEED_10:\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval16 |= 0x2000;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval16 |= 0x0040;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   "Speed not supported: 0x%x\\n", phy->req_line_speed);\n\t\t\treturn;\n\t\t}\n\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tval16 |= 0x0100;\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n	t
21831	1025	hid_open_report	drivers/hid/hid-core.c	item.format	1	11	\N	\N	\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\tunsigned int size;\n\t__u8 *start;\n\t__u8 *buf;\n\t__u8 *end;\n\tint ret;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_parser_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tif (WARN_ON(device->status & HID_STAT_PARSED))\n\t\treturn -EBUSY;\n\n\tstart = device->dev_rdesc;\n\tif (WARN_ON(!start))\n\t\treturn -ENODEV;\n\tsize = device->dev_rsize;\n\n\tbuf = kmemdup(start, size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (device->driver->report_fixup)\n\t\tstart = device->driver->report_fixup(device, buf, &size);\n\telse\n\t\tstart = buf;\n\n\tstart = kmemdup(start, size, GFP_KERNEL);\n\tkfree(buf);\n\tif (start == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice->rdesc = start;\n\tdevice->rsize = size;\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tparser->device = device;\n\n\tend = start + size;\n\n\tdevice->collection = kcalloc(HID_DEFAULT_NUM_COLLECTIONS,\n\t\t\t\t     sizeof(struct hid_collection), GFP_KERNEL);\n\tif (!device->collection) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdevice->collection_size = HID_DEFAULT_NUM_COLLECTIONS;\n\n\tret = -EINVAL;\n\twhile ((start = fetch_item(start, end, &item)) != NULL) {\n\n\t\tif (item.format != HID_ITEM_FORMAT_SHORT) {\n	f
26936	829	hp_wmi_rfkill2_setup	drivers/platform/x86/hp-wmi.c	state.device	2	-11	\N	\N	\tstruct bios_rfkill2_state state;\n\tint err, i;\n\n\terr = hp_wmi_perform_query(HPWMI_WIRELESS2_QUERY, HPWMI_READ, &state,\n\t\t\t\t   0, sizeof(state));\n\tif (err)\n\t\treturn err < 0 ? err : -EINVAL;\n\n\tif (state.count > HPWMI_MAX_RFKILL2_DEVICES) {\n\t\tpr_warn("unable to parse 0x1b query output\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < state.count; i++) {\n\t\tstruct rfkill *rfkill;\n\t\tenum rfkill_type type;\n\t\tchar *name;\n\t\tswitch (state.device[i].radio_type) {\n\t\tcase HPWMI_WIFI:\n\t\t\ttype = RFKILL_TYPE_WLAN;\n\t\t\tname = "hp-wifi";\n\t\t\tbreak;\n\t\tcase HPWMI_BLUETOOTH:\n\t\t\ttype = RFKILL_TYPE_BLUETOOTH;\n\t\t\tname = "hp-bluetooth";\n\t\t\tbreak;\n\t\tcase HPWMI_WWAN:\n\t\t\ttype = RFKILL_TYPE_WWAN;\n\t\t\tname = "hp-wwan";\n\t\t\tbreak;\n\t\tcase HPWMI_GPS:\n\t\t\ttype = RFKILL_TYPE_GPS;\n\t\t\tname = "hp-gps";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn("unknown device type 0x%x\\n",\n\t\t\t\tstate.device[i].radio_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!state.device[i].vendor_id) {\n	f
27182	1895	hidpp_ff_init	drivers/hid/hid-logitech-hidpp.c	num_slots	1	11	\N	\N	\tstruct hid_device *hid = hidpp->hid_dev;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid)->descriptor);\n\tconst u16 bcdDevice = le16_to_cpu(udesc->bcdDevice);\n\tstruct ff_device *ff;\n\tstruct hidpp_report response;\n\tstruct hidpp_ff_private_data *data;\n\tint error, j, num_slots;\n\tu8 version;\n\n\tif (!dev) {\n\t\thid_err(hid, "Struct input_dev not set!\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Get firmware release */\n\tversion = bcdDevice & 255;\n\n\t/* Set supported force feedback capabilities */\n\tfor (j = 0; hiddpp_ff_effects[j] >= 0; j++)\n\t\tset_bit(hiddpp_ff_effects[j], dev->ffbit);\n\tif (version > 1)\n\t\tfor (j = 0; hiddpp_ff_effects_v2[j] >= 0; j++)\n\t\t\tset_bit(hiddpp_ff_effects_v2[j], dev->ffbit);\n\n\t/* Read number of slots available in device */\n\terror = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\tHIDPP_FF_GET_INFO, NULL, 0, &response);\n\tif (error) {\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\thid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\\n",\n\t\t\t__func__, error);\n\t\treturn -EPROTO;\n\t}\n\n\tnum_slots = response.fap.params[0] - HIDPP_FF_RESERVED_SLOTS;\n\n\terror = input_ff_create(dev, num_slots);\n	f
43368	451	iblock_execute_zero_out	drivers/target/target_core_iblock.c	ret	1	11	\N	\N	\tstruct se_device *dev = cmd->se_dev;\n\tstruct scatterlist *sg = &cmd->t_data_sg[0];\n\tunsigned char *buf, zero = 0x00, *p = &zero;\n\tint rc, ret;\n\n\tbuf = kmap(sg_page(sg)) + sg->offset;\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t/*\n\t * Fall back to block_execute_write_same() slow-path if\n\t * incoming WRITE_SAME payload does not contain zeros.\n\t */\n\trc = memcmp(buf, p, cmd->data_length);\n\tkunmap(sg_page(sg));\n\n\tif (rc)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tret = blkdev_issue_zeroout(bdev,\n\t\t\t\ttarget_to_linux_sector(dev, cmd->t_task_lba),\n\t\t\t\ttarget_to_linux_sector(dev,\n\t\t\t\t\tsbc_get_write_same_sectors(cmd)),\n\t\t\t\tGFP_KERNEL, false);\n\tif (ret)\n	f
21939	1251	nfc_genl_fw_download_done	net/nfc/netlink.c	msg	1	11	\N	\N	\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n	f
2032	404	clk_dyn_rcg_recalc_rate	drivers/clk/qcom/clk-rcg.c	mode	1	11	\N	\N	\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tu32 m, n, pre_div, ns, md, mode, reg;\n\tint bank;\n\tstruct mn *mn;\n\tbool banked_p = !!rcg->p[1].pre_div_width;\n\tbool banked_mn = !!rcg->mn[1].width;\n\n\tregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tbank = reg_to_bank(rcg, reg);\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\n\tm = n = pre_div = mode = 0;\n\n\tif (banked_mn) {\n\t\tmn = &rcg->mn[bank];\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\n\t\tm = md_to_m(mn, md);\n\t\tn = ns_m_to_n(mn, ns, m);\n\t\t/* Two NS registers means mode control is in NS register */\n\t\tif (rcg->ns_reg[0] != rcg->ns_reg[1])\n\t\t\treg = ns;\n\t\tmode = reg_to_mnctr_mode(mn, reg);\n\t}\n\n\tif (banked_p)\n\t\tpre_div = ns_to_pre_div(&rcg->p[bank], ns);\n\n\treturn calc_rate(parent_rate, m, n, mode, pre_div);\n	t
28233	3845	delay_drop_debugfs_init	drivers/infiniband/hw/mlx5/main.c	dbg->dir_debugfs	1	13	\N	\N	\tstruct mlx5_ib_dbg_delay_drop *dbg;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\tdbg = kzalloc(sizeof(*dbg), GFP_KERNEL);\n\tif (!dbg)\n\t\treturn -ENOMEM;\n\n\tdev->delay_drop.dbg = dbg;\n\n\tdbg->dir_debugfs =\n\t\tdebugfs_create_dir("delay_drop",\n\t\t\t\t   dev->mdev->priv.dbg_root);\n\tif (!dbg->dir_debugfs)\n	f
28240	3859	delay_drop_debugfs_init	drivers/infiniband/hw/mlx5/main.c	dbg->rqs_cnt_debugfs	1	13	\N	\N	\tstruct mlx5_ib_dbg_delay_drop *dbg;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\tdbg = kzalloc(sizeof(*dbg), GFP_KERNEL);\n\tif (!dbg)\n\t\treturn -ENOMEM;\n\n\tdev->delay_drop.dbg = dbg;\n\n\tdbg->dir_debugfs =\n\t\tdebugfs_create_dir("delay_drop",\n\t\t\t\t   dev->mdev->priv.dbg_root);\n\tif (!dbg->dir_debugfs)\n\t\tgoto out_debugfs;\n\n\tdbg->events_cnt_debugfs =\n\t\tdebugfs_create_atomic_t("num_timeout_events", 0400,\n\t\t\t\t\tdbg->dir_debugfs,\n\t\t\t\t\t&dev->delay_drop.events_cnt);\n\tif (!dbg->events_cnt_debugfs)\n\t\tgoto out_debugfs;\n\n\tdbg->rqs_cnt_debugfs =\n\t\tdebugfs_create_atomic_t("num_rqs", 0400,\n\t\t\t\t\tdbg->dir_debugfs,\n\t\t\t\t\t&dev->delay_drop.rqs_cnt);\n\tif (!dbg->rqs_cnt_debugfs)\n	f
31576	3083	i915_ggtt_init_hw	drivers/gpu/drm/i915/i915_gem_gtt.c	dev_priv	1	11	\N	\N	\tstruct i915_ggtt *ggtt = &dev_priv->ggtt;\n\tint ret;\n\n\tINIT_LIST_HEAD(&dev_priv->vm_list);\n\n\t/* Note that we use page colouring to enforce a guard page at the\n\t * end of the address space. This is required as the CS may prefetch\n\t * beyond the end of the batch buffer, across the page boundary,\n\t * and beyond the end of the GTT if we do not provide a guard.\n\t */\n\tmutex_lock(&dev_priv->drm.struct_mutex);\n\ti915_address_space_init(&ggtt->base, dev_priv, "[global]");\n\tif (!HAS_LLC(dev_priv) && !USES_PPGTT(dev_priv))\n\t\tggtt->base.mm.color_adjust = i915_gtt_color_adjust;\n\tmutex_unlock(&dev_priv->drm.struct_mutex);\n\n\tif (!io_mapping_init_wc(&dev_priv->ggtt.mappable,\n\t\t\t\tdev_priv->ggtt.mappable_base,\n\t\t\t\tdev_priv->ggtt.mappable_end)) {\n\t\tret = -EIO;\n\t\tgoto out_gtt_cleanup;\n\t}\n\n\tggtt->mtrr = arch_phys_wc_add(ggtt->mappable_base, ggtt->mappable_end);\n\n\t/*\n\t * Initialise stolen early so that we may reserve preallocated\n\t * objects for the BIOS to KMS transition.\n\t */\n\tret = i915_gem_init_stolen(dev_priv);\n	f
39162	1475	hs400_tune_response	drivers/mmc/host/mtk-sd.c	final_cmd_delay.final_phase	1	11	\N	\N	\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 cmd_delay = 0;\n\tstruct msdc_delay_phase final_cmd_delay = { 0,};\n\tu8 final_delay;\n\tint cmd_err;\n\tint i, j;\n\n\t/* select EMMC50 PAD CMD tune */\n\tsdr_set_bits(host->base + PAD_CMD_TUNE, BIT(0));\n\n\tif (mmc->ios.timing == MMC_TIMING_MMC_HS200 ||\n\t    mmc->ios.timing == MMC_TIMING_UHS_SDR104)\n\t\tsdr_set_field(host->base + MSDC_PAD_TUNE,\n\t\t\t      MSDC_PAD_TUNE_CMDRRDLY,\n\t\t\t      host->hs200_cmd_int_delay);\n\n\tif (host->hs400_cmd_resp_sel_rising)\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\telse\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tfor (i = 0 ; i < PAD_DELAY_MAX; i++) {\n\t\tsdr_set_field(host->base + PAD_CMD_TUNE,\n\t\t\t      PAD_CMD_TUNE_RX_DLY3, i);\n\t\t/*\n\t\t * Using the same parameters, it may sometimes pass the test,\n\t\t * but sometimes it may fail. To make sure the parameters are\n\t\t * more stable, we test each set of parameters 3 times.\n\t\t */\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tmmc_send_tuning(mmc, opcode, &cmd_err);\n\t\t\tif (!cmd_err) {\n\t\t\t\tcmd_delay |= (1 << i);\n\t\t\t} else {\n\t\t\t\tcmd_delay &= ~(1 << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfinal_cmd_delay = get_best_delay(host, cmd_delay);\n\tsdr_set_field(host->base + PAD_CMD_TUNE, PAD_CMD_TUNE_RX_DLY3,\n	f
40651	404	hsr_get_node_list	net/hsr/hsr_netlink.c	skb_out	1	11	\N	\N	\t/* For receiving */\n\tstruct nlattr *na;\n\tstruct net_device *hsr_dev;\n\n\t/* For sending */\n\tstruct sk_buff *skb_out;\n\tvoid *msg_head;\n\tstruct hsr_priv *hsr;\n\tvoid *pos;\n\tunsigned char addr[ETH_ALEN];\n\tint res;\n\n\tif (!info)\n\t\tgoto invalid;\n\n\tna = info->attrs[HSR_A_IFINDEX];\n\tif (!na)\n\t\tgoto invalid;\n\n\thsr_dev = __dev_get_by_index(genl_info_net(info),\n\t\t\t\t     nla_get_u32(info->attrs[HSR_A_IFINDEX]));\n\tif (!hsr_dev)\n\t\tgoto invalid;\n\tif (!is_hsr_master(hsr_dev))\n\t\tgoto invalid;\n\n\n\t/* Send reply */\n\n\tskb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb_out) {\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmsg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,\n	f
41909	278	hsr_get_node_status	net/hsr/hsr_netlink.c	skb_out	1	11	\N	\N	\t/* For receiving */\n\tstruct nlattr *na;\n\tstruct net_device *hsr_dev;\n\n\t/* For sending */\n\tstruct sk_buff *skb_out;\n\tvoid *msg_head;\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tunsigned char hsr_node_addr_b[ETH_ALEN];\n\tint hsr_node_if1_age;\n\tu16 hsr_node_if1_seq;\n\tint hsr_node_if2_age;\n\tu16 hsr_node_if2_seq;\n\tint addr_b_ifindex;\n\tint res;\n\n\tif (!info)\n\t\tgoto invalid;\n\n\tna = info->attrs[HSR_A_IFINDEX];\n\tif (!na)\n\t\tgoto invalid;\n\tna = info->attrs[HSR_A_NODE_ADDR];\n\tif (!na)\n\t\tgoto invalid;\n\n\thsr_dev = __dev_get_by_index(genl_info_net(info),\n\t\t\t\t\tnla_get_u32(info->attrs[HSR_A_IFINDEX]));\n\tif (!hsr_dev)\n\t\tgoto invalid;\n\tif (!is_hsr_master(hsr_dev))\n\t\tgoto invalid;\n\n\n\t/* Send reply */\n\n\tskb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb_out) {\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmsg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,\n	f
53053	1044	nfc_genl_llc_get_params	net/nfc/netlink.c	msg	1	11	\N	\N	\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\n	f
58334	182	mxm_shadow_wmi	drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c	status	1	11	\N	\N	\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tu32 mxms_args[] = { 0x534D584D /* MXMS */, version, 0 };\n\tstruct acpi_buffer args = { sizeof(mxms_args), mxms_args };\n\tstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tif (!wmi_has_guid(WMI_WMMX_GUID)) {\n\t\tnvkm_debug(subdev, "WMMX GUID not found\\n");\n\t\treturn false;\n\t}\n\n\tmxms_args[1] = wmi_wmmx_mxmi(mxm, 0x00);\n\tif (!mxms_args[1])\n\t\tmxms_args[1] = wmi_wmmx_mxmi(mxm, version);\n\tif (!mxms_args[1])\n\t\treturn false;\n\n\tstatus = wmi_evaluate_method(WMI_WMMX_GUID, 0, 0, &args, &retn);\n\tif (ACPI_FAILURE(status)) {\n	t
20885	825	acpi_ds_evaluate_name_path	drivers/acpi/acpica/dsutils.c	type	1	13	\N	\N	\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *op = walk_state->op;\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *new_obj_desc;\n\tu8 type;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_evaluate_name_path, walk_state);\n\n\tif (!op->common.parent) {\n\n\t\t/* This happens after certain exception processing */\n\n\t\tgoto exit;\n\t}\n\n\tif ((op->common.parent->common.aml_opcode == AML_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_VARIABLE_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_REF_OF_OP)) {\n\n\t\t/* TBD: Should we specify this feature as a bit of op_info->Flags of these opcodes? */\n\n\t\tgoto exit;\n\t}\n\n\tstatus = acpi_ds_create_operand(walk_state, op, 0);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (op->common.flags & ACPI_PARSEOP_TARGET) {\n\t\tnew_obj_desc = *operand;\n\t\tgoto push_result;\n\t}\n\n\ttype = (*operand)->common.type;\n\n\tstatus = acpi_ex_resolve_to_value(operand, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (type == ACPI_TYPE_INTEGER) {\n	f
2063	821	arizona_of_get_core_pdata	drivers/mfd/arizona-core.c	ret	1	11	\N	\N	\tstruct arizona_pdata *pdata = &arizona->pdata;\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tu32 val;\n\tu32 pdm_val[ARIZONA_MAX_PDM_SPK];\n\tint ret, i;\n\tint count = 0;\n\n\tpdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);\n\tif (pdata->reset == -EPROBE_DEFER) {\n\t\treturn pdata->reset;\n\t} else if (pdata->reset < 0) {\n\t\tdev_err(arizona->dev, "Reset GPIO missing/malformed: %d\\n",\n\t\t\tpdata->reset);\n\n\t\tpdata->reset = 0;\n\t}\n\n\tret = of_property_read_u32_array(arizona->dev->of_node,\n\t\t\t\t\t "wlf,gpio-defaults",\n\t\t\t\t\t pdata->gpio_defaults,\n\t\t\t\t\t ARRAY_SIZE(pdata->gpio_defaults));\n\tif (ret >= 0) {\n	t
29506	3221	hwsim_get_radio_nl	drivers/net/wireless/mac80211_hwsim.c	skb	1	11	\N	\N	\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb;\n\tint idx, res = -ENODEV;\n\n\tif (!info->attrs[HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx != idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = mac80211_hwsim_get_radio(skb, data, info->snd_portid,\n	f
30015	344	i915_gem_object_unbind	drivers/gpu/drm/i915/i915_gem.c	ret	1	11	\N	\N	\tstruct i915_vma *vma;\n\tLIST_HEAD(still_in_list);\n\tint ret;\n\n\tlockdep_assert_held(&obj->base.dev->struct_mutex);\n\n\t/* Closed vma are removed from the obj->vma_list - but they may\n\t * still have an active binding on the object. To remove those we\n\t * must wait for all rendering to complete to the object (as unbinding\n\t * must anyway), and retire the requests.\n\t */\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_LOCKED |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT,\n\t\t\t\t   NULL);\n\tif (ret)\n\t\treturn ret;\n\n\ti915_gem_retire_requests(to_i915(obj->base.dev));\n\n\twhile ((vma = list_first_entry_or_null(&obj->vma_list,\n\t\t\t\t\t       struct i915_vma,\n\t\t\t\t\t       obj_link))) {\n\t\tlist_move_tail(&vma->obj_link, &still_in_list);\n\t\tret = i915_vma_unbind(vma);\n\t\tif (ret)\n	f
31380	1468	hva_to_pfn_remapped	virt/kvm/kvm_main.c	pfn	1	11	\N	\N	\tunsigned long pfn;\n\tint r;\n\n\tr = follow_pfn(vma, addr, &pfn);\n\tif (r) {\n\t\t/*\n\t\t * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does\n\t\t * not call the fault handler, so do it here.\n\t\t */\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current, current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = follow_pfn(vma, addr, &pfn);\n\t\tif (r)\n\t\t\treturn r;\n\n\t}\n\n\n\t/*\n\t * Get a reference here because callers of *hva_to_pfn* and\n\t * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the\n\t * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP\n\t * set, but the kvm_get_pfn/kvm_release_pfn_clean pair will\n\t * simply do nothing for reserved pfns.\n\t *\n\t * Whoever called remap_pfn_range is also going to call e.g.\n\t * unmap_mapping_range before the underlying pages are freed,\n\t * causing a call to our MMU notifier.\n\t */ \n\tkvm_get_pfn(pfn);\n	f
43204	300	ipheth_carrier_set	drivers/net/usb/ipheth.c	retval	1	11	\N	\N	\tstruct usb_device *udev = dev->udev;\n\tint retval;\n\n\tretval = usb_control_msg(udev,\n\t\t\tusb_rcvctrlpipe(udev, IPHETH_CTRL_ENDP),\n\t\t\tIPHETH_CMD_CARRIER_CHECK, /* request */\n\t\t\t0xc0, /* request type */\n\t\t\t0x00, /* value */\n\t\t\t0x02, /* index */\n\t\t\tdev->ctrl_buf, IPHETH_CTRL_BUF_SIZE,\n\t\t\tIPHETH_CTRL_TIMEOUT);\n\tif (retval < 0) {\n	f
43988	312	pp_init	drivers/ntb/test/ntb_pingpong.c	pp_debugfs_dir	1	13	\N	\N	\tint rc;\n\n\tif (debugfs_initialized())\n\t\tpp_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\trc = ntb_register_client(&pp_client);\n\tif (rc)\n\t\tgoto err_client;\n\n\treturn 0;\n\nerr_client:\n\tdebugfs_remove_recursive(pp_debugfs_dir);\n	f
8742	1614	mb86a20s_get_stats	drivers/media/dvb-frontends/mb86a20s.c	rc	1	11	\N	\N	\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc = 0, layer;\n\tu32 bit_error = 0, bit_count = 0;\n\tu32 t_pre_bit_error = 0, t_pre_bit_count = 0;\n\tu32 t_post_bit_error = 0, t_post_bit_count = 0;\n\tu32 block_error = 0, block_count = 0;\n\tu32 t_block_error = 0, t_block_count = 0;\n\tint active_layers = 0, pre_ber_layers = 0, post_ber_layers = 0;\n\tint per_layers = 0;\n\n\tdev_dbg(&state->i2c->dev, "%s called.\\n", __func__);\n\n\tmb86a20s_get_main_CNR(fe);\n\n\t/* Get per-layer stats */\n\tmb86a20s_get_blk_error_layer_CNR(fe);\n\n\t/*\n\t * At state 7, only CNR is available\n\t * For BER measures, state=9 is required\n\t * FIXME: we may get MER measures with state=8\n\t */\n\tif (status_nr < 9)\n\t\treturn 0;\n\n\tfor (layer = 0; layer < NUM_LAYERS; layer++) {\n\t\tif (c->isdbt_layer_enabled & (1 << layer)) {\n\t\t\t/* Layer is active and has rc segments */\n\t\t\tactive_layers++;\n\n\t\t\t/* Handle BER before vterbi */\n\t\t\trc = mb86a20s_get_pre_ber(fe, layer,\n\t\t\t\t\t\t  &bit_error, &bit_count);\n\t\t\tif (rc >= 0) {\n	t
63095	702	nfnl_cthelper_del	net/netfilter/nfnetlink_cthelper.c	tuple.src.l3num	1	11	\N	\N	\tchar *helper_name = NULL;\n\tstruct nf_conntrack_helper *cur;\n\tstruct nf_conntrack_tuple tuple;\n\tbool tuple_set = false, found = false;\n\tstruct nfnl_cthelper *nlcth, *n;\n\tint j = 0, ret;\n\n\tif (tb[NFCTH_NAME])\n\t\thelper_name = nla_data(tb[NFCTH_NAME]);\n\n\tif (tb[NFCTH_TUPLE]) {\n\t\tret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttuple_set = true;\n\t}\n\n\tret = -ENOENT;\n\tlist_for_each_entry_safe(nlcth, n, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\t\tj++;\n\n\t\tif (helper_name &&\n\t\t    strncmp(cur->name, helper_name, NF_CT_HELPER_NAME_LEN))\n\t\t\tcontinue;\n\n\t\tif (tuple_set &&\n\t\t    (tuple.src.l3num != cur->tuple.src.l3num ||\n	f
-609	10255	nested_vmx_store_msr	arch/x86/kvm/vmx.c	&e)	2	3	\N	\N	\tu32 i;\n\tstruct vmx_msr_entry e;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t"%s cannot read MSR entry (%u, 0x%08llx)\\n",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n	f
29299	4426	ieee80211_nullfunc_get	net/mac80211/tx.c	skb	1	-1	\N	\N	\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*nullfunc));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n	f
24300	1225	ieee80211_rx_rsl	drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c	skb->data	1	-11	\N	\N	\tstruct net_device *dev = ieee->dev;\n\tstruct rtl_80211_hdr_4addr *hdr;\n\t//struct rtl_80211_hdr_3addrqos *hdr;\n\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n\t//added by amy for reorder\n\tu8\tTID = 0;\n\tu16\tSeqNum = 0;\n\tPRX_TS_RECORD pTS = NULL;\n\t//bool bIsAggregateFrame = false;\n\t//added by amy for reorder\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct net_device *wds = NULL;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n//\tu16 qos_ctl = 0;\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tu8 bssid[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\n\tint i;\n\tstruct ieee80211_rxb *rxb = NULL;\n\t// cheat the hdr type\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO "%s: SKB length < 10\\n",\n\t\t       dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\tif (HTCCheck(ieee, skb->data))\n\t{\n\t\tif(net_ratelimit())\n\t\t\tprintk("find HTCControl\\n");\n\t\thdrlen += 4;\n\t\trx_stats->bContainHTC = true;\n\t}\n\n\t//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);\n#ifdef NOT_YET\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (iface->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\t\twstats.level = rx_stats->rssi;\n\t\twstats.noise = rx_stats->noise;\n\t\twstats.updated = 6;\t/* No qual value */\n\t\t/* Update spy records */\n\t\twireless_spy_update(dev, hdr->addr2, &wstats);\n\t}\n#endif /* IW_WIRELESS_SPY */\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\treturn 1;\n\t}\n\n\tif (ieee->host_decrypt) {\n\t\tint idx = 0;\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tidx = skb->data[hdrlen + 3] >> 6;\n\t\tcrypt = ieee->crypt[idx];\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address ("individual RA"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void) hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t\t&sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_WEP)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP("Decryption failed (not set)"\n\t\t\t\t\t     " (SA=%pM)\\n",\n\t\t\t\t\t     hdr->addr2);\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (skb->len < IEEE80211_DATA_HDR3_LEN)\n\t\tgoto rx_dropped;\n\n\t// if QoS enabled, should check the sequence for each of the AC\n\tif ((!ieee->pHTInfo->bCurRxReorderEnable) || !ieee->current_network.qos_data.active|| !IsDataFrame(skb->data) || IsLegacyDataFrame(skb->data)) {\n\t\tif (is_duplicate_packet(ieee, hdr))\n\t\tgoto rx_dropped;\n\n\t}\n\telse\n\t{\n\t\tPRX_TS_RECORD pRxTS = NULL;\n\t\t\t//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\\n",__func__, tid);\n\t\tif(GetTs(\n\t\t\t\tieee,\n\t\t\t\t(PTS_COMMON_INFO *) &pRxTS,\n\t\t\t\thdr->addr2,\n\t\t\t\tFrame_QoSTID((u8 *)(skb->data)),\n\t\t\t\tRX_DIR,\n\t\t\t\ttrue))\n\t\t{\n\n\t\t//\tIEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->RxLastFragNum is %d,frag is %d,pRxTS->RxLastSeqNum is %d,seq is %d\\n",__func__,pRxTS->RxLastFragNum,frag,pRxTS->RxLastSeqNum,WLAN_GET_SEQ_SEQ(sc));\n\t\t\tif ((fc & (1<<11)) &&\n\t\t\t    (frag == pRxTS->RxLastFragNum) &&\n\t\t\t    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {\n\t\t\t\tgoto rx_dropped;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpRxTS->RxLastFragNum = frag;\n\t\t\t\tpRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\\n",__func__);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\tif (type == IEEE80211_FTYPE_MGMT) {\n\n\n\t//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n\n\t/* Data frame - extract src/dst addresses */\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr1, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_DATA_HDR4_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tmemcpy(bssid, ieee->current_network.bssid, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) == IEEE80211_FCTL_FROMDS &&\n\t    ieee->stadev &&\n\t    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) &&\n\t    !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\tcase AP_RX_CONTINUE:\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\t//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL&&\n\t    stype != IEEE80211_STYPE_QOS_DATA//add by David,2006.8.4\n\t    ) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\n\t\t\t\t"RX: dropped data frame "\n\t\t\t\t"with no data (type=0x%02x, "\n\t\t\t\t"subtype=0x%02x, len=%d)\\n",\n\t\t\t\ttype, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\tif (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))\n\t\tgoto rx_dropped;\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t{\n\t\tprintk("decrypt frame error\\n");\n\t\tgoto rx_dropped;\n\t}\n\n\n\thdr = (struct rtl_80211_hdr_4addr *) skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the "if" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\n\tif ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG("Rx Fragment received (%u)\\n", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t"Rx cannot get skb from fragment "\n\t\t\t\t\t"cache (morefrag=%d seq=%u frag=%u)\\n",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING "%s: host decrypted and "\n\t\t\t       "reassembled frame did not fit skb\\n",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_put_data(frag_skb, skb->data, flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_put_data(frag_skb, skb->data + hdrlen, flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct rtl_80211_hdr_4addr *) skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t{\n\t\tprintk("==>decrypt msdu error\\n");\n\t\tgoto rx_dropped;\n\t}\n\n\t//added by amy for AP roaming\n\tieee->LinkDetectInfo.NumRecvDataInPeriod++;\n\tieee->LinkDetectInfo.NumRxOkInPeriod++;\n\n\thdr = (struct rtl_80211_hdr_4addr *) skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep) {\n\t\tif (/*ieee->ieee802_1x &&*/\n\t\t    ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n	f
28552	513	ieee80211_data_to_8023_exthdr	net/wireless/util.c	tmp.h_proto	1	11	\N	\N	\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct {\n\t\tu8 hdr[ETH_ALEN] __aligned(2);\n\t\t__be16 proto;\n\t} payload;\n\tstruct ethhdr tmp;\n\tu16 hdrlen;\n\tu8 mesh_flags = 0;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn -1;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (skb->len < hdrlen + 8)\n\t\treturn -1;\n\n\t/* convert IEEE 802.11 header + possible LLC headers into Ethernet\n\t * header\n\t * IEEE 802.11 address fields:\n\t * ToDS FromDS Addr1 Addr2 Addr3 Addr4\n\t *   0     0   DA    SA    BSSID n/a\n\t *   0     1   DA    BSSID SA    n/a\n\t *   1     0   BSSID SA    DA    n/a\n\t *   1     1   RA    TA    DA    SA\n\t */\n\tmemcpy(tmp.h_dest, ieee80211_get_DA(hdr), ETH_ALEN);\n\tmemcpy(tmp.h_source, ieee80211_get_SA(hdr), ETH_ALEN);\n\n\tif (iftype == NL80211_IFTYPE_MESH_POINT)\n\t\tskb_copy_bits(skb, hdrlen, &mesh_flags, 1);\n\n\tmesh_flags &= MESH_FLAGS_AE;\n\n\tswitch (hdr->frame_control &\n\t\tcpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {\n\tcase cpu_to_le16(IEEE80211_FCTL_TODS):\n\t\tif (unlikely(iftype != NL80211_IFTYPE_AP &&\n\t\t\t     iftype != NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     iftype != NL80211_IFTYPE_P2P_GO))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS):\n\t\tif (unlikely(iftype != NL80211_IFTYPE_WDS &&\n\t\t\t     iftype != NL80211_IFTYPE_MESH_POINT &&\n\t\t\t     iftype != NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     iftype != NL80211_IFTYPE_STATION))\n\t\t\treturn -1;\n\t\tif (iftype == NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (mesh_flags == MESH_FLAGS_AE_A4)\n\t\t\t\treturn -1;\n\t\t\tif (mesh_flags == MESH_FLAGS_AE_A5_A6) {\n\t\t\t\tskb_copy_bits(skb, hdrlen +\n\t\t\t\t\toffsetof(struct ieee80211s_hdr, eaddr1),\n\t\t\t\t\ttmp.h_dest, 2 * ETH_ALEN);\n\t\t\t}\n\t\t\thdrlen += __ieee80211_get_mesh_hdrlen(mesh_flags);\n\t\t}\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_FCTL_FROMDS):\n\t\tif ((iftype != NL80211_IFTYPE_STATION &&\n\t\t     iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t\t     iftype != NL80211_IFTYPE_MESH_POINT) ||\n\t\t    (is_multicast_ether_addr(tmp.h_dest) &&\n\t\t     ether_addr_equal(tmp.h_source, addr)))\n\t\t\treturn -1;\n\t\tif (iftype == NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (mesh_flags == MESH_FLAGS_AE_A5_A6)\n\t\t\t\treturn -1;\n\t\t\tif (mesh_flags == MESH_FLAGS_AE_A4)\n\t\t\t\tskb_copy_bits(skb, hdrlen +\n\t\t\t\t\toffsetof(struct ieee80211s_hdr, eaddr1),\n\t\t\t\t\ttmp.h_source, ETH_ALEN);\n\t\t\thdrlen += __ieee80211_get_mesh_hdrlen(mesh_flags);\n\t\t}\n\t\tbreak;\n\tcase cpu_to_le16(0):\n\t\tif (iftype != NL80211_IFTYPE_ADHOC &&\n\t\t    iftype != NL80211_IFTYPE_STATION &&\n\t\t    iftype != NL80211_IFTYPE_OCB)\n\t\t\t\treturn -1;\n\t\tbreak;\n\t}\n\n\tskb_copy_bits(skb, hdrlen, &payload, sizeof(payload));\n\ttmp.h_proto = payload.proto;\n\n\tif (likely((ether_addr_equal(payload.hdr, rfc1042_header) &&\n	f
35926	649	nfnl_cthelper_get	net/netfilter/nfnetlink_cthelper.c	skb2	2	-11	\N	\N	\tint ret = -ENOENT;\n\tstruct nf_conntrack_helper *cur;\n\tstruct sk_buff *skb2;\n\tchar *helper_name = NULL;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nfnl_cthelper *nlcth;\n\tbool tuple_set = false;\n\n\tif (nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nfnl_cthelper_dump_table,\n\t\t};\n\t\treturn netlink_dump_start(nfnl, skb, nlh, &c);\n\t}\n\n\tif (tb[NFCTH_NAME])\n\t\thelper_name = nla_data(tb[NFCTH_NAME]);\n\n\tif (tb[NFCTH_TUPLE]) {\n\t\tret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttuple_set = true;\n\t}\n\n\tlist_for_each_entry(nlcth, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\t\tif (helper_name &&\n\t\t    strncmp(cur->name, helper_name, NF_CT_HELPER_NAME_LEN))\n\t\t\tcontinue;\n\n\t\tif (tuple_set &&\n\t\t    (tuple.src.l3num != cur->tuple.src.l3num ||\n\t\t     tuple.dst.protonum != cur->tuple.dst.protonum))\n\t\t\tcontinue;\n\n\t\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (skb2 == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,\n	f
46116	390	ifi_canfd_handle_lec_err	drivers/net/can/ifi_canfd/ifi_canfd.c	cf->can_id	1	11	\N	\N	\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tconst u32 errmask = IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST;\n\n\tif (!(errctr & errmask))\t/* No error happened. */\n\t\treturn 0;\n\n\tpriv->can.can_stats.bus_error++;\n\tstats->rx_errors++;\n\n\t/* Propagate the error condition to the CAN stack. */\n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t/* Read the error counter register and check for new errors. */\n\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n	f
9826	101	pm860x_led_set	drivers/leds/leds-88pm860x.c	ret	1	11	\N	\N	\tstruct pm860x_led *led = container_of(cdev, struct pm860x_led, cdev);\n\tstruct pm860x_chip *chip;\n\tunsigned char buf[3];\n\tint ret;\n\n\tchip = led->chip;\n\tmutex_lock(&led->lock);\n\tled->brightness = value >> 3;\n\n\tif ((led->current_brightness == 0) && led->brightness) {\n\t\tled_power_set(chip, led->port, 1);\n\t\tif (led->iset) {\n\t\t\tpm860x_set_bits(led->i2c, led->reg_control,\n\t\t\t\t\tLED_CURRENT_MASK, led->iset);\n\t\t}\n\t\tpm860x_set_bits(led->i2c, led->reg_blink,\n\t\t\t\tLED_BLINK_MASK, LED_ON_CONTINUOUS);\n\t\tpm860x_set_bits(led->i2c, PM8606_WLED3B, led->blink_mask,\n\t\t\t\tled->blink_mask);\n\t}\n\tpm860x_set_bits(led->i2c, led->reg_control, LED_PWM_MASK,\n\t\t\tled->brightness);\n\n\tif (led->brightness == 0) {\n\t\tpm860x_bulk_read(led->i2c, led->reg_control, 3, buf);\n\t\tret = buf[0] & LED_PWM_MASK;\n\t\tret |= buf[1] & LED_PWM_MASK;\n\t\tret |= buf[2] & LED_PWM_MASK;\n\t\tif (ret == 0) {\n	t
62842	1039	ieee802154_create	net/ieee802154/socket.c	sk->sk_prot->init	1	11	\N	\N	\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\t/* FIXME: sk->sk_destruct */\n\tsk->sk_family = PF_IEEE802154;\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n	f
51931	1110	ieee80211_send_layer2_update	net/mac80211/cfg.c	skb	0	11	\N	\N	\tstruct iapp_layer2_update *msg;\n\tstruct sk_buff *skb;\n\n\t/* Send Level 2 Update Frame to update forwarding tables in layer 2\n\t * bridge devices */\n\n\tskb = dev_alloc_skb(sizeof(*msg));\n\tif (!skb)\n\t\treturn;\n\tmsg = skb_put(skb, sizeof(*msg));\n	f
-512	553	sh_dmae_chan_probe	drivers/dma/sh/shdmac.c	schan	1000	3	\N	\N	\tconst struct sh_dmae_channel *chan_pdata = &shdev->pdata->channel[id];\n\tstruct shdma_dev *sdev = &shdev->shdma_dev;\n\tstruct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);\n\tstruct sh_dmae_chan *sh_chan;\n\tstruct shdma_chan *schan;\n\tint err;\n\n\tsh_chan = devm_kzalloc(sdev->dma_dev.dev, sizeof(struct sh_dmae_chan),\n\t\t\t       GFP_KERNEL);\n\tif (!sh_chan)\n\t\treturn -ENOMEM;\n\n\tschan = &sh_chan->shdma_chan;\n\tschan->max_xfer_len = SH_DMA_TCR_MAX + 1;\n\n\tshdma_chan_probe(sdev, schan, id);\n\n\tsh_chan->base = shdev->chan_reg + chan_pdata->offset;\n\n\t/* set up channel irq */\n\tif (pdev->id >= 0)\n\t\tsnprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),\n\t\t\t "sh-dmae%d.%d", pdev->id, id);\n\telse\n\t\tsnprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),\n\t\t\t "sh-dma%d", id);\n\n\terr = shdma_request_irq(schan, irq, flags, sh_chan->dev_id);\n	f
40363	983	inet_diag_dump_icsk	net/ipv4/inet_diag.c	inet_diag_dump_icsk_phi$$sk4$obj$0$2$0$obj$and$255$shl$8$or$%sk4$obj$0$2$0$obj$and$65280$ashr$8$	0	11	\N	\N	\tbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\tstruct net *net = sock_net(skb->sk);\n\tu32 idiag_states = r->idiag_states;\n\tint i, num, s_i, s_num;\n\tstruct sock *sk;\n\n\tif (idiag_states & TCPF_SYN_RECV)\n\t\tidiag_states |= TCPF_NEW_SYN_RECV;\n\ts_i = cb->args[1];\n\ts_num = num = cb->args[2];\n\n\tif (cb->args[0] == 0) {\n\t\tif (!(idiag_states & TCPF_LISTEN) || r->id.idiag_dport)\n\t\t\tgoto skip_listen_ht;\n\n\t\tfor (i = s_i; i < INET_LHTABLE_SIZE; i++) {\n\t\t\tstruct inet_listen_hashbucket *ilb;\n\n\t\t\tnum = 0;\n\t\t\tilb = &hashinfo->listening_hash[i];\n\t\t\tspin_lock(&ilb->lock);\n\t\t\tsk_for_each(sk, &ilb->head) {\n\t\t\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (num < s_num) {\n\t\t\t\t\tnum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t\t    sk->sk_family != r->sdiag_family)\n\t\t\t\t\tgoto next_listen;\n\n\t\t\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t\t\t    r->id.idiag_sport)\n\t\t\t\t\tgoto next_listen;\n\n\t\t\t\tif (inet_csk_diag_dump(sk, skb, cb, r,\n\t\t\t\t\t\t       bc, net_admin) < 0) {\n\t\t\t\t\tspin_unlock(&ilb->lock);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\nnext_listen:\n\t\t\t\t++num;\n\t\t\t}\n\t\t\tspin_unlock(&ilb->lock);\n\n\t\t\ts_num = 0;\n\t\t}\nskip_listen_ht:\n\t\tcb->args[0] = 1;\n\t\ts_i = num = s_num = 0;\n\t}\n\n\tif (!(idiag_states & ~TCPF_LISTEN))\n\t\tgoto out;\n\n#define SKARR_SZ 16\n\tfor (i = s_i; i <= hashinfo->ehash_mask; i++) {\n\t\tstruct inet_ehash_bucket *head = &hashinfo->ehash[i];\n\t\tspinlock_t *lock = inet_ehash_lockp(hashinfo, i);\n\t\tstruct hlist_nulls_node *node;\n\t\tstruct sock *sk_arr[SKARR_SZ];\n\t\tint num_arr[SKARR_SZ];\n\t\tint idx, accum, res;\n\n\t\tif (hlist_nulls_empty(&head->chain))\n\t\t\tcontinue;\n\n\t\tif (i > s_i)\n\t\t\ts_num = 0;\n\nnext_chunk:\n\t\tnum = 0;\n\t\taccum = 0;\n\t\tspin_lock_bh(lock);\n\t\tsk_nulls_for_each(sk, node, &head->chain) {\n\t\t\tint state;\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\t\t\tif (num < s_num)\n\t\t\t\tgoto next_normal;\n\t\t\tstate = (sk->sk_state == TCP_TIME_WAIT) ?\n\t\t\t\tinet_twsk(sk)->tw_substate : sk->sk_state;\n\t\t\tif (!(idiag_states & (1 << state)))\n\t\t\t\tgoto next_normal;\n\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t    sk->sk_family != r->sdiag_family)\n\t\t\t\tgoto next_normal;\n\t\t\tif (r->id.idiag_sport != htons(sk->sk_num) &&\n	f
61071	117	nfp_devlink_port_split	drivers/net/ethernet/netronome/nfp/nfp_devlink.c	eth_port.port_lanes / count	1	11	\N	\N	\tstruct nfp_pf *pf = devlink_priv(devlink);\n\tstruct nfp_eth_table_port eth_port;\n\tint ret;\n\n\tif (count < 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pf->lock);\n\n\trtnl_lock();\n\tret = nfp_devlink_fill_eth_port_from_id(pf, port_index, &eth_port);\n\trtnl_unlock();\n\tif (ret)\n\t\tgoto out;\n\n\tif (eth_port.is_split || eth_port.port_lanes % count) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nfp_devlink_set_lanes(pf, eth_port.index,\n	t
44281	3891	intel_pmu_init	arch/x86/events/intel/core.c	intel_pmu_init_$__UNIQUE_ID_max1_229$obj	0	11	\N	\N	\tunion cpuid10_edx edx;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_ebx ebx;\n\tstruct event_constraint *c;\n\tunsigned int unused;\n\tstruct extra_reg *er;\n\tint version, i;\n\tstruct attribute **extra_attr = NULL;\n\tchar *name;\n\n\tif (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {\n\t\tswitch (boot_cpu_data.x86) {\n\t\tcase 0x6:\n\t\t\treturn p6_pmu_init();\n\t\tcase 0xb:\n\t\t\treturn knc_pmu_init();\n\t\tcase 0xf:\n\t\t\treturn p4_pmu_init();\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * Check whether the Architectural PerfMon supports\n\t * Branch Misses Retired hw_event or not.\n\t */\n\tcpuid(10, &eax.full, &ebx.full, &unused, &edx.full);\n\tif (eax.split.mask_length < ARCH_PERFMON_EVENTS_COUNT)\n\t\treturn -ENODEV;\n\n\tversion = eax.split.version_id;\n\tif (version < 2)\n\t\tx86_pmu = core_pmu;\n\telse\n\t\tx86_pmu = intel_pmu;\n\n\tx86_pmu.version\t\t\t= version;\n\tx86_pmu.num_counters\t\t= eax.split.num_counters;\n\tx86_pmu.cntval_bits\t\t= eax.split.bit_width;\n\tx86_pmu.cntval_mask\t\t= (1ULL << eax.split.bit_width) - 1;\n\n\tx86_pmu.events_maskl\t\t= ebx.full;\n\tx86_pmu.events_mask_len\t\t= eax.split.mask_length;\n\n\tx86_pmu.max_pebs_events\t\t= min_t(unsigned, MAX_PEBS_EVENTS, x86_pmu.num_counters);\n\n\n\tx86_pmu.attrs\t\t\t= intel_pmu_attrs;\n\t/*\n\t * Quirk: v2 perfmon does not report fixed-purpose events, so\n\t * assume at least 3 events, when not running in a hypervisor:\n\t */\n\tif (version > 1) {\n\t\tint assume = 3 * !boot_cpu_has(X86_FEATURE_HYPERVISOR);\n\n\t\tx86_pmu.num_counters_fixed =\n\t\t\tmax((int)edx.split.num_counters_fixed, assume);\n	f
42862	2542	iscsi_if_send_reply	drivers/scsi/scsi_transport_iscsi.c	skb	1	11	\N	\N	\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tint len = nlmsg_total_size(size);\n\tint flags = multi ? NLM_F_MULTI : 0;\n\tint t = done ? NLMSG_DONE : type;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR "Could not allocate skb to send reply.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, t, (len - sizeof(*nlh)), 0);\n	f
50771	911	inode_in_dir	fs/btrfs/tree-log.c	di	1	11	\N	\N	\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n	f
52752	151	nfs4_file_llseek	fs/nfs/nfs4file.c	ret	1	11	\N	\N	\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -ENOTSUPP)\n	f
63629	207	integrator_ap_timer_init_of	drivers/clocksource/timer-integrator-ap.c	path	1	11	\N	\N	\tconst char *path;\n\tvoid __iomem *base;\n\tint err;\n\tint irq;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tstruct device_node *pri_node;\n\tstruct device_node *sec_node;\n\n\tbase = of_io_request_and_map(node, 0, "integrator-timer");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err("No clock for %s\\n", node->name);\n\t\treturn PTR_ERR(clk);\n\t}\n\tclk_prepare_enable(clk);\n\trate = clk_get_rate(clk);\n\twritel(0, base + TIMER_CTRL);\n\n\terr = of_property_read_string(of_aliases,\n\t\t\t\t"arm,timer-primary", &path);\n\tif (err) {\n\t\tpr_warn("Failed to read property\\n");\n\t\treturn err;\n\t}\n\n\tpri_node = of_find_node_by_path(path);\n	f
44310	440	init_vq	drivers/block/virtio_blk.c	num_vqs	0	11	\N	\N	\tint err;\n\tint i;\n\tvq_callback_t **callbacks;\n\tconst char **names;\n\tstruct virtqueue **vqs;\n\tunsigned short num_vqs;\n\tstruct virtio_device *vdev = vblk->vdev;\n\tstruct irq_affinity desc = { 0, };\n\n\terr = virtio_cread_feature(vdev, VIRTIO_BLK_F_MQ,\n\t\t\t\t   struct virtio_blk_config, num_queues,\n\t\t\t\t   &num_vqs);\n\tif (err)\n\t\tnum_vqs = 1;\n\n\tvblk->vqs = kmalloc_array(num_vqs, sizeof(*vblk->vqs), GFP_KERNEL);\n	f
29500	934	helene_x_pon	drivers/media/dvb-frontends/helene.c	rdata	2	-11	\N	TP, if i2c_transfer fails	\t/* RFIN matching in power save (terrestrial) = ACTIVE */\n\t/* RFIN matching in power save (satellite) = ACTIVE */\n\tu8 dataT[] = { 0x06, 0x00, 0x02, 0x00 };\n\t/* SAT_RF_ACTIVE = true, lnaOff = false, terrRfActive = true */\n\tu8 dataS[] = { 0x05, 0x06 };\n\tu8 cdata[] = {0x7A, 0x01};\n\tu8 data[20];\n\tu8 rdata[2];\n\n\t/* mode select */\n\thelene_write_reg(priv, 0x01, 0x00);\n\n\thelene_write_reg(priv, 0x67, dataT[3]);\n\thelene_write_reg(priv, 0x43, dataS[1]);\n\thelene_write_regs(priv, 0x5E, dataT, 3);\n\thelene_write_reg(priv, 0x0C, dataS[0]);\n\n\t/* Initial setting for internal logic block */\n\thelene_write_regs(priv, 0x99, cdata, sizeof(cdata));\n\n\t/* 0x81 - 0x94 */\n\tdata[0] = 0x18; /* xtal 24 MHz */\n\tdata[1] = (uint8_t)(0x80 | (0x04 & 0x1F)); /* 4 x 25 = 100uA */\n\tdata[2] = (uint8_t)(0x80 | (0x26 & 0x7F)); /* 38 x 0.25 = 9.5pF */\n\tdata[3] = 0x80; /* REFOUT signal output 500mVpp */\n\tdata[4] = 0x00; /* GPIO settings */\n\tdata[5] = 0x00; /* GPIO settings */\n\tdata[6] = 0xC4; /* Clock enable for internal logic block */\n\tdata[7] = 0x40; /* Start CPU boot-up */\n\tdata[8] = 0x10; /* For burst-write */\n\n\t/* Setting for internal RFAGC */\n\tdata[9] = 0x00;\n\tdata[10] = 0x45;\n\tdata[11] = 0x75;\n\n\tdata[12] = 0x07; /* Setting for analog block */\n\n\t/* Initial setting for internal analog block */\n\tdata[13] = 0x1C;\n\tdata[14] = 0x3F;\n\tdata[15] = 0x02;\n\tdata[16] = 0x10;\n\tdata[17] = 0x20;\n\tdata[18] = 0x0A;\n\tdata[19] = 0x00;\n\n\thelene_write_regs(priv, 0x81, data, sizeof(data));\n\n\t/* Setting for internal RFAGC */\n\thelene_write_reg(priv, 0x9B, 0x00);\n\n\tmsleep(20);\n\n\t/* Check CPU_STT/CPU_ERR */\n\thelene_read_regs(priv, 0x1A, rdata, sizeof(rdata));\n\n\tif (rdata[0] != 0x00) {\n	f
30979	1183	epic_rx	drivers/net/ethernet/smsc/epic100.c	skb	2	-11	\N	\N	\tstruct epic_private *ep = netdev_priv(dev);\n\tint entry = ep->cur_rx % RX_RING_SIZE;\n\tint rx_work_limit = ep->dirty_rx + RX_RING_SIZE - ep->cur_rx;\n\tint work_done = 0;\n\n\tif (debug > 4)\n\t\tnetdev_dbg(dev, " In epic_rx(), entry %d %8.8x.\\n", entry,\n\t\t\t   ep->rx_ring[entry].rxstatus);\n\n\tif (rx_work_limit > budget)\n\t\trx_work_limit = budget;\n\n\t/* If we own the next entry, it's a new packet. Send it up. */\n\twhile ((ep->rx_ring[entry].rxstatus & DescOwn) == 0) {\n\t\tint status = ep->rx_ring[entry].rxstatus;\n\n\t\tif (debug > 4)\n\t\t\tnetdev_dbg(dev, "  epic_rx() status was %8.8x.\\n",\n\t\t\t\t   status);\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\t\tif (status & 0x2006) {\n\t\t\tif (debug > 2)\n\t\t\t\tnetdev_dbg(dev, "epic_rx() error status was %8.8x.\\n",\n\t\t\t\t\t   status);\n\t\t\tif (status & 0x2000) {\n\t\t\t\tnetdev_warn(dev, "Oversized Ethernet frame spanned multiple buffers, status %4.4x!\\n",\n\t\t\t\t\t    status);\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t} else if (status & 0x0006)\n\t\t\t\t/* Rx Frame errors are counted in hardware. */\n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\t/* Malloc up new buffer, compatible with net-2e. */\n\t\t\t/* Omit the four octet CRC from the length. */\n\t\t\tshort pkt_len = (status >> 16) - 4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len > PKT_BUF_SZ - 4) {\n\t\t\t\tnetdev_err(dev, "Oversized Ethernet frame, status %x %d bytes.\\n",\n\t\t\t\t\t   status, pkt_len);\n\t\t\t\tpkt_len = 1514;\n\t\t\t}\n\t\t\t/* Check if the packet is long enough to accept without copying\n\t\t\t   to a minimally-sized skbuff. */\n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t/* 16 byte align the IP header */\n	t
40465	1289	ip_fib_net_exit	net/ipv4/fib_frontend.c	ip_fib_net_exit_$____ptr21$obj	0	11	\N	\N	\tunsigned int i;\n\n\trtnl_lock();\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tRCU_INIT_POINTER(net->ipv4.fib_main, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_default, NULL);\n#endif\n\tfor (i = 0; i < FIB_TABLE_HASHSZ; i++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist) {\n	f
2151	363	qcom_ebi2_probe	drivers/bus/qcom-ebi2.c	csindex	1	11	\N	\N	\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tvoid __iomem *ebi2_base;\n\tvoid __iomem *ebi2_xmem;\n\tstruct clk *ebi2xclk;\n\tstruct clk *ebi2clk;\n\tbool have_children = false;\n\tu32 val;\n\tint ret;\n\n\tebi2xclk = devm_clk_get(dev, "ebi2x");\n\tif (IS_ERR(ebi2xclk))\n\t\treturn PTR_ERR(ebi2xclk);\n\n\tret = clk_prepare_enable(ebi2xclk);\n\tif (ret) {\n\t\tdev_err(dev, "could not enable EBI2X clk (%d)\\n", ret);\n\t\treturn ret;\n\t}\n\n\tebi2clk = devm_clk_get(dev, "ebi2");\n\tif (IS_ERR(ebi2clk)) {\n\t\tret = PTR_ERR(ebi2clk);\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tret = clk_prepare_enable(ebi2clk);\n\tif (ret) {\n\t\tdev_err(dev, "could not enable EBI2 clk\\n");\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tebi2_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_base)) {\n\t\tret = PTR_ERR(ebi2_base);\n\t\tgoto err_disable_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tebi2_xmem = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_xmem)) {\n\t\tret = PTR_ERR(ebi2_xmem);\n\t\tgoto err_disable_clk;\n\t}\n\n\t/* Allegedly this turns the power save mode off */\n\twritel(0UL, ebi2_xmem + EBI2_XMEM_CFG);\n\n\t/* Disable all chipselects */\n\tval = readl(ebi2_base);\n\tval &= ~EBI2_CSN_MASK;\n\twritel(val, ebi2_base);\n\n\t/* Walk over the child nodes and see what chipselects we use */\n\tfor_each_available_child_of_node(np, child) {\n\t\tu32 csindex;\n\n\t\t/* Figure out the chipselect */\n\t\tret = of_property_read_u32(child, "reg", &csindex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (csindex > 5) {\n	t
39548	720	ip6_fragment	net/ipv6/ip6_output.c	skb	0	11	\N	\N	\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?\n\t\t\t\tinet6_sk(skb->sk) : NULL;\n\tstruct ipv6hdr *tmp_hdr;\n\tstruct frag_hdr *fh;\n\tunsigned int mtu, hlen, left, len;\n\tint hroom, troom;\n\t__be32 frag_id;\n\tint ptr, offset = 0, err = 0;\n\tu8 *prevhdr, nexthdr = 0;\n\n\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\tif (err < 0)\n\t\tgoto fail;\n\thlen = err;\n\tnexthdr = *prevhdr;\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t/* We must not fragment if the socket is set to force MTU discovery\n\t * or if the skb it not generated by a local socket.\n\t */\n\tif (unlikely(!skb->ignore_df && skb->len > mtu))\n\t\tgoto fail_toobig;\n\n\tif (IP6CB(skb)->frag_max_size) {\n\t\tif (IP6CB(skb)->frag_max_size > mtu)\n\t\t\tgoto fail_toobig;\n\n\t\t/* don't send fragments larger than what we received */\n\t\tmtu = IP6CB(skb)->frag_max_size;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tif (mtu < hlen + sizeof(struct frag_hdr) + 8)\n\t\tgoto fail_toobig;\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tfrag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,\n\t\t\t\t    &ipv6_hdr(skb)->saddr);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto fail;\n\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb) ||\n\t\t    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t/* Correct geometry. */\n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t/* Partially cloned skb? */\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = 0;\n\t\toffset = 0;\n\t\t/* BUILD HEADER */\n\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\ttmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\t\tif (!tmp_hdr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfrag = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = __skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfh->identification = frag_id;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\n\t\tfor (;;) {\n\t\t\t/* Prepare header of the next frame,\n\t\t\t * before previous one went down. */\n\t\t\tif (frag) {\n\t\t\t\tfrag->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb_reset_transport_header(frag);\n\t\t\t\tfh = __skb_push(frag, sizeof(struct frag_hdr));\n\t\t\t\t__skb_push(frag, hlen);\n\t\t\t\tskb_reset_network_header(frag);\n\t\t\t\tmemcpy(skb_network_header(frag), tmp_hdr,\n\t\t\t\t       hlen);\n\t\t\t\toffset += skb->len - hlen - sizeof(struct frag_hdr);\n\t\t\t\tfh->nexthdr = nexthdr;\n\t\t\t\tfh->reserved = 0;\n\t\t\t\tfh->frag_off = htons(offset);\n\t\t\t\tif (frag->next)\n\t\t\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\t\t\tfh->identification = frag_id;\n\t\t\t\tipv6_hdr(frag)->payload_len =\n\t\t\t\t\t\thtons(frag->len -\n\t\t\t\t\t\t      sizeof(struct ipv6hdr));\n\t\t\t\tip6_copy_metadata(frag, skb);\n	f
37412	4125	AscInitAsc1000Driver	drivers/scsi/advansys.c	fw->size - 4) != chksum	2	-11	\N	\N	\tconst struct firmware *fw;\n\tconst char fwname[] = "advansys/mcode.bin";\n\tint err;\n\tunsigned long chksum;\n\tint warn_code;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tif ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&\n\t    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {\n\t\tAscResetChipAndScsiBus(asc_dvc);\n\t\tmdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */\n\t}\n\tasc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;\n\tif (asc_dvc->err_code != 0)\n\t\treturn ASC_ERROR;\n\tif (!AscFindSignature(asc_dvc->iop_base)) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn warn_code;\n\t}\n\tAscDisableInterrupt(iop_base);\n\tAscInitLram(asc_dvc);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR "Failed to load image \\"%s\\" err %d\\n",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR "Bogus length %zu in image \\"%s\\"\\n",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tASC_DBG(1, "_asc_mcode_chksum 0x%lx\\n", (ulong)chksum);\n\tif (AscLoadMicroCode(iop_base, 0, &fw->data[4],\n	t
61909	769	iproc_gpio_probe	drivers/pinctrl/bcm/pinctrl-iproc-gpio.c	iproc_gpio_probe_	1	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct iproc_gpio *chip;\n\tstruct gpio_chip *gc;\n\tu32 ngpios, pinconf_disable_mask = 0;\n\tint irq, ret;\n\tbool no_pinconf = false;\n\n\t/* NSP does not support drive strength config */\n\tif (of_device_is_compatible(dev->of_node, "brcm,iproc-nsp-gpio"))\n\t\tpinconf_disable_mask = BIT(IPROC_PINCONF_DRIVE_STRENGTH);\n\t/* Stingray does not support pinconf in this controller */\n\telse if (of_device_is_compatible(dev->of_node,\n\t\t\t\t\t "brcm,iproc-stingray-gpio"))\n\t\tno_pinconf = true;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tplatform_set_drvdata(pdev, chip);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tchip->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(chip->base)) {\n\t\tdev_err(dev, "unable to map I/O memory\\n");\n\t\treturn PTR_ERR(chip->base);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tchip->io_ctrl = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(chip->io_ctrl)) {\n\t\t\tdev_err(dev, "unable to map I/O memory\\n");\n\t\t\treturn PTR_ERR(chip->io_ctrl);\n\t\t}\n\t}\n\n\tif (of_property_read_u32(dev->of_node, "ngpios", &ngpios)) {\n	f
44274	1882	ip_vs_in	net/netfilter/ipvs/ip_vs_core.c	iph.protocol	1	11	\N	\N	\tstruct ip_vs_iphdr iph;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tstruct ip_vs_conn *cp;\n\tint ret, pkts;\n\tint conn_reuse_mode;\n\tstruct sock *sk;\n\n\t/* Already marked as IPVS request or reply? */\n\tif (skb->ipvs_property)\n\t\treturn NF_ACCEPT;\n\n\t/*\n\t *\tBig tappo:\n\t *\t- remote client: only PACKET_HOST\n\t *\t- route: used for struct net when skb->dev is unset\n\t */\n\tif (unlikely((skb->pkt_type != PACKET_HOST &&\n\t\t      hooknum != NF_INET_LOCAL_OUT) ||\n\t\t     !skb_dst(skb))) {\n\t\tip_vs_fill_iph_skb(af, skb, false, &iph);\n\t\tIP_VS_DBG_BUF(12, "packet type=%d proto=%d daddr=%s"\n\t\t\t      " ignored in hook %u\\n",\n\t\t\t      skb->pkt_type, iph.protocol,\n\t\t\t      IP_VS_DBG_ADDR(af, &iph.daddr), hooknum);\n\t\treturn NF_ACCEPT;\n\t}\n\t/* ipvs enabled in this netns ? */\n\tif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\n\t\treturn NF_ACCEPT;\n\n\tip_vs_fill_iph_skb(af, skb, false, &iph);\n\n\t/* Bad... Do not break raw sockets */\n\tsk = skb_to_full_sk(skb);\n\tif (unlikely(sk && hooknum == NF_INET_LOCAL_OUT &&\n\t\t     af == AF_INET)) {\n\n\t\tif (sk->sk_family == PF_INET && inet_sk(sk)->nodefrag)\n\t\t\treturn NF_ACCEPT;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tif (unlikely(iph.protocol == IPPROTO_ICMPV6)) {\n	f
45041	266	ipv6_getorigdst	net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	&sin6.sin6_addr	1	11	\N	\N	\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tconst struct nf_conntrack_tuple_hash *h;\n\tstruct sockaddr_in6 sin6;\n\tstruct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };\n\tstruct nf_conn *ct;\n\n\ttuple.src.u3.in6 = sk->sk_v6_rcv_saddr;\n\ttuple.src.u.tcp.port = inet->inet_sport;\n\ttuple.dst.u3.in6 = sk->sk_v6_daddr;\n\ttuple.dst.u.tcp.port = inet->inet_dport;\n\ttuple.dst.protonum = sk->sk_protocol;\n\n\tif (sk->sk_protocol != IPPROTO_TCP && sk->sk_protocol != IPPROTO_SCTP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (*len < 0 || (unsigned int) *len < sizeof(sin6))\n\t\treturn -EINVAL;\n\n\th = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);\n\tif (!h) {\n\t\tpr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\\n",\n\t\t\t &tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),\n\t\t\t &tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));\n\t\treturn -ENOENT;\n\t}\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;\n\tsin6.sin6_flowinfo = inet6->flow_label & IPV6_FLOWINFO_MASK;\n\tmemcpy(&sin6.sin6_addr,\n\t\t&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,\n\t\t\t\t\tsizeof(sin6.sin6_addr));\n\n\tnf_ct_put(ct);\n\tsin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr,\n	f
47349	537	ipvlan_xmit_mode_l2	drivers/net/ipvlan/ipvlan_core.c	addr_type	1	11	\N	\N	\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ethhdr *eth = eth_hdr(skb);\n\tstruct ipvl_addr *addr;\n\tvoid *lyr3h;\n\tint addr_type;\n\n\tif (ether_addr_equal(eth->h_dest, eth->h_source)) {\n\t\tlyr3h = ipvlan_get_L3_hdr(skb, &addr_type);\n\t\tif (lyr3h) {\n\t\t\taddr = ipvlan_addr_lookup(ipvlan->port, lyr3h, addr_type, true);\n	f
46504	244	ioctl_file_clone_range	fs/ioctl.c	args.src_fd	1	11	\N	\N	\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n	t
28268	291	ip_options_compile	net/ipv4/ip_options.c	optlen	0	11	\N	\N	\t__be32 spec_dst = htonl(INADDR_ANY);\n\tunsigned char *pp_ptr = NULL;\n\tstruct rtable *rt = NULL;\n\tunsigned char *optptr;\n\tunsigned char *iph;\n\tint optlen, l;\n\n\tif (skb) {\n\t\trt = skb_rtable(skb);\n\t\toptptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\t} else\n\t\toptptr = opt->__data;\n\tiph = optptr - sizeof(struct iphdr);\n\n\tfor (l = opt->optlen; l > 0; ) {\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_END:\n\t\t\tfor (optptr++, l--; l > 0; optptr++, l--) {\n\t\t\t\tif (*optptr != IPOPT_END) {\n\t\t\t\t\t*optptr = IPOPT_END;\n\t\t\t\t\topt->is_changed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto eol;\n\t\tcase IPOPT_NOOP:\n\t\t\tl--;\n\t\t\toptptr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(l < 2)) {\n\t\t\tpp_ptr = optptr;\n\t\t\tgoto error;\n\t\t}\n\t\toptlen = optptr[1];\n\t\tif (optlen < 2 || optlen > l) {\n	f
2201	2771	efx_farch_filter_table_restore	drivers/net/ethernet/sfc/farch.c	&filter	1	11	\N	\N	\tstruct efx_farch_filter_state *state = efx->filter_state;\n\tenum efx_farch_filter_table_id table_id;\n\tstruct efx_farch_filter_table *table;\n\tefx_oword_t filter;\n\tunsigned int filter_idx;\n\n\tspin_lock_bh(&efx->filter_lock);\n\n\tfor (table_id = 0; table_id < EFX_FARCH_FILTER_TABLE_COUNT; table_id++) {\n\t\ttable = &state->table[table_id];\n\n\t\t/* Check whether this is a regular register table */\n\t\tif (table->step == 0)\n\t\t\tcontinue;\n\n\t\tfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\n\t\t\tif (!test_bit(filter_idx, table->used_bitmap))\n\t\t\t\tcontinue;\n\t\t\tefx_farch_filter_build(&filter, &table->spec[filter_idx]);\n	t
2323	404	exynos_ppmu_v2_set_event	drivers/devfreq/event/exynos-ppmu.c	pmnc	1	11	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tunsigned int pmnc, cntens;\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\n\t/* Enable all counters */\n\tret = regmap_read(info->regmap, PPMU_V2_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Set the event of Read/Write data count  */\n\tswitch (id) {\n\tcase PPMU_PMNCNT0:\n\tcase PPMU_PMNCNT1:\n\tcase PPMU_PMNCNT2:\n\t\tret = regmap_write(info->regmap, PPMU_V2_CH_EVx_TYPE(id),\n\t\t\t\tPPMU_V2_RO_DATA_CNT | PPMU_V2_WO_DATA_CNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PPMU_PMNCNT3:\n\t\tret = regmap_write(info->regmap, PPMU_V2_CH_EVx_TYPE(id),\n\t\t\t\tPPMU_V2_EVT3_RW_DATA_CNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* Reset cycle counter/performance counter and enable PPMU */\n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_DIVIDER_MASK\n\t\t\t| PPMU_V2_PMNC_START_MODE_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tpmnc |= (PPMU_V2_MODE_MANUAL << PPMU_V2_PMNC_START_MODE_SHIFT);\n\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n	t
20198	498	__napi_alloc_skb	net/core/skbuff.c	skb	1	11	\N	\N	\tstruct napi_alloc_cache *nc = this_cpu_ptr(&napi_alloc_cache);\n\tstruct sk_buff *skb;\n\tvoid *data;\n\n\tlen += NET_SKB_PAD + NET_IP_ALIGN;\n\n\tif ((len > SKB_WITH_OVERHEAD(PAGE_SIZE)) ||\n\t    (gfp_mask & (__GFP_DIRECT_RECLAIM | GFP_DMA))) {\n\t\tskb = __alloc_skb(len, gfp_mask, SKB_ALLOC_RX, NUMA_NO_NODE);\n\t\tif (!skb)\n\t\t\tgoto skb_fail;\n\t\tgoto skb_success;\n\t}\n\n\tlen += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tlen = SKB_DATA_ALIGN(len);\n\n\tif (sk_memalloc_socks())\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\n\tdata = page_frag_alloc(&nc->page, len, gfp_mask);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\n\tskb = __build_skb(data, len);\n\tif (unlikely(!skb)) {\n\t\tskb_free_frag(data);\n\t\treturn NULL;\n\t}\n\n\t/* use OR instead of assignment to avoid clearing of bits in mask */\n\tif (nc->page.pfmemalloc)\n\t\tskb->pfmemalloc = 1;\n\tskb->head_frag = 1;\n\nskb_success:\n\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);\n	f
40972	856	mcba_usb_probe	drivers/net/can/usb/mcba_usb.c	err	2	-11	\N	\N	\tstruct net_device *netdev;\n\tstruct mcba_priv *priv;\n\tint err = -ENOMEM;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\tnetdev = alloc_candev(sizeof(struct mcba_priv), MCBA_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, "Couldn't alloc candev\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\tpriv->usb_ka_first_pass = true;\n\tpriv->can_ka_first_pass = true;\n\tpriv->can_speed_check = false;\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\tinit_usb_anchor(&priv->tx_submitted);\n\n\tusb_set_intfdata(intf, priv);\n\n\t/* Init CAN device */\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.termination_const = mcba_termination;\n\tpriv->can.termination_const_cnt = ARRAY_SIZE(mcba_termination);\n\tpriv->can.bitrate_const = mcba_bitrate;\n\tpriv->can.bitrate_const_cnt = ARRAY_SIZE(mcba_bitrate);\n\n\tpriv->can.do_set_termination = mcba_set_termination;\n\tpriv->can.do_set_mode = mcba_net_set_mode;\n\tpriv->can.do_get_berr_counter = mcba_net_get_berr_counter;\n\tpriv->can.do_set_bittiming = mcba_net_set_bittiming;\n\n\tnetdev->netdev_ops = &mcba_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, "couldn't register CAN device: %d\\n", err);\n\n\t\tgoto cleanup_free_candev;\n\t}\n\n\tdevm_can_led_init(netdev);\n\n\t/* Start USB dev only if we have successfully registered CAN device */\n\terr = mcba_usb_start(priv);\n\tif (err) {\n	f
39416	1725	is_trap_at_addr	kernel/events/uprobes.c	page	1	11	\N	\N	\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n	f
24349	355	match_mnt_path_str	security/apparmor/mount.c	&perms	1	11	\N	\N	\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n	t
58372	673	isight_probe	sound/firewire/isight.c	isight->unit	1	11	\N	\N	\tstruct fw_device *fw_dev = fw_parent_device(unit);\n\tstruct snd_card *card;\n\tstruct isight *isight;\n\tint err;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,\n\t\t\t   sizeof(*isight), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tisight = card->private_data;\n\tisight->card = card;\n\tmutex_init(&isight->mutex);\n\tisight->unit = fw_unit_get(unit);\n\tisight->device = fw_dev;\n\tisight->audio_base = get_unit_base(unit);\n\tif (!isight->audio_base) {\n\t\tdev_err(&unit->device, "audio unit base not found\\n");\n\t\terr = -ENXIO;\n\t\tgoto err_unit;\n\t}\n\tfw_iso_resources_init(&isight->resources, unit);\n\n\tcard->private_free = isight_card_free;\n\n\tstrcpy(card->driver, "iSight");\n\tstrcpy(card->shortname, "Apple iSight");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t "Apple iSight (GUID %08x%08x) at %s, S%d",\n\t\t fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t dev_name(&unit->device), 100 << fw_dev->max_speed);\n\tstrcpy(card->mixername, "iSight");\n\n\terr = isight_create_pcm(isight);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = isight_create_mixer(isight);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdev_set_drvdata(&unit->device, isight);\n\n\treturn 0;\n\nerr_unit:\n\tfw_unit_put(isight->unit);\n	f
2330	174	exynos_ppmu_set_event	drivers/devfreq/event/exynos-ppmu.c	pmnc	1	11	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\tu32 pmnc, cntens;\n\n\tif (id < 0)\n\t\treturn id;\n\n\t/* Enable specific counter */\n\tret = regmap_read(info->regmap, PPMU_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Set the event of Read/Write data count  */\n\tret = regmap_write(info->regmap, PPMU_BEVTxSEL(id),\n\t\t\t\tPPMU_RO_DATA_CNT | PPMU_WO_DATA_CNT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Reset cycle counter/performance counter and enable PPMU */\n\tret = regmap_read(info->regmap, PPMU_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tret = regmap_write(info->regmap, PPMU_PMNC, pmnc);\n	t
2377	109	mtk_rtc_irq_handler_thread	drivers/rtc/rtc-mt6397.c	irqsta	1	11	\N	\N	\tstruct mt6397_rtc *rtc = data;\n\tu32 irqsta, irqen;\n\tint ret;\n\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_IRQ_STA, &irqsta);\n\tif ((ret >= 0) && (irqsta & RTC_IRQ_STA_AL)) {\n	t
51943	754	kszphy_probe	drivers/net/phy/micrel.c	priv->led_mode	1	11	\N	\N	\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tconst struct device_node *np = phydev->mdio.dev.of_node;\n\tstruct kszphy_priv *priv;\n\tstruct clk *clk;\n\tint ret;\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tpriv->type = type;\n\n\tif (type->led_mode_reg) {\n\t\tret = of_property_read_u32(np, "micrel,led-mode",\n\t\t\t\t&priv->led_mode);\n\t\tif (ret)\n\t\t\tpriv->led_mode = -1;\n\n\t\tif (priv->led_mode > 3) {\n	f
25918	889	mcp23s08_probe_one	drivers/pinctrl/pinctrl-mcp23s08.c	status	1	11	\N	\N	\tint status, ret;\n\tbool mirror = false;\n\n\tmutex_init(&mcp->lock);\n\n\tmcp->dev = dev;\n\tmcp->addr = addr;\n\tmcp->irq_active_high = false;\n\n\tmcp->chip.direction_input = mcp23s08_direction_input;\n\tmcp->chip.get = mcp23s08_get;\n\tmcp->chip.direction_output = mcp23s08_direction_output;\n\tmcp->chip.set = mcp23s08_set;\n\tmcp->chip.dbg_show = mcp23s08_dbg_show;\n#ifdef CONFIG_OF_GPIO\n\tmcp->chip.of_gpio_n_cells = 2;\n\tmcp->chip.of_node = dev->of_node;\n#endif\n\n\tswitch (type) {\n#ifdef CONFIG_SPI_MASTER\n\tcase MCP_TYPE_S08:\n\t\tmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\n\t\t\t\t\t       &mcp23x08_regmap);\n\t\tmcp->reg_shift = 0;\n\t\tmcp->chip.ngpio = 8;\n\t\tmcp->chip.label = "mcp23s08";\n\t\tbreak;\n\n\tcase MCP_TYPE_S17:\n\t\tmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\n\t\t\t\t\t       &mcp23x17_regmap);\n\t\tmcp->reg_shift = 1;\n\t\tmcp->chip.ngpio = 16;\n\t\tmcp->chip.label = "mcp23s17";\n\t\tbreak;\n\n\tcase MCP_TYPE_S18:\n\t\tmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\n\t\t\t\t\t       &mcp23x17_regmap);\n\t\tmcp->reg_shift = 1;\n\t\tmcp->chip.ngpio = 16;\n\t\tmcp->chip.label = "mcp23s18";\n\t\tbreak;\n#endif /* CONFIG_SPI_MASTER */\n\n#if IS_ENABLED(CONFIG_I2C)\n\tcase MCP_TYPE_008:\n\t\tmcp->regmap = devm_regmap_init_i2c(data, &mcp23x08_regmap);\n\t\tmcp->reg_shift = 0;\n\t\tmcp->chip.ngpio = 8;\n\t\tmcp->chip.label = "mcp23008";\n\t\tbreak;\n\n\tcase MCP_TYPE_017:\n\t\tmcp->regmap = devm_regmap_init_i2c(data, &mcp23x17_regmap);\n\t\tmcp->reg_shift = 1;\n\t\tmcp->chip.ngpio = 16;\n\t\tmcp->chip.label = "mcp23017";\n\t\tbreak;\n#endif /* CONFIG_I2C */\n\n\tdefault:\n\t\tdev_err(dev, "invalid device type (%d)\\n", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(mcp->regmap))\n\t\treturn PTR_ERR(mcp->regmap);\n\n\tmcp->chip.base = base;\n\tmcp->chip.can_sleep = true;\n\tmcp->chip.parent = dev;\n\tmcp->chip.owner = THIS_MODULE;\n\n\t/* verify MCP_IOCON.SEQOP = 0, so sequential reads work,\n\t * and MCP_IOCON.HAEN = 1, so we work with all chips.\n\t */\n\n\tret = mcp_read(mcp, MCP_IOCON, &status);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tmcp->irq_controller =\n\t\tdevice_property_read_bool(dev, "interrupt-controller");\n\tif (mcp->irq && mcp->irq_controller) {\n\t\tmcp->irq_active_high =\n\t\t\tdevice_property_read_bool(dev,\n\t\t\t\t\t      "microchip,irq-active-high");\n\n\t\tmirror = device_property_read_bool(dev, "microchip,irq-mirror");\n\t}\n\n\tif ((status & IOCON_SEQOP) || !(status & IOCON_HAEN) || mirror ||\n\t     mcp->irq_active_high) {\n\t\t/* mcp23s17 has IOCON twice, make sure they are in sync */\n\t\tstatus &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));\n\t\tstatus |= IOCON_HAEN | (IOCON_HAEN << 8);\n\t\tif (mcp->irq_active_high)\n\t\t\tstatus |= IOCON_INTPOL | (IOCON_INTPOL << 8);\n\t\telse\n\t\t\tstatus &= ~(IOCON_INTPOL | (IOCON_INTPOL << 8));\n\n\t\tif (mirror)\n\t\t\tstatus |= IOCON_MIRROR | (IOCON_MIRROR << 8);\n\n\t\tif (type == MCP_TYPE_S18)\n\t\t\tstatus |= IOCON_INTCC | (IOCON_INTCC << 8);\n\n\t\tret = mcp_write(mcp, MCP_IOCON, status);\n	f
2432	259	s5m_check_peding_alarm_interrupt	drivers/rtc/rtc-s5m.c	val	1	11	\N	\N	\tint ret;\n\tunsigned int val;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S5M8763X:\n\t\tret = regmap_read(info->regmap, S5M_RTC_STATUS, &val);\n\t\tval &= S5M_ALARM0_STATUS;\n\t\tbreak;\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tret = regmap_read(info->s5m87xx->regmap_pmic, S2MPS14_REG_ST2,\n\t\t\t\t&val);\n\t\tval &= S2MPS_ALARM0_STATUS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val)\n	t
41151	223	dccp_v6_send_response	net/dccp/ipv6.c	skb	2	-11	\N	\N	\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n	f
42438	448	gs_usb_set_bittiming	drivers/net/can/usb/gs_usb.c	rc	2	-11	\N	\N	\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct usb_interface *intf = dev->iface;\n\tint rc;\n\tstruct gs_device_bittiming *dbt;\n\n\tdbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\n\tif (!dbt)\n\t\treturn -ENOMEM;\n\n\tdbt->prop_seg = bt->prop_seg;\n\tdbt->phase_seg1 = bt->phase_seg1;\n\tdbt->phase_seg2 = bt->phase_seg2;\n\tdbt->sjw = bt->sjw;\n\tdbt->brp = bt->brp;\n\n\t/* request bit timings */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BITTIMING,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dbt,\n\t\t\t     sizeof(*dbt),\n\t\t\t     1000);\n\n\tkfree(dbt);\n\n\tif (rc < 0)\n	f
26880	104	lis3lv02d_acpi_init	drivers/platform/x86/hp_accel.c	lis3lv02d_acpi_init_	0	11	\N	\N	\tstruct acpi_device *dev = lis3->bus_priv;\n\tif (acpi_evaluate_object(dev->handle, METHOD_NAME__INI,\n	f
36957	3989	lan78xx_reset_resume	drivers/net/usb/lan78xx.c	dev	1	11	\N	\N	\tstruct lan78xx_net *dev = usb_get_intfdata(intf);\n\n\tlan78xx_reset(dev);\n\n\tlan78xx_phy_init(dev);\n	f
61401	1199	ksz_switch_register	drivers/net/dsa/microchip/ksz_common.c	dev	1	11	\N	\N	\tint ret;\n\n\tif (dev->pdata)\n\t\tdev->chip_id = dev->pdata->chip_id;\n\n\tif (ksz_switch_detect(dev))\n\t\treturn -EINVAL;\n\n\tret = ksz_switch_init(dev);\n	f
33335	2163	binder_transaction_buffer_release	drivers/android/binder.c	rdata.desc	1	-1	\N	postcondition error	\tbinder_size_t *offp, *off_start, *off_end;\n\tint debug_id = buffer->debug_id;\n\n\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t     "%d buffer release %d, size %zd-%zd, failed at %p\\n",\n\t\t     proc->pid, buffer->debug_id,\n\t\t     buffer->data_size, buffer->offsets_size, failed_at);\n\n\tif (buffer->target_node)\n\t\tbinder_dec_node(buffer->target_node, 1, 0);\n\n\toff_start = (binder_size_t *)(buffer->data +\n\t\t\t\t      ALIGN(buffer->data_size, sizeof(void *)));\n\tif (failed_at)\n\t\toff_end = failed_at;\n\telse\n\t\toff_end = (void *)off_start + buffer->offsets_size;\n\tfor (offp = off_start; offp < off_end; offp++) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size = binder_validate_object(buffer, *offp);\n\n\t\tif (object_size == 0) {\n\t\t\tpr_err("transaction release %d bad object at offset %lld, size %zd\\n",\n\t\t\t       debug_id, (u64)*offp, buffer->data_size);\n\t\t\tcontinue;\n\t\t}\n\t\thdr = (struct binder_object_header *)(buffer->data + *offp);\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\t\t\tstruct binder_node *node;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tnode = binder_get_node(proc, fp->binder);\n\t\t\tif (node == NULL) {\n\t\t\t\tpr_err("transaction release %d bad node %016llx\\n",\n\t\t\t\t       debug_id, (u64)fp->binder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t\t     "        node %d u%016llx\\n",\n\t\t\t\t     node->debug_id, (u64)node->ptr);\n\t\t\tbinder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,\n\t\t\t\t\t0);\n\t\t\tbinder_put_node(node);\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\t\t\tstruct binder_ref_data rdata;\n\t\t\tint ret;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_dec_ref_for_handle(proc, fp->handle,\n\t\t\t\thdr->type == BINDER_TYPE_HANDLE, &rdata);\n\n\t\t\tif (ret) {\n\t\t\t\tpr_err("transaction release %d bad handle %d, ret = %d\\n",\n\t\t\t\t debug_id, fp->handle, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n	f
58282	2736	kvm_vcpu_compat_ioctl	virt/kvm/kvm_main.c	kvm_sigmask.len	0	11	\N	\N	\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = compat_ptr(arg);\n\tint r;\n\n\tif (vcpu->kvm->mm != current->mm)\n\t\treturn -EIO;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tcompat_sigset_t csigset;\n\t\tsigset_t sigset;\n\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(csigset))\n	f
2442	97	ds1374_read_rtc	drivers/rtc/rtc-ds1374.c	ret	1	11	\N	\N	\tu8 buf[4];\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(nbytes > 4))\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, nbytes, buf);\n\n\tif (ret < 0)\n	t
43729	481	i8k_ioctl_unlocked	drivers/hwmon/dell-smm-hwmon.c	speed	2	-11	\N	\N	\tint val = 0;\n\tint speed;\n\tunsigned char buff[16];\n\tint __user *argp = (int __user *)arg;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase I8K_BIOS_VERSION:\n\t\tif (!isdigit(bios_version[0]) || !isdigit(bios_version[1]) ||\n\t\t    !isdigit(bios_version[2]))\n\t\t\treturn -EINVAL;\n\n\t\tval = (bios_version[0] << 16) |\n\t\t\t\t(bios_version[1] << 8) | bios_version[2];\n\t\tbreak;\n\n\tcase I8K_MACHINE_ID:\n\t\tif (restricted && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tmemset(buff, 0, sizeof(buff));\n\t\tstrlcpy(buff, bios_machineid, sizeof(buff));\n\t\tbreak;\n\n\tcase I8K_FN_STATUS:\n\t\tval = i8k_get_fn_status();\n\t\tbreak;\n\n\tcase I8K_POWER_STATUS:\n\t\tval = i8k_get_power_status();\n\t\tbreak;\n\n\tcase I8K_GET_TEMP:\n\t\tval = i8k_get_temp(0);\n\t\tbreak;\n\n\tcase I8K_GET_SPEED:\n\t\tif (copy_from_user(&val, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tval = i8k_get_fan_speed(val);\n\t\tbreak;\n\n\tcase I8K_GET_FAN:\n\t\tif (copy_from_user(&val, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tval = i8k_get_fan_status(val);\n\t\tbreak;\n\n\tcase I8K_SET_FAN:\n\t\tif (restricted && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&val, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&speed, argp + 1, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tval = i8k_set_fan(val, speed);\n	f
42279	372	llc_ui_bind	net/llc/af_llc.c	ask	1	11	\N	\N	\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tdprintk("%s: binding %02X\\n", __func__, addr->sllc_sap);\n\n\tlock_sock(sk);\n\tif (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (unlikely(addr->sllc_family != AF_LLC))\n\t\tgoto out;\n\trc = -ENODEV;\n\trcu_read_lock();\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev) {\n\t\t\tif (!addr->sllc_arphrd)\n\t\t\t\taddr->sllc_arphrd = llc->dev->type;\n\t\t\tif (is_zero_ether_addr(addr->sllc_mac))\n\t\t\t\tmemcpy(addr->sllc_mac, llc->dev->dev_addr,\n\t\t\t\t       IFHWADDRLEN);\n\t\t\tif (addr->sllc_arphrd != llc->dev->type ||\n\t\t\t    !ether_addr_equal(addr->sllc_mac,\n\t\t\t\t\t      llc->dev->dev_addr)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tllc->dev = NULL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tllc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,\n\t\t\t\t\t   addr->sllc_mac);\n\tif (llc->dev)\n\t\tdev_hold(llc->dev);\n\trcu_read_unlock();\n\tif (!llc->dev)\n\t\tgoto out;\n\tif (!addr->sllc_sap) {\n\t\trc = -EUSERS;\n\t\taddr->sllc_sap = llc_ui_autoport();\n\t\tif (!addr->sllc_sap)\n\t\t\tgoto out;\n\t}\n\tsap = llc_sap_find(addr->sllc_sap);\n\tif (!sap) {\n\t\tsap = llc_sap_open(addr->sllc_sap, NULL);\n\t\trc = -EBUSY; /* some other network layer is using the sap */\n\t\tif (!sap)\n\t\t\tgoto out;\n\t} else {\n\t\tstruct llc_addr laddr, daddr;\n\t\tstruct sock *ask;\n\n\t\tmemset(&laddr, 0, sizeof(laddr));\n\t\tmemset(&daddr, 0, sizeof(daddr));\n\t\t/*\n\t\t * FIXME: check if the address is multicast,\n\t\t * \t  only SOCK_DGRAM can do this.\n\t\t */\n\t\tmemcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\t\tladdr.lsap = addr->sllc_sap;\n\t\trc = -EADDRINUSE; /* mac + sap clash. */\n\t\task = llc_lookup_established(sap, &daddr, &laddr);\n\t\tif (ask) {\n	f
41399	292	lowpan_frag_reasm	net/ieee802154/6lowpan/reassembly.c	headstolen	1	11	\N	\N	\tstruct sk_buff *fp, *head = fq->q.fragments;\n\tint sum_truesize;\n\n\tinet_frag_kill(&fq->q, &lowpan_frags);\n\n\t/* Make the one we just received the head. */\n\tif (prev) {\n\t\thead = prev->next;\n\t\tfp = skb_clone(head, GFP_ATOMIC);\n\n\t\tif (!fp)\n\t\t\tgoto out_oom;\n\n\t\tfp->next = head->next;\n\t\tif (!fp->next)\n\t\t\tfq->q.fragments_tail = fp;\n\t\tprev->next = fp;\n\n\t\tskb_morph(head, fq->q.fragments);\n\t\thead->next = fq->q.fragments->next;\n\n\t\tconsume_skb(fq->q.fragments);\n\t\tfq->q.fragments = head;\n\t}\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\tgoto out_oom;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments.\n\t */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (!clone)\n\t\t\tgoto out_oom;\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = head->data_len - plen;\n\t\tclone->data_len = clone->len;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tadd_frag_mem_limit(fq->q.net, clone->truesize);\n\t}\n\n\tWARN_ON(head == NULL);\n\n\tsum_truesize = head->truesize;\n\tfor (fp = head->next; fp;) {\n\t\tbool headstolen;\n\t\tint delta;\n\t\tstruct sk_buff *next = fp->next;\n\n\t\tsum_truesize += fp->truesize;\n\t\tif (skb_try_coalesce(head, fp, &headstolen, &delta)) {\n\t\t\tkfree_skb_partial(fp, headstolen);\n	f
26039	2183	netlink_dump	net/netlink/af_netlink.c	skb	1	11	\N	\N	\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tstruct module *module;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\n\t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n\t * required, but it makes sense to _attempt_ a 16K bytes allocation\n\t * to reduce number of system calls on dump operations, if user\n\t * ever provided a big enough buffer.\n\t */\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size,\n\t\t\t\t(GFP_KERNEL & ~__GFP_DIRECT_RECLAIM) |\n\t\t\t\t__GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\n\t/* Trim skb to allocated size. User is expected to provide buffer as\n\t * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at\n\t * netlink_recvmsg())). dump will pack as many smaller messages as\n\t * could fit within the allocated skb. skb is typically allocated\n\t * with larger space than required (could be as much as near 2x the\n\t * requested size with align to next power of 2 approach). Allowing\n\t * dump to use the excess space makes it difficult for a user to have a\n\t * reasonable static buffer based on the expected largest dump of a\n\t * single netdev. The outcome is MSG_TRUNC error.\n\t */\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n	f
46357	506	hidled_probe	drivers/hid/hid-led.c	hidled_probe_$ldev$obj$0$obj$1$obj	0	13	\N	\N	\tstruct hidled_device *ldev;\n\tunsigned int minor;\n\tint ret, i;\n\n\tldev = devm_kzalloc(&hdev->dev, sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev)\n\t\treturn -ENOMEM;\n\n\tldev->buf = devm_kmalloc(&hdev->dev, MAX_REPORT_SIZE, GFP_KERNEL);\n\tif (!ldev->buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tldev->hdev = hdev;\n\tmutex_init(&ldev->lock);\n\n\tfor (i = 0; !ldev->config && i < ARRAY_SIZE(hidled_configs); i++)\n\t\tif (hidled_configs[i].type == id->driver_data)\n\t\t\tldev->config = &hidled_configs[i];\n\n\tif (!ldev->config)\n\t\treturn -EINVAL;\n\n\tif (ldev->config->init) {\n\t\tret = ldev->config->init(ldev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tldev->rgb = devm_kcalloc(&hdev->dev, ldev->config->num_leds,\n\t\t\t\t sizeof(struct hidled_rgb), GFP_KERNEL);\n\tif (!ldev->rgb)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tfor (i = 0; i < ldev->config->num_leds; i++) {\n\t\tldev->rgb[i].ldev = ldev;\n\t\tldev->rgb[i].num = i;\n\t\tret = hidled_init_rgb(&ldev->rgb[i], minor);\n\t\tif (ret) {\n\t\t\thid_hw_stop(hdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thid_info(hdev, "%s initialized\\n", ldev->config->name);\n	f
21014	2343	acpi_nfit_init_mapping	drivers/acpi/nfit/core.c	nfit_spa->nd_region	2	-11	\N	\N	\tstruct nvdimm *nvdimm = acpi_nfit_dimm_by_handle(acpi_desc,\n\t\t\tmemdev->device_handle);\n\tstruct acpi_nfit_system_address *spa = nfit_spa->spa;\n\tstruct nd_blk_region_desc *ndbr_desc;\n\tstruct nfit_mem *nfit_mem;\n\tint blk_valid = 0, rc;\n\n\tif (!nvdimm) {\n\t\tdev_err(acpi_desc->dev, "spa%d dimm: %#x not found\\n",\n\t\t\t\tspa->range_index, memdev->device_handle);\n\t\treturn -ENODEV;\n\t}\n\n\tmapping->nvdimm = nvdimm;\n\tswitch (nfit_spa_type(spa)) {\n\tcase NFIT_SPA_PM:\n\tcase NFIT_SPA_VOLATILE:\n\t\tmapping->start = memdev->address;\n\t\tmapping->size = memdev->region_size;\n\t\tbreak;\n\tcase NFIT_SPA_DCR:\n\t\tnfit_mem = nvdimm_provider_data(nvdimm);\n\t\tif (!nfit_mem || !nfit_mem->bdw) {\n\t\t\tdev_dbg(acpi_desc->dev, "spa%d %s missing bdw\\n",\n\t\t\t\t\tspa->range_index, nvdimm_name(nvdimm));\n\t\t} else {\n\t\t\tmapping->size = nfit_mem->bdw->capacity;\n\t\t\tmapping->start = nfit_mem->bdw->start_address;\n\t\t\tndr_desc->num_lanes = nfit_mem->bdw->windows;\n\t\t\tblk_valid = 1;\n\t\t}\n\n\t\tndr_desc->mapping = mapping;\n\t\tndr_desc->num_mappings = blk_valid;\n\t\tndbr_desc = to_blk_region_desc(ndr_desc);\n\t\tndbr_desc->enable = acpi_nfit_blk_region_enable;\n\t\tndbr_desc->do_io = acpi_desc->blk_do_io;\n\t\trc = acpi_nfit_init_interleave_set(acpi_desc, ndr_desc, spa);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tnfit_spa->nd_region = nvdimm_blk_region_create(acpi_desc->nvdimm_bus,\n\t\t\t\tndr_desc);\n\t\tif (!nfit_spa->nd_region)\n	f
2472	386	pm8xxx_rtc_enable	drivers/rtc/rtc-pm8xxx.c	ctrl_reg	1	11	\N	\N	\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tunsigned int ctrl_reg;\n\tint rc;\n\n\t/* Check if the RTC is on, else turn it on */\n\trc = regmap_read(rtc_dd->regmap, regs->ctrl, &ctrl_reg);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(ctrl_reg & PM8xxx_RTC_ENABLE)) {\n	t
46461	664	log_writes_map	drivers/md/dm-log-writes.c	dst	2	-11	\N	\N	\tstruct log_writes_c *lc = ti->private;\n\tstruct per_bio_data *pb = dm_per_bio_data(bio, sizeof(struct per_bio_data));\n\tstruct pending_block *block;\n\tstruct bvec_iter iter;\n\tstruct bio_vec bv;\n\tsize_t alloc_size;\n\tint i = 0;\n\tbool flush_bio = (bio->bi_opf & REQ_PREFLUSH);\n\tbool fua_bio = (bio->bi_opf & REQ_FUA);\n\tbool discard_bio = (bio_op(bio) == REQ_OP_DISCARD);\n\n\tpb->block = NULL;\n\n\t/* Don't bother doing anything if logging has been disabled */\n\tif (!lc->logging_enabled)\n\t\tgoto map_bio;\n\n\t/*\n\t * Map reads as normal.\n\t */\n\tif (bio_data_dir(bio) == READ)\n\t\tgoto map_bio;\n\n\t/* No sectors and not a flush?  Don't care */\n\tif (!bio_sectors(bio) && !flush_bio)\n\t\tgoto map_bio;\n\n\t/*\n\t * Discards will have bi_size set but there's no actual data, so just\n\t * allocate the size of the pending block.\n\t */\n\tif (discard_bio)\n\t\talloc_size = sizeof(struct pending_block);\n\telse\n\t\talloc_size = sizeof(struct pending_block) + sizeof(struct bio_vec) * bio_segments(bio);\n\n\tblock = kzalloc(alloc_size, GFP_NOIO);\n\tif (!block) {\n\t\tDMERR("Error allocating pending block");\n\t\tspin_lock_irq(&lc->blocks_lock);\n\t\tlc->logging_enabled = false;\n\t\tspin_unlock_irq(&lc->blocks_lock);\n\t\treturn DM_MAPIO_KILL;\n\t}\n\tINIT_LIST_HEAD(&block->list);\n\tpb->block = block;\n\tatomic_inc(&lc->pending_blocks);\n\n\tif (flush_bio)\n\t\tblock->flags |= LOG_FLUSH_FLAG;\n\tif (fua_bio)\n\t\tblock->flags |= LOG_FUA_FLAG;\n\tif (discard_bio)\n\t\tblock->flags |= LOG_DISCARD_FLAG;\n\n\tblock->sector = bio_to_dev_sectors(lc, bio->bi_iter.bi_sector);\n\tblock->nr_sectors = bio_to_dev_sectors(lc, bio_sectors(bio));\n\n\t/* We don't need the data, just submit */\n\tif (discard_bio) {\n\t\tWARN_ON(flush_bio || fua_bio);\n\t\tif (lc->device_supports_discard)\n\t\t\tgoto map_bio;\n\t\tbio_endio(bio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\t/* Flush bio, splice the unflushed blocks onto this list and submit */\n\tif (flush_bio && !bio_sectors(bio)) {\n\t\tspin_lock_irq(&lc->blocks_lock);\n\t\tlist_splice_init(&lc->unflushed_blocks, &block->list);\n\t\tspin_unlock_irq(&lc->blocks_lock);\n\t\tgoto map_bio;\n\t}\n\n\t/*\n\t * We will write this bio somewhere else way later so we need to copy\n\t * the actual contents into new pages so we know the data will always be\n\t * there.\n\t *\n\t * We do this because this could be a bio from O_DIRECT in which case we\n\t * can't just hold onto the page until some later point, we have to\n\t * manually copy the contents.\n\t */\n\tbio_for_each_segment(bv, bio, iter) {\n\t\tstruct page *page;\n\t\tvoid *src, *dst;\n\n\t\tpage = alloc_page(GFP_NOIO);\n\t\tif (!page) {\n\t\t\tDMERR("Error allocing page");\n\t\t\tfree_pending_block(lc, block);\n\t\t\tspin_lock_irq(&lc->blocks_lock);\n\t\t\tlc->logging_enabled = false;\n\t\t\tspin_unlock_irq(&lc->blocks_lock);\n\t\t\treturn DM_MAPIO_KILL;\n\t\t}\n\n\t\tsrc = kmap_atomic(bv.bv_page);\n\t\tdst = kmap_atomic(page);\n\t\tmemcpy(dst, src + bv.bv_offset, bv.bv_len);\n	t
20955	883	hip04_mac_probe	drivers/net/ethernet/hisilicon/hip04_eth.c	priv->phy_node	1	-1	\N	\N	\tstruct device *d = &pdev->dev;\n\tstruct device_node *node = d->of_node;\n\tstruct of_phandle_args arg;\n\tstruct net_device *ndev;\n\tstruct hip04_priv *priv;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(struct hip04_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->base = devm_ioremap_resource(d, res);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto init_fail;\n\t}\n\n\tret = of_parse_phandle_with_fixed_args(node, "port-handle", 2, 0, &arg);\n\tif (ret < 0) {\n\t\tdev_warn(d, "no port-handle\\n");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->port = arg.args[0];\n\tpriv->chan = arg.args[1] * RX_DESC_NUM;\n\n\thrtimer_init(&priv->tx_coalesce_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\n\t/* BQL will try to keep the TX queue as short as possible, but it can't\n\t * be faster than tx_coalesce_usecs, so we need a fast timeout here,\n\t * but also long enough to gather up enough frames to ensure we don't\n\t * get more interrupts than necessary.\n\t * 200us is enough for 16 frames of 1500 bytes at gigabit ethernet rate\n\t */\n\tpriv->tx_coalesce_frames = TX_DESC_NUM * 3 / 4;\n\tpriv->tx_coalesce_usecs = 200;\n\tpriv->tx_coalesce_timer.function = tx_done;\n\n\tpriv->map = syscon_node_to_regmap(arg.np);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_warn(d, "no syscon hisilicon,hip04-ppe\\n");\n\t\tret = PTR_ERR(priv->map);\n\t\tgoto init_fail;\n\t}\n\n\tpriv->phy_mode = of_get_phy_mode(node);\n\tif (priv->phy_mode < 0) {\n\t\tdev_warn(d, "not find phy-mode\\n");\n\t\tret = -EINVAL;\n\t\tgoto init_fail;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto init_fail;\n\t}\n\n\tret = devm_request_irq(d, irq, hip04_mac_interrupt,\n\t\t\t       0, pdev->name, ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, "devm_request_irq failed\\n");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->phy_node = of_parse_phandle(node, "phy-handle", 0);\n\tif (priv->phy_node) {\n	f
24674	994	sh_css_sp_init_stage	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css_sp.c	queue_id	1	13	\N	\N	\tconst struct ia_css_binary_xinfo *xinfo;\n\tconst struct ia_css_binary_info  *info;\n\tenum ia_css_err err = IA_CSS_SUCCESS;\n\tint i;\n\tstruct ia_css_pipe *pipe = NULL;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\tbool continuous = sh_css_continuous_is_enabled((uint8_t)pipe_num);\n\n\tassert(binary != NULL);\n\tassert(blob_info != NULL);\n\tassert(args != NULL);\n\tassert(isp_mem_if != NULL);\n\n\txinfo = binary->info;\n\tinfo  = &xinfo->sp;\n\t{\n\t\t/**\n\t\t * Clear sh_css_sp_stage for easy debugging.\n\t\t * program_input_circuit must be saved as it is set outside\n\t\t * this function.\n\t\t */\n\t\tuint8_t program_input_circuit;\n\t\tprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\n\t\tmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\n\t\tsh_css_sp_stage.program_input_circuit = (uint8_t)program_input_circuit;\n\t}\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\n\tif (info == NULL) {\n\t\tsh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;\n\t\treturn IA_CSS_SUCCESS;\n\t}\n\n#if defined(USE_INPUT_SYSTEM_VERSION_2401)\n\t(void)continuous;\n\tsh_css_sp_stage.deinterleaved = 0;\n#else\n\tsh_css_sp_stage.deinterleaved = ((stage == 0) && continuous);\n#endif\n\n\tinitialize_stage_frames(&sh_css_sp_stage.frames);\n\t/*\n\t * TODO: Make the Host dynamically determine\n\t * the stage type.\n\t */\n\tsh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;\n\tsh_css_sp_stage.num\t\t= (uint8_t)stage;\n\tsh_css_sp_stage.isp_online\t= (uint8_t)binary->online;\n\tsh_css_sp_stage.isp_copy_vf     = (uint8_t)args->copy_vf;\n\tsh_css_sp_stage.isp_copy_output = (uint8_t)args->copy_output;\n\tsh_css_sp_stage.enable.vf_output = (args->out_vf_frame != NULL);\n\n\t/* Copy the frame infos first, to be overwritten by the frames,\n\t   if these are present.\n\t*/\n\tsh_css_sp_stage.frames.effective_in_res.width = binary->effective_in_frame_res.width;\n\tsh_css_sp_stage.frames.effective_in_res.height = binary->effective_in_frame_res.height;\n\n\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.in.info,\n\t\t\t\t&binary->in_frame_info);\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.out[i].info,\n\t\t\t\t\t&binary->out_frame_info[i]);\n\t}\n\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.internal_frame_info,\n\t\t\t\t&binary->internal_frame_info);\n\tsh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;\n\tsh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;\n\tsh_css_sp_stage.isp_pipe_version      = (uint8_t)info->pipeline.isp_pipe_version;\n\tsh_css_sp_stage.isp_deci_log_factor   = (uint8_t)binary->deci_factor_log2;\n\tsh_css_sp_stage.isp_vf_downscale_bits = (uint8_t)binary->vf_downscale_log2;\n\n\tsh_css_sp_stage.if_config_index = (uint8_t) if_config_index;\n\n\tsh_css_sp_stage.sp_enable_xnr = (uint8_t)xnr;\n\tsh_css_sp_stage.xmem_bin_addr = xinfo->xmem_addr;\n\tsh_css_sp_stage.xmem_map_addr = sh_css_params_ddr_address_map();\n\tsh_css_isp_stage.blob_info = *blob_info;\n\tsh_css_stage_write_binary_info((struct ia_css_binary_info *)info);\n\n\t/* Make sure binary name is smaller than allowed string size */\n\tassert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME-1);\n\tstrncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME-1);\n\tsh_css_isp_stage.binary_name[SH_CSS_MAX_BINARY_NAME - 1] = 0;\n\tsh_css_isp_stage.mem_initializers = *isp_mem_if;\n\n\t/**\n\t * Even when a stage does not need uds and does not params,\n\t * ia_css_uds_sp_scale_params() seems to be called (needs\n\t * further investigation). This function can not deal with\n\t * dx, dy = {0, 0}\n\t */\n\n\terr = sh_css_sp_write_frame_pointers(args);\n\t/* TODO: move it to a better place */\n\tif (binary->info->sp.enable.s3a) {\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_3A_STATISTICS, thread_id, &queue_id);\n\t\tsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.s3a_buf, queue_id, mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_3A_STATISTICS);\n	f
55970	321	udf_lookup	fs/udf/namei.c	&cfi	1	13	\N	\N	\tstruct inode *inode = NULL;\n\tstruct fileIdentDesc cfi;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc *fi;\n\n\tif (dentry->d_name.len > UDF_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n#ifdef UDF_RECOVERY\n\t/* temporary shorthand for specifying files by inode number */\n\tif (!strncmp(dentry->d_name.name, ".B=", 3)) {\n\t\tstruct kernel_lb_addr lb = {\n\t\t\t.logicalBlockNum = 0,\n\t\t\t.partitionReferenceNum =\n\t\t\t\tsimple_strtoul(dentry->d_name.name + 3,\n\t\t\t\t\t\tNULL, 0),\n\t\t};\n\t\tinode = udf_iget(dir->i_sb, lb);\n\t\tif (IS_ERR(inode))\n\t\t\treturn inode;\n\t} else\n#endif /* UDF_RECOVERY */\n\n\tfi = udf_find_entry(dir, &dentry->d_name, &fibh, &cfi);\n	f
50964	6950	rtl8169_xmit_frags	drivers/net/ethernet/realtek/r8169.c	txd->opts1	2	-11	\N	\N	\tstruct skb_shared_info *info = skb_shinfo(skb);\n\tunsigned int cur_frag, entry;\n\tstruct TxDesc *uninitialized_var(txd);\n\tstruct device *d = &tp->pci_dev->dev;\n\n\tentry = tp->cur_tx;\n\tfor (cur_frag = 0; cur_frag < info->nr_frags; cur_frag++) {\n\t\tconst skb_frag_t *frag = info->frags + cur_frag;\n\t\tdma_addr_t mapping;\n\t\tu32 status, len;\n\t\tvoid *addr;\n\n\t\tentry = (entry + 1) % NUM_TX_DESC;\n\n\t\ttxd = tp->TxDescArray + entry;\n\t\tlen = skb_frag_size(frag);\n\t\taddr = skb_frag_address(frag);\n\t\tmapping = dma_map_single(d, addr, len, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(d, mapping))) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetif_err(tp, drv, tp->dev,\n\t\t\t\t\t  "Failed to map TX fragments DMA!\\n");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t/* Anti gcc 2.95.3 bugware (sic) */\n\t\tstatus = opts[0] | len |\n\t\t\t(RingEnd * !((entry + 1) % NUM_TX_DESC));\n\n\t\ttxd->opts1 = cpu_to_le32(status);\n\t\ttxd->opts2 = cpu_to_le32(opts[1]);\n\t\ttxd->addr = cpu_to_le64(mapping);\n\n\t\ttp->tx_skb[entry].len = len;\n\t}\n\n\tif (cur_frag) {\n\t\ttp->tx_skb[entry].skb = skb;\n\t\ttxd->opts1 |= cpu_to_le32(LastFrag);\n	t
22124	55	hsu_pci_irq	drivers/dma/hsu/pci.c	status	1	11	\N	\N	\tstruct hsu_dma_chip *chip = dev;\n\tstruct pci_dev *pdev = to_pci_dev(chip->dev);\n\tu32 dmaisr;\n\tu32 status;\n\tunsigned short i;\n\tint ret = 0;\n\tint err;\n\n\t/*\n\t * On Intel Tangier B0 and Anniedale the interrupt line, disregarding\n\t * to have different numbers, is shared between HSU DMA and UART IPs.\n\t * Thus on such SoCs we are expecting that IRQ handler is called in\n\t * UART driver only.\n\t */\n\tif (pdev->device == PCI_DEVICE_ID_INTEL_MRFLD_HSU_DMA)\n\t\treturn IRQ_HANDLED;\n\n\tdmaisr = readl(chip->regs + HSU_PCI_DMAISR);\n\tfor (i = 0; i < chip->hsu->nr_channels; i++) {\n\t\tif (dmaisr & 0x1) {\n\t\t\terr = hsu_dma_get_status(chip, i, &status);\n\t\t\tif (err > 0)\n\t\t\t\tret |= 1;\n\t\t\telse if (err == 0)\n\t\t\t\tret |= hsu_dma_do_irq(chip, i, status);\n	f
23223	212	cramfs_read	fs/cramfs/inode.c	page	1	11	\N	\N	\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_SHIFT;\n\toffset &= PAGE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n	f
23385	135	blkdev_report_zones_ioctl	block/blk-zoned.c	i	1	11	\N	\N	\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct blk_zone_report_hdr *hdr;\n\tunsigned int nrz = *nr_zones;\n\tstruct page *page;\n\tunsigned int nr_rep;\n\tsize_t rep_bytes;\n\tunsigned int nr_pages;\n\tstruct bio *bio;\n\tstruct bio_vec *bv;\n\tunsigned int i, n, nz;\n\tunsigned int ofst;\n\tvoid *addr;\n\tint ret;\n\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tif (!blk_queue_is_zoned(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nrz)\n\t\treturn 0;\n\n\tif (sector > bdev->bd_part->nr_sects) {\n\t\t*nr_zones = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The zone report has a header. So make room for it in the\n\t * payload. Also make sure that the report fits in a single BIO\n\t * that will not be split down the stack.\n\t */\n\trep_bytes = sizeof(struct blk_zone_report_hdr) +\n\t\tsizeof(struct blk_zone) * nrz;\n\trep_bytes = (rep_bytes + PAGE_SIZE - 1) & PAGE_MASK;\n\tif (rep_bytes > (queue_max_sectors(q) << 9))\n\t\trep_bytes = queue_max_sectors(q) << 9;\n\n\tnr_pages = min_t(unsigned int, BIO_MAX_PAGES,\n\t\t\t rep_bytes >> PAGE_SHIFT);\n\tnr_pages = min_t(unsigned int, nr_pages,\n\t\t\t queue_max_segments(q));\n\n\tbio = bio_alloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = blk_zone_start(q, sector);\n\tbio_set_op_attrs(bio, REQ_OP_ZONE_REPORT, 0);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(gfp_mask);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!bio_add_page(bio, page, PAGE_SIZE, 0)) {\n\t\t\t__free_page(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 0)\n	f
21414	219	qpnp_tm_probe	drivers/thermal/qcom-spmi-temp-alarm.c	ret	1	13	\N	\N	\tstruct qpnp_tm_chip *chip;\n\tstruct device_node *node;\n\tu8 type, subtype;\n\tu32 res;\n\tint ret, irq;\n\n\tnode = pdev->dev.of_node;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, chip);\n\n\tchip->map = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chip->map)\n\t\treturn -ENXIO;\n\n\tret = of_property_read_u32(node, "reg", &res);\n\tif (ret < 0)\n	f
2498	252	wm831x_rtc_readalarm	drivers/rtc/rtc-wm831x.c	time	1	11	\N	\N	\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu16 data[2];\n\tu32 time;\n\n\tret = wm831x_bulk_read(wm831x_rtc->wm831x, WM831X_RTC_ALARM_1,\n\t\t\t       2, data);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to read alarm time: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\ttime = (data[0] << 16) | data[1];\n\n\trtc_time_to_tm(time, &alrm->time);\n	t
2508	160	gfs2_mount_args	fs/gfs2/super.c	&tmp[0]	1	11	\N	\N	\tchar *o;\n\tint token;\n\tsubstring_t tmp[MAX_OPT_ARGS];\n\tint rv;\n\n\t/* Split the options into tokens with the "," character and\n\t   process them */\n\n\twhile (1) {\n\t\to = strsep(&options, ",");\n\t\tif (o == NULL)\n\t\t\tbreak;\n\t\tif (*o == '\\0')\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_lockproto:\n\t\t\tmatch_strlcpy(args->ar_lockproto, &tmp[0],\n	t
55573	1443	batadv_tt_local_table_free	net/batman-adv/translation-table.c	batadv_tt_local_table_free_$____ptr18$obj	0	13	\N	\N	\tstruct batadv_hashtable *hash;\n\tspinlock_t *list_lock; /* protects write access to the hash lists */\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tt_local_entry *tt_local;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tu32 i;\n\n\tif (!bat_priv->tt.local_hash)\n\t\treturn;\n\n\thash = bat_priv->tt.local_hash;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common_entry, node_tmp,\n	f
23549	504	adfs_fill_super	fs/adfs/super.c	root	1	11	\N	\N	\tstruct adfs_discrecord *dr;\n\tstruct buffer_head *bh;\n\tstruct object_info root_obj;\n\tunsigned char *b_data;\n\tstruct adfs_sb_info *asb;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\n\tasb = kzalloc(sizeof(*asb), GFP_KERNEL);\n\tif (!asb)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = asb;\n\n\t/* set default options */\n\tasb->s_uid = GLOBAL_ROOT_UID;\n\tasb->s_gid = GLOBAL_ROOT_GID;\n\tasb->s_owner_mask = ADFS_DEFAULT_OWNER_MASK;\n\tasb->s_other_mask = ADFS_DEFAULT_OTHER_MASK;\n\tasb->s_ftsuffix = 0;\n\n\tif (parse_options(sb, data))\n\t\tgoto error;\n\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tif (!(bh = sb_bread(sb, ADFS_DISCRECORD / BLOCK_SIZE))) {\n\t\tadfs_error(sb, "unable to read superblock");\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\tb_data = bh->b_data + (ADFS_DISCRECORD % BLOCK_SIZE);\n\n\tif (adfs_checkbblk(b_data)) {\n\t\tif (!silent)\n\t\t\tprintk("VFS: Can't find an adfs filesystem on dev "\n\t\t\t\t"%s.\\n", sb->s_id);\n\t\tret = -EINVAL;\n\t\tgoto error_free_bh;\n\t}\n\n\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\n\t/*\n\t * Do some sanity checks on the ADFS disc record\n\t */\n\tif (adfs_checkdiscrecord(dr)) {\n\t\tif (!silent)\n\t\t\tprintk("VPS: Can't find an adfs filesystem on dev "\n\t\t\t\t"%s.\\n", sb->s_id);\n\t\tret = -EINVAL;\n\t\tgoto error_free_bh;\n\t}\n\n\tbrelse(bh);\n\tif (sb_set_blocksize(sb, 1 << dr->log2secsize)) {\n\t\tbh = sb_bread(sb, ADFS_DISCRECORD / sb->s_blocksize);\n\t\tif (!bh) {\n\t\t\tadfs_error(sb, "couldn't read superblock on "\n\t\t\t\t"2nd try.");\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t\tb_data = bh->b_data + (ADFS_DISCRECORD % sb->s_blocksize);\n\t\tif (adfs_checkbblk(b_data)) {\n\t\t\tadfs_error(sb, "disc record mismatch, very weird!");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_free_bh;\n\t\t}\n\t\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\t} else {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR "VFS: Unsupported blocksize on dev "\n\t\t\t\t"%s.\\n", sb->s_id);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * blocksize on this device should now be set to the ADFS log2secsize\n\t */\n\n\tsb->s_magic\t\t= ADFS_SUPER_MAGIC;\n\tasb->s_idlen\t\t= dr->idlen;\n\tasb->s_map_size\t\t= dr->nzones | (dr->nzones_high << 8);\n\tasb->s_map2blk\t\t= dr->log2bpmb - dr->log2secsize;\n\tasb->s_size    \t\t= adfs_discsize(dr, sb->s_blocksize_bits);\n\tasb->s_version \t\t= dr->format_version;\n\tasb->s_log2sharesize\t= dr->log2sharesize;\n\n\tasb->s_map = adfs_read_map(sb, dr);\n\tif (IS_ERR(asb->s_map)) {\n\t\tret =  PTR_ERR(asb->s_map);\n\t\tgoto error_free_bh;\n\t}\n\n\tbrelse(bh);\n\n\t/*\n\t * set up enough so that we can read an inode\n\t */\n\tsb->s_op = &adfs_sops;\n\n\tdr = (struct adfs_discrecord *)(asb->s_map[0].dm_bh->b_data + 4);\n\n\troot_obj.parent_id = root_obj.file_id = le32_to_cpu(dr->root);\n\troot_obj.name_len  = 0;\n\t/* Set root object date as 01 Jan 1987 00:00:00 */\n\troot_obj.loadaddr  = 0xfff0003f;\n\troot_obj.execaddr  = 0xec22c000;\n\troot_obj.size\t   = ADFS_NEWDIR_SIZE;\n\troot_obj.attr\t   = ADFS_NDA_DIRECTORY   | ADFS_NDA_OWNER_READ |\n\t\t\t     ADFS_NDA_OWNER_WRITE | ADFS_NDA_PUBLIC_READ;\n\troot_obj.filetype  = -1;\n\n\t/*\n\t * If this is a F+ disk with variable length directories,\n\t * get the root_size from the disc record.\n\t */\n\tif (asb->s_version) {\n\t\troot_obj.size = le32_to_cpu(dr->root_size);\n\t\tasb->s_dir     = &adfs_fplus_dir_ops;\n\t\tasb->s_namelen = ADFS_FPLUS_NAME_LEN;\n\t} else {\n\t\tasb->s_dir     = &adfs_f_dir_ops;\n\t\tasb->s_namelen = ADFS_F_NAME_LEN;\n\t}\n\t/*\n\t * ,xyz hex filetype suffix may be added by driver\n\t * to files that have valid RISC OS filetype\n\t */\n\tif (asb->s_ftsuffix)\n\t\tasb->s_namelen += 4;\n\n\tsb->s_d_op = &adfs_dentry_operations;\n\troot = adfs_iget(sb, &root_obj);\n\tsb->s_root = d_make_root(root);\n	f
23777	347	hfsplus_delete_cat	fs/hfsplus/catalog.c	&fd.search_key->cat.name.length	1	11	\N	\N	\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, "delete_cat: %s,%u\\n", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n	f
23880	2541	ext4_mb_init_backend	fs/ext4/mballoc.c	sbi->s_buddy_cache	1	11	\N	\N	\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, "can't get new inode");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, "can't read descriptor %u", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\n	f
23942	723	igmp_send_report	net/ipv4/igmp.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tstruct rtable *rt;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct net *net = dev_net(dev);\n\t__be32\tgroup = pmc ? pmc->multiaddr : 0;\n\tstruct flowi4 fl4;\n\t__be32\tdst;\n\tint hlen, tlen;\n\n\tif (type == IGMPV3_HOST_MEMBERSHIP_REPORT)\n\t\treturn igmpv3_send_report(in_dev, pmc);\n\n\tif (ipv4_is_local_multicast(group) && !net->ipv4.sysctl_igmp_llm_reports)\n\t\treturn 0;\n\n\tif (type == IGMP_HOST_LEAVE_MESSAGE)\n\t\tdst = IGMP_ALL_ROUTER;\n\telse\n\t\tdst = group;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, dst, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt))\n\t\treturn -1;\n\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tskb = alloc_skb(IGMP_SIZE + hlen + tlen, GFP_ATOMIC);\n\tif (!skb) {\n\t\tip_rt_put(rt);\n\t\treturn -1;\n\t}\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tskb_dst_set(skb, &rt->dst);\n	f
24029	1269	ap_probe	drivers/staging/greybus/es2.c	num_cports	1	11	\N	\N	\tstruct es2_ap_dev *es2;\n\tstruct gb_host_device *hd;\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\t__u8 ep_addr;\n\tint retval;\n\tint i;\n\tint num_cports;\n\tbool bulk_out_found = false;\n\tbool bulk_in_found = false;\n\tbool arpc_in_found = false;\n\n\tudev = usb_get_dev(interface_to_usbdev(interface));\n\n\tnum_cports = apb_get_cport_count(udev);\n\tif (num_cports < 0) {\n	f
24144	238	async_bump	drivers/staging/irda/net/wrapper.c	newskb	1	11	\N	\N	\tstruct sk_buff *newskb;\n\tstruct sk_buff *dataskb;\n\tint\t\tdocopy;\n\n\t/* Check if we need to copy the data to a new skb or not.\n\t * If the driver doesn't use ZeroCopy Rx, we have to do it.\n\t * With ZeroCopy Rx, the rx_buff already point to a valid\n\t * skb. But, if the frame is small, it is more efficient to\n\t * copy it to save memory (copy will be fast anyway - that's\n\t * called Rx-copy-break). Jean II */\n\tdocopy = ((rx_buff->skb == NULL) ||\n\t\t  (rx_buff->len < IRDA_RX_COPY_THRESHOLD));\n\n\t/* Allocate a new skb */\n\tnewskb = dev_alloc_skb(docopy ? rx_buff->len + 1 : rx_buff->truesize);\n\tif (!newskb)  {\n\t\tstats->rx_dropped++;\n\t\t/* We could deliver the current skb if doing ZeroCopy Rx,\n\t\t * but this would stall the Rx path. Better drop the\n\t\t * packet... Jean II */\n\t\treturn;\n\t}\n\n\t/* Align IP header to 20 bytes (i.e. increase skb->data)\n\t * Note this is only useful with IrLAN, as PPP has a variable\n\t * header size (2 or 1 bytes) - Jean II */\n\tskb_reserve(newskb, 1);\n	f
23898	4276	ext4_fill_super	fs/ext4/super.c	first_not_zeroed	0	11	\N	\N	\tstruct dax_device *dax_dev = fs_dax_get_by_bdev(sb->s_bdev);\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_daxdev = dax_dev;\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, "unable to set blocksize");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, "unable to read superblock");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, "metadata_csum and uninit_bg are "\n\t\t\t     "redundant flags; please run fsck.");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, "VFS: Found ext4 filesystem with "\n\t\t\t "unknown checksum algorithm.");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb) ||\n\t    ext4_has_feature_ea_inode(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash("crc32c", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, "Cannot load crc32c driver.");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, "VFS: Found ext4 filesystem with "\n\t\t\t "invalid superblock checksum.  Run e2fsck?");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb) || ext4_has_feature_ea_inode(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t "failed to parse options in superblock: %s",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING "EXT4-fs: Warning: mounting "\n\t\t\t    "with data=journal disables delayed "\n\t\t\t    "allocation and O_DIRECT support!\\n");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "both data=journal and delalloc");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "both data=journal and dioread_nolock");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "both data=journal and dax");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (ext4_has_feature_encrypt(sb)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t "encrypted files will use data=ordered "\n\t\t\t\t "instead of data journaling mode");\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       "feature flags set on rev 0 fs, "\n\t\t       "running e2fsck is recommended");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "The Hurd can't support 64-bit file systems");\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\t/*\n\t\t * ea_inode feature uses l_i_version field which is not\n\t\t * available in HURD_COMPAT mode.\n\t\t */\n\t\tif (ext4_has_feature_ea_inode(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "ea_inode feature is not supported for Hurd");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, "mounting ext2 file system "\n\t\t\t\t "using the ext4 subsystem");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, "couldn't mount as ext2 due "\n\t\t\t\t "to feature incompatibilities");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, "mounting ext3 file system "\n\t\t\t\t "using the ext4 subsystem");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, "couldn't mount as ext3 due "\n\t\t\t\t "to feature incompatibilities");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb_rdonly(sb))))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       "Unsupported filesystem blocksize %d (%d log_block_size)",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Invalid log block size: %u",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Number of reserved GDT blocks insanely large: %d",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, "Unsupported encryption level %d",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, "bad block size %d",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "Can't read superblock on 2nd try");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "Magic mismatch, very weird!");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "unsupported inode size: %d",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "unsupported descriptor size %lu",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, "invalid inodes per group: %lu\\n",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "cluster size (%d) smaller than "\n\t\t\t\t "block size (%d)", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Invalid log cluster size: %u",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "#clusters per group too big: %lu",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, "blocks per group (%lu) and "\n\t\t\t\t "clusters per group (%lu) inconsistent",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, "fragment/cluster size (%d) != "\n\t\t\t\t     "block size (%d)", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "#blocks per group too big: %lu",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, "filesystem"\n\t\t\t " too large to mount safely on this system");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, "CONFIG_LBDAF not enabled");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, "bad geometry: block count %llu "\n\t\t       "exceeds size of device (%llu blocks)",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, "bad geometry: first data "\n\t\t\t "block %u is beyond end of filesystem (%llu)",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, "groups count too large: %u "\n\t\t       "(block count %llu, first data block %u, "\n\t\t       "blocks per group %lu)", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) > db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t "first meta block group too large: %u "\n\t\t\t\t "(group descriptor block count %u)",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, "not enough memory");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\t/* Pre-read the descriptors into the buffer cache */\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsb_breadahead(sb, block);\n\t}\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "can't read group descriptor %d", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, "group descriptors corrupted!");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(&sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !sb_rdonly(sb))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\terr = ext4_load_journal(sb, es, journal_devnum);\n\t\tif (err)\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !sb_rdonly(sb) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, "required journal recovery "\n\t\t       "suppressed and not mounted read-only");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "journal_checksum, fs mounted w/o journal");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "journal_async_commit, fs mounted w/o journal");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "commit=%lu, fs mounted w/o journal",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t\t "data=, fs mounted w/o journal");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, "Failed to set 64-bit journal feature");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, "Failed to set journal checksum "\n\t\t\t "feature set");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, "Journal does not support "\n\t\t\t       "requested data journaling mode");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, "can't mount with "\n\t\t\t"journal_async_commit in data=ordered mode");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tif (!test_opt(sb, NO_MBCACHE)) {\n\t\tsbi->s_ea_block_cache = ext4_xattr_create_cache();\n\t\tif (!sbi->s_ea_block_cache) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Failed to create ea_block_cache");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\n\t\tif (ext4_has_feature_ea_inode(sb)) {\n\t\t\tsbi->s_ea_inode_cache = ext4_xattr_create_cache();\n\t\t\tif (!sbi->s_ea_inode_cache) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t "Failed to create ea_inode_cache");\n\t\t\t\tgoto failed_mount_wq;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Unsupported blocksize for fs encryption");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !sb_rdonly(sb) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue("ext4-rsv-conversion", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR "EXT4-fs: failed to create workqueue\\n");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, "get root inode failed");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, "corrupt root inode, run e2fsck");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, "get root dentry failed");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb_rdonly(sb)))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, "required extra inode space not"\n\t\t\t "available");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, "failed to initialize system "\n\t\t\t "zone (%d)", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, "failed to initialize mballoc (%d)",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, "insufficient memory");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       "unable to initialize "\n\t\t\t       "flex_bg meta info!");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n	f
57379	1601	nilfs_btree_delete	fs/nilfs2/btree.c	level	1	13	\N	\N	\tstruct nilfs_btree_path *path;\n\tstruct nilfs_bmap_stats stats;\n\tstruct inode *dat;\n\tint level, ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, NULL,\n\t\t\t\t    NILFS_BTREE_LEVEL_NODE_MIN, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\tdat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;\n\n\tret = nilfs_btree_prepare_delete(btree, path, &level, &stats, dat);\n\tif (ret < 0)\n\t\tgoto out;\n\tnilfs_btree_commit_delete(btree, path, level, dat);\n	f
24526	1311	finish_rmw	fs/btrfs/raid56.c	&rbio->stripes_pending	1	11	\N	\N	\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < rbio->stripe_npages; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < rbio->stripe_npages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < rbio->stripe_npages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n	f
25443	492	ifi_canfd_handle_state_change	drivers/net/can/ifi_canfd/ifi_canfd.c	cf->data	1	11	\N	\N	\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct can_berr_counter bec;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t/* error warning state */\n\t\tpriv->can.can_stats.error_warning++;\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t/* error passive state */\n\t\tpriv->can.can_stats.error_passive++;\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t/* bus-off state */\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tifi_canfd_irq_enable(ndev, 0);\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(ndev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* propagate the error condition to the CAN stack */\n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tifi_canfd_get_berr_counter(ndev, &bec);\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t/* error warning state */\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t/* error passive state */\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n	f
25716	685	iproc_pll_clk_setup	drivers/clk/bcm/clk-iproc-pll.c	parent_name	1	11	\N	\N	\tint i, ret;\n\tstruct iproc_pll *pll;\n\tstruct iproc_clk *iclk;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\n\tif (WARN_ON(!pll_ctrl) || WARN_ON(!clk_ctrl))\n\t\treturn;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (WARN_ON(!pll))\n\t\treturn;\n\n\tpll->clk_data = kzalloc(sizeof(*pll->clk_data->hws) * num_clks +\n\t\t\t\tsizeof(*pll->clk_data), GFP_KERNEL);\n\tif (WARN_ON(!pll->clk_data))\n\t\tgoto err_clk_data;\n\tpll->clk_data->num = num_clks;\n\n\tpll->clks = kcalloc(num_clks, sizeof(*pll->clks), GFP_KERNEL);\n\tif (WARN_ON(!pll->clks))\n\t\tgoto err_clks;\n\n\tpll->control_base = of_iomap(node, 0);\n\tif (WARN_ON(!pll->control_base))\n\t\tgoto err_pll_iomap;\n\n\t/* Some SoCs do not require the pwr_base, thus failing is not fatal */\n\tpll->pwr_base = of_iomap(node, 1);\n\n\t/* some PLLs require gating control at the top ASIU level */\n\tif (pll_ctrl->flags & IPROC_CLK_PLL_ASIU) {\n\t\tpll->asiu_base = of_iomap(node, 2);\n\t\tif (WARN_ON(!pll->asiu_base))\n\t\t\tgoto err_asiu_iomap;\n\t}\n\n\tif (pll_ctrl->flags & IPROC_CLK_PLL_SPLIT_STAT_CTRL) {\n\t\t/* Some SoCs have a split status/control.  If this does not\n\t\t * exist, assume they are unified.\n\t\t */\n\t\tpll->status_base = of_iomap(node, 2);\n\t\tif (!pll->status_base)\n\t\t\tgoto err_status_iomap;\n\t} else\n\t\tpll->status_base = pll->control_base;\n\n\t/* initialize and register the PLL itself */\n\tpll->ctrl = pll_ctrl;\n\n\ticlk = &pll->clks[0];\n\ticlk->pll = pll;\n\ticlk->name = node->name;\n\n\tinit.name = node->name;\n\tinit.ops = &iproc_pll_ops;\n\tinit.flags = 0;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n	f
34234	3564	ath6kl_wmi_set_appie_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_set_appie_cmd_$p$obj	0	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_set_appie_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + ie_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "set_appie_cmd: mgmt_frm_type=%u ie_len=%u\\n",\n\t\t   mgmt_frm_type, ie_len);\n\tp = (struct wmi_set_appie_cmd *) skb->data;\n\tp->mgmt_frm_type = mgmt_frm_type;\n	f
20612	1243	keyctl_reject_key	security/keys/keyctl.c	dest_keyring	7	12	\N	\N	\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter("%d,%u,%u,%d", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n	t
26440	186	rv3029_set_sr	drivers/rtc/rtc-rv3029c2.c	buf	1	13	\N	\N	\tu8 buf[1];\n\tint sr;\n\n\tbuf[0] = val;\n\tsr = rv3029_write_regs(dev, RV3029_STATUS, buf, 1);\n\tdev_dbg(dev, "status = 0x%.2x (%d)\\n", buf[0], buf[0]);\n	f
2523	250	max30102_led_init	drivers/iio/health/max30102.c	reg	1	11	\N	\N	\tstruct device *dev = &data->client->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int val;\n\tint reg, ret;\n\n\tret = of_property_read_u32(np, "maxim,red-led-current-microamp", &val);\n\tif (ret) {\n\t\tdev_info(dev, "no red-led-current-microamp set\\n");\n\n\t\t/* Default to 7 mA RED LED */\n\t\tval = 7000;\n\t}\n\n\tret = max30102_get_current_idx(val, &reg);\n\tif (ret) {\n\t\tdev_err(dev, "invalid RED LED current setting %d\\n", val);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, MAX30102_REG_RED_LED_CONFIG, reg);\n	t
-606	71	dcb_gpio_entry	drivers/gpu/drm/nouveau/nvkm/subdev/bios/gpio.c	cnt	2	3	\N	\N	\tu8  hdr, cnt, xver; /* use gpio version for xpio entry parsing */\n\tu16 gpio;\n\n\tif (!idx--)\n\t\tgpio = dcb_gpio_table(bios, ver, &hdr, &cnt, len);\n\telse\n\t\tgpio = dcb_xpio_table(bios, idx, &xver, &hdr, &cnt, len);\n\n\tif (gpio && ent < cnt)\n	f
26060	130	ahci_qoriq_hardreset	drivers/ata/ahci_qoriq.c	px_is	1	11	\N	\N	\tconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tu32 px_cmd, px_is, px_val;\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_qoriq_priv *qoriq_priv = hpriv->plat_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc;\n\tbool ls1021a_workaround = (qoriq_priv->type == AHCI_LS1021A);\n\n\tDPRINTK("ENTER\\n");\n\n\tahci_stop_engine(ap);\n\n\t/*\n\t * There is a errata on ls1021a Rev1.0 and Rev2.0 which is:\n\t * A-009042: The device detection initialization sequence\n\t * mistakenly resets some registers.\n\t *\n\t * Workaround for this is:\n\t * The software should read and store PxCMD and PxIS values\n\t * before issuing the device detection initialization sequence.\n\t * After the sequence is complete, software should restore the\n\t * PxCMD and PxIS with the stored values.\n\t */\n\tif (ls1021a_workaround) {\n\t\tpx_cmd = readl(port_mmio + PORT_CMD);\n\t\tpx_is = readl(port_mmio + PORT_IRQ_STAT);\n\t}\n\n\t/* clear D2H reception area to properly wait for D2H FIS */\n\tata_tf_init(link->device, &tf);\n\ttf.command = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\trc = sata_link_hardreset(link, timing, deadline, &online,\n\t\t\t\t ahci_check_ready);\n\n\t/* restore the PxCMD and PxIS on ls1021 */\n\tif (ls1021a_workaround) {\n\t\tpx_val = readl(port_mmio + PORT_CMD);\n\t\tif (px_val != px_cmd)\n\t\t\twritel(px_cmd, port_mmio + PORT_CMD);\n\n\t\tpx_val = readl(port_mmio + PORT_IRQ_STAT);\n\t\tif (px_val != px_is)\n	f
26155	2127	dapm_debugfs_add_widget	sound/soc/soc-dapm.c	d	1	11	\N	\N	\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct dentry *d;\n\n\tif (!dapm->debugfs_dapm || !w->name)\n\t\treturn;\n\n\td = debugfs_create_file(w->name, 0444,\n\t\t\t\tdapm->debugfs_dapm, w,\n\t\t\t\t&dapm_widget_power_fops);\n\tif (!d)\n	f
26048	745	ata_task_ioctl	drivers/ata/libata-scsi.c	sshdr.asc	1	-1	\N	\N	\tint rc = 0;\n\tu8 scsi_cmd[MAX_COMMAND_SIZE];\n\tu8 args[7], *sensebuf = NULL;\n\tstruct scsi_sense_hdr sshdr;\n\tint cmd_result;\n\n\tif (arg == NULL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(args, arg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\n\tif (!sensebuf)\n\t\treturn -ENOMEM;\n\n\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\tscsi_cmd[0]  = ATA_16;\n\tscsi_cmd[1]  = (3 << 1); /* Non-data */\n\tscsi_cmd[2]  = 0x20;     /* cc but no off.line or data xfer */\n\tscsi_cmd[4]  = args[1];\n\tscsi_cmd[6]  = args[2];\n\tscsi_cmd[8]  = args[3];\n\tscsi_cmd[10] = args[4];\n\tscsi_cmd[12] = args[5];\n\tscsi_cmd[13] = args[6] & 0x4f;\n\tscsi_cmd[14] = args[0];\n\n\t/* Good values for timeout and retries?  Values below\n\t   from scsi_ioctl_send_command() for default case... */\n\tcmd_result = scsi_execute(scsidev, scsi_cmd, DMA_NONE, NULL, 0,\n\t\t\t\tsensebuf, &sshdr, (10*HZ), 5, 0, 0, NULL);\n\n\tif (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */\n\t\tu8 *desc = sensebuf + 8;\n\t\tcmd_result &= ~(0xFF<<24); /* DRIVER_SENSE is not an error */\n\n\t\t/* If we set cc then ATA pass-through will cause a\n\t\t * check condition even if no error. Filter that. */\n\t\tif (cmd_result & SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (sshdr.sense_key == RECOVERED_ERROR &&\n	f
2551	332	twl4030_madc_channel_raw_read	drivers/iio/adc/twl4030-madc.c	ret	1	11	\N	\N	\tu16 val;\n\tint ret;\n\t/*\n\t * For each ADC channel, we have MSB and LSB register pair. MSB address\n\t * is always LSB address+1. reg parameter is the address of LSB register\n\t */\n\tret = twl_i2c_read_u16(TWL4030_MODULE_MADC, &val, reg);\n\tif (ret) {\n	t
2623	441	vl6180_init	drivers/iio/light/vl6180.c	ret	1	11	\N	\N	\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = vl6180_read_byte(client, VL6180_MODEL_ID);\n\tif (ret < 0)\n	t
25879	55	br_dev_queue_push_xmit	net/bridge/br_forward.c	skb	0	11	\N	\N	\tif (!is_skb_forwardable(skb->dev, skb))\n\t\tgoto drop;\n\n\tskb_push(skb, ETH_HLEN);\n\tbr_drop_fake_rtable(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (skb->protocol == htons(ETH_P_8021Q) ||\n\t     skb->protocol == htons(ETH_P_8021AD))) {\n\t\tint depth;\n\n\t\tif (!__vlan_get_protocol(skb, skb->protocol, &depth))\n\t\t\tgoto drop;\n\n\t\tskb_set_network_header(skb, depth);\n\t}\n\n\tdev_queue_xmit(skb);\n	f
26354	1009	early_init_dt_scan_chosen_stdout	drivers/of/fdt.c	early_init_dt_scan_chosen_stdout_	0	11	\N	\N	\tint offset;\n\tconst char *p, *q, *options = NULL;\n\tint l;\n\tconst struct earlycon_id *match;\n\tconst void *fdt = initial_boot_params;\n\n\toffset = fdt_path_offset(fdt, "/chosen");\n\tif (offset < 0)\n\t\toffset = fdt_path_offset(fdt, "/chosen@0");\n\tif (offset < 0)\n\t\treturn -ENOENT;\n\n\tp = fdt_getprop(fdt, offset, "stdout-path", &l);\n\tif (!p)\n\t\tp = fdt_getprop(fdt, offset, "linux,stdout-path", &l);\n\tif (!p || !l)\n\t\treturn -ENOENT;\n\n\tq = strchrnul(p, ':');\n\tif (*q != '\\0')\n\t\toptions = q + 1;\n\tl = q - p;\n\n\t/* Get the node specified by stdout-path */\n\toffset = fdt_path_offset_namelen(fdt, p, l);\n\tif (offset < 0) {\n\t\tpr_warn("earlycon: stdout-path %.*s not found\\n", l, p);\n\t\treturn 0;\n\t}\n\n\tfor (match = __earlycon_table; match < __earlycon_table_end; match++) {\n\t\tif (!match->compatible[0])\n\t\t\tcontinue;\n\n\t\tif (fdt_node_check_compatible(fdt, offset, match->compatible))\n	f
21774	183	efi_get_device_by_path	drivers/firmware/efi/dev-path-parser.c	parent	7	12	\N	initializer is use	\tstruct device *parent = NULL, *child;\n\tlong ret = 0;\n\n\tif (!*len)\n\t\treturn NULL;\n\n\twhile (!ret) {\n\t\tif (*len < 4 || *len < (*node)->length)\n\t\t\tret = -EINVAL;\n\t\telse if ((*node)->type     == EFI_DEV_ACPI &&\n\t\t\t (*node)->sub_type == EFI_DEV_BASIC_ACPI)\n\t\t\tret = parse_acpi_path(*node, parent, &child);\n\t\telse if ((*node)->type     == EFI_DEV_HW &&\n\t\t\t (*node)->sub_type == EFI_DEV_PCI)\n\t\t\tret = parse_pci_path(*node, parent, &child);\n	t
33663	234	set_filter_wr	drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c	skb	1	13	\N	\N	\tstruct filter_entry *f = &adapter->tids.ftid_tab[fidx];\n\tstruct fw_filter_wr *fwr;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(sizeof(*fwr), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* If the new filter requires loopback Destination MAC and/or VLAN\n\t * rewriting then we need to allocate a Layer 2 Table (L2T) entry for\n\t * the filter.\n\t */\n\tif (f->fs.newdmac || f->fs.newvlan) {\n\t\t/* allocate L2T entry for new filter */\n\t\tf->l2t = t4_l2t_alloc_switching(adapter, f->fs.vlan,\n\t\t\t\t\t\tf->fs.eport, f->fs.dmac);\n\t\tif (!f->l2t) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfwr = __skb_put_zero(skb, sizeof(*fwr));\n	f
27278	2534	btusb_qca_send_vendor_req	drivers/bluetooth/btusb.c	err	1	11	\N	\N	\tstruct btusb_data *btdata = hci_get_drvdata(hdev);\n\tstruct usb_device *udev = btdata->udev;\n\tint pipe, err;\n\tu8 *buf;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Found some of USB hosts have IOT issues with ours so that we should\n\t * not wait until HCI layer is ready.\n\t */\n\tpipe = usb_rcvctrlpipe(udev, 0);\n\terr = usb_control_msg(udev, pipe, request, USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      0, 0, buf, size, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n	f
27071	684	asus_rfkill_hotplug	drivers/platform/x86/asus-wmi.c	l	1	13	\N	\N	\tstruct pci_dev *dev;\n\tstruct pci_bus *bus;\n\tbool blocked;\n\tbool absent;\n\tu32 l;\n\n\tmutex_lock(&asus->wmi_lock);\n\tblocked = asus_wlan_rfkill_blocked(asus);\n\tmutex_unlock(&asus->wmi_lock);\n\n\tmutex_lock(&asus->hotplug_lock);\n\tpci_lock_rescan_remove();\n\n\tif (asus->wlan.rfkill)\n\t\trfkill_set_sw_state(asus->wlan.rfkill, blocked);\n\n\tif (asus->hotplug_slot) {\n\t\tbus = pci_find_bus(0, 1);\n\t\tif (!bus) {\n\t\t\tpr_warn("Unable to find PCI bus 1?\\n");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {\n\t\t\tpr_err("Unable to read PCI config space?\\n");\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tabsent = (l == 0xffffffff);\n	f
43825	1554	lgdt3306a_qam_lock_poll	drivers/media/dvb-frontends/lgdt3306a.c	packet_error	1	13	\N	\N	\tu8 cnt;\n\tu8 packet_error;\n\tu32\tsnr;\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tif (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {\n\t\t\tdbg_info("no fec lock!\\n");\n\t\t\treturn LG3306_UNLOCK;\n\t\t}\n\n\t\tmsleep(20);\n\n\t\tpacket_error = lgdt3306a_get_packet_error(state);\n\t\tsnr = lgdt3306a_calculate_snr_x100(state);\n\t\tdbg_info("cnt=%d errors=%d snr=%d\\n", cnt, packet_error, snr);\n	f
29195	350	ip_rcv_finish	net/ipv4/ip_input.c	err	1	11	\N	\N	\tconst struct iphdr *iph = ip_hdr(skb);\n\tint (*edemux)(struct sk_buff *skb);\n\tstruct net_device *dev = skb->dev;\n\tstruct rtable *rt;\n\tint err;\n\n\t/* if ingress device is enslaved to an L3 master device pass the\n\t * skb to its handler for processing\n\t */\n\tskb = l3mdev_ip_rcv(skb);\n\tif (!skb)\n\t\treturn NET_RX_SUCCESS;\n\n\tif (net->ipv4.sysctl_ip_early_demux &&\n\t    !skb_dst(skb) &&\n\t    !skb->sk &&\n\t    !ip_is_fragment(iph)) {\n\t\tconst struct net_protocol *ipprot;\n\t\tint protocol = iph->protocol;\n\n\t\tipprot = rcu_dereference(inet_protos[protocol]);\n\t\tif (ipprot && (edemux = READ_ONCE(ipprot->early_demux))) {\n\t\t\terr = edemux(skb);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto drop_error;\n\t\t\t/* must reload iph, skb->head might have changed */\n\t\t\tiph = ip_hdr(skb);\n\t\t}\n\t}\n\n\t/*\n\t *\tInitialise the virtual path cache for the packet. It describes\n\t *\thow the packet travels inside Linux networking.\n\t */\n\tif (!skb_valid_dst(skb)) {\n\t\terr = ip_route_input_noref(skb, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, dev);\n\t\tif (unlikely(err))\n	f
28711	2326	adv76xx_set_edid	drivers/media/i2c/adv7604.c	spa_loc	1	11	\N	\N	\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tunsigned int spa_loc;\n\tu16 pa;\n\tint err;\n\tint i;\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->pad > ADV7604_PAD_HDMI_PORT_D)\n\t\treturn -EINVAL;\n\tif (edid->start_block != 0)\n\t\treturn -EINVAL;\n\tif (edid->blocks == 0) {\n\t\t/* Disable hotplug and I2C access to EDID RAM from DDC port */\n\t\tstate->edid.present &= ~(1 << edid->pad);\n\t\tadv76xx_set_hpd(state, state->edid.present);\n\t\trep_write_clr_set(sd, info->edid_enable_reg, 0x0f, state->edid.present);\n\n\t\t/* Fall back to a 16:9 aspect ratio */\n\t\tstate->aspect_ratio.numerator = 16;\n\t\tstate->aspect_ratio.denominator = 9;\n\n\t\tif (!state->edid.present)\n\t\t\tstate->edid.blocks = 0;\n\n\t\tv4l2_dbg(2, debug, sd, "%s: clear EDID pad %d, edid.present = 0x%x\\n",\n\t\t\t\t__func__, edid->pad, state->edid.present);\n\t\treturn 0;\n\t}\n\tif (edid->blocks > 2) {\n\t\tedid->blocks = 2;\n\t\treturn -E2BIG;\n\t}\n\tpa = cec_get_edid_phys_addr(edid->edid, edid->blocks * 128, &spa_loc);\n\terr = cec_phys_addr_validate(pa, &pa, NULL);\n\tif (err)\n\t\treturn err;\n\n\tv4l2_dbg(2, debug, sd, "%s: write EDID pad %d, edid.present = 0x%x\\n",\n\t\t\t__func__, edid->pad, state->edid.present);\n\n\t/* Disable hotplug and I2C access to EDID RAM from DDC port */\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\tadv76xx_set_hpd(state, 0);\n\trep_write_clr_set(sd, info->edid_enable_reg, 0x0f, 0x00);\n\n\t/*\n\t * Return an error if no location of the source physical address\n\t * was found.\n\t */\n\tif (spa_loc == 0)\n	t
58331	3281	interrupt_init_v2_hw	drivers/scsi/hisi_sas/hisi_sas_v2_hw.c	irq	1	13	\N	\N	\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tstruct device *dev = &pdev->dev;\n\tint irq, rc, irq_map[128];\n\tint i, phy_no, fatal_no, queue_no, k;\n\n\tfor (i = 0; i < 128; i++)\n\t\tirq_map[i] = platform_get_irq(pdev, i);\n\n\tfor (i = 0; i < HISI_SAS_PHY_INT_NR; i++) {\n\t\tirq = irq_map[i + 1]; /* Phy up/down is irq1 */\n\t\trc = devm_request_irq(dev, irq, phy_interrupts[i], 0,\n	f
-604	240	clk_alpha_pll_enable	drivers/clk/qcom/clk-alpha-pll.c	val	2	3	\N	\N	\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val, mask, off;\n\n\toff = pll->offset;\n\n\tmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\n\tret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If in FSM mode, just vote for it */\n\tif (val & PLL_VOTE_FSM_ENA) {\n	f
45504	257	vctrl_parse_dt	drivers/regulator/vctrl-regulator.c	vctrl->min_slew_down_rate	1	11	\N	\N	\tint ret;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 pval;\n\tu32 vrange_ctrl[2];\n\n\tvctrl->ctrl_reg = devm_regulator_get(&pdev->dev, "ctrl");\n\tif (IS_ERR(vctrl->ctrl_reg))\n\t\treturn PTR_ERR(vctrl->ctrl_reg);\n\n\tret = of_property_read_u32(np, "ovp-threshold-percent", &pval);\n\tif (!ret) {\n\t\tvctrl->ovp_threshold = pval;\n\t\tif (vctrl->ovp_threshold > 100) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"ovp-threshold-percent (%u) > 100\\n",\n\t\t\t\tvctrl->ovp_threshold);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(np, "min-slew-down-rate", &pval);\n\tif (!ret) {\n\t\tvctrl->min_slew_down_rate = pval;\n\n\t\t/* We use the value as int and as divider; sanity check */\n\t\tif (vctrl->min_slew_down_rate == 0) {\n	t
30252	605	ip_frag_reasm	net/ipv4/ip_fragment.c	clone->truesize	1	11	\N	\N	\tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n\tstruct iphdr *iph;\n\tstruct sk_buff *fp, *head = qp->q.fragments;\n\tint len;\n\tint ihlen;\n\tint err;\n\tu8 ecn;\n\n\tipq_kill(qp);\n\n\tecn = ip_frag_ecn_table[qp->ecn];\n\tif (unlikely(ecn == 0xff)) {\n\t\terr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\t/* Make the one we just received the head. */\n\tif (prev) {\n\t\thead = prev->next;\n\t\tfp = skb_clone(head, GFP_ATOMIC);\n\t\tif (!fp)\n\t\t\tgoto out_nomem;\n\n\t\tfp->next = head->next;\n\t\tif (!fp->next)\n\t\t\tqp->q.fragments_tail = fp;\n\t\tprev->next = fp;\n\n\t\tskb_morph(head, qp->q.fragments);\n\t\thead->next = qp->q.fragments->next;\n\n\t\tconsume_skb(qp->q.fragments);\n\t\tqp->q.fragments = head;\n\t}\n\n\tWARN_ON(!head);\n\tWARN_ON(FRAG_CB(head)->offset != 0);\n\n\t/* Allocate a new buffer for the datagram. */\n\tihlen = ip_hdrlen(head);\n\tlen = ihlen + qp->q.len;\n\n\terr = -E2BIG;\n\tif (len > 65535)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\tgoto out_nomem;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (!clone)\n\t\t\tgoto out_nomem;\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tadd_frag_mem_limit(qp->q.net, clone->truesize);\n	f
31242	1395	check_for_space	drivers/md/dm-thin.c	nr_free	1	11	\N	\N	\tint r;\n\tdm_block_t nr_free;\n\n\tif (get_pool_mode(pool) != PM_OUT_OF_DATA_SPACE)\n\t\treturn;\n\n\tr = dm_pool_get_free_block_count(pool->pmd, &nr_free);\n\tif (r)\n\t\treturn;\n\n\tif (nr_free)\n	f
31920	372	arch_prepare_optimized_kprobe	arch/x86/kernel/kprobes/opt.c	ret	2	-11	\N	\N	\tu8 *buf;\n\tint ret;\n\tlong rel;\n\n\tif (!can_optimize((unsigned long)op->kp.addr))\n\t\treturn -EILSEQ;\n\n\top->optinsn.insn = get_optinsn_slot();\n\tif (!op->optinsn.insn)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Verify if the address gap is in 2GB range, because this uses\n\t * a relative jump.\n\t */\n\trel = (long)op->optinsn.insn - (long)op->kp.addr + RELATIVEJUMP_SIZE;\n\tif (abs(rel) > 0x7fffffff) {\n\t\t__arch_remove_optimized_kprobe(op, 0);\n\t\treturn -ERANGE;\n\t}\n\n\tbuf = (u8 *)op->optinsn.insn;\n\tset_memory_rw((unsigned long)buf & PAGE_MASK, 1);\n\n\t/* Copy instructions into the out-of-line buffer */\n\tret = copy_optimized_instructions(buf + TMPL_END_IDX, op->kp.addr);\n\tif (ret < 0) {\n	f
31911	1577	intel_hdmi_set_edid	drivers/gpu/drm/i915/intel_hdmi.c	edid->input	0	11	\N	\N	\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);\n\tstruct edid *edid;\n\tbool connected = false;\n\n\tintel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);\n\n\tedid = drm_get_edid(connector,\n\t\t\t    intel_gmbus_get_adapter(dev_priv,\n\t\t\t    intel_hdmi->ddc_bus));\n\n\tintel_hdmi_dp_dual_mode_detect(connector, edid != NULL);\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS);\n\n\tto_intel_connector(connector)->detect_edid = edid;\n\tif (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {\n	f
-602	470	show_als_en	drivers/leds/leds-lm3533.c	val	2	3	\N	\N	\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tbool enable;\n\tu8 reg;\n\tu8 val;\n\tint ret;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tenable = val & LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\n	f
2468	180	pm8xxx_rtc_read_time	drivers/rtc/rtc-pm8xxx.c	reg	11	12	\N	\N	\tint rc;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tunsigned long secs;\n\tunsigned int reg;\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\n\trc = regmap_bulk_read(rtc_dd->regmap, regs->read, value, sizeof(value));\n\tif (rc) {\n\t\tdev_err(dev, "RTC read data register failed\\n");\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Read the LSB again and check if there has been a carry over.\n\t * If there is, redo the read operation.\n\t */\n\trc = regmap_read(rtc_dd->regmap, regs->read, &reg);\n\tif (rc < 0) {\n\t\tdev_err(dev, "RTC read data register failed\\n");\n\t\treturn rc;\n\t}\n\n\tif (unlikely(reg < value[0])) {\n	t
-600	159	clear_page_presence	arch/x86/mm/kmmio.c	level	2	3	\N	\N	\tunsigned int level;\n\tpte_t *pte = lookup_address(f->addr, &level);\n\n\tif (!pte) {\n\t\tpr_err("no pte for addr 0x%08lx\\n", f->addr);\n\t\treturn -1;\n\t}\n\n\tswitch (level) {\n	f
32001	1386	calc_target	net/ceph/osd_client.c	&up	1	11	\N	\N	\tstruct ceph_pg_pool_info *pi;\n\tstruct ceph_pg pgid, last_pgid;\n\tstruct ceph_osds up, acting;\n\tbool force_resend = false;\n\tbool unpaused = false;\n\tbool legacy_change;\n\tbool split = false;\n\tbool sort_bitwise = ceph_osdmap_flag(osdc, CEPH_OSDMAP_SORTBITWISE);\n\tbool recovery_deletes = ceph_osdmap_flag(osdc,\n\t\t\t\t\t\t CEPH_OSDMAP_RECOVERY_DELETES);\n\tenum calc_target_result ct_res;\n\tint ret;\n\n\tt->epoch = osdc->osdmap->epoch;\n\tpi = ceph_pg_pool_by_id(osdc->osdmap, t->base_oloc.pool);\n\tif (!pi) {\n\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\tgoto out;\n\t}\n\n\tif (osdc->osdmap->epoch == pi->last_force_request_resend) {\n\t\tif (t->last_force_resend < pi->last_force_request_resend) {\n\t\t\tt->last_force_resend = pi->last_force_request_resend;\n\t\t\tforce_resend = true;\n\t\t} else if (t->last_force_resend == 0) {\n\t\t\tforce_resend = true;\n\t\t}\n\t}\n\n\t/* apply tiering */\n\tceph_oid_copy(&t->target_oid, &t->base_oid);\n\tceph_oloc_copy(&t->target_oloc, &t->base_oloc);\n\tif ((t->flags & CEPH_OSD_FLAG_IGNORE_OVERLAY) == 0) {\n\t\tif (t->flags & CEPH_OSD_FLAG_READ && pi->read_tier >= 0)\n\t\t\tt->target_oloc.pool = pi->read_tier;\n\t\tif (t->flags & CEPH_OSD_FLAG_WRITE && pi->write_tier >= 0)\n\t\t\tt->target_oloc.pool = pi->write_tier;\n\n\t\tpi = ceph_pg_pool_by_id(osdc->osdmap, t->target_oloc.pool);\n\t\tif (!pi) {\n\t\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __ceph_object_locator_to_pg(pi, &t->target_oid, &t->target_oloc,\n\t\t\t\t\t  &pgid);\n\tif (ret) {\n\t\tWARN_ON(ret != -ENOENT);\n\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\tgoto out;\n\t}\n\tlast_pgid.pool = pgid.pool;\n\tlast_pgid.seed = ceph_stable_mod(pgid.seed, t->pg_num, t->pg_num_mask);\n\n\tceph_pg_to_up_acting_osds(osdc->osdmap, pi, &pgid, &up, &acting);\n	f
32015	1922	futex_requeue	kernel/futex.c	&key2	1	11	\N	\N	\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n	f
24122	629	receive_dux_commands	drivers/staging/comedi/drivers/usbdux.c	ret	1	11	\N	\N	\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\tint nrec;\n\tint i;\n\n\tfor (i = 0; i < RETRIES; i++) {\n\t\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),\n\t\t\t\t   devpriv->insn_buf, SIZEINSNBUF,\n\t\t\t\t   &nrec, BULK_TIMEOUT);\n\t\tif (ret < 0)\n	t
41328	333	cookie_v4_check	net/ipv4/syncookies.c	req	1	11	\N	\N	\tstruct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tstruct flowi4 fl4;\n\tu32 tsoff = 0;\n\n\tif (!sock_net(sk)->ipv4.sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v4_check(ip_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(sock_net(sk), skb, &tcp_opt, 0, NULL);\n\n\tif (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {\n\t\ttsoff = secure_tcp_ts_off(sock_net(sk),\n\t\t\t\t\t  ip_hdr(skb)->daddr,\n\t\t\t\t\t  ip_hdr(skb)->saddr);\n\t\ttcp_opt.rcv_tsecr -= tsoff;\n\t}\n\n\tif (!cookie_timestamp_decode(sock_net(sk), &tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops, sk, false); /* for safety */\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n	f
34372	3562	is_ancestor	fs/btrfs/send.c	parent_gen	1	-1	\N	stack pointer not null	\tu64 ino = ino2;\n\tbool free_path = false;\n\tint ret = 0;\n\n\tif (!fs_path) {\n\t\tfs_path = fs_path_alloc();\n\t\tif (!fs_path)\n\t\t\treturn -ENOMEM;\n\t\tfree_path = true;\n\t}\n\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tu64 parent;\n\t\tu64 parent_gen;\n\n\t\tfs_path_reset(fs_path);\n\t\tret = get_first_ref(root, ino, &parent, &parent_gen, fs_path);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT && ino == ino2)\n\t\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (parent == ino1) {\n\t\t\tret = parent_gen == ino1_gen ? 1 : 0;\n	f
44778	1248	rpc_sockname	net/sunrpc/clnt.c	sock	1	13	\N	\N	\tstruct socket *sock;\n\tint err;\n\n\terr = __sock_create(net, sap->sa_family,\n\t\t\t\tSOCK_DGRAM, IPPROTO_UDP, &sock, 1);\n\tif (err < 0) {\n\t\tdprintk("RPC:       can't create UDP socket (%d)\\n", err);\n\t\tgoto out;\n\t}\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\terr = kernel_bind(sock,\n	f
2709	118	tps65090_try_enable_fet	drivers/regulator/tps65090-regulator.c	control	2	-11	\N	\N	\tunsigned int control;\n\tint ret, i;\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t rdev->desc->enable_mask,\n\t\t\t\t rdev->desc->enable_mask);\n\tif (ret < 0) {\n\t\tdev_err(&rdev->dev, "Error in updating reg %#x\\n",\n\t\t\trdev->desc->enable_reg);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MAX_CTRL_READ_TRIES; i++) {\n\t\tret = regmap_read(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  &control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(control & BIT(CTRL_TO_BIT)))\n	t
34470	10977	btrfs_trim_free_extents	fs/btrfs/extent-tree.c	len	1	11	\N	\N	\tu64 start = 0, len = 0;\n\tint ret;\n\n\t*trimmed = 0;\n\n\t/* Not writeable = nothing to do. */\n\tif (!device->writeable)\n\t\treturn 0;\n\n\t/* No free space = nothing to do. */\n\tif (device->total_bytes <= device->bytes_used)\n\t\treturn 0;\n\n\tret = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\t\tstruct btrfs_transaction *trans;\n\t\tu64 bytes;\n\n\t\tret = mutex_lock_interruptible(&fs_info->chunk_mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdown_read(&fs_info->commit_root_sem);\n\n\t\tspin_lock(&fs_info->trans_lock);\n\t\ttrans = fs_info->running_transaction;\n\t\tif (trans)\n\t\t\trefcount_inc(&trans->use_count);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tret = find_free_dev_extent_start(trans, device, minlen, start,\n\t\t\t\t\t\t &start, &len);\n\t\tif (trans)\n\t\t\tbtrfs_put_transaction(trans);\n\n\t\tif (ret) {\n\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_issue_discard(device->bdev, start, len, &bytes);\n	f
34498	679	create_snapshot	fs/btrfs/ioctl.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_KERNEL);\n\tif (!pending_snapshot)\n\t\treturn -ENOMEM;\n\n\tpending_snapshot->root_item = kzalloc(sizeof(struct btrfs_root_item),\n\t\t\tGFP_KERNEL);\n\tpending_snapshot->path = btrfs_alloc_path();\n\tif (!pending_snapshot->root_item || !pending_snapshot->path) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pending;\n\t}\n\n\tatomic_inc(&root->will_be_snapshotted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshotting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto dec_and_free;\n\n\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, (u64)-1);\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n	f
34958	1028	iwl_mvm_sar_init	drivers/net/wireless/intel/iwlwifi/mvm/fw.c	ret	1	11	\N	\N	\tint ret;\n\n\tret = iwl_mvm_sar_get_wrds_table(mvm);\n\tif (ret < 0) {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t"WRDS SAR BIOS table invalid or unavailable. (%d)\\n",\n\t\t\t\tret);\n\t\t/* if not available, don't fail and don't bother with EWRD */\n\t\treturn 0;\n\t}\n\n\tret = iwl_mvm_sar_get_ewrd_table(mvm);\n\t/* if EWRD is not available, we can still use WRDS, so don't fail */\n\tif (ret < 0)\n	f
2646	3522	ip_vs_genl_set_config	net/netfilter/ipvs/ip_vs_ctl.c	&t	1	11	\N	\N	\tstruct ip_vs_timeout_user t;\n\n\t__ip_vs_get_timeouts(ipvs, &t);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\n\t\tt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\n\t\tt.tcp_fin_timeout =\n\t\t\tnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\n\t\tt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\n\n\treturn ip_vs_set_timeout(ipvs, &t);\n	t
34947	3008	nfp_net_ring_reconfig	drivers/net/ethernet/netronome/nfp/nfp_net_common.c	nn	7	12	\N	\N	\tint r, err;\n\n\tdp->fl_bufsz = nfp_net_calc_fl_bufsz(dp);\n\n\tdp->num_stack_tx_rings = dp->num_tx_rings;\n\tif (dp->xdp_prog)\n\t\tdp->num_stack_tx_rings -= dp->num_rx_rings;\n\n\tdp->num_r_vecs = max(dp->num_rx_rings, dp->num_stack_tx_rings);\n\n\terr = nfp_net_check_config(nn, dp, extack);\n\tif (err)\n\t\tgoto exit_free_dp;\n\n\tif (!netif_running(dp->netdev)) {\n\t\tnfp_net_dp_swap(nn, dp);\n\t\terr = 0;\n\t\tgoto exit_free_dp;\n\t}\n\n\t/* Prepare new rings */\n\tfor (r = nn->dp.num_r_vecs; r < dp->num_r_vecs; r++) {\n\t\terr = nfp_net_prepare_vector(nn, &nn->r_vecs[r], r);\n\t\tif (err) {\n\t\t\tdp->num_r_vecs = r;\n\t\t\tgoto err_cleanup_vecs;\n\t\t}\n\t}\n\n\terr = nfp_net_rx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_cleanup_vecs;\n\n\terr = nfp_net_tx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_free_rx;\n\n\t/* Stop device, swap in new rings, try to start the firmware */\n\tnfp_net_close_stack(nn);\n\tnfp_net_clear_config_and_disable(nn);\n\n\terr = nfp_net_dp_swap_enable(nn, dp);\n\tif (err) {\n\t\tint err2;\n\n\t\tnfp_net_clear_config_and_disable(nn);\n	t
23998	118	gb_interface_read_dme	drivers/staging/greybus/interface.c	intf	1	13	\N	\N	\tint ret;\n\n\t/* DME attributes have already been read */\n\tif (intf->dme_read)\n\t\treturn 0;\n\n\tret = gb_interface_dme_attr_get(intf, DME_DDBL1_MANUFACTURERID,\n\t\t\t\t\t&intf->ddbl1_manufacturer_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_dme_attr_get(intf, DME_DDBL1_PRODUCTID,\n\t\t\t\t\t&intf->ddbl1_product_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intf->ddbl1_manufacturer_id == TOSHIBA_DMID &&\n\t    intf->ddbl1_product_id == TOSHIBA_ES2_BRIDGE_DPID) {\n\t\tintf->quirks |= GB_INTERFACE_QUIRK_NO_GMP_IDS;\n\t\tintf->quirks |= GB_INTERFACE_QUIRK_NO_INIT_STATUS;\n\t}\n\n\tret = gb_interface_read_ara_dme(intf);\n	f
36138	3120	iwl_trans_pcie_alloc	drivers/net/wireless/intel/iwlwifi/pcie/trans.c	trans	1	11	\N	\N	\tstruct iwl_trans_pcie *trans_pcie;\n\tstruct iwl_trans *trans;\n\tint ret, addr_size;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cfg->gen2)\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, cfg, &trans_ops_pcie_gen2);\n\telse\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, cfg, &trans_ops_pcie);\n\tif (!trans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ttrans_pcie->trans = trans;\n\ttrans_pcie->opmode_down = true;\n\tspin_lock_init(&trans_pcie->irq_lock);\n\tspin_lock_init(&trans_pcie->reg_lock);\n\tmutex_init(&trans_pcie->mutex);\n\tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n\ttrans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n\tif (!trans_pcie->tso_hdr_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pci;\n\t}\n\n\n\tif (!cfg->base_params->pcie_l1_allowed) {\n\t\t/*\n\t\t * W/A - seems to solve weird behavior. We need to remove this\n\t\t * if we don't want to stay in L1 all the time. This wastes a\n\t\t * lot of power.\n\t\t */\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\t\t       PCIE_LINK_STATE_L1 |\n\t\t\t\t       PCIE_LINK_STATE_CLKPM);\n\t}\n\n\tif (cfg->use_tfh) {\n\t\taddr_size = 64;\n\t\ttrans_pcie->max_tbs = IWL_TFH_NUM_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd);\n\t} else {\n\t\taddr_size = 36;\n\t\ttrans_pcie->max_tbs = IWL_NUM_OF_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfd);\n\t}\n\ttrans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size));\n\tif (!ret)\n\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t  DMA_BIT_MASK(addr_size));\n\tif (ret) {\n\t\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (!ret)\n\t\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t\t  DMA_BIT_MASK(32));\n\t\t/* both attempts failed: */\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, "No suitable DMA available\\n");\n\t\t\tgoto out_no_pci;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "pcim_iomap_regions_request_all failed\\n");\n\t\tgoto out_no_pci;\n\t}\n\n\ttrans_pcie->hw_base = pcim_iomap_table(pdev)[0];\n\tif (!trans_pcie->hw_base) {\n\t\tdev_err(&pdev->dev, "pcim_iomap_table failed\\n");\n\t\tret = -ENODEV;\n\t\tgoto out_no_pci;\n\t}\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\ttrans_pcie->pci_dev = pdev;\n\tiwl_disable_interrupts(trans);\n\n\ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n\t/*\n\t * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have\n\t * changed, and now the revision step also includes bit 0-1 (no more\n\t * "dash" value). To keep hw_rev backwards compatible - we'll store it\n\t * in the old format.\n\t */\n\tif (trans->cfg->device_family >= IWL_DEVICE_FAMILY_8000) {\n\t\tunsigned long flags;\n\n\t\ttrans->hw_rev = (trans->hw_rev & 0xfff0) |\n\t\t\t\t(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);\n\n\t\tret = iwl_pcie_prepare_card_hw(trans);\n\t\tif (ret) {\n\t\t\tIWL_WARN(trans, "Exit HW not ready\\n");\n\t\t\tgoto out_no_pci;\n\t\t}\n\n\t\t/*\n\t\t * in-order to recognize C step driver should read chip version\n\t\t * id located at the AUX bus MISC address space.\n\t\t */\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n\t\tudelay(2);\n\n\t\tret = iwl_poll_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,\n\t\t\t\t   25000);\n\t\tif (ret < 0) {\n\t\t\tIWL_DEBUG_INFO(trans, "Failed to wake up the nic\\n");\n\t\t\tgoto out_no_pci;\n\t\t}\n\n\t\tif (iwl_trans_grab_nic_access(trans, &flags)) {\n	f
36766	1396	e1000_check_for_copper_link_ich8lan	drivers/net/ethernet/intel/e1000e/ich8lan.c	link	1	11	\N	\N	\tstruct e1000_mac_info *mac = &hw->mac;\n\ts32 ret_val, tipg_reg = 0;\n\tu16 emi_addr, emi_val = 0;\n\tbool link;\n\tu16 phy_reg;\n\n\t/* We only want to go out to the PHY registers to see if Auto-Neg\n\t * has completed and/or if our link status has changed.  The\n\t * get_link_status flag is set upon receiving a Link Status\n\t * Change or Rx Sequence Error interrupt.\n\t */\n\tif (!mac->get_link_status)\n\t\treturn 0;\n\n\t/* First we want to see if the MII Status Register reports\n\t * link.  If so, then we want to get the current speed/duplex\n\t * of the PHY.\n\t */\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->mac.type == e1000_pchlan) {\n\t\tret_val = e1000_k1_gig_workaround_hv(hw, link);\n	f
36961	2450	lan78xx_reset	drivers/net/usb/lan78xx.c	dev->chipid	1	11	\N	\N	\tstruct lan78xx_priv *pdata = (struct lan78xx_priv *)(dev->data[0]);\n\tu32 buf;\n\tint ret = 0;\n\tunsigned long timeout;\n\n\tret = lan78xx_read_reg(dev, HW_CFG, &buf);\n\tbuf |= HW_CFG_LRST_;\n\tret = lan78xx_write_reg(dev, HW_CFG, buf);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tmdelay(1);\n\t\tret = lan78xx_read_reg(dev, HW_CFG, &buf);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tnetdev_warn(dev->net,\n\t\t\t\t    "timeout on completion of LiteReset");\n\t\t\treturn -EIO;\n\t\t}\n\t} while (buf & HW_CFG_LRST_);\n\n\tlan78xx_init_mac_address(dev);\n\n\t/* save DEVID for later usage */\n\tret = lan78xx_read_reg(dev, ID_REV, &buf);\n\tdev->chipid = (buf & ID_REV_CHIP_ID_MASK_) >> 16;\n\tdev->chiprev = buf & ID_REV_CHIP_REV_MASK_;\n\n\t/* Respond to the IN token with a NAK */\n\tret = lan78xx_read_reg(dev, USB_CFG0, &buf);\n\tbuf |= USB_CFG_BIR_;\n\tret = lan78xx_write_reg(dev, USB_CFG0, buf);\n\n\t/* Init LTM */\n\tlan78xx_init_ltm(dev);\n\n\tif (dev->udev->speed == USB_SPEED_SUPER) {\n\t\tbuf = DEFAULT_BURST_CAP_SIZE / SS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_BURST_CAP_SIZE;\n\t\tdev->rx_qlen = 4;\n\t\tdev->tx_qlen = 4;\n\t} else if (dev->udev->speed == USB_SPEED_HIGH) {\n\t\tbuf = DEFAULT_BURST_CAP_SIZE / HS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_BURST_CAP_SIZE;\n\t\tdev->rx_qlen = RX_MAX_QUEUE_MEMORY / dev->rx_urb_size;\n\t\tdev->tx_qlen = RX_MAX_QUEUE_MEMORY / dev->hard_mtu;\n\t} else {\n\t\tbuf = DEFAULT_BURST_CAP_SIZE / FS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_BURST_CAP_SIZE;\n\t\tdev->rx_qlen = 4;\n\t}\n\n\tret = lan78xx_write_reg(dev, BURST_CAP, buf);\n\tret = lan78xx_write_reg(dev, BULK_IN_DLY, DEFAULT_BULK_IN_DELAY);\n\n\tret = lan78xx_read_reg(dev, HW_CFG, &buf);\n\tbuf |= HW_CFG_MEF_;\n\tret = lan78xx_write_reg(dev, HW_CFG, buf);\n\n\tret = lan78xx_read_reg(dev, USB_CFG0, &buf);\n\tbuf |= USB_CFG_BCE_;\n\tret = lan78xx_write_reg(dev, USB_CFG0, buf);\n\n\t/* set FIFO sizes */\n\tbuf = (MAX_RX_FIFO_SIZE - 512) / 512;\n\tret = lan78xx_write_reg(dev, FCT_RX_FIFO_END, buf);\n\n\tbuf = (MAX_TX_FIFO_SIZE - 512) / 512;\n\tret = lan78xx_write_reg(dev, FCT_TX_FIFO_END, buf);\n\n\tret = lan78xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL_);\n\tret = lan78xx_write_reg(dev, FLOW, 0);\n\tret = lan78xx_write_reg(dev, FCT_FLOW, 0);\n\n\t/* Don't need rfe_ctl_lock during initialisation */\n\tret = lan78xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);\n\tpdata->rfe_ctl |= RFE_CTL_BCAST_EN_ | RFE_CTL_DA_PERFECT_;\n\tret = lan78xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\n\n\t/* Enable or disable checksum offload engines */\n\tlan78xx_set_features(dev->net, dev->net->features);\n\n\tlan78xx_set_multicast(dev->net);\n\n\t/* reset PHY */\n\tret = lan78xx_read_reg(dev, PMT_CTL, &buf);\n\tbuf |= PMT_CTL_PHY_RST_;\n\tret = lan78xx_write_reg(dev, PMT_CTL, buf);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tmdelay(1);\n\t\tret = lan78xx_read_reg(dev, PMT_CTL, &buf);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tnetdev_warn(dev->net, "timeout waiting for PHY Reset");\n\t\t\treturn -EIO;\n\t\t}\n\t} while ((buf & PMT_CTL_PHY_RST_) || !(buf & PMT_CTL_READY_));\n\n\tret = lan78xx_read_reg(dev, MAC_CR, &buf);\n\t/* LAN7801 only has RGMII mode */\n\tif (dev->chipid == ID_REV_CHIP_ID_7801_)\n	f
2843	1313	moxa_tiocmset	drivers/tty/moxa.c	rts	1	11	\N	\N	\tstruct moxa_port *ch;\n\tint dtr, rts;\n\n\tmutex_lock(&moxa_openlock);\n\tch = tty->driver_data;\n\tif (!ch) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -EINVAL;\n\t}\n\n\tMoxaPortGetLineOut(ch, &dtr, &rts);\n\tif (set & TIOCM_RTS)\n\t\trts = 1;\n\tif (set & TIOCM_DTR)\n\t\tdtr = 1;\n\tif (clear & TIOCM_RTS)\n\t\trts = 0;\n\tif (clear & TIOCM_DTR)\n\t\tdtr = 0;\n\tMoxaPortLineCtrl(ch, dtr, rts);\n	t
38173	1223	ebt_register_table	net/bridge/netfilter/ebtables.c	newinfo	1	11	\N	\N	\tstruct ebt_table_info *newinfo;\n\tstruct ebt_table *t, *table;\n\tstruct ebt_replace_kernel *repl;\n\tint ret, i, countersize;\n\tvoid *p;\n\n\tif (input_table == NULL || (repl = input_table->table) == NULL ||\n\t    repl->entries == NULL || repl->entries_size == 0 ||\n\t    repl->counters != NULL || input_table->private != NULL) {\n\t\tBUGPRINT("Bad table data for ebt_register_table!!!\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Don't add one table to multiple lists. */\n\ttable = kmemdup(input_table, sizeof(struct ebt_table), GFP_KERNEL);\n\tif (!table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcountersize = COUNTER_OFFSET(repl->nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tret = -ENOMEM;\n\tif (!newinfo)\n\t\tgoto free_table;\n\n\tp = vmalloc(repl->entries_size);\n\tif (!p)\n\t\tgoto free_newinfo;\n\n\tmemcpy(p, repl->entries, repl->entries_size);\n\tnewinfo->entries = p;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\t/* fill in newinfo and parse the entries */\n\tnewinfo->chainstack = NULL;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((repl->valid_hooks & (1 << i)) == 0)\n\t\t\tnewinfo->hook_entry[i] = NULL;\n\t\telse\n\t\t\tnewinfo->hook_entry[i] = p +\n\t\t\t\t((char *)repl->hook_entry[i] - repl->entries);\n\t}\n\tret = translate_table(net, repl->name, newinfo);\n	f
3019	132	cleanup_traps	drivers/infiniband/hw/hfi1/mad.c	q	1	11	\N	\N	\tstruct trap_node *node, *q;\n\tunsigned long flags;\n\tstruct list_head trap_list;\n\tint i;\n\n\tfor (i = 0; i < RVT_MAX_TRAP_LISTS; i++) {\n\t\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\t\tlist_replace_init(&ibp->rvp.trap_lists[i].list, &trap_list);\n\t\tibp->rvp.trap_lists[i].list_len = 0;\n\t\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\n\t\t/*\n\t\t * Remove all items from the list, freeing all the non-given\n\t\t * traps.\n\t\t */\n\t\tlist_for_each_entry_safe(node, q, &trap_list, list) {\n	t
3012	466	apply_tx_eq_prog	drivers/infiniband/hw/hfi1/platform.c	tx_preset	1	11	\N	\N	\tu8 *cache = ppd->qsfp_info.cache;\n\tu32 tx_preset;\n\tu8 tx_eq;\n\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x4))\n\t\treturn;\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index, TX_PRESET_TABLE_QSFP_TX_EQ_APPLY,\n\t\t&tx_preset, 4);\n\tif (!tx_preset) {\n	t
42030	4862	hub_port_connect	drivers/usb/core/hub.c	devstat	1	11	\N	\N	\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a "removed" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, "connect-debounce failed\\n");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was "removed".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\tfor (i = 0; i < SET_CONFIG_TRIES; i++) {\n\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t"couldn't allocate usb_device\\n");\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tusb_lock_port(port_dev);\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tusb_unlock_port(port_dev);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a "powered" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, "get status %d ?\\n", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n	f
20535	3330	gpiod_get_index	drivers/gpio/gpiolib.c	desc	1	-1	\N	\N	\tstruct gpio_desc *desc = NULL;\n\tint status;\n\tenum gpio_lookup_flags lookupflags = 0;\n\n\tdev_dbg(dev, "GPIO lookup for consumer %s\\n", con_id);\n\n\tif (dev) {\n\t\t/* Using device tree? */\n\t\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\t\tdev_dbg(dev, "using device tree for GPIO lookup\\n");\n\t\t\tdesc = of_find_gpio(dev, con_id, idx, &lookupflags);\n\t\t} else if (ACPI_COMPANION(dev)) {\n\t\t\tdev_dbg(dev, "using ACPI for GPIO lookup\\n");\n\t\t\tdesc = acpi_find_gpio(dev, con_id, idx, &flags, &lookupflags);\n\t\t}\n\t}\n\n\t/*\n\t * Either we are not using DT or ACPI, or their lookup did not return\n\t * a result. In that case, use platform lookup as a fallback.\n\t */\n\tif (!desc || desc == ERR_PTR(-ENOENT)) {\n	f
32538	580	amd_sched_main	drivers/gpu/drm/amd/scheduler/gpu_scheduler.c	amd_sched_main_	1	13	\N	\N	\tstruct sched_param sparam = {.sched_priority = 1};\n\tstruct amd_gpu_scheduler *sched = (struct amd_gpu_scheduler *)param;\n\tint r, count;\n\n\tsched_setscheduler(current, SCHED_FIFO, &sparam);\n\n\twhile (!kthread_should_stop()) {\n\t\tstruct amd_sched_entity *entity = NULL;\n\t\tstruct amd_sched_fence *s_fence;\n\t\tstruct amd_sched_job *sched_job;\n\t\tstruct dma_fence *fence;\n\n\t\twait_event_interruptible(sched->wake_up_worker,\n	f
28992	419	m88ds3103_set_frontend	drivers/media/dvb-frontends/m88ds3103.c	ret	1	11	\N	\N	\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len;\n\tconst struct m88ds3103_reg_val *init;\n\tu8 u8tmp, u8tmp1 = 0, u8tmp2 = 0; /* silence compiler warning */\n\tu8 buf[3];\n\tu16 u16tmp;\n\tu32 tuner_frequency_khz, target_mclk;\n\ts32 s32tmp;\n\n\tdev_dbg(&client->dev,\n\t\t"delivery_system=%d modulation=%d frequency=%u symbol_rate=%d inversion=%d pilot=%d rolloff=%d\\n",\n\t\tc->delivery_system, c->modulation, c->frequency, c->symbol_rate,\n\t\tc->inversion, c->pilot, c->rolloff);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\t/* reset */\n\tret = regmap_write(dev->regmap, 0x07, 0x80);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x07, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t/* Disable demod clock path */\n\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\tret = regmap_write(dev->regmap, 0x06, 0xe0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* program tuner */\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->ops.tuner_ops.get_frequency) {\n\t\tret = fe->ops.tuner_ops.get_frequency(fe, &tuner_frequency_khz);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\t/*\n\t\t * Use nominal target frequency as tuner driver does not provide\n\t\t * actual frequency used. Carrier offset calculation is not\n\t\t * valid.\n\t\t */\n\t\ttuner_frequency_khz = c->frequency;\n\t}\n\n\t/* select M88RS6000 demod main mclk and ts mclk from tuner die. */\n\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\tif (c->symbol_rate > 45010000)\n\t\t\tdev->mclk = 110250000;\n\t\telse\n\t\t\tdev->mclk = 96000000;\n\n\t\tif (c->delivery_system == SYS_DVBS)\n\t\t\ttarget_mclk = 96000000;\n\t\telse\n\t\t\ttarget_mclk = 144000000;\n\n\t\t/* Enable demod clock path */\n\t\tret = regmap_write(dev->regmap, 0x06, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tusleep_range(10000, 20000);\n\t} else {\n\t/* set M88DS3103 mclk and ts mclk. */\n\t\tdev->mclk = 96000000;\n\n\t\tswitch (dev->cfg->ts_mode) {\n\t\tcase M88DS3103_TS_SERIAL:\n\t\tcase M88DS3103_TS_SERIAL_D7:\n\t\t\ttarget_mclk = dev->cfg->ts_clk;\n\t\t\tbreak;\n\t\tcase M88DS3103_TS_PARALLEL:\n\t\tcase M88DS3103_TS_CI:\n\t\t\tif (c->delivery_system == SYS_DVBS)\n\t\t\t\ttarget_mclk = 96000000;\n\t\t\telse {\n\t\t\t\tif (c->symbol_rate < 18000000)\n\t\t\t\t\ttarget_mclk = 96000000;\n\t\t\t\telse if (c->symbol_rate < 28000000)\n\t\t\t\t\ttarget_mclk = 144000000;\n\t\t\t\telse\n\t\t\t\t\ttarget_mclk = 192000000;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, "invalid ts_mode\\n");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (target_mclk) {\n\t\tcase 96000000:\n\t\t\tu8tmp1 = 0x02; /* 0b10 */\n\t\t\tu8tmp2 = 0x01; /* 0b01 */\n\t\t\tbreak;\n\t\tcase 144000000:\n\t\t\tu8tmp1 = 0x00; /* 0b00 */\n\t\t\tu8tmp2 = 0x01; /* 0b01 */\n\t\t\tbreak;\n\t\tcase 192000000:\n\t\t\tu8tmp1 = 0x03; /* 0b11 */\n\t\t\tu8tmp2 = 0x00; /* 0b00 */\n\t\t\tbreak;\n\t\t}\n\t\tret = m88ds3103_update_bits(dev, 0x22, 0xc0, u8tmp1 << 6);\n\t\tif (ret)\n	f
51258	454	cuse_send_init	fs/fuse/cuse.c	req->out.args	1	13	\N	\N	\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n	f
9428	191	agp_3_5_isochronous_node_enable	drivers/char/agp/isoch.c	target.n	1	13	\N	\N	\t/*\n\t * Convenience structure to make the calculations clearer\n\t * here.  The field names come straight from the AGP 3.0 spec.\n\t */\n\tstruct isoch_data {\n\t\tu32 maxbw;\n\t\tu32 n;\n\t\tu32 y;\n\t\tu32 l;\n\t\tu32 rq;\n\t\tstruct agp_3_5_dev *dev;\n\t};\n\n\tstruct pci_dev *td = bridge->dev, *dev;\n\tstruct list_head *head = &dev_list->list, *pos;\n\tstruct agp_3_5_dev *cur;\n\tstruct isoch_data *master, target;\n\tunsigned int cdev = 0;\n\tu32 mnistat, tnistat, tstatus, mcmd;\n\tu16 tnicmd, mnicmd;\n\tu8 mcapndx;\n\tu32 tot_bw = 0, tot_n = 0, tot_rq = 0, y_max, rq_isoch, rq_async;\n\tu32 step, rem, rem_isoch, rem_async;\n\tint ret = 0;\n\n\t/*\n\t * We'll work with an array of isoch_data's (one for each\n\t * device in dev_list) throughout this function.\n\t */\n\tif ((master = kmalloc(ndevs * sizeof(*master), GFP_KERNEL)) == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto get_out;\n\t}\n\n\t/*\n\t * Sort the device list by maxbw.  We need to do this because the\n\t * spec suggests that the devices with the smallest requirements\n\t * have their resources allocated first, with all remaining resources\n\t * falling to the device with the largest requirement.\n\t *\n\t * We don't exactly do this, we divide target resources by ndevs\n\t * and split them amongst the AGP 3.0 devices.  The remainder of such\n\t * division operations are dropped on the last device, sort of like\n\t * the spec mentions it should be done.\n\t *\n\t * We can't do this sort when we initially construct the dev_list\n\t * because we don't know until this function whether isochronous\n\t * transfers are enabled and consequently whether maxbw will mean\n\t * anything.\n\t */\n\tagp_3_5_dev_list_sort(dev_list, ndevs);\n\n\tpci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\n\tpci_read_config_dword(td, bridge->capndx+AGPSTAT, &tstatus);\n\n\t/* Extract power-on defaults from the target */\n\ttarget.maxbw = (tnistat >> 16) & 0xff;\n\ttarget.n     = (tnistat >> 8)  & 0xff;\n\ttarget.y     = (tnistat >> 6)  & 0x3;\n\ttarget.l     = (tnistat >> 3)  & 0x7;\n\ttarget.rq    = (tstatus >> 24) & 0xff;\n\n\ty_max = target.y;\n\n\t/*\n\t * Extract power-on defaults for each device in dev_list.  Along\n\t * the way, calculate the total isochronous bandwidth required\n\t * by these devices and the largest requested payload size.\n\t */\n\tlist_for_each(pos, head) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\t\tdev = cur->dev;\n\n\t\tmcapndx = cur->capndx;\n\n\t\tpci_read_config_dword(dev, cur->capndx+AGPNISTAT, &mnistat);\n\n\t\tmaster[cdev].maxbw = (mnistat >> 16) & 0xff;\n\t\tmaster[cdev].n     = (mnistat >> 8)  & 0xff;\n\t\tmaster[cdev].y     = (mnistat >> 6)  & 0x3;\n\t\tmaster[cdev].dev   = cur;\n\n\t\ttot_bw += master[cdev].maxbw;\n\t\ty_max = max(y_max, master[cdev].y);\n\n\t\tcdev++;\n\t}\n\n\t/* Check if this configuration has any chance of working */\n\tif (tot_bw > target.maxbw) {\n\t\tdev_err(&td->dev, "isochronous bandwidth required "\n\t\t\t"by AGP 3.0 devices exceeds that which is supported by "\n\t\t\t"the AGP 3.0 bridge!\\n");\n\t\tret = -ENODEV;\n\t\tgoto free_and_exit;\n\t}\n\n\ttarget.y = y_max;\n\n\t/*\n\t * Write the calculated payload size into the target's NICMD\n\t * register.  Doing this directly effects the ISOCH_N value\n\t * in the target's NISTAT register, so we need to do this now\n\t * to get an accurate value for ISOCH_N later.\n\t */\n\tpci_read_config_word(td, bridge->capndx+AGPNICMD, &tnicmd);\n\ttnicmd &= ~(0x3 << 6);\n\ttnicmd |= target.y << 6;\n\tpci_write_config_word(td, bridge->capndx+AGPNICMD, tnicmd);\n\n\t/* Reread the target's ISOCH_N */\n\tpci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\n\ttarget.n = (tnistat >> 8) & 0xff;\n\n\t/* Calculate the minimum ISOCH_N needed by each master */\n\tfor (cdev=0; cdev<ndevs; cdev++) {\n\t\tmaster[cdev].y = target.y;\n\t\tmaster[cdev].n = master[cdev].maxbw / (master[cdev].y + 1);\n\n\t\ttot_n += master[cdev].n;\n\t}\n\n\t/* Exit if the minimal ISOCH_N allocation among the masters is more\n\t * than the target can handle. */\n\tif (tot_n > target.n) {\n	f
55555	284	afs_write_end	fs/afs/write.c	ret	1	13	\N	\N	\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tstruct key *key = file->private_data;\n\tloff_t i_size, maybe_i_size;\n\tint ret;\n\n\t_enter("{%x:%u},{%lx}",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index);\n\n\tmaybe_i_size = pos + copied;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (maybe_i_size > i_size) {\n\t\tspin_lock(&vnode->writeback_lock);\n\t\ti_size = i_size_read(&vnode->vfs_inode);\n\t\tif (maybe_i_size > i_size)\n\t\t\ti_size_write(&vnode->vfs_inode, maybe_i_size);\n\t\tspin_unlock(&vnode->writeback_lock);\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tif (copied < len) {\n\t\t\t/* Try and load any missing data from the server.  The\n\t\t\t * unmarshalling routine will take care of clearing any\n\t\t\t * bits that are beyond the EOF.\n\t\t\t */\n\t\t\tret = afs_fill_page(vnode, key, pos + copied,\n\t\t\t\t\t    len - copied, page);\n\t\t\tif (ret < 0)\n	f
-240	204	iproc_adc_interrupt_handler	drivers/iio/adc/bcm_iproc_adc.c	valid_entries	5	20	\N	\N	\tirqreturn_t retval = IRQ_NONE;\n\tstruct iproc_adc_priv *adc_priv;\n\tstruct iio_dev *indio_dev = data;\n\tunsigned int valid_entries;\n\tu32 intr_status;\n\tu32 intr_channels;\n\tu32 channel_status;\n\tu32 ch_intr_status;\n\n\tadc_priv = iio_priv(indio_dev);\n\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tdev_dbg(&indio_dev->dev, "iproc_adc_interrupt_handler(),INTRPT_STS:%x\\n",\n\t\t\tintr_status);\n\n\tintr_channels = (intr_status & IPROC_ADC_INTR_MASK) >> IPROC_ADC_INTR;\n\tif (intr_channels) {\n\t\tregmap_read(adc_priv->regmap,\n\t\t\t    IPROC_ADC_CHANNEL_INTERRUPT_STATUS +\n\t\t\t    IPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\n\t\t\t    &ch_intr_status);\n\n\t\tif (ch_intr_status & IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK) {\n\t\t\tregmap_read(adc_priv->regmap,\n\t\t\t\t\tIPROC_ADC_CHANNEL_STATUS +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tadc_priv->chan_id,\n\t\t\t\t\t&channel_status);\n\n\t\t\tvalid_entries = ((channel_status &\n\t\t\t\tIPROC_ADC_CHANNEL_VALID_ENTERIES_MASK) >>\n\t\t\t\tIPROC_ADC_CHANNEL_VALID_ENTERIES);\n\t\t\tif (valid_entries >= 1) {\n	f
45261	815	add_new_gdb	fs/ext4/resize.c	&iloc	1	11	\N	\N	\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_fsblk_t gdblock = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tstruct buffer_head *gdb_bh;\n\tint gdbackups;\n\tstruct ext4_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       "EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n",\n\t\t       gdb_num);\n\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\n\tgdbackups = verify_reserved_gdb(sb, group, gdb_bh);\n\tif (gdbackups < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text4_warning(sb, "new group %u GDT block %llu not reserved",\n\t\t\t     group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(gdb_bh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(dind, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, dind);\n\tif (unlikely(err))\n\t\text4_std_error(sb, err);\n\n\t/* ext4_reserve_inode_write() gets a reference on the iloc */\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n	f
-234	1083	max17042_probe	drivers/power/supply/max17042_battery.c	val	5	20	\N	\N	\tstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\n\tconst struct power_supply_desc *max17042_desc = &max17042_psy_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tconst struct acpi_device_id *acpi_id = NULL;\n\tstruct device *dev = &client->dev;\n\tstruct max17042_chip *chip;\n\tint ret;\n\tint i;\n\tu32 val;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EIO;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tif (id) {\n\t\tchip->chip_type = id->driver_data;\n\t} else {\n\t\tacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\n\t\tif (!acpi_id)\n\t\t\treturn -ENODEV;\n\n\t\tchip->chip_type = acpi_id->driver_data;\n\t}\n\tchip->regmap = devm_regmap_init_i2c(client, &max17042_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tdev_err(&client->dev, "Failed to initialize regmap\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->pdata = max17042_get_pdata(chip);\n\tif (!chip->pdata) {\n\t\tdev_err(&client->dev, "no platform data provided\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_set_clientdata(client, chip);\n\tpsy_cfg.drv_data = chip;\n\n\t/* When current is not measured,\n\t * CURRENT_NOW and CURRENT_AVG properties should be invisible. */\n\tif (!chip->pdata->enable_current_sense)\n\t\tmax17042_desc = &max17042_no_current_sense_psy_desc;\n\n\tif (chip->pdata->r_sns == 0)\n\t\tchip->pdata->r_sns = MAX17042_DEFAULT_SNS_RESISTOR;\n\n\tif (chip->pdata->init_data)\n\t\tfor (i = 0; i < chip->pdata->num_init_data; i++)\n\t\t\tregmap_write(chip->regmap,\n\t\t\t\t\tchip->pdata->init_data[i].addr,\n\t\t\t\t\tchip->pdata->init_data[i].data);\n\n\tif (!chip->pdata->enable_current_sense) {\n\t\tregmap_write(chip->regmap, MAX17042_CGAIN, 0x0000);\n\t\tregmap_write(chip->regmap, MAX17042_MiscCFG, 0x0003);\n\t\tregmap_write(chip->regmap, MAX17042_LearnCFG, 0x0007);\n\t}\n\n\tchip->battery = devm_power_supply_register(&client->dev, max17042_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(chip->battery)) {\n\t\tdev_err(&client->dev, "failed: power supply register\\n");\n\t\treturn PTR_ERR(chip->battery);\n\t}\n\n\tif (client->irq) {\n\t\tunsigned int flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\n\n\t\t/*\n\t\t * On ACPI systems the IRQ may be handled by ACPI-event code,\n\t\t * so we need to share (if the ACPI code is willing to share).\n\t\t */\n\t\tif (acpi_id)\n\t\t\tflags |= IRQF_SHARED | IRQF_PROBE_SHARED;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tmax17042_thread_handler, flags,\n\t\t\t\t\t\tchip->battery->desc->name,\n\t\t\t\t\t\tchip);\n\t\tif (!ret) {\n\t\t\tregmap_update_bits(chip->regmap, MAX17042_CONFIG,\n\t\t\t\t\tCONFIG_ALRT_BIT_ENBL,\n\t\t\t\t\tCONFIG_ALRT_BIT_ENBL);\n\t\t\tmax17042_set_soc_threshold(chip, 1);\n\t\t} else {\n\t\t\tclient->irq = 0;\n\t\t\tif (ret != -EBUSY)\n\t\t\t\tdev_err(&client->dev, "Failed to get IRQ\\n");\n\t\t}\n\t}\n\t/* Not able to update the charge threshold when exceeded? -> disable */\n\tif (!client->irq)\n\t\tregmap_write(chip->regmap, MAX17042_SALRT_Th, 0xff00);\n\n\tregmap_read(chip->regmap, MAX17042_STATUS, &val);\n\tif (val & STATUS_POR_BIT) {\n	f
46491	931	ext4_da_write_inline_data_begin	fs/ext4/inline.c	iloc.bh	1	11	\N	\N	\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\text4_journal_stop(handle);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n	f
54828	2401	bio_readpage_error	fs/btrfs/extent_io.c	bio_readpage_error_$failrec$obj$7	0	13	\N	\N	\tstruct io_failure_record *failrec;\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct bio *bio;\n\tint read_mode = 0;\n\tblk_status_t status;\n\tint ret;\n\n\tBUG_ON(bio_op(failed_bio) == REQ_OP_WRITE);\n\n\tret = btrfs_get_io_failure_record(inode, start, end, &failrec);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!btrfs_check_repairable(inode, failed_bio, failrec,\n\t\t\t\t    failed_mirror)) {\n\t\tfree_io_failure(failure_tree, tree, failrec);\n\t\treturn -EIO;\n\t}\n\n\tif (failed_bio->bi_vcnt > 1)\n\t\tread_mode |= REQ_FAILFAST_DEV;\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\tbio = btrfs_create_repair_bio(inode, failed_bio, failrec, page,\n\t\t\t\t      start - page_offset(page),\n\t\t\t\t      (int)phy_offset, failed_bio->bi_end_io,\n\t\t\t\t      NULL);\n\tbio_set_op_attrs(bio, REQ_OP_READ, read_mode);\n\n\tbtrfs_debug(btrfs_sb(inode->i_sb),\n	f
47637	367	iwl_mvm_rx_rx_mpdu	drivers/net/wireless/intel/iwlwifi/mvm/rx.c	sta	1	11	\N	\N	\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_phy_info *phy_info;\n\tstruct iwl_rx_mpdu_res_start *rx_res;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct sk_buff *skb;\n\tu32 len;\n\tu32 rate_n_flags;\n\tu32 rx_pkt_status;\n\tu8 crypt_len = 0;\n\tbool take_ref;\n\n\tphy_info = &mvm->last_phy_info;\n\trx_res = (struct iwl_rx_mpdu_res_start *)pkt->data;\n\thdr = (struct ieee80211_hdr *)(pkt->data + sizeof(*rx_res));\n\tlen = le16_to_cpu(rx_res->byte_count);\n\trx_pkt_status = le32_to_cpup((__le32 *)\n\t\t(pkt->data + sizeof(*rx_res) + len));\n\n\t/* Dont use dev_alloc_skb(), we'll have enough headroom once\n\t * ieee80211_hdr pulled.\n\t */\n\tskb = alloc_skb(128, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(mvm, "alloc_skb failed\\n");\n\t\treturn;\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\n\t/*\n\t * drop the packet if it has failed being decrypted by HW\n\t */\n\tif (iwl_mvm_set_mac80211_rx_flag(mvm, hdr, rx_status, rx_pkt_status,\n\t\t\t\t\t &crypt_len)) {\n\t\tIWL_DEBUG_DROP(mvm, "Bad decryption results 0x%08x\\n",\n\t\t\t       rx_pkt_status);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/*\n\t * Keep packets with CRC errors (and with overrun) for monitor mode\n\t * (otherwise the firmware discards them) but mark them as bad.\n\t */\n\tif (!(rx_pkt_status & RX_MPDU_RES_STATUS_CRC_OK) ||\n\t    !(rx_pkt_status & RX_MPDU_RES_STATUS_OVERRUN_OK)) {\n\t\tIWL_DEBUG_RX(mvm, "Bad CRC or FIFO: 0x%08X.\\n", rx_pkt_status);\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t}\n\n\t/* This will be used in several places later */\n\trate_n_flags = le32_to_cpu(phy_info->rate_n_flags);\n\n\t/* rx_status carries information about the packet to mac80211 */\n\trx_status->mactime = le64_to_cpu(phy_info->timestamp);\n\trx_status->device_timestamp = le32_to_cpu(phy_info->system_timestamp);\n\trx_status->band =\n\t\t(phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_BAND_24)) ?\n\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\trx_status->freq =\n\t\tieee80211_channel_to_frequency(le16_to_cpu(phy_info->channel),\n\t\t\t\t\t       rx_status->band);\n\n\t/* TSF as indicated by the firmware  is at INA time */\n\trx_status->flag |= RX_FLAG_MACTIME_PLCP_START;\n\n\tiwl_mvm_get_signal_strength(mvm, phy_info, rx_status);\n\n\tIWL_DEBUG_STATS_LIMIT(mvm, "Rssi %d, TSF %llu\\n", rx_status->signal,\n\t\t\t      (unsigned long long)rx_status->mactime);\n\n\trcu_read_lock();\n\tif (rx_pkt_status & RX_MPDU_RES_STATUS_SRC_STA_FOUND) {\n\t\tu32 id = rx_pkt_status & RX_MPDU_RES_STATUS_STA_ID_MSK;\n\n\t\tid >>= RX_MDPU_RES_STATUS_STA_ID_SHIFT;\n\n\t\tif (!WARN_ON_ONCE(id >= ARRAY_SIZE(mvm->fw_id_to_mac_id))) {\n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[id]);\n\t\t\tif (IS_ERR(sta))\n\t\t\t\tsta = NULL;\n\t\t}\n\t} else if (!is_multicast_ether_addr(hdr->addr2)) {\n\t\t/* This is fine since we prevent two stations with the same\n\t\t * address from being added.\n\t\t */\n\t\tsta = ieee80211_find_sta_by_ifaddr(mvm->hw, hdr->addr2, NULL);\n\t}\n\n\tif (sta) {\n	f
48012	451	ina2xx_probe	drivers/hwmon/ina2xx.c	val	1	11	\N	\N	\tstruct device *dev = &client->dev;\n\tstruct ina2xx_data *data;\n\tstruct device *hwmon_dev;\n\tu32 val;\n\tint ret, group = 0;\n\tenum ina2xx_ids chip;\n\n\tif (client->dev.of_node)\n\t\tchip = (enum ina2xx_ids)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = id->driver_data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* set the device type */\n\tdata->config = &ina2xx_config[chip];\n\n\tif (of_property_read_u32(dev->of_node, "shunt-resistor", &val) < 0) {\n\t\tstruct ina2xx_platform_data *pdata = dev_get_platdata(dev);\n\n\t\tif (pdata)\n\t\t\tval = pdata->shunt_uohms;\n\t\telse\n\t\t\tval = INA2XX_RSHUNT_DEFAULT;\n\t}\n\n\tif (val <= 0 || val > data->config->calibration_factor)\n	f
49310	186	adf_probe	drivers/crypto/qat/qat_dh895xccvf/adf_drv.c	accel_dev	1	11	\N	\N	\tstruct adf_accel_dev *accel_dev;\n\tstruct adf_accel_dev *pf;\n\tstruct adf_accel_pci *accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data;\n\tchar name[ADF_DEVICE_NAME_LENGTH];\n\tunsigned int i, bar_nr;\n\tint ret, bar_mask;\n\n\tswitch (ent->device) {\n\tcase ADF_DH895XCCIOV_PCI_DEVICE_ID:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, "Invalid device 0x%x.\\n", ent->device);\n\t\treturn -ENODEV;\n\t}\n\n\taccel_dev = kzalloc_node(sizeof(*accel_dev), GFP_KERNEL,\n\t\t\t\t dev_to_node(&pdev->dev));\n\tif (!accel_dev)\n\t\treturn -ENOMEM;\n\n\taccel_dev->is_vf = true;\n\tpf = adf_devmgr_pci_to_accel_dev(pdev->physfn);\n\taccel_pci_dev = &accel_dev->accel_pci_dev;\n\taccel_pci_dev->pci_dev = pdev;\n\n\t/* Add accel device to accel table */\n\tif (adf_devmgr_add_dev(accel_dev, pf)) {\n\t\tdev_err(&pdev->dev, "Failed to add new accelerator device.\\n");\n\t\tkfree(accel_dev);\n\t\treturn -EFAULT;\n\t}\n\tINIT_LIST_HEAD(&accel_dev->crypto_list);\n\n\taccel_dev->owner = THIS_MODULE;\n\t/* Allocate and configure device configuration structure */\n\thw_data = kzalloc_node(sizeof(*hw_data), GFP_KERNEL,\n\t\t\t       dev_to_node(&pdev->dev));\n\tif (!hw_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\taccel_dev->hw_device = hw_data;\n\tadf_init_hw_data_dh895xcciov(accel_dev->hw_device);\n\n\t/* Get Accelerators and Accelerators Engines masks */\n\thw_data->accel_mask = hw_data->get_accel_mask(hw_data->fuses);\n\thw_data->ae_mask = hw_data->get_ae_mask(hw_data->fuses);\n\taccel_pci_dev->sku = hw_data->get_sku(hw_data);\n\n\t/* Create dev top level debugfs entry */\n\tsnprintf(name, sizeof(name), "%s%s_%02x:%02d.%d",\n\t\t ADF_DEVICE_NAME_PREFIX, hw_data->dev_class->name,\n\t\t pdev->bus->number, PCI_SLOT(pdev->devfn),\n\t\t PCI_FUNC(pdev->devfn));\n\n\taccel_dev->debugfs_dir = debugfs_create_dir(name, NULL);\n\tif (!accel_dev->debugfs_dir) {\n\t\tdev_err(&pdev->dev, "Could not create debugfs dir %s\\n", name);\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t/* Create device configuration table */\n\tret = adf_cfg_dev_add(accel_dev);\n	f
51493	320	b43legacy_radio_aci_scan	drivers/net/wireless/broadcom/b43legacy/radio.c	ret	1	11	\N	\N	\tstruct b43legacy_phy *phy = &dev->phy;\n\tu8 ret[13];\n\tunsigned int channel = phy->channel;\n\tunsigned int i;\n\tunsigned int j;\n\tunsigned int start;\n\tunsigned int end;\n\n\tif (!((phy->type == B43legacy_PHYTYPE_G) && (phy->rev > 0)))\n\t\treturn 0;\n\n\tb43legacy_phy_lock(dev);\n\tb43legacy_radio_lock(dev);\n\tb43legacy_phy_write(dev, 0x0802,\n\t\t\t    b43legacy_phy_read(dev, 0x0802) & 0xFFFC);\n\tb43legacy_phy_write(dev, B43legacy_PHY_G_CRS,\n\t\t\t    b43legacy_phy_read(dev, B43legacy_PHY_G_CRS)\n\t\t\t    & 0x7FFF);\n\tb43legacy_set_all_gains(dev, 3, 8, 1);\n\n\tstart = (channel - 5 > 0) ? channel - 5 : 1;\n\tend = (channel + 5 < 14) ? channel + 5 : 13;\n\n\tfor (i = start; i <= end; i++) {\n\t\tif (abs(channel - i) > 2)\n\t\t\tret[i-1] = b43legacy_radio_aci_detect(dev, i);\n\t}\n\tb43legacy_radio_selectchannel(dev, channel, 0);\n\tb43legacy_phy_write(dev, 0x0802,\n\t\t\t    (b43legacy_phy_read(dev, 0x0802) & 0xFFFC)\n\t\t\t    | 0x0003);\n\tb43legacy_phy_write(dev, 0x0403,\n\t\t\t    b43legacy_phy_read(dev, 0x0403) & 0xFFF8);\n\tb43legacy_phy_write(dev, B43legacy_PHY_G_CRS,\n\t\t\t    b43legacy_phy_read(dev, B43legacy_PHY_G_CRS)\n\t\t\t    | 0x8000);\n\tb43legacy_set_original_gains(dev);\n\tfor (i = 0; i < 13; i++) {\n\t\tif (!ret[i])\n	f
29117	4993	mlx4_do_mirror_rule	drivers/net/ethernet/mellanox/mlx4/resource_tracker.c	reg_id	1	11	\N	\N	\tstruct mlx4_cmd_mailbox *mailbox;\n\tint err;\n\tstruct res_fs_rule *mirr_rule;\n\tu64 reg_id;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tif (!fs_rule->mirr_mbox) {\n\t\tmlx4_err(dev, "rule mirroring mailbox is null\\n");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(mailbox->buf, fs_rule->mirr_mbox, fs_rule->mirr_mbox_size);\n\terr = mlx4_cmd_imm(dev, mailbox->dma, &reg_id, fs_rule->mirr_mbox_size >> 2, 0,\n\t\t\t   MLX4_QP_FLOW_STEERING_ATTACH, MLX4_CMD_TIME_CLASS_A,\n\t\t\t   MLX4_CMD_NATIVE);\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\tif (err)\n\t\tgoto err;\n\n\terr = add_res_range(dev, fs_rule->com.owner, reg_id, 1, RES_FS_RULE, fs_rule->qpn);\n	f
29910	1976	mvneta_rx_swbm	drivers/net/ethernet/marvell/mvneta.c	skb	1	11	\N	\N	\tstruct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);\n\tstruct net_device *dev = pp->dev;\n\tint rx_done;\n\tu32 rcvd_pkts = 0;\n\tu32 rcvd_bytes = 0;\n\n\t/* Get number of received packets */\n\trx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);\n\n\tif (rx_todo > rx_done)\n\t\trx_todo = rx_done;\n\n\trx_done = 0;\n\n\t/* Fairness NAPI loop */\n\twhile (rx_done < rx_todo) {\n\t\tstruct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);\n\t\tstruct sk_buff *skb;\n\t\tunsigned char *data;\n\t\tdma_addr_t phys_addr;\n\t\tu32 rx_status, frag_size;\n\t\tint rx_bytes, err, index;\n\n\t\trx_done++;\n\t\trx_status = rx_desc->status;\n\t\trx_bytes = rx_desc->data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);\n\t\tindex = rx_desc - rxq->descs;\n\t\tdata = rxq->buf_virt_addr[index];\n\t\tphys_addr = rx_desc->buf_phys_addr;\n\n\t\tif (!mvneta_rxq_desc_is_first_last(rx_status) ||\n\t\t    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {\nerr_drop_frame:\n\t\t\tdev->stats.rx_errors++;\n\t\t\tmvneta_rx_error(pp, rx_desc);\n\t\t\t/* leave the descriptor untouched */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rx_bytes <= rx_copybreak) {\n\t\t/* better copy a small frame and not unmap the DMA region */\n\t\t\tskb = netdev_alloc_skb_ip_align(dev, rx_bytes);\n\t\t\tif (unlikely(!skb))\n\t\t\t\tgoto err_drop_frame;\n\n\t\t\tdma_sync_single_range_for_cpu(dev->dev.parent,\n\t\t\t\t\t\t      phys_addr,\n\t\t\t\t\t\t      MVNETA_MH_SIZE + NET_SKB_PAD,\n\t\t\t\t\t\t      rx_bytes,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tskb_put_data(skb, data + MVNETA_MH_SIZE + NET_SKB_PAD,\n	f
48055	837	mwifiex_deinit_priv_params	drivers/net/wireless/marvell/mwifiex/cfg80211.c	mwifiex_deinit_priv_params_	2	-11	\N	\N	\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tunsigned long flags;\n\n\tpriv->mgmt_frame_mask = 0;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n	t
48760	441	nfc_llcp_send_connect	net/nfc/llcp_commands.c	service_name_tlv_length	1	11	\N	\N	\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug("Sending CONNECT\\n");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tsize += rw_tlv_length;\n\n\tpr_debug("SKB size %d SN length %zu\\n", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n	f
48893	235	nfp_nffw_info_open	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.c	err	1	11	\N	\N	\tstruct nfp_nffw_info_data *fwinf;\n\tstruct nfp_nffw_info *state;\n\tu32 info_ver;\n\tint err;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->res = nfp_resource_acquire(cpp, NFP_RESOURCE_NFP_NFFW);\n\tif (IS_ERR(state->res))\n\t\tgoto err_free;\n\n\tfwinf = &state->fwinf;\n\n\tif (sizeof(*fwinf) > nfp_resource_size(state->res))\n\t\tgoto err_release;\n\n\terr = nfp_cpp_read(cpp, nfp_resource_cpp_id(state->res),\n\t\t\t   nfp_resource_address(state->res),\n\t\t\t   fwinf, sizeof(*fwinf));\n\tif (err < sizeof(*fwinf))\n	f
49290	84	mcopy_atomic_pte	mm/userfaultfd.c	memcg	1	11	\N	\N	\tstruct mem_cgroup *memcg;\n\tpte_t _dst_pte, *dst_pte;\n\tspinlock_t *ptl;\n\tvoid *page_kaddr;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, dst_vma, dst_addr);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\tpage_kaddr = kmap_atomic(page);\n\t\tret = copy_from_user(page_kaddr,\n\t\t\t\t     (const void __user *) src_addr,\n\t\t\t\t     PAGE_SIZE);\n\t\tkunmap_atomic(page_kaddr);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tret = -ENOMEM;\n\tif (mem_cgroup_try_charge(page, dst_mm, GFP_KERNEL, &memcg, false))\n\t\tgoto out_release;\n\n\t_dst_pte = mk_pte(page, dst_vma->vm_page_prot);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = pte_mkwrite(pte_mkdirty(_dst_pte));\n\n\tret = -EEXIST;\n\tdst_pte = pte_offset_map_lock(dst_mm, dst_pmd, dst_addr, &ptl);\n\tif (!pte_none(*dst_pte))\n\t\tgoto out_release_uncharge_unlock;\n\n\tinc_mm_counter(dst_mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, dst_vma, dst_addr, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n	f
52145	1449	ext4_init_inode_table	fs/ext4/ialloc.c	ret	1	11	\N	\N	\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct buffer_head *group_desc_bh;\n\thandle_t *handle;\n\text4_fsblk_t blk;\n\tint num, ret = 0, used_blks = 0;\n\n\t/* This should not happen, but just to be sure check this */\n\tif (sb_rdonly(sb)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\tif (!gdp)\n\t\tgoto out;\n\n\t/*\n\t * We do not need to lock this, because we are the only one\n\t * handling this flag.\n\t */\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))\n\t\tgoto out;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tdown_write(&grp->alloc_sem);\n\t/*\n\t * If inode bitmap was already initialized there may be some\n\t * used inodes so we need to skip blocks with used inodes in\n\t * inode table.\n\t */\n\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)))\n\t\tused_blks = DIV_ROUND_UP((EXT4_INODES_PER_GROUP(sb) -\n\t\t\t    ext4_itable_unused_count(sb, gdp)),\n\t\t\t    sbi->s_inodes_per_block);\n\n\tif ((used_blks < 0) || (used_blks > sbi->s_itb_per_group)) {\n\t\text4_error(sb, "Something is wrong with group %u: "\n\t\t\t   "used itable blocks: %d; "\n\t\t\t   "itable unused count: %u",\n\t\t\t   group, used_blks,\n\t\t\t   ext4_itable_unused_count(sb, gdp));\n\t\tret = 1;\n\t\tgoto err_out;\n\t}\n\n\tblk = ext4_inode_table(sb, gdp) + used_blks;\n\tnum = sbi->s_itb_per_group - used_blks;\n\n\tBUFFER_TRACE(group_desc_bh, "get_write_access");\n\tret = ext4_journal_get_write_access(handle,\n\t\t\t\t\t    group_desc_bh);\n\tif (ret)\n\t\tgoto err_out;\n\n\t/*\n\t * Skip zeroout if the inode table is full. But we set the ZEROED\n\t * flag anyway, because obviously, when it is full it does not need\n\t * further zeroing.\n\t */\n\tif (unlikely(num == 0))\n\t\tgoto skip_zeroout;\n\n\text4_debug("going to zero out inode table in group %d\\n",\n\t\t   group);\n\tret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);\n\tif (ret < 0)\n	f
52196	197	detect_quirks	sound/firewire/oxfw/oxfw.c	key	1	11	\N	\N	\tstruct fw_device *fw_dev = fw_parent_device(oxfw->unit);\n\tstruct fw_csr_iterator it;\n\tint key, val;\n\tint vendor, model;\n\n\t/*\n\t * Add ALSA control elements for two models to keep compatibility to\n\t * old firewire-speaker module.\n\t */\n\tif (oxfw->entry->vendor_id == VENDOR_GRIFFIN)\n\t\treturn snd_oxfw_add_spkr(oxfw, false);\n\tif (oxfw->entry->vendor_id == VENDOR_LACIE)\n\t\treturn snd_oxfw_add_spkr(oxfw, true);\n\n\t/*\n\t * Stanton models supports asynchronous transactions for unique MIDI\n\t * messages.\n\t */\n\tif (oxfw->entry->vendor_id == OUI_STANTON) {\n\t\t/* No physical MIDI ports. */\n\t\toxfw->midi_input_ports = 0;\n\t\toxfw->midi_output_ports = 0;\n\n\t\t/* Output stream exists but no data channels are useful. */\n\t\toxfw->has_output = false;\n\n\t\treturn snd_oxfw_scs1x_add(oxfw);\n\t}\n\n\t/*\n\t * TASCAM FireOne has physical control and requires a pair of additional\n\t * MIDI ports.\n\t */\n\tif (oxfw->entry->vendor_id == VENDOR_TASCAM) {\n\t\toxfw->midi_input_ports++;\n\t\toxfw->midi_output_ports++;\n\t\treturn 0;\n\t}\n\n\t/* Seek from Root Directory of Config ROM. */\n\tvendor = model = 0;\n\tfw_csr_iterator_init(&it, fw_dev->config_rom + 5);\n\twhile (fw_csr_iterator_next(&it, &key, &val)) {\n\t\tif (key == CSR_VENDOR)\n	f
52498	414	nfs4_init_client	fs/nfs/nfs4client.c	old	1	11	\N	\N	\tchar buf[INET6_ADDRSTRLEN + 1];\n\tconst char *ip_addr = cl_init->ip_addr;\n\tstruct nfs_client *old;\n\tint error;\n\n\tif (clp->cl_cons_state == NFS_CS_READY)\n\t\t/* the client is initialised already */\n\t\treturn clp;\n\n\t/* Check NFS protocol revision and initialize RPC op vector */\n\tclp->rpc_ops = &nfs_v4_clientops;\n\n\tif (clp->cl_minorversion != 0)\n\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);\n\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);\n\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);\n\n\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);\n\tif (error == -EINVAL)\n\t\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* If no clientaddr= option was specified, find a usable cb address */\n\tif (ip_addr == NULL) {\n\t\tstruct sockaddr_storage cb_addr;\n\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;\n\n\t\terror = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));\n\t\tif (error < 0)\n\t\t\tgoto error;\n\t\terror = rpc_ntop(sap, buf, sizeof(buf));\n\t\tif (error < 0)\n\t\t\tgoto error;\n\t\tip_addr = (const char *)buf;\n\t}\n\tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));\n\n\terror = nfs_idmap_new(clp);\n\tif (error < 0) {\n\t\tdprintk("%s: failed to create idmapper. Error = %d\\n",\n\t\t\t__func__, error);\n\t\tgoto error;\n\t}\n\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);\n\n\terror = nfs4_init_client_minor_version(clp);\n\tif (error < 0)\n\t\tgoto error;\n\n\tif (!nfs4_has_session(clp))\n\t\tnfs_mark_client_ready(clp, NFS_CS_READY);\n\n\terror = nfs4_discover_server_trunking(clp, &old);\n\tif (error < 0)\n\t\tgoto error;\n\n\tif (clp != old)\n	f
807	288	ds278x_bat_update	drivers/power/supply/ds2782_battery.c	ds278x_bat_update_$info.addr$obj$38$obj	0	13	\N	\N	\tint old_status = info->status;\n\tint old_capacity = info->capacity;\n\n\tds278x_get_status(info, &info->status);\n\n\tif ((old_status != info->status) || (old_capacity != info->capacity))\n	f
53284	5452	ext4_setattr	fs/ext4/inode.c	error	1	11	\N	\N	\tstruct inode *inode = d_inode(dentry);\n\tint error, rc = 0;\n\tint orphan = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\n\terror = setattr_prepare(dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr)) {\n\t\terror = dquot_initialize(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +\n\t\t\t EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t/* dquot_transfer() calls back ext4_get_inode_usage() which\n\t\t * counts xattr inode references.\n\t\t */\n\t\tdown_read(&EXT4_I(inode)->xattr_sem);\n\t\terror = dquot_transfer(inode, attr);\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\t\tif (error) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\thandle_t *handle;\n\t\tloff_t oldsize = inode->i_size;\n\t\tint shrink = (attr->ia_size <= inode->i_size);\n\n\t\tif (ext4_encrypted_inode(inode)) {\n\t\t\terror = fscrypt_get_encryption_info(inode);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (!fscrypt_has_encryption_key(inode))\n\t\t\t\treturn -ENOKEY;\n\t\t}\n\n\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\t\tif (attr->ia_size > sbi->s_bitmap_maxbytes)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)\n\t\t\tinode_inc_iversion(inode);\n\n\t\tif (ext4_should_order_data(inode) &&\n\t\t    (attr->ia_size < inode->i_size)) {\n\t\t\terror = ext4_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t    attr->ia_size);\n\t\t\tif (error)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tif (attr->ia_size != inode->i_size) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terror = PTR_ERR(handle);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ext4_handle_valid(handle) && shrink) {\n\t\t\t\terror = ext4_orphan_add(handle, inode);\n\t\t\t\torphan = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Update c/mtime on truncate up, ext4_truncate() will\n\t\t\t * update c/mtime in shrink case below\n\t\t\t */\n\t\t\tif (!shrink) {\n\t\t\t\tinode->i_mtime = current_time(inode);\n\t\t\t\tinode->i_ctime = inode->i_mtime;\n\t\t\t}\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tEXT4_I(inode)->i_disksize = attr->ia_size;\n\t\t\trc = ext4_mark_inode_dirty(handle, inode);\n\t\t\tif (!error)\n\t\t\t\terror = rc;\n\t\t\t/*\n\t\t\t * We have to update i_size under i_data_sem together\n\t\t\t * with i_disksize to avoid races with writeback code\n\t\t\t * running ext4_wb_update_i_disksize().\n\t\t\t */\n\t\t\tif (!error)\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\text4_journal_stop(handle);\n\t\t\tif (error) {\n\t\t\t\tif (orphan)\n\t\t\t\t\text4_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tif (!shrink)\n\t\t\tpagecache_isize_extended(inode, oldsize, inode->i_size);\n\n\t\t/*\n\t\t * Blocks are going to be removed from the inode. Wait\n\t\t * for dio in flight.  Temporarily disable\n\t\t * dioread_nolock to prevent livelock.\n\t\t */\n\t\tif (orphan) {\n\t\t\tif (!ext4_should_journal_data(inode)) {\n\t\t\t\text4_inode_block_unlocked_dio(inode);\n\t\t\t\tinode_dio_wait(inode);\n\t\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\t} else\n\t\t\t\text4_wait_for_tail_page_commit(inode);\n\t\t}\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t/*\n\t\t * Truncate pagecache after we've waited for commit\n\t\t * in data=journal mode to make pages freeable.\n\t\t */\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tif (shrink) {\n\t\t\trc = ext4_truncate(inode);\n\t\t\tif (rc)\n\t\t\t\terror = rc;\n\t\t}\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t}\n\n\tif (!error) {\n	f
3469	4942	set_agc_rf	drivers/media/dvb-frontends/drx39xyj/drxj.c	data	1	11	\N	\N	\tstruct i2c_device_addr *dev_addr = NULL;\n\tstruct drxj_data *ext_attr = NULL;\n\tstruct drxj_cfg_agc *p_agc_settings = NULL;\n\tstruct drx_common_attr *common_attr = NULL;\n\tint rc;\n\tdrx_write_reg16func_t scu_wr16 = NULL;\n\tdrx_read_reg16func_t scu_rr16 = NULL;\n\n\tcommon_attr = (struct drx_common_attr *) demod->my_common_attr;\n\tdev_addr = demod->my_i2c_dev_addr;\n\text_attr = (struct drxj_data *) demod->my_ext_attr;\n\n\tif (atomic) {\n\t\tscu_rr16 = drxj_dap_scu_atomic_read_reg16;\n\t\tscu_wr16 = drxj_dap_scu_atomic_write_reg16;\n\t} else {\n\t\tscu_rr16 = drxj_dap_read_reg16;\n\t\tscu_wr16 = drxj_dap_write_reg16;\n\t}\n\n\t/* Configure AGC only if standard is currently active */\n\tif ((ext_attr->standard == agc_settings->standard) ||\n\t    (DRXJ_ISQAMSTD(ext_attr->standard) &&\n\t     DRXJ_ISQAMSTD(agc_settings->standard)) ||\n\t    (DRXJ_ISATVSTD(ext_attr->standard) &&\n\t     DRXJ_ISATVSTD(agc_settings->standard))) {\n\t\tu16 data = 0;\n\n\t\tswitch (agc_settings->ctrl_mode) {\n\t\tcase DRX_AGC_CTRL_AUTO:\n\n\t\t\t/* Enable RF AGC DAC */\n\t\t\trc = drxj_dap_read_reg16(dev_addr, IQM_AF_STDBY__A, &data, 0);\n\t\t\tif (rc != 0) {\n\t\t\t\tpr_err("error %d\\n", rc);\n\t\t\t\tgoto rw_error;\n\t\t\t}\n\t\t\tdata |= IQM_AF_STDBY_STDBY_TAGC_RF_A2_ACTIVE;\n\t\t\trc = drxj_dap_write_reg16(dev_addr, IQM_AF_STDBY__A, data, 0);\n	t
-216	173	stm32_timer_stop	drivers/iio/trigger/stm32-timer-trigger.c	cr1	4	20	\N	\N	\tu32 ccer, cr1;\n\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tif (ccer & TIM_CCER_CCXE)\n\t\treturn;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tif (cr1 & TIM_CR1_CEN)\n	f
3754	77	max8997_battery_get_property	drivers/power/supply/max8997_charger.c	reg	1	11	\N	\N	\tstruct charger_data *charger = power_supply_get_drvdata(psy);\n\tstruct i2c_client *i2c = charger->iodev->i2c;\n\tint ret;\n\tu8 reg;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & (1 << 0)) == 0x1)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & (1 << 2)) == 0x0)\n\t\t\tval->intval = 1;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t/* DCINOK */\n\t\tif (reg & (1 << 1))\n	t
3756	681	ov8858_g_comp_delay	drivers/staging/media/atomisp/i2c/ov8858.c	usec	1	11	\N	\N	\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov8858_device *dev = to_ov8858_sensor(sd);\n\tint ret = 0, exposure;\n\tu16 vts, data;\n\n\tif (dev->exposure == 0) {\n\t\tret = ov8858_read_reg(client, OV8858_16BIT,\n\t\t\t\t       OV8858_LONG_EXPO + 1, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\texposure = data;\n\t\texposure >>= 4;\n\t} else {\n\t\texposure = dev->exposure;\n\t}\n\n\tret = ov8858_read_reg(client, OV8858_16BIT, OV8858_TIMING_VTS, &vts);\n\tif (ret || vts == 0)\n\t\tvts = OV8858_DEPTH_VTS_CONST;\n\n\t*usec = (exposure * 33333 / vts);\n\tif (*usec >  OV8858_DEPTH_COMP_CONST)\n	t
3833	1067	aif1clk_ev	sound/soc/codecs/wm8994.c	val	1	11	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\n\tstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint mask = WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA;\n\tint i;\n\tint dac;\n\tint adc;\n\tint val;\n\n\tswitch (control->type) {\n\tcase WM8994:\n\tcase WM8958:\n\t\tmask |= WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t/* Don't enable timeslot 2 if not in use */\n\t\tif (wm8994->channels[0] <= 2)\n\t\t\tmask &= ~(WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);\n\n\t\tval = snd_soc_read(codec, WM8994_AIF1_CONTROL_1);\n\t\tif ((val & WM8994_AIF1ADCL_SRC) &&\n	t
49811	283	ds2780_get_accumulated_current	drivers/power/supply/ds2780_battery.c	sense_res_raw	1	13	\N	\N	\tint ret, sense_res;\n\ts16 current_raw;\n\tu8 sense_res_raw;\n\n\t/*\n\t * The units of measurement for accumulated current are dependent on\n\t * the value of the sense resistor.\n\t */\n\tret = ds2780_read8(dev_info, &sense_res_raw, DS2780_RSNSP_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sense_res_raw == 0) {\n	f
3611	1153	lg2160_read_lock_status	drivers/media/dvb-frontends/lg2160.c	val	7	12	\N	don't know what lg_fail is	\tu8 val;\n\tint ret;\n\n\t*acq_lock = 0;\n\t*sync_lock = 0;\n\n\tret = lg216x_read_reg(state, 0x011b, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*sync_lock = (val & 0x20) ? 0 : 1;\n\t*acq_lock  = (val & 0x40) ? 0 : 1;\n	t
28011	357	remove_file	drivers/infiniband/hw/qib/qib_fs.c	remove_file_$lock.addr.i16$obj$0	0	13	\N	\N	\tstruct qib_devdata *dd;\n\tssize_t ret;\n\tloff_t pos;\n\tchar *tmp;\n\n\tpos = *ppos;\n\n\tif (pos != 0 || count != sizeof(struct qib_flash))\n\t\treturn -EINVAL;\n\n\ttmp = memdup_user(buf, count);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tdd = private2dd(file);\n\tif (qib_eeprom_write(dd, pos, tmp, count)) {\n\t\tret = -ENXIO;\n\t\tqib_dev_err(dd, "failed to write to flash\\n");\n\t\tgoto bail_tmp;\n\t}\n\n\t*ppos = pos + count;\n\tret = count;\n\nbail_tmp:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic const struct file_operations flash_ops = {\n\t.read = flash_read,\n\t.write = flash_write,\n\t.llseek = default_llseek,\n};\n	f
3934	874	area_cache_get	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c	err	1	11	\N	\N	\tstruct nfp_cpp_area_cache *cache;\n\tint err;\n\n\t/* Early exit when length == 0, which prevents\n\t * the need for special case code below when\n\t * checking against available cache size.\n\t */\n\tif (length == 0 || id == 0)\n\t\treturn NULL;\n\n\t/* Remap from cpp_island to cpp_target */\n\terr = nfp_target_cpp(id, addr, &id, &addr, cpp->imb_cat_table);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tmutex_lock(&cpp->area_cache_mutex);\n\n\tif (list_empty(&cpp->area_cache_list)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\taddr += *offset;\n\n\t/* See if we have a match */\n\tlist_for_each_entry(cache, &cpp->area_cache_list, entry) {\n\t\tif (id == cache->id &&\n\t\t    addr >= cache->addr &&\n\t\t    addr + length <= cache->addr + cache->size)\n\t\t\tgoto exit;\n\t}\n\n\t/* No matches - inspect the tail of the LRU */\n\tcache = list_entry(cpp->area_cache_list.prev,\n\t\t\t   struct nfp_cpp_area_cache, entry);\n\n\t/* Can we fit in the cache entry? */\n\tif (round_down(addr + length - 1, cache->size) !=\n\t    round_down(addr, cache->size)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\t/* If id != 0, we will need to release it */\n\tif (cache->id) {\n\t\tnfp_cpp_area_release(cache->area);\n\t\tcache->id = 0;\n\t\tcache->addr = 0;\n\t}\n\n\t/* Adjust the start address to be cache size aligned */\n\tcache->id = id;\n\tcache->addr = addr & ~(u64)(cache->size - 1);\n\n\t/* Re-init to the new ID and address */\n\tif (cpp->op->area_init) {\n\t\terr = cpp->op->area_init(cache->area,\n\t\t\t\t\t id, cache->addr, cache->size);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Attempt to acquire */\n\terr = nfp_cpp_area_acquire(cache->area);\n\tif (err < 0) {\n	t
3992	307	prepare_exec_creds	kernel/cred.c	new->process_keyring	1	11	\N	\N	\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n	t
4275	1128	r820t_set_tv_standard	drivers/media/tuners/r820t.c	priv->fil_cal_code	1	11	\N	\N	\tint rc, i;\n\tu32 if_khz, filt_cal_lo;\n\tu8 data[5], val;\n\tu8 filt_gain, img_r, filt_q, hp_cor, ext_enable, loop_through;\n\tu8 lt_att, flt_ext_widest, polyfil_cur;\n\tbool need_calibration;\n\n\ttuner_dbg("selecting the delivery system\\n");\n\n\tif (delsys == SYS_ISDBT) {\n\t\tif_khz = 4063;\n\t\tfilt_cal_lo = 59000;\n\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\timg_r = 0x00;\t\t/* image negative */\n\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\thp_cor = 0x6a;\t\t/* 1.7m disable, +2cap, 1.25mhz */\n\t\text_enable = 0x40;\t/* r30[6], ext enable; r30[5]:0 ext at lna max */\n\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\tflt_ext_widest = 0x80;\t/* r15[7]: flt_ext_wide on */\n\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t} else if (delsys == SYS_DVBC_ANNEX_A) {\n\t\tif_khz = 5070;\n\t\tfilt_cal_lo = 73500;\n\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\timg_r = 0x00;\t\t/* image negative */\n\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\thp_cor = 0x0b;\t\t/* 1.7m disable, +0cap, 1.0mhz */\n\t\text_enable = 0x40;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\tflt_ext_widest = 0x00;\t/* r15[7]: flt_ext_wide off */\n\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t} else if (delsys == SYS_DVBC_ANNEX_C) {\n\t\tif_khz = 4063;\n\t\tfilt_cal_lo = 55000;\n\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\timg_r = 0x00;\t\t/* image negative */\n\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\thp_cor = 0x6a;\t\t/* 1.7m disable, +0cap, 1.0mhz */\n\t\text_enable = 0x40;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\tflt_ext_widest = 0x80;\t/* r15[7]: flt_ext_wide on */\n\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t} else {\n\t\tif (bw <= 6) {\n\t\t\tif_khz = 3570;\n\t\t\tfilt_cal_lo = 56000;\t/* 52000->56000 */\n\t\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\t\timg_r = 0x00;\t\t/* image negative */\n\t\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\t\thp_cor = 0x6b;\t\t/* 1.7m disable, +2cap, 1.0mhz */\n\t\t\text_enable = 0x60;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\t\tflt_ext_widest = 0x00;\t/* r15[7]: flt_ext_wide off */\n\t\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t\t} else if (bw == 7) {\n#if 0\n\t\t\t/*\n\t\t\t * There are two 7 MHz tables defined on the original\n\t\t\t * driver, but just the second one seems to be visible\n\t\t\t * by rtl2832. Keep this one here commented, as it\n\t\t\t * might be needed in the future\n\t\t\t */\n\n\t\t\tif_khz = 4070;\n\t\t\tfilt_cal_lo = 60000;\n\t\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\t\timg_r = 0x00;\t\t/* image negative */\n\t\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\t\thp_cor = 0x2b;\t\t/* 1.7m disable, +1cap, 1.0mhz */\n\t\t\text_enable = 0x60;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\t\tflt_ext_widest = 0x00;\t/* r15[7]: flt_ext_wide off */\n\t\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n#endif\n\t\t\t/* 7 MHz, second table */\n\t\t\tif_khz = 4570;\n\t\t\tfilt_cal_lo = 63000;\n\t\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\t\timg_r = 0x00;\t\t/* image negative */\n\t\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\t\thp_cor = 0x2a;\t\t/* 1.7m disable, +1cap, 1.25mhz */\n\t\t\text_enable = 0x60;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\t\tflt_ext_widest = 0x00;\t/* r15[7]: flt_ext_wide off */\n\t\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t\t} else {\n\t\t\tif_khz = 4570;\n\t\t\tfilt_cal_lo = 68500;\n\t\t\tfilt_gain = 0x10;\t/* +3db, 6mhz on */\n\t\t\timg_r = 0x00;\t\t/* image negative */\n\t\t\tfilt_q = 0x10;\t\t/* r10[4]:low q(1'b1) */\n\t\t\thp_cor = 0x0b;\t\t/* 1.7m disable, +0cap, 1.0mhz */\n\t\t\text_enable = 0x60;\t/* r30[6]=1 ext enable; r30[5]:1 ext at lna max-1 */\n\t\t\tloop_through = 0x00;\t/* r5[7], lt on */\n\t\t\tlt_att = 0x00;\t\t/* r31[7], lt att enable */\n\t\t\tflt_ext_widest = 0x00;\t/* r15[7]: flt_ext_wide off */\n\t\t\tpolyfil_cur = 0x60;\t/* r25[6:5]:min */\n\t\t}\n\t}\n\n\t/* Initialize the shadow registers */\n\tmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\n\n\t/* Init Flag & Xtal_check Result */\n\tif (priv->imr_done)\n\t\tval = 1 | priv->xtal_cap_sel << 1;\n\telse\n\t\tval = 0;\n\trc = r820t_write_reg_mask(priv, 0x0c, val, 0x0f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* version */\n\trc = r820t_write_reg_mask(priv, 0x13, VER_NUM, 0x3f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* for LT Gain test */\n\tif (type != V4L2_TUNER_ANALOG_TV) {\n\t\trc = r820t_write_reg_mask(priv, 0x1d, 0x00, 0x38);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tusleep_range(1000, 2000);\n\t}\n\tpriv->int_freq = if_khz * 1000;\n\n\t/* Check if standard changed. If so, filter calibration is needed */\n\tif (type != priv->type)\n\t\tneed_calibration = true;\n\telse if ((type == V4L2_TUNER_ANALOG_TV) && (std != priv->std))\n\t\tneed_calibration = true;\n\telse if ((type == V4L2_TUNER_DIGITAL_TV) &&\n\t\t ((delsys != priv->delsys) || bw != priv->bw))\n\t\tneed_calibration = true;\n\telse\n\t\tneed_calibration = false;\n\n\tif (need_calibration) {\n\t\ttuner_dbg("calibrating the tuner\\n");\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t/* Set filt_cap */\n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, hp_cor, 0x60);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t/* set cali clk =on */\n\t\t\trc = r820t_write_reg_mask(priv, 0x0f, 0x04, 0x04);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t/* X'tal cap 0pF for PLL */\n\t\t\trc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x03);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\trc = r820t_set_pll(priv, type, filt_cal_lo * 1000);\n\t\t\tif (rc < 0 || !priv->has_lock)\n\t\t\t\treturn rc;\n\n\t\t\t/* Start Trigger */\n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, 0x10, 0x10);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tusleep_range(1000, 2000);\n\n\t\t\t/* Stop Trigger */\n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, 0x00, 0x10);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t/* set cali clk =off */\n\t\t\trc = r820t_write_reg_mask(priv, 0x0f, 0x00, 0x04);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t/* Check if calibration worked */\n\t\t\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tpriv->fil_cal_code = data[4] & 0x0f;\n\t\t\tif (priv->fil_cal_code && priv->fil_cal_code != 0x0f)\n	t
4370	1866	get_memory_layout	drivers/edac/sb_edac.c	rir_way	1	11	\N	\N	\tstruct sbridge_pvt *pvt = mci->pvt_info;\n\tint i, j, k, n_sads, n_tads, sad_interl;\n\tu32 reg;\n\tu64 limit, prv = 0;\n\tu64 tmp_mb;\n\tu32 gb, mb;\n\tu32 rir_way;\n\n\t/*\n\t * Step 1) Get TOLM/TOHM ranges\n\t */\n\n\tpvt->tolm = pvt->info.get_tolm(pvt);\n\ttmp_mb = (1 + pvt->tolm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tolm);\n\n\t/* Address range is already 45:25 */\n\tpvt->tohm = pvt->info.get_tohm(pvt);\n\ttmp_mb = (1 + pvt->tohm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tohm);\n\n\t/*\n\t * Step 2) Get SAD range and SAD Interleave list\n\t * TAD registers contain the interleave wayness. However, it\n\t * seems simpler to just discover it indirectly, with the\n\t * algorithm bellow.\n\t */\n\tprv = 0;\n\tfor (n_sads = 0; n_sads < pvt->info.max_sad; n_sads++) {\n\t\t/* SAD_LIMIT Address range is 45:26 */\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.dram_rule[n_sads],\n\t\t\t\t      &reg);\n\t\tlimit = pvt->info.sad_limit(reg);\n\n\t\tif (!DRAM_RULE_ENABLE(reg))\n\t\t\tcontinue;\n\n\t\tif (limit <= prv)\n\t\t\tbreak;\n\n\t\ttmp_mb = (limit + 1) >> 20;\n\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\tedac_dbg(0, "SAD#%d %s up to %u.%03u GB (0x%016Lx) Interleave: %s reg=0x%08x\\n",\n\t\t\t n_sads,\n\t\t\t show_dram_attr(pvt->info.dram_attr(reg)),\n\t\t\t gb, (mb*1000)/1024,\n\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t get_intlv_mode_str(reg, pvt->info.type),\n\t\t\t reg);\n\t\tprv = limit;\n\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.interleave_list[n_sads],\n\t\t\t\t      &reg);\n\t\tsad_interl = sad_pkg(pvt->info.interleave_pkg, reg, 0);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tu32 pkg = sad_pkg(pvt->info.interleave_pkg, reg, j);\n\t\t\tif (j > 0 && sad_interl == pkg)\n\t\t\t\tbreak;\n\n\t\t\tedac_dbg(0, "SAD#%d, interleave #%d: %d\\n",\n\t\t\t\t n_sads, j, pkg);\n\t\t}\n\t}\n\n\tif (pvt->info.type == KNIGHTS_LANDING)\n\t\treturn;\n\n\t/*\n\t * Step 3) Get TAD range\n\t */\n\tprv = 0;\n\tfor (n_tads = 0; n_tads < MAX_TAD; n_tads++) {\n\t\tpci_read_config_dword(pvt->pci_ha, tad_dram_rule[n_tads], &reg);\n\t\tlimit = TAD_LIMIT(reg);\n\t\tif (limit <= prv)\n\t\t\tbreak;\n\t\ttmp_mb = (limit + 1) >> 20;\n\n\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\tedac_dbg(0, "TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\\n",\n\t\t\t n_tads, gb, (mb*1000)/1024,\n\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t (u32)(1 << TAD_SOCK(reg)),\n\t\t\t (u32)TAD_CH(reg) + 1,\n\t\t\t (u32)TAD_TGT0(reg),\n\t\t\t (u32)TAD_TGT1(reg),\n\t\t\t (u32)TAD_TGT2(reg),\n\t\t\t (u32)TAD_TGT3(reg),\n\t\t\t reg);\n\t\tprv = limit;\n\t}\n\n\t/*\n\t * Step 4) Get TAD offsets, per each channel\n\t */\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tif (!pvt->channel[i].dimms)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < n_tads; j++) {\n\t\t\tpci_read_config_dword(pvt->pci_tad[i],\n\t\t\t\t\t      tad_ch_nilv_offset[j],\n\t\t\t\t\t      &reg);\n\t\t\ttmp_mb = TAD_OFFSET(reg) >> 20;\n\t\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\t\tedac_dbg(0, "TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\\n",\n\t\t\t\t i, j,\n\t\t\t\t gb, (mb*1000)/1024,\n\t\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t\t reg);\n\t\t}\n\t}\n\n\t/*\n\t * Step 6) Get RIR Wayness/Limit, per each channel\n\t */\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tif (!pvt->channel[i].dimms)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < MAX_RIR_RANGES; j++) {\n\t\t\tpci_read_config_dword(pvt->pci_tad[i],\n\t\t\t\t\t      rir_way_limit[j],\n\t\t\t\t\t      &reg);\n\n\t\t\tif (!IS_RIR_VALID(reg))\n\t\t\t\tcontinue;\n\n\t\t\ttmp_mb = pvt->info.rir_limit(reg) >> 20;\n\t\t\trir_way = 1 << RIR_WAY(reg);\n\t\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\t\tedac_dbg(0, "CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\\n",\n	t
28668	2203	adv7842_cec_tx_raw_status	drivers/media/i2c/adv7842.c	low_drive_cnt	1	11	\N	\N	\tstruct adv7842_state *state = to_state(sd);\n\n\tif ((cec_read(sd, 0x11) & 0x01) == 0) {\n\t\tv4l2_dbg(1, debug, sd, "%s: tx raw: tx disabled\\n", __func__);\n\t\treturn;\n\t}\n\n\tif (tx_raw_status & 0x02) {\n\t\tv4l2_dbg(1, debug, sd, "%s: tx raw: arbitration lost\\n",\n\t\t\t __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\n\t\t\t\t  1, 0, 0, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x04) {\n\t\tu8 status;\n\t\tu8 nack_cnt;\n\t\tu8 low_drive_cnt;\n\n\t\tv4l2_dbg(1, debug, sd, "%s: tx raw: retry failed\\n", __func__);\n\t\t/*\n\t\t * We set this status bit since this hardware performs\n\t\t * retransmissions.\n\t\t */\n\t\tstatus = CEC_TX_STATUS_MAX_RETRIES;\n\t\tnack_cnt = cec_read(sd, 0x14) & 0xf;\n\t\tif (nack_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_NACK;\n\t\tlow_drive_cnt = cec_read(sd, 0x14) >> 4;\n\t\tif (low_drive_cnt)\n	t
45246	493	handle_button_press_event	drivers/pci/hotplug/shpchp_ctrl.c	getstatus	1	13	\N	\N	\tu8 getstatus;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\tswitch (p_slot->state) {\n\tcase STATIC_STATE:\n\t\tp_slot->hpc_ops->get_power_status(p_slot, &getstatus);\n\t\tif (getstatus) {\n	f
45914	454	mt9m111_set_gain	drivers/media/usb/gspca/m5602/m5602_mt9m111.c	err	1	13	\N	\N	\tint err, tmp;\n\tu8 data[2] = {0x00, 0x00};\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Set the correct page map */\n\terr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\n\tif (err < 0)\n	f
4585	470	set_temp_hyst	drivers/hwmon/asb100.c	HYST	1	11	\N	\N	\tint ret = 0;\n\n\tswitch (nr) {\n\tcase 1: case 2:\n\t\tret = sprintf(buf, "%d\\n", LM75_TEMP_FROM_REG(reg));\n\t\tbreak;\n\tcase 0: case 3: default:\n\t\tret = sprintf(buf, "%d\\n", TEMP_FROM_REG(reg));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#define show_temp_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tchar *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct asb100_data *data = asb100_update_device(dev); \\\n\treturn sprintf_temp_from_reg(data->reg[nr], buf, nr); \\\n}\n\nshow_temp_reg(temp);\nshow_temp_reg(temp_max);\nshow_temp_reg(temp_hyst);\n\n#define set_temp_reg(REG, reg) \\\nstatic ssize_t set_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tconst char *buf, size_t count) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct asb100_data *data = i2c_get_clientdata(client); \\\n\tlong val; \\\n\tint err = kstrtol(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tswitch (nr) { \\\n\tcase 1: case 2: \\\n\t\tdata->reg[nr] = LM75_TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\tcase 0: case 3: default: \\\n\t\tdata->reg[nr] = TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\t} \\\n\tasb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), \\\n\t\t\tdata->reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nset_temp_reg(MAX, temp_max);\nset_temp_reg(HYST, temp_hyst);\n	t
4717	3188	SiS_GetCRT2DataLVDS	drivers/video/fbdev/sis/init301.c	ResIndex	1	11	\N	\N	   unsigned short CRT2Index, ResIndex, backup;\n   const struct SiS_LVDSData *LVDSData = NULL;\n\n   SiS_GetCRT2ResInfo(SiS_Pr, ModeNo, ModeIdIndex);\n\n   if(SiS_Pr->SiS_VBType & VB_SISVB) {\n      SiS_Pr->SiS_RVBHCMAX  = 1;\n      SiS_Pr->SiS_RVBHCFACT = 1;\n      SiS_Pr->SiS_NewFlickerMode = 0;\n      SiS_Pr->SiS_RVBHRS = 50;\n      SiS_Pr->SiS_RY1COE = 0;\n      SiS_Pr->SiS_RY2COE = 0;\n      SiS_Pr->SiS_RY3COE = 0;\n      SiS_Pr->SiS_RY4COE = 0;\n      SiS_Pr->SiS_RVBHRS2 = 0;\n   }\n\n   if((SiS_Pr->SiS_VBType & VB_SISVB) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA)) {\n\n#ifdef CONFIG_FB_SIS_315\n      SiS_CalcPanelLinkTiming(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);\n      SiS_CalcLCDACRT1Timing(SiS_Pr, ModeNo, ModeIdIndex);\n#endif\n\n   } else {\n\n      /* 301BDH needs LVDS Data */\n      backup = SiS_Pr->SiS_IF_DEF_LVDS;\n      if((SiS_Pr->SiS_VBType & VB_NoLCD) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD)) {\n\t SiS_Pr->SiS_IF_DEF_LVDS = 1;\n      }\n\n      SiS_GetCRT2Ptr(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex,\n                     \t\t            &CRT2Index, &ResIndex);\n\n      SiS_Pr->SiS_IF_DEF_LVDS = backup;\n\n      switch(CRT2Index) {\n\t case 10: LVDSData = SiS_Pr->SiS_LVDS320x240Data_1;    break;\n\t case 14: LVDSData = SiS_Pr->SiS_LVDS320x240Data_2;    break;\n\t case 12: LVDSData = SiS_Pr->SiS_LVDS640x480Data_1;    break;\n\t case 16: LVDSData = SiS_Pr->SiS_LVDS800x600Data_1;    break;\n\t case 18: LVDSData = SiS_Pr->SiS_LVDS1024x600Data_1;   break;\n\t case 20: LVDSData = SiS_Pr->SiS_LVDS1024x768Data_1;   break;\n#ifdef CONFIG_FB_SIS_300\n\t case 80: LVDSData = SiS_Pr->SiS_LVDSBARCO1366Data_1;  break;\n\t case 81: LVDSData = SiS_Pr->SiS_LVDSBARCO1366Data_2;  break;\n\t case 82: LVDSData = SiS_Pr->SiS_LVDSBARCO1024Data_1;  break;\n\t case 84: LVDSData = SiS_Pr->SiS_LVDS848x480Data_1;    break;\n\t case 85: LVDSData = SiS_Pr->SiS_LVDS848x480Data_2;    break;\n#endif\n\t case 90: LVDSData = SiS_Pr->SiS_CHTVUNTSCData;        break;\n\t case 91: LVDSData = SiS_Pr->SiS_CHTVONTSCData;        break;\n\t case 92: LVDSData = SiS_Pr->SiS_CHTVUPALData;         break;\n\t case 93: LVDSData = SiS_Pr->SiS_CHTVOPALData;         break;\n\t case 94: LVDSData = SiS_Pr->SiS_CHTVUPALMData;        break;\n\t case 95: LVDSData = SiS_Pr->SiS_CHTVOPALMData;        break;\n\t case 96: LVDSData = SiS_Pr->SiS_CHTVUPALNData;        break;\n\t case 97: LVDSData = SiS_Pr->SiS_CHTVOPALNData;        break;\n\t case 99: LVDSData = SiS_Pr->SiS_CHTVSOPALData;\t       break;\n      }\n\n      if(LVDSData) {\n\t SiS_Pr->SiS_VGAHT = (LVDSData+ResIndex)->VGAHT;\n\t SiS_Pr->SiS_VGAVT = (LVDSData+ResIndex)->VGAVT;\n\t SiS_Pr->SiS_HT    = (LVDSData+ResIndex)->LCDHT;\n\t SiS_Pr->SiS_VT    = (LVDSData+ResIndex)->LCDVT;\n      } else {\n\t SiS_CalcPanelLinkTiming(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);\n      }\n\n      if( (!(SiS_Pr->SiS_VBType & VB_SISVB)) &&\n\t  (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) &&\n\t  (!(SiS_Pr->SiS_LCDInfo & LCDPass11)) ) {\n\t if( (!(SiS_Pr->SiS_LCDInfo & DontExpandLCD)) ||\n\t     (SiS_Pr->SiS_SetFlag & SetDOSMode) ) {\n\t    SiS_Pr->SiS_HDE = SiS_Pr->PanelXRes;\n            SiS_Pr->SiS_VDE = SiS_Pr->PanelYRes;\n#ifdef CONFIG_FB_SIS_300\n\t    if(SiS_Pr->SiS_CustomT == CUT_BARCO1366) {\n\t       if(ResIndex < 0x08) {\n	t
4759	1894	viafb_setmode	drivers/video/fbdev/via/hw.c	&var2	1	11	\N	\N	\tint j, cxres = 0, cyres = 0;\n\tint port;\n\tu32 devices = viaparinfo->shared->iga1_devices\n\t\t| viaparinfo->shared->iga2_devices;\n\tu8 value, index, mask;\n\tstruct fb_var_screeninfo var2;\n\n\tdevice_screen_off();\n\tdevice_off();\n\tvia_set_state(devices, VIA_STATE_OFF);\n\n\thw_init();\n\n\t/* Update Patch Register */\n\n\tif ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266\n\t\t|| viaparinfo->chip_info->gfx_chip_name == UNICHROME_K400)\n\t\t&& viafbinfo->var.xres == 1024 && viafbinfo->var.yres == 768) {\n\t\tfor (j = 0; j < res_patch_table[0].table_length; j++) {\n\t\t\tindex = res_patch_table[0].io_reg_table[j].index;\n\t\t\tport = res_patch_table[0].io_reg_table[j].port;\n\t\t\tvalue = res_patch_table[0].io_reg_table[j].value;\n\t\t\tmask = res_patch_table[0].io_reg_table[j].mask;\n\t\t\tviafb_write_reg_mask(index, port, value, mask);\n\t\t}\n\t}\n\n\tvia_set_primary_pitch(viafbinfo->fix.line_length);\n\tvia_set_secondary_pitch(viafb_dual_fb ? viafbinfo1->fix.line_length\n\t\t: viafbinfo->fix.line_length);\n\tvia_set_primary_color_depth(viaparinfo->depth);\n\tvia_set_secondary_color_depth(viafb_dual_fb ? viaparinfo1->depth\n\t\t: viaparinfo->depth);\n\tvia_set_source(viaparinfo->shared->iga1_devices, IGA1);\n\tvia_set_source(viaparinfo->shared->iga2_devices, IGA2);\n\tif (viaparinfo->shared->iga2_devices)\n\t\tenable_second_display_channel();\n\telse\n\t\tdisable_second_display_channel();\n\n\t/* Update Refresh Rate Setting */\n\n\t/* Clear On Screen */\n\n\tif (viafb_dual_fb) {\n\t\tvar2 = viafbinfo1->var;\n\t} else if (viafb_SAMM_ON) {\n\t\tviafb_fill_var_timing_info(&var2, viafb_get_best_mode(\n\t\t\tviafb_second_xres, viafb_second_yres, viafb_refresh1));\n\t\tcxres = viafbinfo->var.xres;\n\t\tcyres = viafbinfo->var.yres;\n\t\tvar2.bits_per_pixel = viafbinfo->var.bits_per_pixel;\n\t}\n\n\t/* CRT set mode */\n\tif (viafb_CRT_ON) {\n\t\tif (viaparinfo->shared->iga2_devices & VIA_CRT\n\t\t\t&& viafb_SAMM_ON)\n\t\t\tviafb_fill_crtc_timing(&var2, cxres, cyres, IGA2);\n	t
-244	295	stm32_pwm_detect_complementary	drivers/pwm/pwm-stm32.c	ccer	5	20	\N	\N	\tu32 ccer;\n\n\t/*\n\t * If complementary bit doesn't exist writing 1 will have no\n\t * effect so we can detect it.\n\t */\n\tregmap_update_bits(priv->regmap,\n\t\t\t   TIM_CCER, TIM_CCER_CC1NE, TIM_CCER_CC1NE);\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tregmap_update_bits(priv->regmap, TIM_CCER, TIM_CCER_CC1NE, 0);\n\n\tpriv->have_complementary_output = (ccer != 0);\n	f
-412	368	pt_req_sense	drivers/block/paride/pt.c	buf	2	3	\N	\N	\tchar rs_cmd[12] = { ATAPI_REQ_SENSE, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r;\n\n\tr = pt_command(tape, rs_cmd, 16, "Request sense");\n\tmdelay(1);\n\tif (!r)\n\t\tpt_completion(tape, buf, "Request sense");\n\n\ttape->last_sense = -1;\n\tif (!r) {\n\t\tif (!quiet)\n\t\t\tprintk("%s: Sense key: %x, ASC: %x, ASQ: %x\\n",\n	f
-410	562	quirk_intel_purley_xeon_ras_cap	arch/x86/kernel/quirks.c	capid0	2	3	\N	\N	\tstruct pci_dev *nb_ht;\n\tunsigned int devfn;\n\tu32 node;\n\tu32 val;\n\n\tdevfn = PCI_DEVFN(PCI_SLOT(dev->devfn), 0);\n\tnb_ht = pci_get_slot(dev->bus, devfn);\n\tif (!nb_ht)\n\t\treturn;\n\n\tpci_read_config_dword(nb_ht, 0x60, &val);\n\tnode = pcibus_to_node(dev->bus) | (val & 7);\n\t/*\n\t * Some hardware may return an invalid node ID,\n\t * so check it first:\n\t */\n\tif (node_online(node))\n\t\tset_dev_node(&dev->dev, node);\n\tpci_dev_put(nb_ht);\n}\n\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,\n	f
-246	419	ltc3589_isr	drivers/regulator/ltc3589.c	irqstat	5	20	\N	\N	\tstruct ltc3589 *ltc3589 = dev_id;\n\tunsigned int i, irqstat, event;\n\n\tregmap_read(ltc3589->regmap, LTC3589_IRQSTAT, &irqstat);\n\n\tif (irqstat & LTC3589_IRQSTAT_THERMAL_WARN) {\n	f
4958	3180	e1000_detect_gig_phy	drivers/net/ethernet/intel/e1000/e1000_hw.c	phy_id_high	6	12	\N	\N	\ts32 phy_init_status, ret_val;\n\tu16 phy_id_high, phy_id_low;\n\tbool match = false;\n\n\tif (hw->phy_id != 0)\n\t\treturn E1000_SUCCESS;\n\n\t/* Read the PHY ID Registers to identify which PHY is onboard. */\n\tret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw->phy_id = (u32)(phy_id_high << 16);\n	t
52631	1100	ceph_sync_write	fs/ceph/file.c	pages[n]	1	11	\N	\N	\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint ret;\n\tbool check_caps = false;\n\tstruct timespec mtime = current_time(inode);\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout("sync_write on file %p %lld~%u snapc %p seq %lld\\n",\n\t     file, pos, (unsigned)count, snapc, snapc->seq);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_SHIFT);\n\tif (ret < 0)\n\t\tdout("invalidate_inode_pages2_range returned %d\\n", ret);\n\n\tflags = /* CEPH_OSD_FLAG_ORDERSNAP | */ CEPH_OSD_FLAG_WRITE;\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0, 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * write from beginning of first page,\n\t\t * regardless of io alignment\n\t\t */\n\t\tnum_pages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft = len;\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE);\n\t\t\tret = copy_page_from_iter(pages[n], 0, plen, from);\n	t
40505	1696	fib_trie_free	net/ipv4/fib_trie.c	fib_trie_free_$__mptr48$obj	0	11	\N	\N	\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\n\t/* walk trie in reverse order and free everything */\n\tfor (;;) {\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\tn = pn;\n\t\t\tpn = node_parent(pn);\n\n\t\t\t/* drop emptied tnode */\n\t\t\tput_child_root(pn, n->key, NULL);\n\t\t\tnode_free(n);\n\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab the next available node */\n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t/* record pn and cindex for leaf walking */\n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n	t
53168	1682	ql_process_mac_rx_skb	drivers/net/ethernet/qlogic/qlge/qlge_main.c	skb->len	1	11	\N	\N	\tstruct net_device *ndev = qdev->ndev;\n\tstruct sk_buff *skb = NULL;\n\tstruct sk_buff *new_skb = NULL;\n\tstruct bq_desc *sbq_desc = ql_get_curr_sbuf(rx_ring);\n\n\tskb = sbq_desc->p.skb;\n\t/* Allocate new_skb and copy */\n\tnew_skb = netdev_alloc_skb(qdev->ndev, length + NET_IP_ALIGN);\n\tif (new_skb == NULL) {\n\t\trx_ring->rx_dropped++;\n\t\treturn;\n\t}\n\tskb_reserve(new_skb, NET_IP_ALIGN);\n\n\tpci_dma_sync_single_for_cpu(qdev->pdev,\n\t\t\t\t    dma_unmap_addr(sbq_desc, mapaddr),\n\t\t\t\t    dma_unmap_len(sbq_desc, maplen),\n\t\t\t\t    PCI_DMA_FROMDEVICE);\n\n\tskb_put_data(new_skb, skb->data, length);\n\n\tpci_dma_sync_single_for_device(qdev->pdev,\n\t\t\t\t       dma_unmap_addr(sbq_desc, mapaddr),\n\t\t\t\t       dma_unmap_len(sbq_desc, maplen),\n\t\t\t\t       PCI_DMA_FROMDEVICE);\n\tskb = new_skb;\n\n\t/* Frame error, so drop the packet. */\n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_ERR_MASK) {\n\t\tql_categorize_rx_err(qdev, ib_mac_rsp->flags2, rx_ring);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t/* loopback self test for ethtool */\n\tif (test_bit(QL_SELFTEST, &qdev->flags)) {\n\t\tql_check_lb_frame(qdev, skb);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t/* The max framesize filter on this chip is set higher than\n\t * MTU since FCoE uses 2k frames.\n\t */\n\tif (skb->len > ndev->mtu + ETH_HLEN) {\n	t
36759	557	at91_rx_overflow_err	drivers/net/can/at91_can.c	cf->can_id	1	11	\N	\N	\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\tnetdev_dbg(dev, "RX buffer overflow\\n");\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tcf->can_id |= CAN_ERR_CRTL;\n	t
8134	577	da9052_clear_fault_log	drivers/mfd/da9052-core.c	fault_log	1	11	\N	condi of may_init == postcondi	\tint ret = 0;\n\tint fault_log = 0;\n\n\tfault_log = da9052_reg_read(da9052, DA9052_FAULTLOG_REG);\n\tif (fault_log < 0) {\n\t\tdev_err(da9052->dev,\n\t\t\t"Cannot read FAULT_LOG %d\\n", fault_log);\n\t\treturn fault_log;\n\t}\n\n\tif (fault_log) {\n\t\tif (fault_log & DA9052_FAULTLOG_TWDERROR)\n\t\t\tdev_dbg(da9052->dev,\n\t\t\t\t"Fault log entry detected: TWD_ERROR\\n");\n\t\tif (fault_log & DA9052_FAULTLOG_VDDFAULT)\n\t\t\tdev_dbg(da9052->dev,\n\t\t\t\t"Fault log entry detected: VDD_FAULT\\n");\n\t\tif (fault_log & DA9052_FAULTLOG_VDDSTART)\n\t\t\tdev_dbg(da9052->dev,\n\t\t\t\t"Fault log entry detected: VDD_START\\n");\n\t\tif (fault_log & DA9052_FAULTLOG_TEMPOVER)\n\t\t\tdev_dbg(da9052->dev,\n\t\t\t\t"Fault log entry detected: TEMP_OVER\\n");\n\t\tif (fault_log & DA9052_FAULTLOG_KEYSHUT)\n\t\t\tdev_dbg(da9052->dev,\n\t\t\t\t"Fault log entry detected: KEY_SHUT\\n");\n\t\tif (fault_log & DA9052_FAULTLOG_NSDSET)\n	t
42351	212	dvbsky_rc_query	drivers/media/usb/dvb-usb-v2/dvbsky.c	code	1	11	\N	\N	\tu32 code = 0xffff, scancode;\n\tu8 rc5_command, rc5_system;\n\tu8 obuf[2], ibuf[2], toggle;\n\tint ret;\n\n\tobuf[0] = 0x10;\n\tret = dvbsky_usb_generic_rw(d, obuf, 1, ibuf, 2);\n\tif (ret)\n\t\tdev_err(&d->udev->dev, "failed=%d\\n", ret);\n\tif (ret == 0)\n\t\tcode = (ibuf[0] << 8) | ibuf[1];\n\tif (code != 0xffff) {\n\t\tdev_dbg(&d->udev->dev, "rc code: %x\\n", code);\n\t\trc5_command = code & 0x3F;\n\t\trc5_system = (code & 0x7C0) >> 6;\n\t\ttoggle = (code & 0x800) ? 1 : 0;\n	t
46982	2257	max98090_interrupt	sound/soc/codecs/max98090.c	active	1	11	\N	\N	\tstruct max98090_priv *max98090 = data;\n\tstruct snd_soc_codec *codec = max98090->codec;\n\tint ret;\n\tunsigned int mask;\n\tunsigned int active;\n\n\t/* Treat interrupt before codec is initialized as spurious */\n\tif (codec == NULL)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(codec->dev, "***** max98090_interrupt *****\\n");\n\n\tret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\n\n\tif (ret != 0) {\n\t\tdev_err(codec->dev,\n\t\t\t"failed to read M98090_REG_INTERRUPT_S: %d\\n",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);\n\n\tif (ret != 0) {\n\t\tdev_err(codec->dev,\n\t\t\t"failed to read M98090_REG_DEVICE_STATUS: %d\\n",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_dbg(codec->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\\n",\n\t\tactive, mask, active & mask);\n\n\tactive &= mask;\n\n\tif (!active)\n\t\treturn IRQ_NONE;\n\n\tif (active & M98090_CLD_MASK)\n	t
53525	1116	audit_rule_change	kernel/auditfilter.c	entry->rule.exe	1	11	\N	\N	\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change("add_rule", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change("remove_rule", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n	f
53822	5379	btrfs_evict_inode	fs/btrfs/inode.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *rsv, *global_rsv;\n\tint steal_from_global = 0;\n\tu64 min_size;\n\tint ret;\n\n\ttrace_btrfs_inode_evict(inode);\n\n\tif (!root) {\n\t\tkmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));\n\t\treturn;\n\t}\n\n\tmin_size = btrfs_calc_trunc_metadata_size(fs_info, 1);\n\n\tevict_inode_truncate_pages(inode);\n\n\tif (inode->i_nlink &&\n\t    ((btrfs_root_refs(&root->root_item) != 0 &&\n\t      root->root_key.objectid != BTRFS_ROOT_TREE_OBJECTID) ||\n\t     btrfs_is_free_space_inode(BTRFS_I(inode))))\n\t\tgoto no_delete;\n\n\tif (is_bad_inode(inode)) {\n\t\tbtrfs_orphan_del(NULL, BTRFS_I(inode));\n\t\tgoto no_delete;\n\t}\n\t/* do we really want it for ->i_nlink > 0 and zero btrfs_root_refs? */\n\tif (!special_file(inode->i_mode))\n\t\tbtrfs_wait_ordered_range(inode, 0, (u64)-1);\n\n\tbtrfs_free_io_failure_record(BTRFS_I(inode), 0, (u64)-1);\n\n\tif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags)) {\n\t\tBUG_ON(test_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t\t &BTRFS_I(inode)->runtime_flags));\n\t\tgoto no_delete;\n\t}\n\n\tif (inode->i_nlink > 0) {\n\t\tBUG_ON(btrfs_root_refs(&root->root_item) != 0 &&\n\t\t       root->root_key.objectid != BTRFS_ROOT_TREE_OBJECTID);\n\t\tgoto no_delete;\n\t}\n\n\tret = btrfs_commit_inode_delayed_inode(BTRFS_I(inode));\n\tif (ret) {\n\t\tbtrfs_orphan_del(NULL, BTRFS_I(inode));\n\t\tgoto no_delete;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(fs_info, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tbtrfs_orphan_del(NULL, BTRFS_I(inode));\n\t\tgoto no_delete;\n\t}\n\trsv->size = min_size;\n\trsv->failfast = 1;\n\tglobal_rsv = &fs_info->global_block_rsv;\n\n\tbtrfs_i_size_write(BTRFS_I(inode), 0);\n\n\t/*\n\t * This is a bit simpler than btrfs_truncate since we've already\n\t * reserved our space for our orphan item in the unlink, so we just\n\t * need to reserve some slack space in case we add bytes and update\n\t * inode item when doing the truncate.\n\t */\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(root, rsv, min_size,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_LIMIT);\n\n\t\t/*\n\t\t * Try and steal from the global reserve since we will\n\t\t * likely not use this space anyway, we want to try as\n\t\t * hard as possible to get this to work.\n\t\t */\n\t\tif (ret)\n	f
61609	2987	xfrm_notify_policy	net/xfrm/xfrm_user.c	skb	1	-11	\N	\N	\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n	t
54007	1257	ext4_ind_remove_space	fs/ext4/indirect.c	chain	1	11	\N	\N	\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4], offsets2[4];\n\tIndirect chain[4], chain2[4];\n\tIndirect *partial, *partial2;\n\text4_lblk_t max_block;\n\t__le32 nr = 0, nr2 = 0;\n\tint n = 0, n2 = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tif (end >= max_block)\n\t\tend = max_block;\n\tif ((start >= end) || (start > max_block))\n\t\treturn 0;\n\n\tn = ext4_block_to_path(inode, start, offsets, NULL);\n\tn2 = ext4_block_to_path(inode, end, offsets2, NULL);\n\n\tBUG_ON(n > n2);\n\n\tif ((n == 1) && (n == n2)) {\n\t\t/* We're punching only within direct block range */\n\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t       i_data + offsets2[0]);\n\t\treturn 0;\n\t} else if (n2 > n) {\n\t\t/*\n\t\t * Start and end are on a different levels so we're going to\n\t\t * free partial block at start, and partial block at end of\n\t\t * the range. If there are some levels in between then\n\t\t * do_indirects label will take care of that.\n\t\t */\n\n\t\tif (n == 1) {\n\t\t\t/*\n\t\t\t * Start is at the direct block level, free\n\t\t\t * everything to the end of the level.\n\t\t\t */\n\t\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\t\tgoto end_range;\n\t\t}\n\n\n\t\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n	f
32421	112	mt7601u_vendor_request	drivers/net/wireless/mediatek/mt7601u/usb.c	ret	1	11	\N	\N	\tint i, ret;\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\tconst u8 req_type = direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\n\tconst unsigned int pipe = (direction == USB_DIR_IN) ?\n\t\tusb_rcvctrlpipe(usb_dev, 0) : usb_sndctrlpipe(usb_dev, 0);\n\n\tfor (i = 0; i < MT_VEND_REQ_MAX_RETRY; i++) {\n\t\tret = usb_control_msg(usb_dev, pipe, req, req_type,\n\t\t\t\t      val, offset, buf, buflen,\n\t\t\t\t      MT_VEND_REQ_TOUT_MS);\n\t\ttrace_mt_vend_req(dev, pipe, req, req_type, val, offset,\n\t\t\t\t  buf, buflen, ret);\n\n\t\tif (ret == -ENODEV)\n	t
41392	243	via_cputemp_online	drivers/hwmon/via-cputemp.c	err	1	11	\N	\N	\tint err;\n\tstruct platform_device *pdev;\n\tstruct pdev_entry *pdev_entry;\n\n\tpdev = platform_device_alloc(DRVNAME, cpu);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err("Device allocation failed\\n");\n\t\tgoto exit;\n\t}\n\n\tpdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);\n\tif (!pdev_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n	t
43591	650	isdn_ppp_ioctl	drivers/isdn/i4l/isdn_ppp.c	&fprog	1	11	\N	\N	\tunsigned long val;\n\tint r, i, j;\n\tstruct ippp_struct *is;\n\tisdn_net_local *lp;\n\tstruct isdn_ppp_comp_data data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tis = file->private_data;\n\tlp = is->lp;\n\n\tif (is->debug & 0x1)\n\t\tprintk(KERN_DEBUG "isdn_ppp_ioctl: minor: %d cmd: %x state: %x\\n", min, cmd, is->state);\n\n\tif (!(is->state & IPPP_OPEN))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase PPPIOCBUNDLE:\n#ifdef CONFIG_ISDN_MPP\n\t\tif (!(is->state & IPPP_CONNECT))\n\t\t\treturn -EINVAL;\n\t\tif ((r = get_arg(argp, &val, sizeof(val))))\n\t\t\treturn r;\n\t\tprintk(KERN_DEBUG "iPPP-bundle: minor: %d, slave unit: %d, master unit: %d\\n",\n\t\t       (int) min, (int) is->unit, (int) val);\n\t\treturn isdn_ppp_bundle(is, val);\n#else\n\t\treturn -1;\n#endif\n\t\tbreak;\n\tcase PPPIOCGUNIT:\t/* get ppp/isdn unit number */\n\t\tif ((r = set_arg(argp, &is->unit, sizeof(is->unit))))\n\t\t\treturn r;\n\t\tbreak;\n\tcase PPPIOCGIFNAME:\n\t\tif (!lp)\n\t\t\treturn -EINVAL;\n\t\tif ((r = set_arg(argp, lp->netdev->dev->name,\n\t\t\t\t strlen(lp->netdev->dev->name))))\n\t\t\treturn r;\n\t\tbreak;\n\tcase PPPIOCGMPFLAGS:\t/* get configuration flags */\n\t\tif ((r = set_arg(argp, &is->mpppcfg, sizeof(is->mpppcfg))))\n\t\t\treturn r;\n\t\tbreak;\n\tcase PPPIOCSMPFLAGS:\t/* set configuration flags */\n\t\tif ((r = get_arg(argp, &val, sizeof(val))))\n\t\t\treturn r;\n\t\tis->mpppcfg = val;\n\t\tbreak;\n\tcase PPPIOCGFLAGS:\t/* get configuration flags */\n\t\tif ((r = set_arg(argp, &is->pppcfg, sizeof(is->pppcfg))))\n\t\t\treturn r;\n\t\tbreak;\n\tcase PPPIOCSFLAGS:\t/* set configuration flags */\n\t\tif ((r = get_arg(argp, &val, sizeof(val)))) {\n\t\t\treturn r;\n\t\t}\n\t\tif (val & SC_ENABLE_IP && !(is->pppcfg & SC_ENABLE_IP) && (is->state & IPPP_CONNECT)) {\n\t\t\tif (lp) {\n\t\t\t\t/* OK .. we are ready to send buffers */\n\t\t\t\tis->pppcfg = val; /* isdn_ppp_xmit test for SC_ENABLE_IP !!! */\n\t\t\t\tnetif_wake_queue(lp->netdev->dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tis->pppcfg = val;\n\t\tbreak;\n\tcase PPPIOCGIDLE:\t/* get idle time information */\n\t\tif (lp) {\n\t\t\tstruct ppp_idle pidle;\n\t\t\tpidle.xmit_idle = pidle.recv_idle = lp->huptimer;\n\t\t\tif ((r = set_arg(argp, &pidle, sizeof(struct ppp_idle))))\n\t\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PPPIOCSMRU:\t/* set receive unit size for PPP */\n\t\tif ((r = get_arg(argp, &val, sizeof(val))))\n\t\t\treturn r;\n\t\tis->mru = val;\n\t\tbreak;\n\tcase PPPIOCSMPMRU:\n\t\tbreak;\n\tcase PPPIOCSMPMTU:\n\t\tbreak;\n\tcase PPPIOCSMAXCID:\t/* set the maximum compression slot id */\n\t\tif ((r = get_arg(argp, &val, sizeof(val))))\n\t\t\treturn r;\n\t\tval++;\n\t\tif (is->maxcid != val) {\n#ifdef CONFIG_ISDN_PPP_VJ\n\t\t\tstruct slcompress *sltmp;\n#endif\n\t\t\tif (is->debug & 0x1)\n\t\t\t\tprintk(KERN_DEBUG "ippp, ioctl: changed MAXCID to %ld\\n", val);\n\t\t\tis->maxcid = val;\n#ifdef CONFIG_ISDN_PPP_VJ\n\t\t\tsltmp = slhc_init(16, val);\n\t\t\tif (IS_ERR(sltmp))\n\t\t\t\treturn PTR_ERR(sltmp);\n\t\t\tif (is->slcomp)\n\t\t\t\tslhc_free(is->slcomp);\n\t\t\tis->slcomp = sltmp;\n#endif\n\t\t}\n\t\tbreak;\n\tcase PPPIOCGDEBUG:\n\t\tif ((r = set_arg(argp, &is->debug, sizeof(is->debug))))\n\t\t\treturn r;\n\t\tbreak;\n\tcase PPPIOCSDEBUG:\n\t\tif ((r = get_arg(argp, &val, sizeof(val))))\n\t\t\treturn r;\n\t\tis->debug = val;\n\t\tbreak;\n\tcase PPPIOCGCOMPRESSORS:\n\t{\n\t\tunsigned long protos[8] = {0,};\n\t\tstruct isdn_ppp_compressor *ipc = ipc_head;\n\t\twhile (ipc) {\n\t\t\tj = ipc->num / (sizeof(long) * 8);\n\t\t\ti = ipc->num % (sizeof(long) * 8);\n\t\t\tif (j < 8)\n\t\t\t\tprotos[j] |= (1UL << i);\n\t\t\tipc = ipc->next;\n\t\t}\n\t\tif ((r = set_arg(argp, protos, 8 * sizeof(long))))\n\t\t\treturn r;\n\t}\n\tbreak;\n\tcase PPPIOCSCOMPRESSOR:\n\t\tif ((r = get_arg(argp, &data, sizeof(struct isdn_ppp_comp_data))))\n\t\t\treturn r;\n\t\treturn isdn_ppp_set_compressor(is, &data);\n\tcase PPPIOCGCALLINFO:\n\t{\n\t\tstruct pppcallinfo pci;\n\t\tmemset((char *)&pci, 0, sizeof(struct pppcallinfo));\n\t\tif (lp)\n\t\t{\n\t\t\tstrncpy(pci.local_num, lp->msn, 63);\n\t\t\tif (lp->dial) {\n\t\t\t\tstrncpy(pci.remote_num, lp->dial->num, 63);\n\t\t\t}\n\t\t\tpci.charge_units = lp->charge;\n\t\t\tif (lp->outgoing)\n\t\t\t\tpci.calltype = CALLTYPE_OUTGOING;\n\t\t\telse\n\t\t\t\tpci.calltype = CALLTYPE_INCOMING;\n\t\t\tif (lp->flags & ISDN_NET_CALLBACK)\n\t\t\t\tpci.calltype |= CALLTYPE_CALLBACK;\n\t\t}\n\t\treturn set_arg(argp, &pci, sizeof(struct pppcallinfo));\n\t}\n#ifdef CONFIG_IPPP_FILTER\n\tcase PPPIOCSPASS:\n\t{\n\t\tstruct sock_fprog_kern fprog;\n\t\tstruct sock_filter *code;\n\t\tint err, len = get_filter(argp, &code);\n\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tfprog.len = len;\n\t\tfprog.filter = code;\n\n\t\tif (is->pass_filter) {\n\t\t\tbpf_prog_destroy(is->pass_filter);\n\t\t\tis->pass_filter = NULL;\n\t\t}\n\t\tif (fprog.filter != NULL)\n\t\t\terr = bpf_prog_create(&is->pass_filter, &fprog);\n	t
49498	1604	gfs2_dir_read	fs/gfs2/dir.c	gfs2_dir_read_$dibh$obj$4	0	13	\N	\N	\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tstruct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t/* 96 is max number of dirents which can be stuffed into an inode */\n\tdarr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = (const struct gfs2_dirent **)darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n	f
57465	382	onebit_depop_power_stage	sound/soc/codecs/rt5631.c	hp_zc & 0xf7ff	1	-11	\N	\N	\tunsigned int soft_vol, hp_zc;\n\n\t/* enable one-bit depop function */\n\tsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\n\t\t\t\tRT5631_EN_ONE_BIT_DEPOP, 0);\n\n\t/* keep soft volume and zero crossing setting */\n\tsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\n\tsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\n\thp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\n\tsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\n	t
3143	121	power_supply_update_gen_leds	drivers/power/supply/power_supply_leds.c	power_supply_update_gen_leds_$online$obj	0	13	\N	\N	\tunion power_supply_propval online;\n\n\tif (power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE, &online))\n\t\treturn;\n\n\tdev_dbg(&psy->dev, "%s %d\\n", __func__, online.intval);\n	f
58531	595	wm9090_i2c_probe	sound/soc/codecs/wm9090.c	reg	1	13	\N	\N	\tstruct wm9090_priv *wm9090;\n\tunsigned int reg;\n\tint ret;\n\n\twm9090 = devm_kzalloc(&i2c->dev, sizeof(*wm9090), GFP_KERNEL);\n\tif (!wm9090)\n\t\treturn -ENOMEM;\n\n\twm9090->regmap = devm_regmap_init_i2c(i2c, &wm9090_regmap);\n\tif (IS_ERR(wm9090->regmap)) {\n\t\tret = PTR_ERR(wm9090->regmap);\n\t\tdev_err(&i2c->dev, "Failed to allocate regmap: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm9090->regmap, WM9090_SOFTWARE_RESET, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reg != 0x9093) {\n	f
40649	306	trace_event_raw_event_check_mmio_spte	arch/x86/kvm/mmu.c	spte & shadow_mmio_mask	0	11	\N	\N		t
-403	169	mdio_sc_cfg_reg_write	drivers/net/ethernet/hisilicon/hns_mdio.c	reg_value	2	3	\N	\N	\tu32 time_cnt;\n\tu32 reg_value;\n\n\tregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\n\n\tfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\n\t\tregmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\n\t\treg_value &= st_msk;\n\t\tif ((!!check_st) == (!!reg_value))\n\t\t\tbreak;\n\t}\n\n\tif ((!!check_st) != (!!reg_value))\n	f
60138	947	dsps_probe	drivers/usb/musb/musb_dsps.c	ret	1	11	\N	\N	\tconst struct of_device_id *match;\n\tconst struct dsps_musb_wrapper *wrp;\n\tstruct dsps_glue *glue;\n\tint ret;\n\n\tif (!strcmp(pdev->name, "musb-hdrc"))\n\t\treturn -ENODEV;\n\n\tmatch = of_match_node(musb_dsps_of_match, pdev->dev.of_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, "fail to get matching of_match struct\\n");\n\t\treturn -EINVAL;\n\t}\n\twrp = match->data;\n\n\tif (of_device_is_compatible(pdev->dev.of_node, "ti,musb-dm816"))\n\t\tdsps_ops.read_fifo = dsps_read_fifo32;\n\n\t/* allocate glue */\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev = &pdev->dev;\n\tglue->wrp = wrp;\n\tglue->usbss_base = of_iomap(pdev->dev.parent->of_node, 0);\n\tif (!glue->usbss_base)\n\t\treturn -ENXIO;\n\n\tif (usb_get_dr_mode(&pdev->dev) == USB_DR_MODE_PERIPHERAL) {\n\t\tret = dsps_setup_optional_vbus_irq(pdev, glue);\n\t\tif (ret)\n\t\t\tgoto err_iounmap;\n\t}\n\n\tplatform_set_drvdata(pdev, glue);\n\tpm_runtime_enable(&pdev->dev);\n\tret = dsps_create_musb_pdev(glue, pdev);\n\tif (ret)\n	t
61007	4078	rtnl_stats_get	net/core/rtnetlink.c	nskb	1	11	\N	\N	\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev = NULL;\n\tint idxattr = 0, prividx = 0;\n\tstruct if_stats_msg *ifsm;\n\tstruct sk_buff *nskb;\n\tu32 filter_mask;\n\tint err;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifsm))\n\t\treturn -EINVAL;\n\n\tifsm = nlmsg_data(nlh);\n\tif (ifsm->ifindex > 0)\n\t\tdev = __dev_get_by_index(net, ifsm->ifindex);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tfilter_mask = ifsm->filter_mask;\n\tif (!filter_mask)\n\t\treturn -EINVAL;\n\n\tnskb = nlmsg_new(if_nlmsg_stats_size(dev, filter_mask), GFP_KERNEL);\n\tif (!nskb)\n\t\treturn -ENOBUFS;\n\n\terr = rtnl_fill_statsinfo(nskb, dev, RTM_NEWSTATS,\n	t
25856	772	dln2_probe	drivers/mfd/dln2.c	ret	0	11	\N	\N	\tstruct usb_host_interface *hostif = interface->cur_altsetting;\n\tstruct device *dev = &interface->dev;\n\tstruct dln2_dev *dln2;\n\tint ret;\n\tint i, j;\n\n\tif (hostif->desc.bInterfaceNumber != 0 ||\n\t    hostif->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\tdln2 = kzalloc(sizeof(*dln2), GFP_KERNEL);\n\tif (!dln2)\n\t\treturn -ENOMEM;\n\n\tdln2->ep_out = hostif->endpoint[0].desc.bEndpointAddress;\n\tdln2->ep_in = hostif->endpoint[1].desc.bEndpointAddress;\n\tdln2->usb_dev = usb_get_dev(interface_to_usbdev(interface));\n\tdln2->interface = interface;\n\tusb_set_intfdata(interface, dln2);\n\tinit_waitqueue_head(&dln2->disconnect_wq);\n\n\tfor (i = 0; i < DLN2_HANDLES; i++) {\n\t\tinit_waitqueue_head(&dln2->mod_rx_slots[i].wq);\n\t\tspin_lock_init(&dln2->mod_rx_slots[i].lock);\n\t\tfor (j = 0; j < DLN2_MAX_RX_SLOTS; j++)\n\t\t\tinit_completion(&dln2->mod_rx_slots[i].slots[j].done);\n\t}\n\n\tspin_lock_init(&dln2->event_cb_lock);\n\tspin_lock_init(&dln2->disconnect_lock);\n\tINIT_LIST_HEAD(&dln2->event_cb_list);\n\n\tret = dln2_setup_rx_urbs(dln2, hostif);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = dln2_start_rx_urbs(dln2, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_stop_rx;\n\n\tret = dln2_hw_init(dln2);\n\tif (ret < 0) {\n	f
-401	664	isc_update_profile	drivers/media/platform/atmel/atmel-isc.c	sr	2	3	\N	\N	\tstruct regmap *regmap = isc->regmap;\n\tu32 sr;\n\tint counter = 100;\n\n\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_UPPRO);\n\n\tregmap_read(regmap, ISC_CTRLSR, &sr);\n\twhile ((sr & ISC_CTRL_UPPRO) && counter--) {\n	f
25977	221	isight_connect	sound/firewire/isight.c	ch	1	13	\N	\N	\tint ch, err;\n\t__be32 value;\n\nretry_after_bus_reset:\n\tch = fw_iso_resources_allocate(&isight->resources,\n\t\t\t\t       sizeof(struct audio_payload),\n\t\t\t\t       isight->device->max_speed);\n\tif (ch < 0) {\n	f
-400	504	get_signal_parameters	drivers/media/dvb-frontends/stv0910.c	tmp	2	3	\N	\N	\tu8 tmp;\n\n\tif (!state->started)\n\t\treturn -EINVAL;\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tread_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);\n\t\tstate->mod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);\n\t\tstate->pilots = (tmp & 0x01) != 0;\n	f
24337	923	ieee80211_auth_resp	drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c	ieee80211_auth_resp_$auth$obj$0$2	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct ieee80211_authentication *auth;\n\tint len = ieee->tx_headroom + sizeof(struct ieee80211_authentication)+1;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->len = sizeof(struct ieee80211_authentication);\n\n\tauth = (struct ieee80211_authentication *)skb->data;\n\n\tauth->status = cpu_to_le16(status);\n\tauth->transaction = cpu_to_le16(2);\n\tauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\n\n\tmemcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(auth->header.addr1, dest, ETH_ALEN);\n	t
35836	1025	nilfs_ioctl_sync	fs/nilfs2/ioctl.c	ret	1	11	\N	\N	\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n	t
62725	5214	alloc_msg_with_page_vector	net/ceph/osd_client.c	&osd_data	1	11	\N	\N	\tstruct ceph_msg *m;\n\tint type = le16_to_cpu(hdr->type);\n\tu32 front_len = le32_to_cpu(hdr->front_len);\n\tu32 data_len = le32_to_cpu(hdr->data_len);\n\n\tm = ceph_msg_new(type, front_len, GFP_NOIO, false);\n\tif (!m)\n\t\treturn NULL;\n\n\tif (data_len) {\n\t\tstruct page **pages;\n\t\tstruct ceph_osd_data osd_data;\n\n\t\tpages = ceph_alloc_page_vector(calc_pages_for(0, data_len),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (IS_ERR(pages)) {\n\t\t\tceph_msg_put(m);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tceph_osd_data_pages_init(&osd_data, pages, data_len, 0, false,\n\t\t\t\t\t false);\n\t\tceph_osdc_msg_data_add(m, &osd_data);\n	t
54224	1439	fuse_notify_inval_inode	fs/fuse/dev.c	outarg.off	7	12	\N	\N	\tstruct fuse_notify_inval_inode_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\terr = fuse_reverse_inval_inode(fc->sb, outarg.ino,\n	t
54112	433	fuse_flush	fs/fuse/file.c	err	0	11	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tfuse_sync_writes(inode);\n\tinode_unlock(inode);\n\n\terr = filemap_check_errors(file->f_mapping);\n\tif (err)\n\t\treturn err;\n\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\t__set_bit(FR_FORCE, &req->flags);\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n	f
4682	194	store_u8	drivers/hwmon/asc7621.c	store_u8_$__UNIQUE_ID_min1_125$obj	0	13	\N	\N	\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, 0, 255);\n	f
40751	1028	mmp_pdma_probe	drivers/dma/mmp_pdma.c	&pdev->phy_lock	1	13	\N	\N	\tstruct mmp_pdma_device *pdev;\n\tconst struct of_device_id *of_id;\n\tstruct mmp_dma_platdata *pdata = dev_get_platdata(&op->dev);\n\tstruct resource *iores;\n\tint i, ret, irq = 0;\n\tint dma_channels = 0, irq_num = 0;\n\tconst enum dma_slave_buswidth widths =\n\t\tDMA_SLAVE_BUSWIDTH_1_BYTE   | DMA_SLAVE_BUSWIDTH_2_BYTES |\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tpdev = devm_kzalloc(&op->dev, sizeof(*pdev), GFP_KERNEL);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tpdev->dev = &op->dev;\n\n\tspin_lock_init(&pdev->phy_lock);\n	f
-239	194	iproc_adc_interrupt_handler	drivers/iio/adc/bcm_iproc_adc.c	ch_intr_status	5	20	\N	\N	\tirqreturn_t retval = IRQ_NONE;\n\tstruct iproc_adc_priv *adc_priv;\n\tstruct iio_dev *indio_dev = data;\n\tunsigned int valid_entries;\n\tu32 intr_status;\n\tu32 intr_channels;\n\tu32 channel_status;\n\tu32 ch_intr_status;\n\n\tadc_priv = iio_priv(indio_dev);\n\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tdev_dbg(&indio_dev->dev, "iproc_adc_interrupt_handler(),INTRPT_STS:%x\\n",\n\t\t\tintr_status);\n\n\tintr_channels = (intr_status & IPROC_ADC_INTR_MASK) >> IPROC_ADC_INTR;\n\tif (intr_channels) {\n\t\tregmap_read(adc_priv->regmap,\n\t\t\t    IPROC_ADC_CHANNEL_INTERRUPT_STATUS +\n\t\t\t    IPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\n\t\t\t    &ch_intr_status);\n\n\t\tif (ch_intr_status & IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK) {\n	f
-238	188	iproc_adc_interrupt_handler	drivers/iio/adc/bcm_iproc_adc.c	intr_channels	5	20	\N	\N	\tirqreturn_t retval = IRQ_NONE;\n\tstruct iproc_adc_priv *adc_priv;\n\tstruct iio_dev *indio_dev = data;\n\tunsigned int valid_entries;\n\tu32 intr_status;\n\tu32 intr_channels;\n\tu32 channel_status;\n\tu32 ch_intr_status;\n\n\tadc_priv = iio_priv(indio_dev);\n\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tdev_dbg(&indio_dev->dev, "iproc_adc_interrupt_handler(),INTRPT_STS:%x\\n",\n\t\t\tintr_status);\n\n\tintr_channels = (intr_status & IPROC_ADC_INTR_MASK) >> IPROC_ADC_INTR;\n\tif (intr_channels) {\n	f
-607	52	arcpgu_drm_hdmi_init	drivers/gpu/drm/arc/arcpgu_hdmi.c	encoder	2	3	\N	\N	\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *bridge;\n\n\tint ret = 0;\n\n\tencoder = devm_kzalloc(drm->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (encoder == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Locate drm bridge from the hdmi encoder DT node */\n\tbridge = of_drm_find_bridge(np);\n\tif (!bridge)\n\t\treturn -EPROBE_DEFER;\n\n\tencoder->possible_crtcs = 1;\n\tencoder->possible_clones = 0;\n\tret = drm_encoder_init(drm, encoder, &arcpgu_drm_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_TMDS, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Link drm_bridge to encoder */\n\tret = drm_bridge_attach(encoder, bridge, NULL);\n\tif (ret)\n\t\tdrm_encoder_cleanup(encoder);\n	f
28411	1881	nsc_ircc_dma_receive_complete	drivers/staging/irda/drivers/nsc-ircc.c	skb	1	13	\N	\N	\tstruct st_fifo *st_fifo;\n\tstruct sk_buff *skb;\n\t__u8 status;\n\t__u8 bank;\n\tint len;\n\n\tst_fifo = &self->st_fifo;\n\n\t/* Save current bank */\n\tbank = inb(iobase+BSR);\n\t\n\t/* Read all entries in status FIFO */\n\tswitch_bank(iobase, BANK5);\n\twhile ((status = inb(iobase+FRM_ST)) & FRM_ST_VLD) {\n\t\t/* We must empty the status FIFO no matter what */\n\t\tlen = inb(iobase+RFLFL) | ((inb(iobase+RFLFH) & 0x1f) << 8);\n\n\t\tif (st_fifo->tail >= MAX_RX_WINDOW) {\n\t\t\tpr_debug("%s(), window is full!\\n", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\tst_fifo->entries[st_fifo->tail].status = status;\n\t\tst_fifo->entries[st_fifo->tail].len = len;\n\t\tst_fifo->pending_bytes += len;\n\t\tst_fifo->tail++;\n\t\tst_fifo->len++;\n\t}\n\t/* Try to process all entries in status FIFO */\n\twhile (st_fifo->len > 0) {\n\t\t/* Get first entry */\n\t\tstatus = st_fifo->entries[st_fifo->head].status;\n\t\tlen    = st_fifo->entries[st_fifo->head].len;\n\t\tst_fifo->pending_bytes -= len;\n\t\tst_fifo->head++;\n\t\tst_fifo->len--;\n\n\t\t/* Check for errors */\n\t\tif (status & FRM_ST_ERR_MSK) {\n\t\t\tif (status & FRM_ST_LOST_FR) {\n\t\t\t\t/* Add number of lost frames to stats */\n\t\t\t\tself->netdev->stats.rx_errors += len;\n\t\t\t} else {\n\t\t\t\t/* Skip frame */\n\t\t\t\tself->netdev->stats.rx_errors++;\n\t\t\t\t\n\t\t\t\tself->rx_buff.data += len;\n\t\t\t\n\t\t\t\tif (status & FRM_ST_MAX_LEN)\n\t\t\t\t\tself->netdev->stats.rx_length_errors++;\n\t\t\t\t\n\t\t\t\tif (status & FRM_ST_PHY_ERR) \n\t\t\t\t\tself->netdev->stats.rx_frame_errors++;\n\t\t\t\t\n\t\t\t\tif (status & FRM_ST_BAD_CRC) \n\t\t\t\t\tself->netdev->stats.rx_crc_errors++;\n\t\t\t}\n\t\t\t/* The errors below can be reported in both cases */\n\t\t\tif (status & FRM_ST_OVR1)\n\t\t\t\tself->netdev->stats.rx_fifo_errors++;\n\t\t\t\n\t\t\tif (status & FRM_ST_OVR2)\n\t\t\t\tself->netdev->stats.rx_fifo_errors++;\n\t\t} else {\n\t\t\t/*  \n\t\t\t * First we must make sure that the frame we\n\t\t\t * want to deliver is all in main memory. If we\n\t\t\t * cannot tell, then we check if the Rx FIFO is\n\t\t\t * empty. If not then we will have to take a nap\n\t\t\t * and try again later.  \n\t\t\t */\n\t\t\tif (st_fifo->pending_bytes < self->io.fifo_size) {\n\t\t\t\tswitch_bank(iobase, BANK0);\n\t\t\t\tif (inb(iobase+LSR) & LSR_RXDA) {\n\t\t\t\t\t/* Put this entry back in fifo */\n\t\t\t\t\tst_fifo->head--;\n\t\t\t\t\tst_fifo->len++;\n\t\t\t\t\tst_fifo->pending_bytes += len;\n\t\t\t\t\tst_fifo->entries[st_fifo->head].status = status;\n\t\t\t\t\tst_fifo->entries[st_fifo->head].len = len;\n\t\t\t\t\t/*  \n\t\t\t\t\t * DMA not finished yet, so try again \n\t\t\t\t\t * later, set timer value, resolution \n\t\t\t\t\t * 125 us \n\t\t\t\t\t */\n\t\t\t\t\tswitch_bank(iobase, BANK4);\n\t\t\t\t\toutb(0x02, iobase+TMRL); /* x 125 us */\n\t\t\t\t\toutb(0x00, iobase+TMRH);\n\n\t\t\t\t\t/* Start timer */\n\t\t\t\t\toutb(IRCR1_TMR_EN, iobase+IRCR1);\n\n\t\t\t\t\t/* Restore bank register */\n\t\t\t\t\toutb(bank, iobase+BSR);\n\t\t\t\t\t\n\t\t\t\t\treturn FALSE; /* I'll be back! */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* \n\t\t\t * Remember the time we received this frame, so we can\n\t\t\t * reduce the min turn time a bit since we will know\n\t\t\t * how much time we have used for protocol processing\n\t\t\t */\n\t\t\tself->stamp = ktime_get();\n\n\t\t\tskb = dev_alloc_skb(len+1);\n\t\t\tif (skb == NULL)  {\n\t\t\t\tself->netdev->stats.rx_dropped++;\n\n\t\t\t\t/* Restore bank register */\n\t\t\t\toutb(bank, iobase+BSR);\n\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t\n\t\t\t/* Make sure IP header gets aligned */\n\t\t\tskb_reserve(skb, 1); \n	f
54247	1010	htree_dirblock_to_tree	fs/ext4/namei.c	hinfo->hash	1	11	\N	\N	\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\tstruct fscrypt_str fname_crypto_str = FSTR_INIT(NULL, 0), tmp_str;\n\n\tdxtrace(printk(KERN_INFO "In htree dirblock_to_tree: block %lu\\n",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\t/* Check if the directory is encrypted */\n\tif (ext4_encrypted_inode(dir)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\terr = fscrypt_fname_alloc_buffer(dir, EXT4_NAME_LEN,\n\t\t\t\t\t\t     &fname_crypto_str);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n	f
54410	1926	fuse_writepages	fs/fuse/file.c	data.req->num_pages	1	11	\N	\N	\tstruct inode *inode = mapping->host;\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.req = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.req) {\n\t\t/* Ignore errors if we can write at least one page */\n\t\tBUG_ON(!data.req->num_pages);\n	f
39161	2939	nested_svm_vmrun	arch/x86/kvm/svm.c	page	1	11	\N	\N	\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n	t
43890	5841	rbd_dev_image_id	drivers/block/rbd.c	image_id	1	11	\N	\N	\tint ret;\n\tsize_t size;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tvoid *response;\n\tchar *image_id;\n\n\t/*\n\t * When probing a parent image, the image id is already\n\t * known (and the image name likely is not).  There's no\n\t * need to fetch the image id again in this case.  We\n\t * do still need to set the image format though.\n\t */\n\tif (rbd_dev->spec->image_id) {\n\t\trbd_dev->image_format = *rbd_dev->spec->image_id ? 2 : 1;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * First, see if the format 2 image id file exists, and if\n\t * so, get the image's persistent id from it.\n\t */\n\tret = ceph_oid_aprintf(&oid, GFP_KERNEL, "%s%s", RBD_ID_PREFIX,\n\t\t\t       rbd_dev->spec->image_name);\n\tif (ret)\n\t\treturn ret;\n\n\tdout("rbd id object name is %s\\n", oid.name);\n\n\t/* Response will be an encoded string, which includes a length */\n\n\tsize = sizeof (__le32) + RBD_IMAGE_ID_LEN_MAX;\n\tresponse = kzalloc(size, GFP_NOIO);\n\tif (!response) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* If it doesn't exist we'll assume it's a format 1 image */\n\n\tret = rbd_obj_method_sync(rbd_dev, &oid, &rbd_dev->header_oloc,\n\t\t\t\t  "get_id", NULL, 0,\n\t\t\t\t  response, RBD_IMAGE_ID_LEN_MAX);\n\tdout("%s: rbd_obj_method_sync returned %d\\n", __func__, ret);\n\tif (ret == -ENOENT) {\n\t\timage_id = kstrdup("", GFP_KERNEL);\n\t\tret = image_id ? 0 : -ENOMEM;\n\t\tif (!ret)\n\t\t\trbd_dev->image_format = 1;\n\t} else if (ret >= 0) {\n\t\tvoid *p = response;\n\n\t\timage_id = ceph_extract_encoded_string(&p, p + ret,\n\t\t\t\t\t\tNULL, GFP_NOIO);\n\t\tret = PTR_ERR_OR_ZERO(image_id);\n\t\tif (!ret)\n\t\t\trbd_dev->image_format = 2;\n\t}\n\n\tif (!ret) {\n\t\trbd_dev->spec->image_id = image_id;\n\t\tdout("image_id is %s\\n", image_id);\n	t
45619	2348	dm_check_edca_turbo	drivers/staging/rtl8192u/r8192U_dm.c	AcmCtrl	1	11	\N	\N	\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = priv->ieee80211->pHTInfo;\n\t/*PSTA_QOS\t\t\tpStaQos = pMgntInfo->pStaQos;*/\n\n\t/* Keep past Tx/Rx packet count for RT-to-RT EDCA turbo. */\n\tstatic unsigned long\t\t\tlastTxOkCnt;\n\tstatic unsigned long\t\t\tlastRxOkCnt;\n\tunsigned long\t\t\t\tcurTxOkCnt = 0;\n\tunsigned long\t\t\t\tcurRxOkCnt = 0;\n\n\t/*\n\t * Do not be Turbo if it's under WiFi config and Qos Enabled, because the EDCA parameters\n\t * should follow the settings from QAP. By Bruce, 2007-12-07.\n\t */\n\tif (priv->ieee80211->state != IEEE80211_LINKED)\n\t\tgoto dm_CheckEdcaTurbo_EXIT;\n\t/* We do not turn on EDCA turbo mode for some AP that has IOT issue */\n\tif (priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO)\n\t\tgoto dm_CheckEdcaTurbo_EXIT;\n\n\t/*printk("========>%s():bis_any_nonbepkts is %d\\n", __func__, priv->bis_any_nonbepkts);*/\n\t/* Check the status for current condition. */\n\tif (!priv->ieee80211->bis_any_nonbepkts) {\n\t\tcurTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;\n\t\tcurRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;\n\t\t/* For RT-AP, we needs to turn it on when Rx>Tx */\n\t\tif (curRxOkCnt > 4*curTxOkCnt) {\n\t\t\t/*printk("%s():curRxOkCnt > 4*curTxOkCnt\\n");*/\n\t\t\tif (!priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA) {\n\t\t\t\twrite_nic_dword(dev, EDCAPARA_BE, edca_setting_DL[pHTInfo->IOTPeer]);\n\t\t\t\tpriv->bis_cur_rdlstate = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/*printk("%s():curRxOkCnt < 4*curTxOkCnt\\n");*/\n\t\t\tif (priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA) {\n\t\t\t\twrite_nic_dword(dev, EDCAPARA_BE, edca_setting_UL[pHTInfo->IOTPeer]);\n\t\t\t\tpriv->bis_cur_rdlstate = false;\n\t\t\t}\n\n\t\t}\n\n\t\tpriv->bcurrent_turbo_EDCA = true;\n\t} else {\n\t\t/*\n\t\t * Turn Off EDCA turbo here.\n\t\t * Restore original EDCA according to the declaration of AP.\n\t\t */\n\t\tif (priv->bcurrent_turbo_EDCA) {\n\t\t\tu8\tu1bAIFS;\n\t\t\tu32\tu4bAcParam, op_limit, cw_max, cw_min;\n\n\t\t\tstruct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;\n\t\t\tu8 mode = priv->ieee80211->mode;\n\n\t\t\t/*  For Each time updating EDCA parameter, reset EDCA turbo mode status. */\n\t\t\tdm_init_edca_turbo(dev);\n\n\t\t\tu1bAIFS = qos_parameters->aifs[0] * ((mode & (IEEE_G | IEEE_N_24G)) ? 9 : 20) + aSifsTime;\n\n\t\t\top_limit = (u32)le16_to_cpu(qos_parameters->tx_op_limit[0]);\n\t\t\tcw_max   = (u32)le16_to_cpu(qos_parameters->cw_max[0]);\n\t\t\tcw_min   = (u32)le16_to_cpu(qos_parameters->cw_min[0]);\n\n\t\t\top_limit <<= AC_PARAM_TXOP_LIMIT_OFFSET;\n\t\t\tcw_max   <<= AC_PARAM_ECW_MAX_OFFSET;\n\t\t\tcw_min   <<= AC_PARAM_ECW_MIN_OFFSET;\n\t\t\tu1bAIFS  <<= AC_PARAM_AIFS_OFFSET;\n\n\t\t\tu4bAcParam = op_limit | cw_max | cw_min | u1bAIFS;\n\t\t\tcpu_to_le32s(&u4bAcParam);\n\n\t\t\twrite_nic_dword(dev, EDCAPARA_BE, u4bAcParam);\n\n\n\t\t\t/*\n\t\t\t * Check ACM bit.\n\t\t\t * If it is set, immediately set ACM control bit to downgrading AC for passing WMM testplan. Annie, 2005-12-13.\n\t\t\t */\n\t\t\t{\n\t\t\t\t/*  TODO:  Modified this part and try to set acm control in only 1 IO processing!! */\n\n\t\t\t\tPACI_AIFSN\tpAciAifsn = (PACI_AIFSN)&(qos_parameters->aifs[0]);\n\t\t\t\tu8\t\tAcmCtrl;\n\n\t\t\t\tread_nic_byte(dev, AcmHwCtrl, &AcmCtrl);\n\n\t\t\t\tif (pAciAifsn->f.ACM) { /*  ACM bit is 1. */\n\t\t\t\t\tAcmCtrl |= AcmHw_BeqEn;\n\t\t\t\t} else {\t/* ACM bit is 0. */\n\t\t\t\t\tAcmCtrl &= (~AcmHw_BeqEn);\n\t\t\t\t}\n\n\t\t\t\tRT_TRACE(COMP_QOS, "SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\\n", AcmCtrl);\n	t
9078	274	get_key_purpletv	drivers/media/pci/saa7134/saa7134-input.c	b	1	11	\N	\N	\tunsigned char b;\n\n\t/* poll IR chip */\n\tif (1 != i2c_master_recv(ir->c, &b, 1)) {\n\t\tir_dbg(ir, "read error\\n");\n\t\treturn -EIO;\n\t}\n\n\t/* no button press */\n\tif (b==0)\n	t
1611	277	carl9170_tx_status_process_ampdu	drivers/net/wireless/ath/carl9170/tx.c	carl9170_tx_status_process_ampdu_$p.addr.i$obj	0	11	\N	\N	\tstruct ar9170 *ar;\n\tstruct carl9170_tx_info *arinfo;\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct sk_buff *skb;\n\n\tarinfo = container_of(ref, struct carl9170_tx_info, ref);\n\ttxinfo = container_of((void *) arinfo, struct ieee80211_tx_info,\n\t\t\t      rate_driver_data);\n\tskb = container_of((void *) txinfo, struct sk_buff, cb);\n\n\tar = arinfo->ar;\n\tif (WARN_ON_ONCE(!ar))\n\t\treturn;\n\n	t
35267	6936	airo_get_range	drivers/net/wireless/cisco/airo.c	cap_rid.softCap	6	12	\N	\N	\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint\t\ti;\n\tint\t\tk;\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t/* Should be based on cap_rid.country to give only\n\t * what the current card support */\n\tk = 0;\n\tfor(i = 0; i < 14; i++) {\n\t\trange->freq[k].i = i + 1; /* List index */\n\t\trange->freq[k].m = 100000 *\n\t\t     ieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ);\n\t\trange->freq[k++].e = 1;\t/* Values in MHz -> * 10^5 * 10 */\n\t}\n\trange->num_frequency = k;\n\n\trange->sensitivity = 65535;\n\n\t/* Hum... Should put the right values there */\n\tif (local->rssi)\n\t\trange->max_qual.qual = 100;\t/* % */\n\telse\n\t\trange->max_qual.qual = airo_get_max_quality(&cap_rid);\n\trange->max_qual.level = 0x100 - 120;\t/* -120 dBm */\n\trange->max_qual.noise = 0x100 - 120;\t/* -120 dBm */\n\n\t/* Experimental measurements - boundary 11/5.5 Mb/s */\n\t/* Note : with or without the (local->rssi), results\n\t * are somewhat different. - Jean II */\n\tif (local->rssi) {\n\t\trange->avg_qual.qual = 50;\t\t/* % */\n\t\trange->avg_qual.level = 0x100 - 70;\t/* -70 dBm */\n\t} else {\n\t\trange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\n\t\trange->avg_qual.level = 0x100 - 80;\t/* -80 dBm */\n\t}\n\trange->avg_qual.noise = 0x100 - 85;\t\t/* -85 dBm */\n\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\n\t\tif(range->bitrate[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_bitrates = i;\n\n\t/* Set an indication of the max TCP throughput\n\t * in bit/s that we can expect using this interface.\n\t * May be use for QoS stuff... Jean II */\n\tif(i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = AIRO_DEF_MTU;\n\trange->min_frag = 256;\n\trange->max_frag = AIRO_DEF_MTU;\n\n\tif(cap_rid.softCap & cpu_to_le16(2)) {\n	t
35057	203	qtnf_cmd_send_config_ap	drivers/net/wireless/quantenna/qtnfmac/commands.c	cmd_skb	1	11	\N	\N	\tstruct sk_buff *cmd_skb;\n\tstruct qtnf_bss_config *bss_cfg = &vif->bss_cfg;\n\tstruct cfg80211_chan_def *chandef = &vif->mac->chandef;\n\tstruct qlink_tlv_channel *qchan;\n\tstruct qlink_auth_encr aen;\n\tu16 res_code = QLINK_CMD_RESULT_OK;\n\tint ret;\n\tint i;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CONFIG_AP,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (unlikely(!cmd_skb))\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, WLAN_EID_SSID, bss_cfg->ssid,\n	t
38055	226	ec_bhf_process_rx	drivers/net/ethernet/ec_bhf.c	skb	1	11	\N	\N	\tstruct rx_desc *desc = &priv->rx_descs[priv->rx_dnext];\n\n\twhile (ec_bhf_pkt_received(desc)) {\n\t\tint pkt_size = (le16_to_cpu(desc->header.len) &\n\t\t\t       RXHDR_LEN_MASK) - sizeof(struct rx_header) - 4;\n\t\tu8 *data = desc->data;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(priv->net_dev, pkt_size);\n\t\tif (skb) {\n\t\t\tskb_put_data(skb, data, pkt_size);\n	t
59746	255	lp55xx_store_engine_select	drivers/leds/leds-lp55xx-common.c	val	1	11	\N	\N	\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\t/* select the engine to be run */\n\n\tswitch (val) {\n	t
60895	542	rk808_probe	drivers/mfd/rk808.c	ret	1	11	\N	\N	\tstruct device_node *np = client->dev.of_node;\n\tstruct rk808 *rk808;\n\tconst struct rk808_reg_data *pre_init_reg;\n\tconst struct mfd_cell *cells;\n\tvoid (*pm_pwroff_fn)(void);\n\tint nr_pre_init_regs;\n\tint nr_cells;\n\tint pm_off = 0, msb, lsb;\n\tint ret;\n\tint i;\n\n\trk808 = devm_kzalloc(&client->dev, sizeof(*rk808), GFP_KERNEL);\n\tif (!rk808)\n\t\treturn -ENOMEM;\n\n\t/* Read chip variant */\n\tmsb = i2c_smbus_read_byte_data(client, RK808_ID_MSB);\n\tif (msb < 0) {\n\t\tdev_err(&client->dev, "failed to read the chip id at 0x%x\\n",\n\t\t\tRK808_ID_MSB);\n\t\treturn msb;\n\t}\n\n\tlsb = i2c_smbus_read_byte_data(client, RK808_ID_LSB);\n\tif (lsb < 0) {\n\t\tdev_err(&client->dev, "failed to read the chip id at 0x%x\\n",\n\t\t\tRK808_ID_LSB);\n\t\treturn lsb;\n\t}\n\n\trk808->variant = ((msb << 8) | lsb) & RK8XX_ID_MSK;\n\tdev_info(&client->dev, "chip id: 0x%x\\n", (unsigned int)rk808->variant);\n\n\tswitch (rk808->variant) {\n\tcase RK805_ID:\n\t\trk808->regmap_cfg = &rk805_regmap_config;\n\t\trk808->regmap_irq_chip = &rk805_irq_chip;\n\t\tpre_init_reg = rk805_pre_init_reg;\n\t\tnr_pre_init_regs = ARRAY_SIZE(rk805_pre_init_reg);\n\t\tcells = rk805s;\n\t\tnr_cells = ARRAY_SIZE(rk805s);\n\t\tpm_pwroff_fn = rk805_device_shutdown;\n\t\tbreak;\n\tcase RK808_ID:\n\t\trk808->regmap_cfg = &rk808_regmap_config;\n\t\trk808->regmap_irq_chip = &rk808_irq_chip;\n\t\tpre_init_reg = rk808_pre_init_reg;\n\t\tnr_pre_init_regs = ARRAY_SIZE(rk808_pre_init_reg);\n\t\tcells = rk808s;\n\t\tnr_cells = ARRAY_SIZE(rk808s);\n\t\tpm_pwroff_fn = rk808_device_shutdown;\n\t\tbreak;\n\tcase RK818_ID:\n\t\trk808->regmap_cfg = &rk818_regmap_config;\n\t\trk808->regmap_irq_chip = &rk818_irq_chip;\n\t\tpre_init_reg = rk818_pre_init_reg;\n\t\tnr_pre_init_regs = ARRAY_SIZE(rk818_pre_init_reg);\n\t\tcells = rk818s;\n\t\tnr_cells = ARRAY_SIZE(rk818s);\n\t\tpm_pwroff_fn = rk818_device_shutdown;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, "Unsupported RK8XX ID %lu\\n",\n\t\t\trk808->variant);\n\t\treturn -EINVAL;\n\t}\n\n\trk808->i2c = client;\n\ti2c_set_clientdata(client, rk808);\n\n\trk808->regmap = devm_regmap_init_i2c(client, rk808->regmap_cfg);\n\tif (IS_ERR(rk808->regmap)) {\n\t\tdev_err(&client->dev, "regmap initialization failed\\n");\n\t\treturn PTR_ERR(rk808->regmap);\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, "No interrupt support, no core IRQ\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_add_irq_chip(rk808->regmap, client->irq,\n\t\t\t\t  IRQF_ONESHOT, -1,\n\t\t\t\t  rk808->regmap_irq_chip, &rk808->irq_data);\n\tif (ret) {\n\t\tdev_err(&client->dev, "Failed to add irq_chip %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_pre_init_regs; i++) {\n\t\tret = regmap_update_bits(rk808->regmap,\n\t\t\t\t\tpre_init_reg[i].addr,\n\t\t\t\t\tpre_init_reg[i].mask,\n\t\t\t\t\tpre_init_reg[i].value);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t"0x%x write err\\n",\n\t\t\t\tpre_init_reg[i].addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,\n\t\t\t      cells, nr_cells, NULL, 0,\n\t\t\t      regmap_irq_get_domain(rk808->irq_data));\n\tif (ret) {\n	t
32934	1004	cp210x_get_termios_port	drivers/usb/serial/cp210x.c	ctl_hs	0	11	\N	\N	\tstruct device *dev = &port->dev;\n\ttcflag_t cflag;\n\tstruct cp210x_flow_ctl flow_ctl;\n\tu32 baud;\n\tu16 bits;\n\tu32 ctl_hs;\n\n\tcp210x_read_u32_reg(port, CP210X_GET_BAUDRATE, &baud);\n\n\tdev_dbg(dev, "%s - baud rate = %d\\n", __func__, baud);\n\t*baudp = baud;\n\n\tcflag = *cflagp;\n\n\tcp210x_get_line_ctl(port, &bits);\n\tcflag &= ~CSIZE;\n\tswitch (bits & BITS_DATA_MASK) {\n\tcase BITS_DATA_5:\n\t\tdev_dbg(dev, "%s - data bits = 5\\n", __func__);\n\t\tcflag |= CS5;\n\t\tbreak;\n\tcase BITS_DATA_6:\n\t\tdev_dbg(dev, "%s - data bits = 6\\n", __func__);\n\t\tcflag |= CS6;\n\t\tbreak;\n\tcase BITS_DATA_7:\n\t\tdev_dbg(dev, "%s - data bits = 7\\n", __func__);\n\t\tcflag |= CS7;\n\t\tbreak;\n\tcase BITS_DATA_8:\n\t\tdev_dbg(dev, "%s - data bits = 8\\n", __func__);\n\t\tcflag |= CS8;\n\t\tbreak;\n\tcase BITS_DATA_9:\n\t\tdev_dbg(dev, "%s - data bits = 9 (not supported, using 8 data bits)\\n", __func__);\n\t\tcflag |= CS8;\n\t\tbits &= ~BITS_DATA_MASK;\n\t\tbits |= BITS_DATA_8;\n\t\tcp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, "%s - Unknown number of data bits, using 8\\n", __func__);\n\t\tcflag |= CS8;\n\t\tbits &= ~BITS_DATA_MASK;\n\t\tbits |= BITS_DATA_8;\n\t\tcp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\t\tbreak;\n\t}\n\n\tswitch (bits & BITS_PARITY_MASK) {\n\tcase BITS_PARITY_NONE:\n\t\tdev_dbg(dev, "%s - parity = NONE\\n", __func__);\n\t\tcflag &= ~PARENB;\n\t\tbreak;\n\tcase BITS_PARITY_ODD:\n\t\tdev_dbg(dev, "%s - parity = ODD\\n", __func__);\n\t\tcflag |= (PARENB|PARODD);\n\t\tbreak;\n\tcase BITS_PARITY_EVEN:\n\t\tdev_dbg(dev, "%s - parity = EVEN\\n", __func__);\n\t\tcflag &= ~PARODD;\n\t\tcflag |= PARENB;\n\t\tbreak;\n\tcase BITS_PARITY_MARK:\n\t\tdev_dbg(dev, "%s - parity = MARK\\n", __func__);\n\t\tcflag |= (PARENB|PARODD|CMSPAR);\n\t\tbreak;\n\tcase BITS_PARITY_SPACE:\n\t\tdev_dbg(dev, "%s - parity = SPACE\\n", __func__);\n\t\tcflag &= ~PARODD;\n\t\tcflag |= (PARENB|CMSPAR);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, "%s - Unknown parity mode, disabling parity\\n", __func__);\n\t\tcflag &= ~PARENB;\n\t\tbits &= ~BITS_PARITY_MASK;\n\t\tcp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\t\tbreak;\n\t}\n\n\tcflag &= ~CSTOPB;\n\tswitch (bits & BITS_STOP_MASK) {\n\tcase BITS_STOP_1:\n\t\tdev_dbg(dev, "%s - stop bits = 1\\n", __func__);\n\t\tbreak;\n\tcase BITS_STOP_1_5:\n\t\tdev_dbg(dev, "%s - stop bits = 1.5 (not supported, using 1 stop bit)\\n", __func__);\n\t\tbits &= ~BITS_STOP_MASK;\n\t\tcp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\t\tbreak;\n\tcase BITS_STOP_2:\n\t\tdev_dbg(dev, "%s - stop bits = 2\\n", __func__);\n\t\tcflag |= CSTOPB;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, "%s - Unknown number of stop bits, using 1 stop bit\\n", __func__);\n\t\tbits &= ~BITS_STOP_MASK;\n\t\tcp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\t\tbreak;\n\t}\n\n\tcp210x_read_reg_block(port, CP210X_GET_FLOW, &flow_ctl,\n\t\t\tsizeof(flow_ctl));\n\tctl_hs = le32_to_cpu(flow_ctl.ulControlHandshake);\n\tif (ctl_hs & CP210X_SERIAL_CTS_HANDSHAKE) {\n	f
53867	1305	da732x_dac_offset_adjust	sound/soc/codecs/da732x.c	~offset[DA732X_HPL_DAC] & DA732X_HP_DAC_OFF_MASK	1	11	\N	\N	\tu8 offset[DA732X_HP_DACS];\n\tu8 sign[DA732X_HP_DACS];\n\tu8 step = DA732X_DAC_OFFSET_STEP;\n\n\t/* Initialize DAC offset calibration circuits and registers */\n\tsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFFSET,\n\t\t      DA732X_HP_DAC_OFFSET_TRIM_VAL);\n\tsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFFSET,\n\t\t      DA732X_HP_DAC_OFFSET_TRIM_VAL);\n\tsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFF_CNTL,\n\t\t      DA732X_HP_DAC_OFF_CALIBRATION |\n\t\t      DA732X_HP_DAC_OFF_SCALE_STEPS);\n\tsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFF_CNTL,\n\t\t      DA732X_HP_DAC_OFF_CALIBRATION |\n\t\t      DA732X_HP_DAC_OFF_SCALE_STEPS);\n\n\t/* Wait for voltage stabilization */\n\tmsleep(DA732X_WAIT_FOR_STABILIZATION);\n\n\t/* Check DAC offset sign */\n\tsign[DA732X_HPL_DAC] = (snd_soc_read(codec, DA732X_REG_HPL_DAC_OFF_CNTL) &\n\t\t\t\tDA732X_HP_DAC_OFF_CNTL_COMPO);\n\tsign[DA732X_HPR_DAC] = (snd_soc_read(codec, DA732X_REG_HPR_DAC_OFF_CNTL) &\n\t\t\t\tDA732X_HP_DAC_OFF_CNTL_COMPO);\n\n\t/* Binary search DAC offset values (both channels at once) */\n\toffset[DA732X_HPL_DAC] = sign[DA732X_HPL_DAC] << DA732X_HP_DAC_COMPO_SHIFT;\n\toffset[DA732X_HPR_DAC] = sign[DA732X_HPR_DAC] << DA732X_HP_DAC_COMPO_SHIFT;\n\n\tdo {\n\t\toffset[DA732X_HPL_DAC] |= step;\n\t\toffset[DA732X_HPR_DAC] |= step;\n\t\tsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFFSET,\n	t
57836	1079	sun4i_i2s_probe	sound/soc/sunxi/sun4i-i2s.c	i2s	1	11	\N	\N	\tstruct sun4i_i2s *i2s;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint irq, ret;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, i2s);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tregs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(&pdev->dev, "Can't retrieve our interrupt\\n");\n\t\treturn irq;\n\t}\n\n\ti2s->variant = of_device_get_match_data(&pdev->dev);\n\tif (!i2s->variant) {\n\t\tdev_err(&pdev->dev, "Failed to determine the quirks to use\\n");\n\t\treturn -ENODEV;\n\t}\n\n\ti2s->bus_clk = devm_clk_get(&pdev->dev, "apb");\n\tif (IS_ERR(i2s->bus_clk)) {\n\t\tdev_err(&pdev->dev, "Can't get our bus clock\\n");\n\t\treturn PTR_ERR(i2s->bus_clk);\n\t}\n\n\ti2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t    i2s->variant->sun4i_i2s_regmap);\n\tif (IS_ERR(i2s->regmap)) {\n\t\tdev_err(&pdev->dev, "Regmap initialisation failed\\n");\n\t\treturn PTR_ERR(i2s->regmap);\n\t}\n\n\ti2s->mod_clk = devm_clk_get(&pdev->dev, "mod");\n\tif (IS_ERR(i2s->mod_clk)) {\n\t\tdev_err(&pdev->dev, "Can't get our mod clock\\n");\n\t\treturn PTR_ERR(i2s->mod_clk);\n\t}\n\n\tif (i2s->variant->has_reset) {\n\t\ti2s->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\t\tif (IS_ERR(i2s->rst)) {\n\t\t\tdev_err(&pdev->dev, "Failed to get reset control\\n");\n\t\t\treturn PTR_ERR(i2s->rst);\n\t\t}\n\t}\n\n\tif (!IS_ERR(i2s->rst)) {\n\t\tret = reset_control_deassert(i2s->rst);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"Failed to deassert the reset control\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti2s->playback_dma_data.addr = res->start +\n\t\t\t\t\ti2s->variant->reg_offset_txdata;\n\ti2s->playback_dma_data.maxburst = 8;\n\n\ti2s->capture_dma_data.addr = res->start + SUN4I_I2S_FIFO_RX_REG;\n\ti2s->capture_dma_data.maxburst = 8;\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = sun4i_i2s_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &sun4i_i2s_component,\n\t\t\t\t\t      &sun4i_i2s_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "Could not register DAI\\n");\n\t\tgoto err_suspend;\n\t}\n\n\tret = snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "Could not register PCM\\n");\n\t\tgoto err_suspend;\n\t}\n\n\tret = sun4i_i2s_init_regmap_fields(&pdev->dev, i2s);\n	t
9252	1407	adv7842_g_input_status	drivers/media/i2c/adv7842.c	adv7842_g_input_status_$and$128	0	11	\N	\N	\tstruct adv7842_state *state = to_state(sd);\n\n\t*status = 0;\n\n\tif (io_read(sd, 0x0c) & 0x24)\n\t\t*status |= V4L2_IN_ST_NO_POWER;\n\n\tif (state->mode == ADV7842_MODE_SDP) {\n\t\t/* status from SDP block */\n\t\tif (!(sdp_read(sd, 0x5A) & 0x01))\n\t\t\t*status |= V4L2_IN_ST_NO_SIGNAL;\n\n\t\tv4l2_dbg(1, debug, sd, "%s: SDP status = 0x%x\\n",\n\t\t\t\t__func__, *status);\n\t\treturn 0;\n\t}\n\t/* status from CP block */\n\tif ((cp_read(sd, 0xb5) & 0xd0) != 0xd0 ||\n\t\t\t!(cp_read(sd, 0xb1) & 0x80))\n	t
26446	321	rv3029_eeprom_update_bits	drivers/rtc/rtc-rv3029c2.c	ret	1	11	\N	\N	\tu8 buf;\n\tint ret;\n\n\tret = rv3029_eeprom_read(dev, reg, &buf, 1);\n\tif (ret < 0)\n	t
31018	2078	twl4030_voice_set_dai_fmt	sound/soc/codecs/twl4030.c	old_format	1	11	\N	\N	\tstruct snd_soc_codec *codec = codec_dai->codec;\n\tstruct twl4030_priv *twl4030 = snd_soc_codec_get_drvdata(codec);\n\tu8 old_format, format;\n\n\t/* get format */\n\told_format = twl4030_read(codec, TWL4030_REG_VOICE_IF);\n\tformat = old_format;\n\n\t/* set master/slave audio interface */\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tformat &= ~(TWL4030_VIF_SLAVE_EN);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tformat |= TWL4030_VIF_SLAVE_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* clock inversion */\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tformat &= ~(TWL4030_VIF_FORMAT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tformat |= TWL4030_VIF_FORMAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (format != old_format) {\n	t
60713	965	tas5086_i2c_probe	sound/soc/codecs/tas5086.c	priv->supplies	1	11	\N	\N	\tstruct tas5086_private *priv;\n\tstruct device *dev = &i2c->dev;\n\tint gpio_nreset = -EINVAL;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, "Failed to get regulators: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->regmap = devm_regmap_init(dev, NULL, i2c, &tas5086_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, "Failed to create regmap: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tif (of_match_device(of_match_ptr(tas5086_dt_ids), dev)) {\n\t\tstruct device_node *of_node = dev->of_node;\n\t\tgpio_nreset = of_get_named_gpio(of_node, "reset-gpio", 0);\n\t}\n\n\tif (gpio_is_valid(gpio_nreset))\n\t\tif (devm_gpio_request(dev, gpio_nreset, "TAS5086 Reset"))\n\t\t\tgpio_nreset = -EINVAL;\n\n\tpriv->gpio_nreset = gpio_nreset;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n	t
62549	520	ade7754_write_frequency	drivers/staging/iio/meter/ade7754.c	val	1	13	\N	\N	\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ade7754_state *st = iio_priv(indio_dev);\n\tu16 val;\n\tint ret;\n\tu8 reg, t;\n\n\tret = kstrtou16(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (!val)\n	f
-230	689	max17042_load_new_capacity_params	drivers/power/supply/max17042_battery.c	vfSoc	5	20	\N	\N	\tu32 full_cap0, rep_cap, dq_acc, vfSoc;\n\tu32 rem_cap;\n\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_read(map, MAX17042_FullCAP0, &full_cap0);\n\tregmap_read(map, MAX17042_VFSOC, &vfSoc);\n\n\t/* fg_vfSoc needs to shifted by 8 bits to get the\n\t * perc in 1% accuracy, to get the right rem_cap multiply\n\t * full_cap0, fg_vfSoc and devide by 100\n\t */\n\trem_cap = ((vfSoc >> 8) * full_cap0) / 100;\n\tmax17042_write_verify_reg(map, MAX17042_RemCap, rem_cap);\n	f
-229	669	max17042_update_capacity_regs	drivers/power/supply/max17042_battery.c	vfSoc	5	20	\N	\N	\tunsigned int vfSoc;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_read(map, MAX17042_VFSOC, &vfSoc);\n\tregmap_write(map, MAX17042_VFSOC0Enable, VFSOC0_UNLOCK);\n\tmax17042_write_verify_reg(map, MAX17042_VFSOC0, vfSoc);\n	f
54664	991	conn_connect	drivers/block/drbd/drbd_receiver.c	fp	1	11	\N	\N	\tstruct drbd_socket sock, msock;\n\tstruct drbd_peer_device *peer_device;\n\tstruct net_conf *nc;\n\tint vnr, timeout, h;\n\tbool discard_my_data, ok;\n\tenum drbd_state_rv rv;\n\tstruct accept_wait_data ad = {\n\t\t.connection = connection,\n\t\t.door_bell = COMPLETION_INITIALIZER_ONSTACK(ad.door_bell),\n\t};\n\n\tclear_bit(DISCONNECT_SENT, &connection->flags);\n\tif (conn_request_state(connection, NS(conn, C_WF_CONNECTION), CS_VERBOSE) < SS_SUCCESS)\n\t\treturn -2;\n\n\tmutex_init(&sock.mutex);\n\tsock.sbuf = connection->data.sbuf;\n\tsock.rbuf = connection->data.rbuf;\n\tsock.socket = NULL;\n\tmutex_init(&msock.mutex);\n\tmsock.sbuf = connection->meta.sbuf;\n\tmsock.rbuf = connection->meta.rbuf;\n\tmsock.socket = NULL;\n\n\t/* Assume that the peer only understands protocol 80 until we know better.  */\n\tconnection->agreed_pro_version = 80;\n\n\tif (prepare_listen_socket(connection, &ad))\n\t\treturn 0;\n\n\tdo {\n\t\tstruct socket *s;\n\n\t\ts = drbd_try_connect(connection);\n\t\tif (s) {\n\t\t\tif (!sock.socket) {\n\t\t\t\tsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &sock, P_INITIAL_DATA);\n\t\t\t} else if (!msock.socket) {\n\t\t\t\tclear_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\t\tmsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &msock, P_INITIAL_META);\n\t\t\t} else {\n\t\t\t\tdrbd_err(connection, "Logic error in conn_connect()\\n");\n\t\t\t\tgoto out_release_sockets;\n\t\t\t}\n\t\t}\n\n\t\tif (connection_established(connection, &sock.socket, &msock.socket))\n\t\t\tbreak;\n\nretry:\n\t\ts = drbd_wait_for_connect(connection, &ad);\n\t\tif (s) {\n\t\t\tint fp = receive_first_packet(connection, s);\n\t\t\tdrbd_socket_okay(&sock.socket);\n\t\t\tdrbd_socket_okay(&msock.socket);\n\t\t\tswitch (fp) {\n	t
35033	3231	brcmf_sdio_verifymemory	drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c	err	1	13	\N	\N	\tchar *ram_cmp;\n\tint err;\n\tbool ret = true;\n\tint address;\n\tint offset;\n\tint len;\n\n\t/* read back and verify */\n\tbrcmf_dbg(INFO, "Compare RAM dl & ul at 0x%08x; size=%d\\n", ram_addr,\n\t\t  ram_sz);\n\tram_cmp = kmalloc(MEMBLOCK, GFP_KERNEL);\n\t/* do not proceed while no memory but  */\n\tif (!ram_cmp)\n\t\treturn true;\n\n\taddress = ram_addr;\n\toffset = 0;\n\twhile (offset < ram_sz) {\n\t\tlen = ((offset + MEMBLOCK) < ram_sz) ? MEMBLOCK :\n\t\t      ram_sz - offset;\n\t\terr = brcmf_sdiod_ramrw(sdiodev, false, address, ram_cmp, len);\n\t\tif (err) {\n	f
21505	500	fd_execute_unmap	drivers/target/target_core_file.c	ret	1	11	\N	\N	\tstruct file *file = FD_DEV(cmd->se_dev)->fd_file;\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tif (cmd->se_dev->dev_attrib.pi_prot_type) {\n\t\tret = fd_do_prot_unmap(cmd, lba, nolb);\n\t\tif (ret)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\t/* The backend is block device, use discard */\n\t\tstruct block_device *bdev = inode->i_bdev;\n\t\tstruct se_device *dev = cmd->se_dev;\n\n\t\tret = blkdev_issue_discard(bdev,\n\t\t\t\t\t   target_to_linux_sector(dev, lba),\n\t\t\t\t\t   target_to_linux_sector(dev,  nolb),\n\t\t\t\t\t   GFP_KERNEL, 0);\n\t\tif (ret < 0) {\n	t
36808	1645	jme_request_irq	drivers/net/ethernet/jme.c	jme_request_irq_	1	11	\N	\N	\tint rc;\n\tstruct net_device *netdev = jme->dev;\n\tirq_handler_t handler = jme_intr;\n\tint irq_flags = IRQF_SHARED;\n\n\tif (!pci_enable_msi(jme->pdev)) {\n	t
2586	206	bmg160_get_filter	drivers/iio/gyro/bmg160_core.c	bw_bits	1	11	\N	\N	\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint i;\n\tunsigned int bw_bits;\n\n\tret = regmap_read(data->regmap, BMG160_REG_PMU_BW, &bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, "Error reading reg_pmu_bw\\n");\n\t\treturn ret;\n\t}\n\n\t/* Ignore the readonly reserved bit. */\n\tbw_bits &= ~BMG160_REG_PMU_BW_RES;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].bw_bits == bw_bits)\n	t
5171	3025	ilk_validate_pipe_wm	drivers/gpu/drm/i915/intel_pm.c	&max	1	11	\N	\N	\t/* LP0 watermark maximums depend on this pipe alone */\n\tconst struct intel_wm_config config = {\n\t\t.num_pipes_active = 1,\n\t\t.sprites_enabled = pipe_wm->sprites_enabled,\n\t\t.sprites_scaled = pipe_wm->sprites_scaled,\n\t};\n\tstruct ilk_wm_maximums max;\n\n\t/* LP0 watermarks always use 1/2 DDB partitioning */\n\tilk_compute_wm_maximums(dev, 0, &config, INTEL_DDB_PART_1_2, &max);\n\n\t/* At least LP0 must be valid */\n\tif (!ilk_validate_wm_level(0, &max, &pipe_wm->wm[0])) {\n	t
43832	556	qed_rdma_start_fw	drivers/net/ethernet/qlogic/qed/qed_rdma.c	p_params_header	6	12	\N	\N	\tstruct rdma_init_func_ramrod_data *p_ramrod;\n\tstruct qed_rdma_cnq_params *p_cnq_pbl_list;\n\tstruct rdma_init_func_hdr *p_params_header;\n\tstruct rdma_cnq_params *p_cnq_params;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tu32 cnq_id, sb_id;\n\tu16 igu_sb_id;\n\tint rc;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "Starting FW\\n");\n\n\t/* Save the number of cnqs for the function close ramrod */\n\tp_hwfn->p_rdma_info->num_cnqs = params->desired_cnq;\n\n\t/* Get SPQ entry */\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent, RDMA_RAMROD_FUNC_INIT,\n\t\t\t\t p_hwfn->p_rdma_info->proto, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tif (QED_IS_IWARP_PERSONALITY(p_hwfn))\n\t\tp_ramrod = &p_ent->ramrod.iwarp_init_func.rdma;\n\telse\n\t\tp_ramrod = &p_ent->ramrod.roce_init_func.rdma;\n\n\tp_params_header = &p_ramrod->params_header;\n	t
46821	612	test_ahash_cycles_digest	crypto/tcrypt.c	ret	1	11	\N	\N	\tunsigned long cycles = 0;\n\tint ret, i;\n\n\t/* Warm-up run. */\n\tfor (i = 0; i < 4; i++) {\n\t\tret = do_one_ahash_op(req, crypto_ahash_digest(req));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* The real thing. */\n\tfor (i = 0; i < 8; i++) {\n\t\tcycles_t start, end;\n\n\t\tstart = get_cycles();\n\n\t\tret = do_one_ahash_op(req, crypto_ahash_digest(req));\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tend = get_cycles();\n\n\t\tcycles += end - start;\n\t}\n\nout:\n\tif (ret)\n	t
49397	2667	ath6kl_wmi_delete_pstream_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class > 3) {\n\t\tath6kl_err("invalid traffic class: %d\\n", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n\tcmd->tsid = tsid;\n\n\tspin_lock_bh(&wmi->lock);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(active_tsids & (1 << tsid))) {\n\t\tdev_kfree_skb(skb);\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   "TSID %d doesn't exist for traffic class: %d\\n",\n\t\t\t   tsid, traffic_class);\n\t\treturn -ENODATA;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "sending delete_pstream_cmd: traffic class: %d tsid=%d\\n",\n\t\t   traffic_class, tsid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_PSTREAM_CMDID,\n	t
41710	629	hash_ipport4_resize	net/netfilter/ipset/ip_set_hash_ipport.c	hash_ipport4_resize_$m$obj$4$obj	0	11	\N	\N	\N	t
50394	603	afs_vnode_link	fs/afs/vnode.c	ret	1	11	\N	\N	\tstruct afs_server *server;\n\tint ret;\n\n\t_enter("%s{%x:%u.%u},%s{%x:%u.%u},%x,%s",\n\t       dvnode->volume->vlocation->vldb.name,\n\t       dvnode->fid.vid,\n\t       dvnode->fid.vnode,\n\t       dvnode->fid.unique,\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt++;\n\tspin_unlock(&dvnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug("USING SERVER: %08x\\n", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_link(server, key, dvnode, vnode, name,\n\t\t\t\t  false);\n\n\t} while (!afs_volume_release_fileserver(dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n	t
9575	7160	get_vmx_mem_address	arch/x86/kvm/vmx.c	get_vmx_mem_address_$s$11$obj	0	11	\N	\N	\tgva_t off;\n\tbool exn;\n\tstruct kvm_segment s;\n\n\t/*\n\t * According to Vol. 3B, "Information for VM Exits Due to Instruction\n\t * Execution", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, "Basic VM-Exit Information").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, "Operand Addressing".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\toff = exit_qualification; /* holds the displacement */\n\tif (base_is_valid)\n\t\toff += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\toff += kvm_register_read(vcpu, index_reg)<<scaling;\n\tvmx_get_segment(vcpu, &s, seg_reg);\n\t*ret = s.base + off;\n\n\tif (addr_size == 1) /* 32 bit */\n\t\t*ret &= 0xffffffff;\n\n\t/* Checks for #GP/#SS exceptions. */\n\texn = false;\n\tif (is_long_mode(vcpu)) {\n\t\t/* Long mode: #GP(0)/#SS(0) if the memory address is in a\n\t\t * non-canonical form. This is the only check on the memory\n\t\t * destination for long mode!\n\t\t */\n\t\texn = is_noncanonical_address(*ret, vcpu);\n\t} else if (is_protmode(vcpu)) {\n\t\t/* Protected mode: apply checks for segment validity in the\n\t\t * following order:\n\t\t * - segment type check (#GP(0) may be thrown)\n\t\t * - usability check (#GP(0)/#SS(0))\n\t\t * - limit check (#GP(0)/#SS(0))\n\t\t */\n\t\tif (wr)\n\t\t\t/* #GP(0) if the destination operand is located in a\n\t\t\t * read-only data segment or any code segment.\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 0 || (s.type & 8));\n\t\telse\n\t\t\t/* #GP(0) if the source operand is located in an\n\t\t\t * execute-only code segment\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 8);\n\t\tif (exn) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.\n\t\t */\n\t\texn = (s.unusable != 0);\n	t
32278	1381	dce_v8_0_audio_write_sad_regs	drivers/gpu/drm/amd/amdgpu/dce_v8_0.c	sad->freq	1	11	\N	\N	\tstruct amdgpu_device *adev = encoder->dev->dev_private;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\tu32 offset;\n\tstruct drm_connector *connector;\n\tstruct amdgpu_connector *amdgpu_connector = NULL;\n\tstruct cea_sad *sads;\n\tint i, sad_count;\n\n\tstatic const u16 eld_reg_to_type[][2] = {\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\n\t};\n\n\tif (!dig || !dig->afmt || !dig->afmt->pin)\n\t\treturn;\n\n\toffset = dig->afmt->pin->offset;\n\n\tlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\n\t\tif (connector->encoder == encoder) {\n\t\t\tamdgpu_connector = to_amdgpu_connector(connector);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!amdgpu_connector) {\n\t\tDRM_ERROR("Couldn't find encoder's connector\\n");\n\t\treturn;\n\t}\n\n\tsad_count = drm_edid_to_sad(amdgpu_connector_edid(connector), &sads);\n\tif (sad_count <= 0) {\n\t\tDRM_ERROR("Couldn't read SADs: %d\\n", sad_count);\n\t\treturn;\n\t}\n\tBUG_ON(!sads);\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\n\t\tu32 value = 0;\n\t\tu8 stereo_freqs = 0;\n\t\tint max_channels = -1;\n\t\tint j;\n\n\t\tfor (j = 0; j < sad_count; j++) {\n\t\t\tstruct cea_sad *sad = &sads[j];\n\n\t\t\tif (sad->format == eld_reg_to_type[i][1]) {\n\t\t\t\tif (sad->channels > max_channels) {\n\t\t\t\t\tvalue = (sad->channels <<\n\t\t\t\t\t\t AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0__MAX_CHANNELS__SHIFT) |\n\t\t\t\t\t        (sad->byte2 <<\n\t\t\t\t\t\t AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0__DESCRIPTOR_BYTE_2__SHIFT) |\n\t\t\t\t\t        (sad->freq <<\n	t
9067	2361	tg3_eee_pull_config	drivers/net/ethernet/broadcom/tg3.c	val	1	11	\N	\N	\tu32 val;\n\tstruct ethtool_eee *dest = &tp->eee;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\n\t\treturn;\n\n\tif (eee)\n\t\tdest = eee;\n\n\tif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, TG3_CL45_D7_EEERES_STAT, &val))\n\t\treturn;\n\n\t/* Pull eee_active */\n\tif (val == TG3_CL45_D7_EEERES_STAT_LP_1000T ||\n	t
22161	556	xfs_inobt_count_blocks	fs/xfs/libxfs/xfs_ialloc_btree.c	cur	1	11	\N	\N	\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\tif (error)\n\t\treturn error;\n\n\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno, btnum);\n\terror = xfs_btree_count_blocks(cur, tree_blocks);\n	t
26745	196	hmc5843_read_measurement	drivers/iio/magnetometer/hmc5843_core.c	ret	1	11	\N	\N	\t__be16 values[3];\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = hmc5843_wait_measurement(data);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\tret = regmap_bulk_read(data->regmap, HMC5843_DATA_OUT_MSB_REGS,\n\t\t\t       values, sizeof(values));\n\tmutex_unlock(&data->lock);\n\tif (ret < 0)\n	t
26747	666	ak8975_start_read_axis	drivers/iio/magnetometer/ak8975.c	ret	1	11	\N	\N	\t/* Set up the device for taking a sample. */\n\tint ret = ak8975_set_mode(data, MODE_ONCE);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, "Error in setting operating mode\\n");\n\t\treturn ret;\n\t}\n\n\t/* Wait for the conversion to complete. */\n\tif (data->eoc_irq)\n\t\tret = wait_conversion_complete_interrupt(data);\n\telse if (gpio_is_valid(data->eoc_gpio))\n\t\tret = wait_conversion_complete_gpio(data);\n\telse\n\t\tret = wait_conversion_complete_polled(data);\n\tif (ret < 0)\n	t
20094	582	sess_alloc_buffer	fs/cifs/sess.c	sess_alloc_buffer_$smb_buf$obj$0	0	-11	\N	\N	\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n	t
41960	3860	hci_sched_acl_blk	net/bluetooth/hci_core.c	hci_sched_acl_blk_	1	11	\N	\N	\tunsigned int cnt = hdev->block_cnt;\n\tstruct hci_chan *chan;\n\tstruct sk_buff *skb;\n\tint quote;\n\tu8 type;\n\n\t__check_timeout(hdev, cnt);\n\n\tBT_DBG("%s", hdev->name);\n\n\tif (hdev->dev_type == HCI_AMP)\n\t\ttype = AMP_LINK;\n\telse\n\t\ttype = ACL_LINK;\n\n\twhile (hdev->block_cnt > 0 &&\n\t       (chan = hci_chan_sent(hdev, type, &quote))) {\n\t\tu32 priority = (skb_peek(&chan->data_q))->priority;\n	t
46569	1635	lpfc_max_vpi_show	drivers/scsi/lpfc/lpfc_attr.c	cnt	1	11	\N	\N	\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, NULL))\n\t\treturn snprintf(buf, PAGE_SIZE, "%d\\n", cnt);\n	t
31103	2181	bitmap_resize	drivers/md/bitmap.c	&bitmap->counts	1	11	\N	\N	\t/* If chunk_size is 0, choose an appropriate chunk size.\n\t * Then possibly allocate new storage space.\n\t * Then quiesce, copy bits, replace bitmap, and re-start\n\t *\n\t * This function is called both to set up the initial bitmap\n\t * and to resize the bitmap while the array is active.\n\t * If this happens as a result of the array being resized,\n\t * chunksize will be zero, and we need to choose a suitable\n\t * chunksize, otherwise we use what we are given.\n\t */\n\tstruct bitmap_storage store;\n\tstruct bitmap_counts old_counts;\n\tunsigned long chunks;\n\tsector_t block;\n\tsector_t old_blocks, new_blocks;\n\tint chunkshift;\n\tint ret = 0;\n\tlong pages;\n\tstruct bitmap_page *new_bp;\n\n\tif (bitmap->storage.file && !init) {\n\t\tpr_info("md: cannot resize file-based bitmap\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chunksize == 0) {\n\t\t/* If there is enough space, leave the chunk size unchanged,\n\t\t * else increase by factor of two until there is enough space.\n\t\t */\n\t\tlong bytes;\n\t\tlong space = bitmap->mddev->bitmap_info.space;\n\n\t\tif (space == 0) {\n\t\t\t/* We don't know how much space there is, so limit\n\t\t\t * to current size - in sectors.\n\t\t\t */\n\t\t\tbytes = DIV_ROUND_UP(bitmap->counts.chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t\tspace = DIV_ROUND_UP(bytes, 512);\n\t\t\tbitmap->mddev->bitmap_info.space = space;\n\t\t}\n\t\tchunkshift = bitmap->counts.chunkshift;\n\t\tchunkshift--;\n\t\tdo {\n\t\t\t/* 'chunkshift' is shift from block size to chunk size */\n\t\t\tchunkshift++;\n\t\t\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\t\t\tbytes = DIV_ROUND_UP(chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t} while (bytes > (space << 9));\n\t} else\n\t\tchunkshift = ffz(~chunksize) - BITMAP_BLOCK_SHIFT;\n\n\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\tmemset(&store, 0, sizeof(store));\n\tif (bitmap->mddev->bitmap_info.offset || bitmap->mddev->bitmap_info.file)\n\t\tret = bitmap_storage_alloc(&store, chunks,\n\t\t\t\t\t   !bitmap->mddev->bitmap_info.external,\n\t\t\t\t\t   mddev_is_clustered(bitmap->mddev)\n\t\t\t\t\t   ? bitmap->cluster_slot : 0);\n\tif (ret) {\n\t\tbitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tpages = DIV_ROUND_UP(chunks, PAGE_COUNTER_RATIO);\n\n\tnew_bp = kzalloc(pages * sizeof(*new_bp), GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!new_bp) {\n\t\tbitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tif (!init)\n\t\tbitmap->mddev->pers->quiesce(bitmap->mddev, 1);\n\n\tstore.file = bitmap->storage.file;\n\tbitmap->storage.file = NULL;\n\n\tif (store.sb_page && bitmap->storage.sb_page)\n\t\tmemcpy(page_address(store.sb_page),\n\t\t       page_address(bitmap->storage.sb_page),\n\t\t       PAGE_SIZE);\n\tbitmap_file_unmap(&bitmap->storage);\n\tbitmap->storage = store;\n\n\told_counts = bitmap->counts;\n\tbitmap->counts.bp = new_bp;\n\tbitmap->counts.pages = pages;\n\tbitmap->counts.missing_pages = pages;\n\tbitmap->counts.chunkshift = chunkshift;\n\tbitmap->counts.chunks = chunks;\n\tbitmap->mddev->bitmap_info.chunksize = 1 << (chunkshift +\n\t\t\t\t\t\t     BITMAP_BLOCK_SHIFT);\n\n\tblocks = min(old_counts.chunks << old_counts.chunkshift,\n\t\t     chunks << chunkshift);\n\n\tspin_lock_irq(&bitmap->counts.lock);\n\t/* For cluster raid, need to pre-allocate bitmap */\n\tif (mddev_is_clustered(bitmap->mddev)) {\n\t\tunsigned long page;\n\t\tfor (page = 0; page < pages; page++) {\n\t\t\tret = bitmap_checkpage(&bitmap->counts, page, 1, 1);\n\t\t\tif (ret) {\n\t\t\t\tunsigned long k;\n\n\t\t\t\t/* deallocate the page memory */\n\t\t\t\tfor (k = 0; k < page; k++) {\n\t\t\t\t\tkfree(new_bp[k].map);\n\t\t\t\t}\n\n\t\t\t\t/* restore some fields from old_counts */\n\t\t\t\tbitmap->counts.bp = old_counts.bp;\n\t\t\t\tbitmap->counts.pages = old_counts.pages;\n\t\t\t\tbitmap->counts.missing_pages = old_counts.pages;\n\t\t\t\tbitmap->counts.chunkshift = old_counts.chunkshift;\n\t\t\t\tbitmap->counts.chunks = old_counts.chunks;\n\t\t\t\tbitmap->mddev->bitmap_info.chunksize = 1 << (old_counts.chunkshift +\n\t\t\t\t\t\t\t\t\t     BITMAP_BLOCK_SHIFT);\n\t\t\t\tblocks = old_counts.chunks << old_counts.chunkshift;\n\t\t\t\tpr_warn("Could not pre-allocate in-memory bitmap for cluster raid\\n");\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbitmap->counts.bp[page].count += 1;\n\t\t}\n\t}\n\n\tfor (block = 0; block < blocks; ) {\n\t\tbitmap_counter_t *bmc_old, *bmc_new;\n\t\tint set;\n\n\t\tbmc_old = bitmap_get_counter(&old_counts, block,\n\t\t\t\t\t     &old_blocks, 0);\n\t\tset = bmc_old && NEEDED(*bmc_old);\n\n\t\tif (set) {\n\t\t\tbmc_new = bitmap_get_counter(&bitmap->counts, block,\n	t
-220	416	stm32_counter_read_raw	drivers/iio/trigger/stm32-timer-trigger.c	dat	4	20	\N	\N	\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 dat;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tregmap_read(priv->regmap, TIM_CNT, &dat);\n\t\t*val = dat;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tregmap_read(priv->regmap, TIM_CR1, &dat);\n\t\t*val = (dat & TIM_CR1_CEN) ? 1 : 0;\n	f
44322	4858	kvm_mmu_pte_write	arch/x86/kvm/mmu.c	gentry	1	11	\N	\N	\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tu64 entry, gentry, *spte;\n\tint npte;\n\tbool remote_flush, local_flush;\n\tunion kvm_mmu_page_role mask = { };\n\n\tmask.cr0_wp = 1;\n\tmask.cr4_pae = 1;\n\tmask.nxe = 1;\n\tmask.smep_andnot_wp = 1;\n\tmask.smap_andnot_wp = 1;\n\tmask.smm = 1;\n\tmask.ad_disabled = 1;\n\n\t/*\n\t * If we don't have indirect shadow pages, it means no page is\n\t * write-protected, so we can exit simply.\n\t */\n\tif (!ACCESS_ONCE(vcpu->kvm->arch.indirect_shadow_pages))\n\t\treturn;\n\n\tremote_flush = local_flush = false;\n\n\tpgprintk("%s: gpa %llx bytes %d\\n", __func__, gpa, bytes);\n\n\tgentry = mmu_pte_write_fetch_gpte(vcpu, &gpa, new, &bytes);\n\n\t/*\n\t * No need to care whether allocation memory is successful\n\t * or not since pte prefetch is skiped if it does not have\n\t * enough objects in the cache.\n\t */\n\tmmu_topup_memory_caches(vcpu);\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\t++vcpu->kvm->stat.mmu_pte_write;\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (detect_write_misaligned(sp, gpa, bytes) ||\n\t\t      detect_write_flooding(sp)) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\t++vcpu->kvm->stat.mmu_flooded;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspte = get_written_sptes(sp, gpa, &npte);\n\t\tif (!spte)\n\t\t\tcontinue;\n\n\t\tlocal_flush = true;\n\t\twhile (npte--) {\n\t\t\tentry = *spte;\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, spte);\n\t\t\tif (gentry &&\n	t
47144	1169	stv0367ter_algo	drivers/media/dvb-frontends/stv0367.c	stv0367ter_algo_$icmp$1	0	11	\N	\N	\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tint offset = 0, tempo = 0;\n\tu8 u_var;\n\tu8 /*constell,*/ counter;\n\ts8 step;\n\ts32 timing_offset = 0;\n\tu32 trl_nomrate = 0, InternalFreq = 0, temp = 0, ifkhz = 0;\n\n\tdprintk("%s:\\n", __func__);\n\n\tstv0367_get_if_khz(state, &ifkhz);\n\n\tter_state->frequency = p->frequency;\n\tter_state->force = FE_TER_FORCENONE\n\t\t\t+ stv0367_readbits(state, F367TER_FORCE) * 2;\n\tter_state->if_iq_mode = state->config->if_iq_mode;\n\tswitch (state->config->if_iq_mode) {\n\tcase FE_TER_NORMAL_IF_TUNER:  /* Normal IF mode */\n\t\tdprintk("ALGO: FE_TER_NORMAL_IF_TUNER selected\\n");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 0);\n\t\tstv0367_writebits(state, F367TER_LONGPATH_IF, 0);\n\t\tstv0367_writebits(state, F367TER_DEMUX_SWAP, 0);\n\t\tbreak;\n\tcase FE_TER_LONGPATH_IF_TUNER:  /* Long IF mode */\n\t\tdprintk("ALGO: FE_TER_LONGPATH_IF_TUNER selected\\n");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 0);\n\t\tstv0367_writebits(state, F367TER_LONGPATH_IF, 1);\n\t\tstv0367_writebits(state, F367TER_DEMUX_SWAP, 1);\n\t\tbreak;\n\tcase FE_TER_IQ_TUNER:  /* IQ mode */\n\t\tdprintk("ALGO: FE_TER_IQ_TUNER selected\\n");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 1);\n\t\tstv0367_writebits(state, F367TER_PPM_INVSEL, 0);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR "ALGO: wrong TUNER type selected\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tusleep_range(5000, 7000);\n\n\tswitch (p->inversion) {\n\tcase INVERSION_AUTO:\n\tdefault:\n\t\tdprintk("%s: inversion AUTO\\n", __func__);\n\t\tif (ter_state->if_iq_mode == FE_TER_IQ_TUNER)\n\t\t\tstv0367_writebits(state, F367TER_IQ_INVERT,\n\t\t\t\t\t\tter_state->sense);\n\t\telse\n\t\t\tstv0367_writebits(state, F367TER_INV_SPECTR,\n\t\t\t\t\t\tter_state->sense);\n\n\t\tbreak;\n\tcase INVERSION_ON:\n\tcase INVERSION_OFF:\n\t\tif (ter_state->if_iq_mode == FE_TER_IQ_TUNER)\n\t\t\tstv0367_writebits(state, F367TER_IQ_INVERT,\n\t\t\t\t\t\tp->inversion);\n\t\telse\n\t\t\tstv0367_writebits(state, F367TER_INV_SPECTR,\n\t\t\t\t\t\tp->inversion);\n\n\t\tbreak;\n\t}\n\n\tif ((ter_state->if_iq_mode != FE_TER_NORMAL_IF_TUNER) &&\n\t\t\t\t(ter_state->pBW != ter_state->bw)) {\n\t\tstv0367ter_agc_iir_lock_detect_set(state);\n\n\t\t/*set fine agc target to 180 for LPIF or IQ mode*/\n\t\t/* set Q_AGCTarget */\n\t\tstv0367_writebits(state, F367TER_SEL_IQNTAR, 1);\n\t\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_MSB, 0xB);\n\t\t/*stv0367_writebits(state,AUT_AGC_TARGET_LSB,0x04); */\n\n\t\t/* set Q_AGCTarget */\n\t\tstv0367_writebits(state, F367TER_SEL_IQNTAR, 0);\n\t\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_MSB, 0xB);\n\t\t/*stv0367_writebits(state,AUT_AGC_TARGET_LSB,0x04); */\n\n\t\tif (!stv0367_iir_filt_init(state, ter_state->bw,\n\t\t\t\t\t\tstate->config->xtal))\n\t\t\treturn -EINVAL;\n\t\t/*set IIR filter once for 6,7 or 8MHz BW*/\n\t\tter_state->pBW = ter_state->bw;\n\n\t\tstv0367ter_agc_iir_rst(state);\n\t}\n\n\tif (ter_state->hierarchy == FE_TER_HIER_LOW_PRIO)\n\t\tstv0367_writebits(state, F367TER_BDI_LPSEL, 0x01);\n\telse\n\t\tstv0367_writebits(state, F367TER_BDI_LPSEL, 0x00);\n\n\tInternalFreq = stv0367ter_get_mclk(state, state->config->xtal) / 1000;\n\ttemp = (int)\n\t\t((((ter_state->bw * 64 * (1 << 15) * 100)\n\t\t\t\t\t\t/ (InternalFreq)) * 10) / 7);\n\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LSB, temp % 2);\n\ttemp = temp / 2;\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LO, temp % 256);\n\n\ttemp = stv0367_readbits(state, F367TER_TRL_NOMRATE_HI) * 512 +\n\t\t\tstv0367_readbits(state, F367TER_TRL_NOMRATE_LO) * 2 +\n\t\t\tstv0367_readbits(state, F367TER_TRL_NOMRATE_LSB);\n\ttemp = (int)(((1 << 17) * ter_state->bw * 1000) / (7 * (InternalFreq)));\n\tstv0367_writebits(state, F367TER_GAIN_SRC_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_GAIN_SRC_LO, temp % 256);\n\ttemp = stv0367_readbits(state, F367TER_GAIN_SRC_HI) * 256 +\n\t\t\tstv0367_readbits(state, F367TER_GAIN_SRC_LO);\n\n\ttemp = (int)\n\t\t((InternalFreq - ifkhz) * (1 << 16) / (InternalFreq));\n\n\tdprintk("DEROT temp=0x%x\\n", temp);\n\tstv0367_writebits(state, F367TER_INC_DEROT_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_INC_DEROT_LO, temp % 256);\n\n\tter_state->echo_pos = 0;\n\tter_state->ucblocks = 0; /* liplianin */\n\tter_state->pBER = 0; /* liplianin */\n\tstv0367_writebits(state, F367TER_LONG_ECHO, ter_state->echo_pos);\n\n\tif (stv0367ter_lock_algo(state) != FE_TER_LOCKOK)\n\t\treturn 0;\n\n\tter_state->state = FE_TER_LOCKOK;\n\n\tter_state->mode = stv0367_readbits(state, F367TER_SYR_MODE);\n\tter_state->guard = stv0367_readbits(state, F367TER_SYR_GUARD);\n\n\tter_state->first_lock = 1; /* we know sense now :) */\n\n\tter_state->agc_val =\n\t\t\t(stv0367_readbits(state, F367TER_AGC1_VAL_LO) << 16) +\n\t\t\t(stv0367_readbits(state, F367TER_AGC1_VAL_HI) << 24) +\n\t\t\tstv0367_readbits(state, F367TER_AGC2_VAL_LO) +\n\t\t\t(stv0367_readbits(state, F367TER_AGC2_VAL_HI) << 8);\n\n\t/* Carrier offset calculation */\n\tstv0367_writebits(state, F367TER_FREEZE, 1);\n\toffset = (stv0367_readbits(state, F367TER_CRL_FOFFSET_VHI) << 16) ;\n\toffset += (stv0367_readbits(state, F367TER_CRL_FOFFSET_HI) << 8);\n\toffset += (stv0367_readbits(state, F367TER_CRL_FOFFSET_LO));\n\tstv0367_writebits(state, F367TER_FREEZE, 0);\n\tif (offset > 8388607)\n\t\toffset -= 16777216;\n\n\toffset = offset * 2 / 16384;\n\n\tif (ter_state->mode == FE_TER_MODE_2K)\n\t\toffset = (offset * 4464) / 1000;/*** 1 FFT BIN=4.464khz***/\n\telse if (ter_state->mode == FE_TER_MODE_4K)\n\t\toffset = (offset * 223) / 100;/*** 1 FFT BIN=2.23khz***/\n\telse  if (ter_state->mode == FE_TER_MODE_8K)\n\t\toffset = (offset * 111) / 100;/*** 1 FFT BIN=1.1khz***/\n\n\tif (stv0367_readbits(state, F367TER_PPM_INVSEL) == 1) {\n\t\tif ((stv0367_readbits(state, F367TER_INV_SPECTR) ==\n\t\t\t\t(stv0367_readbits(state,\n\t\t\t\t\tF367TER_STATUS_INV_SPECRUM) == 1)))\n	t
2770	2429	__xfrm_policy_check	net/xfrm/xfrm_policy.c	pols	1	11	\N	\N	\tstruct net *net = dev_net(skb->dev);\n\tstruct xfrm_policy *pol;\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tint npols = 0;\n\tint xfrm_nr;\n\tint pi;\n\tint reverse;\n\tstruct flowi fl;\n\tint xerr_idx = -1;\n\n\treverse = dir & ~XFRM_POLICY_MASK;\n\tdir &= XFRM_POLICY_MASK;\n\n\tif (__xfrm_decode_session(skb, &fl, family, reverse) < 0) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\treturn 0;\n\t}\n\n\tnf_nat_decode_session(skb, &fl, family);\n\n\t/* First, check used SA against their selectors. */\n\tif (skb->sp) {\n\t\tint i;\n\n\t\tfor (i = skb->sp->len-1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = skb->sp->xvec[i];\n\t\t\tif (!xfrm_selector_match(&x->sel, &fl, family)) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpol = NULL;\n\tsk = sk_to_full_sk(sk);\n\tif (sk && sk->sk_policy[dir]) {\n\t\tpol = xfrm_sk_policy_lookup(sk, dir, &fl, family);\n\t\tif (IS_ERR(pol)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!pol)\n\t\tpol = xfrm_policy_lookup(net, &fl, family, dir);\n\n\tif (IS_ERR(pol)) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\treturn 0;\n\t}\n\n\tif (!pol) {\n\t\tif (skb->sp && secpath_has_nontransport(skb->sp, 0, &xerr_idx)) {\n\t\t\txfrm_secpath_reject(xerr_idx, skb, &fl);\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOPOLS);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tpol->curlft.use_time = get_seconds();\n\n\tpols[0] = pol;\n\tnpols++;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n	t
9559	10255	nested_vmx_store_msr	arch/x86/kvm/vmx.c	&e)	6	12	\N	\N	\tu32 i;\n\tstruct vmx_msr_entry e;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t"%s cannot read MSR entry (%u, 0x%08llx)\\n",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n	t
25741	318	ti_adpll_init_gate	drivers/clk/ti/adpll.c	child_name	1	11	\N	\N	\tconst char *child_name;\n\tconst char *parent_name;\n\tstruct clk *clock;\n\n\tchild_name = ti_adpll_clk_get_name(d, output_index, name);\n\tif (!child_name)\n	t
30153	2160	max98090_jack_work	sound/soc/codecs/max98090.c	reg	1	11	\N	\N	\tstruct max98090_priv *max98090 = container_of(work,\n\t\tstruct max98090_priv,\n\t\tjack_work.work);\n\tstruct snd_soc_codec *codec = max98090->codec;\n\tint status = 0;\n\tint reg;\n\n\t/* Read a second time */\n\tif (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {\n\n\t\t/* Strong pull up allows mic detection */\n\t\tsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\n\t\t\tM98090_JDWK_MASK, 0);\n\n\t\tmsleep(50);\n\n\t\treg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\n\n\t\t/* Weak pull up allows only insertion detection */\n\t\tsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\n\t\t\tM98090_JDWK_MASK, M98090_JDWK_MASK);\n\t} else {\n\t\treg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\n\t}\n\n\treg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\n\n\tswitch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {\n	t
35601	257	panel_simple_get_modes	drivers/gpu/drm/panel/panel-simple.c	edid	1	11	\N	\N	\tstruct panel_simple *p = to_panel_simple(panel);\n\tint num = 0;\n\n\t/* probe EDID if a DDC bus is available */\n\tif (p->ddc) {\n\t\tstruct edid *edid = drm_get_edid(panel->connector, p->ddc);\n\t\tdrm_mode_connector_update_edid_property(panel->connector, edid);\n	t
42645	1356	asus_hwmon_temp1	drivers/platform/x86/asus-wmi.c	value	1	11	\N	\N	\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tu32 value;\n\tint err;\n\n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_THERMAL_CTRL, &value);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue = DECI_KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;\n\n\treturn sprintf(buf, "%d\\n", value);\n	t
62802	1350	smc_create	net/smc/af_smc.c	sk	1	11	\N	\N	\tstruct smc_sock *smc;\n\tstruct sock *sk;\n\tint rc;\n\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_STREAM)\n\t\tgoto out;\n\n\trc = -EPROTONOSUPPORT;\n\tif ((protocol != IPPROTO_IP) && (protocol != IPPROTO_TCP))\n\t\tgoto out;\n\n\trc = -ENOBUFS;\n\tsock->ops = &smc_sock_ops;\n\tsk = smc_sock_alloc(net, sock);\n\tif (!sk)\n\t\tgoto out;\n\n\t/* create internal TCP socket for CLC handshake and fallback */\n\tsmc = smc_sk(sk);\n	t
30838	352	line6_read_data	sound/usb/line6/driver.c	ret	0	11	\N	\N	\tstruct usb_device *usbdev = line6->usbdev;\n\tint ret;\n\tunsigned char len;\n\tunsigned count;\n\n\tif (address > 0xffff || datalen > 0xff)\n\t\treturn -EINVAL;\n\n\t/* query the serial number: */\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x67,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t      (datalen << 8) | 0x21, address,\n\t\t\t      NULL, 0, LINE6_TIMEOUT * HZ);\n\n\tif (ret < 0) {\n	f
40183	694	check_lifetime	net/ipv4/devinet.c	check_lifetime_$__mptr192$obj	0	11	\N	\N	\tunsigned long now, next, next_sec, next_sched;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_node *n;\n\tint i;\n\n\tnow = jiffies;\n\tnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++) {\n\t\tbool change_needed = false;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* We try to batch several events at once. */\n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tchange_needed = true;\n\t\t\t} else if (ifa->ifa_preferred_lft ==\n\t\t\t\t   INFINITY_LIFE_TIME) {\n\t\t\t\tcontinue;\n\t\t\t} else if (age >= ifa->ifa_preferred_lft) {\n\t\t\t\tif (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t\tifa->ifa_valid_lft * HZ, next))\n\t\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_valid_lft * HZ;\n\n\t\t\t\tif (!(ifa->ifa_flags & IFA_F_DEPRECATED))\n\t\t\t\t\tchange_needed = true;\n\t\t\t} else if (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_preferred_lft * HZ,\n\t\t\t\t\t       next)) {\n\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t       ifa->ifa_preferred_lft * HZ;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!change_needed)\n\t\t\tcontinue;\n\t\trtnl_lock();\n\t\thlist_for_each_entry_safe(ifa, n, &inet_addr_lst[i], hash) {\n	t
24622	1454	ov5693_s_power	drivers/staging/media/atomisp/i2c/ov5693/ov5693.c	ret	1	13	\N	\N	\tint ret;\n\n\tpr_info("%s: on %d\\n", __func__, on);\n\tif (on == 0)\n\t\treturn power_down(sd);\n\telse {\n\t\tret = power_up(sd);\n\t\tif (!ret) {\n	f
42256	1794	bnx2x_enable_msi	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c	rc	1	11	\N	\N	\tint rc;\n\n\trc = pci_enable_msi(bp->pdev);\n\tif (rc) {\n	t
51280	238	afs_vlocation_update_record	fs/afs/vlocation.c	ret	1	13	\N	\N	\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug("Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug("Vids: %08x %08x %08x",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n	f
52319	205	shtc1_probe	drivers/hwmon/shtc1.c	id_reg	1	13	\N	\N	\tint ret;\n\tchar id_reg[2];\n\tstruct shtc1_data *data;\n\tstruct device *hwmon_dev;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, "plain i2c transactions not supported\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tret = i2c_master_send(client, shtc1_cmd_read_id_reg, SHTC1_CMD_LENGTH);\n\tif (ret != SHTC1_CMD_LENGTH) {\n\t\tdev_err(dev, "could not send read_id_reg command: %d\\n", ret);\n\t\treturn ret < 0 ? ret : -ENODEV;\n\t}\n\tret = i2c_master_recv(client, id_reg, sizeof(id_reg));\n\tif (ret != sizeof(id_reg)) {\n\t\tdev_err(dev, "could not read ID register: %d\\n", ret);\n\t\treturn -ENODEV;\n\t}\n\tif ((id_reg[1] & SHTC1_ID_REG_MASK) != SHTC1_ID) {\n	f
49327	386	amd8111_access	drivers/i2c/busses/i2c-amd8111.c	amd8111_access_$__UNIQUE_ID_min1_262$obj	0	11	\N	\N	\tstruct amd_smbus *smbus = adap->algo_data;\n\tunsigned char protocol, len, pec, temp[2];\n\tint i, status;\n\n\tprotocol = (read_write == I2C_SMBUS_READ) ? AMD_SMB_PRTCL_READ\n\t\t\t\t\t\t  : AMD_SMB_PRTCL_WRITE;\n\tpec = (flags & I2C_CLIENT_PEC) ? AMD_SMB_PRTCL_PEC : 0;\n\n\tswitch (size) {\n\t\tcase I2C_SMBUS_QUICK:\n\t\t\tprotocol |= AMD_SMB_PRTCL_QUICK;\n\t\t\tread_write = I2C_SMBUS_WRITE;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BYTE:\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD,\n\t\t\t\t\t\t      command);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BYTE;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\t      data->byte);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BYTE_DATA;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\t      data->word & 0xff);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\t\t      data->word >> 8);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_WORD_DATA | pec;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t\t    I2C_SMBUS_BLOCK_MAX);\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t  amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t       data->block[i + 1]);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BLOCK_DATA | pec;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t    I2C_SMBUS_BLOCK_MAX);\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t  amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t       data->block[i + 1]);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_I2C_BLOCK_DATA;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t      data->word & 0xff);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\t      data->word >> 8);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tprotocol = AMD_SMB_PRTCL_PROC_CALL | pec;\n\t\t\tread_write = I2C_SMBUS_READ;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t    I2C_SMBUS_BLOCK_MAX - 1);\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t      data->block[i + 1]);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol = AMD_SMB_PRTCL_BLOCK_PROC_CALL | pec;\n\t\t\tread_write = I2C_SMBUS_READ;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(&adap->dev, "Unsupported transaction %d\\n", size);\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatus = amd_ec_write(smbus, AMD_SMB_ADDR, addr << 1);\n\tif (status)\n\t\treturn status;\n\tstatus = amd_ec_write(smbus, AMD_SMB_PRTCL, protocol);\n\tif (status)\n\t\treturn status;\n\n\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\tif (status)\n\t\treturn status;\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tudelay(500);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tmsleep(1);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif ((~temp[0] & AMD_SMB_STS_DONE) || (temp[0] & AMD_SMB_STS_STATUS))\n\t\treturn -EIO;\n\n\tif (read_write == I2C_SMBUS_WRITE)\n\t\treturn 0;\n\n\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA, &data->byte);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA, temp + 0);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA + 1, temp + 1);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tdata->word = (temp[1] << 8) | temp[0];\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tstatus = amd_ec_read(smbus, AMD_SMB_BCNT, &len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tlen = min_t(u8, len, I2C_SMBUS_BLOCK_MAX);\n	t
24016	151	gb_module_register_interface	drivers/staging/greybus/module.c	intf->type	1	11	\N	\N	\tstruct gb_module *module = intf->module;\n\tu8 intf_id = intf->interface_id;\n\tint ret;\n\n\tmutex_lock(&intf->mutex);\n\n\tret = gb_interface_activate(intf);\n\tif (ret) {\n\t\tif (intf->type != GB_INTERFACE_TYPE_DUMMY) {\n	t
52404	6574	btrfs_exclude_logged_extents	fs/btrfs/extent-tree.c	key.objectid	1	11	\N	\N	\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key key;\n\tint found_type;\n\tint i;\n\n\tif (!btrfs_fs_incompat(fs_info, MIXED_GROUPS))\n\t\treturn 0;\n\n\tfor (i = 0; i < btrfs_header_nritems(eb); i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\titem = btrfs_item_ptr(eb, i, struct btrfs_file_extent_item);\n\t\tfound_type = btrfs_file_extent_type(eb, item);\n\t\tif (found_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tcontinue;\n\t\tkey.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tkey.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\t__exclude_logged_extent(fs_info, key.objectid, key.offset);\n	t
-207	313	meson_sar_adc_read_raw_sample	drivers/iio/adc/meson_saradc.c	regval	5	20	\N	\N	\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint regval, fifo_chan, fifo_val, count;\n\n\tif(!wait_for_completion_timeout(&priv->done,\n\t\t\t\tmsecs_to_jiffies(MESON_SAR_ADC_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\tcount = meson_sar_adc_get_fifo_count(indio_dev);\n\tif (count != 1) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t"ADC FIFO has %d element(s) instead of one\\n", count);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(priv->regmap, MESON_SAR_ADC_FIFO_RD, &regval);\n\tfifo_chan = FIELD_GET(MESON_SAR_ADC_FIFO_RD_CHAN_ID_MASK, regval);\n	f
54785	1154	pm8916_wcd_analog_spmi_probe	sound/soc/codecs/msm8916-wcd-analog.c	priv	1	11	\N	\N	\tstruct pm8916_wcd_analog_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i, irq;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = pm8916_wcd_analog_parse_dt(dev, priv);\n	t
37308	173	njs_pci_probe	drivers/isdn/hisax/nj_s.c	cfg	1	11	\N	\N	\tu32 cfg;\n\n\tif (pci_enable_device(dev_netjet))\n\t\treturn (0);\n\tpci_set_master(dev_netjet);\n\tcs->irq = dev_netjet->irq;\n\tif (!cs->irq) {\n\t\tprintk(KERN_WARNING "NETjet-S: No IRQ for PCI card found\\n");\n\t\treturn (0);\n\t}\n\tcs->hw.njet.base = pci_resource_start(dev_netjet, 0);\n\tif (!cs->hw.njet.base) {\n\t\tprintk(KERN_WARNING "NETjet-S: No IO-Adr for PCI card found\\n");\n\t\treturn (0);\n\t}\n\t/* the TJ300 and TJ320 must be detected, the IRQ handling is different\n\t * unfortunately the chips use the same device ID, but the TJ320 has\n\t * the bit20 in status PCI cfg register set\n\t */\n\tpci_read_config_dword(dev_netjet, 0x04, &cfg);\n\tif (cfg & 0x00100000)\n	t
47998	1498	scrub_handle_errored_block	fs/btrfs/scrub.c	full_stripe_locked	1	13	\N	\N	\tstruct scrub_ctx *sctx = sblock_to_check->sctx;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 length;\n\tu64 logical;\n\tunsigned int failed_mirror_index;\n\tunsigned int is_metadata;\n\tunsigned int have_csum;\n\tstruct scrub_block *sblocks_for_recheck; /* holds one for each mirror */\n\tstruct scrub_block *sblock_bad;\n\tint ret;\n\tint mirror_index;\n\tint page_num;\n\tint success;\n\tbool full_stripe_locked;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tBUG_ON(sblock_to_check->page_count < 1);\n\tfs_info = sctx->fs_info;\n\tif (sblock_to_check->pagev[0]->flags & BTRFS_EXTENT_FLAG_SUPER) {\n\t\t/*\n\t\t * if we find an error in a super block, we just report it.\n\t\t * They will get written with the next transaction commit\n\t\t * anyway\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\t++sctx->stat.super_errors;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn 0;\n\t}\n\tlength = sblock_to_check->page_count * PAGE_SIZE;\n\tlogical = sblock_to_check->pagev[0]->logical;\n\tBUG_ON(sblock_to_check->pagev[0]->mirror_num < 1);\n\tfailed_mirror_index = sblock_to_check->pagev[0]->mirror_num - 1;\n\tis_metadata = !(sblock_to_check->pagev[0]->flags &\n\t\t\tBTRFS_EXTENT_FLAG_DATA);\n\thave_csum = sblock_to_check->pagev[0]->have_csum;\n\tdev = sblock_to_check->pagev[0]->dev;\n\n\t/*\n\t * For RAID5/6, race can happen for a different device scrub thread.\n\t * For data corruption, Parity and Data threads will both try\n\t * to recovery the data.\n\t * Race can lead to doubly added csum error, or even unrecoverable\n\t * error.\n\t */\n\tret = lock_full_stripe(fs_info, logical, &full_stripe_locked);\n\tif (ret < 0) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tif (ret == -ENOMEM)\n\t\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\treturn ret;\n\t}\n\n\tif (sctx->is_dev_replace && !is_metadata && !have_csum) {\n\t\tsblocks_for_recheck = NULL;\n\t\tgoto nodatasum_case;\n\t}\n\n\t/*\n\t * read all mirrors one after the other. This includes to\n\t * re-read the extent or metadata block that failed (that was\n\t * the cause that this fixup code is called) another time,\n\t * page by page this time in order to know which pages\n\t * caused I/O errors and which ones are good (for all mirrors).\n\t * It is the goal to handle the situation when more than one\n\t * mirror contains I/O errors, but the errors do not\n\t * overlap, i.e. the data can be repaired by selecting the\n\t * pages from those mirrors without I/O error on the\n\t * particular pages. One example (with blocks >= 2 * PAGE_SIZE)\n\t * would be that mirror #1 has an I/O error on the first page,\n\t * the second page is good, and mirror #2 has an I/O error on\n\t * the second page, but the first page is good.\n\t * Then the first page of the first mirror can be repaired by\n\t * taking the first page of the second mirror, and the\n\t * second page of the second mirror can be repaired by\n\t * copying the contents of the 2nd page of the 1st mirror.\n\t * One more note: if the pages of one mirror contain I/O\n\t * errors, the checksum cannot be verified. In order to get\n\t * the best data for repairing, the first attempt is to find\n\t * a mirror without I/O errors and with a validated checksum.\n\t * Only if this is not possible, the pages are picked from\n\t * mirrors with I/O errors without considering the checksum.\n\t * If the latter is the case, at the end, the checksum of the\n\t * repaired area is verified in order to correctly maintain\n\t * the statistics.\n\t */\n\n\tsblocks_for_recheck = kcalloc(BTRFS_MAX_MIRRORS,\n\t\t\t\t      sizeof(*sblocks_for_recheck), GFP_NOFS);\n\tif (!sblocks_for_recheck) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.malloc_errors++;\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\n\t/* setup the context, map the logical blocks and alloc the pages */\n\tret = scrub_setup_recheck_block(sblock_to_check, sblocks_for_recheck);\n\tif (ret) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t\tgoto out;\n\t}\n\tBUG_ON(failed_mirror_index >= BTRFS_MAX_MIRRORS);\n\tsblock_bad = sblocks_for_recheck + failed_mirror_index;\n\n\t/* build and submit the bios for the failed mirror, check checksums */\n\tscrub_recheck_block(fs_info, sblock_bad, 1);\n\n\tif (!sblock_bad->header_error && !sblock_bad->checksum_error &&\n\t    sblock_bad->no_io_error_seen) {\n\t\t/*\n\t\t * the error disappeared after reading page by page, or\n\t\t * the area was part of a huge bio and other parts of the\n\t\t * bio caused I/O errors, or the block layer merged several\n\t\t * read requests into one and the error is caused by a\n\t\t * different bio (usually one of the two latter cases is\n\t\t * the cause)\n\t\t */\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.unverified_errors++;\n\t\tsblock_to_check->data_corrected = 1;\n\t\tspin_unlock(&sctx->stat_lock);\n\n\t\tif (sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock_bad);\n\t\tgoto out;\n\t}\n\n\tif (!sblock_bad->no_io_error_seen) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.read_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning("i/o error", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\t} else if (sblock_bad->checksum_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.csum_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning("checksum error", sblock_to_check);\n\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\t\t     BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t} else if (sblock_bad->header_error) {\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.verify_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tif (__ratelimit(&_rs))\n\t\t\tscrub_print_warning("checksum/header error",\n\t\t\t\t\t    sblock_to_check);\n\t\tif (sblock_bad->generation_error)\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_GENERATION_ERRS);\n\t\telse\n\t\t\tbtrfs_dev_stat_inc_and_print(dev,\n\t\t\t\tBTRFS_DEV_STAT_CORRUPTION_ERRS);\n\t}\n\n\tif (sctx->readonly) {\n\t\tASSERT(!sctx->is_dev_replace);\n\t\tgoto out;\n\t}\n\n\tif (!is_metadata && !have_csum) {\n\t\tstruct scrub_fixup_nodatasum *fixup_nodatasum;\n\n\t\tWARN_ON(sctx->is_dev_replace);\n\nnodatasum_case:\n\n\t\t/*\n\t\t * !is_metadata and !have_csum, this means that the data\n\t\t * might not be COWed, that it might be modified\n\t\t * concurrently. The general strategy to work on the\n\t\t * commit root does not help in the case when COW is not\n\t\t * used.\n\t\t */\n\t\tfixup_nodatasum = kzalloc(sizeof(*fixup_nodatasum), GFP_NOFS);\n\t\tif (!fixup_nodatasum)\n\t\t\tgoto did_not_correct_error;\n\t\tfixup_nodatasum->sctx = sctx;\n\t\tfixup_nodatasum->dev = dev;\n\t\tfixup_nodatasum->logical = logical;\n\t\tfixup_nodatasum->root = fs_info->extent_root;\n\t\tfixup_nodatasum->mirror_num = failed_mirror_index + 1;\n\t\tscrub_pending_trans_workers_inc(sctx);\n\t\tbtrfs_init_work(&fixup_nodatasum->work, btrfs_scrub_helper,\n\t\t\t\tscrub_fixup_nodatasum, NULL, NULL);\n\t\tbtrfs_queue_work(fs_info->scrub_workers,\n\t\t\t\t &fixup_nodatasum->work);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * now build and submit the bios for the other mirrors, check\n\t * checksums.\n\t * First try to pick the mirror which is completely without I/O\n\t * errors and also does not have a checksum error.\n\t * If one is found, and if a checksum is present, the full block\n\t * that is known to contain an error is rewritten. Afterwards\n\t * the block is known to be corrected.\n\t * If a mirror is found which is completely correct, and no\n\t * checksum is present, only those pages are rewritten that had\n\t * an I/O error in the block to be repaired, since it cannot be\n\t * determined, which copy of the other pages is better (and it\n\t * could happen otherwise that a correct page would be\n\t * overwritten by a bad one).\n\t */\n\tfor (mirror_index = 0;\n\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t     mirror_index++) {\n\t\tstruct scrub_block *sblock_other;\n\n\t\tif (mirror_index == failed_mirror_index)\n\t\t\tcontinue;\n\t\tsblock_other = sblocks_for_recheck + mirror_index;\n\n\t\t/* build and submit the bios, check checksums */\n\t\tscrub_recheck_block(fs_info, sblock_other, 0);\n\n\t\tif (!sblock_other->header_error &&\n\t\t    !sblock_other->checksum_error &&\n\t\t    sblock_other->no_io_error_seen) {\n\t\t\tif (sctx->is_dev_replace) {\n\t\t\t\tscrub_write_block_to_dev_replace(sblock_other);\n\t\t\t\tgoto corrected_error;\n\t\t\t} else {\n\t\t\t\tret = scrub_repair_block_from_good_copy(\n\t\t\t\t\t\tsblock_bad, sblock_other);\n\t\t\t\tif (!ret)\n\t\t\t\t\tgoto corrected_error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sblock_bad->no_io_error_seen && !sctx->is_dev_replace)\n\t\tgoto did_not_correct_error;\n\n\t/*\n\t * In case of I/O errors in the area that is supposed to be\n\t * repaired, continue by picking good copies of those pages.\n\t * Select the good pages from mirrors to rewrite bad pages from\n\t * the area to fix. Afterwards verify the checksum of the block\n\t * that is supposed to be repaired. This verification step is\n\t * only done for the purpose of statistic counting and for the\n\t * final scrub report, whether errors remain.\n\t * A perfect algorithm could make use of the checksum and try\n\t * all possible combinations of pages from the different mirrors\n\t * until the checksum verification succeeds. For example, when\n\t * the 2nd page of mirror #1 faces I/O errors, and the 2nd page\n\t * of mirror #2 is readable but the final checksum test fails,\n\t * then the 2nd page of mirror #3 could be tried, whether now\n\t * the final checksum succeeds. But this would be a rare\n\t * exception and is therefore not implemented. At least it is\n\t * avoided that the good copy is overwritten.\n\t * A more useful improvement would be to pick the sectors\n\t * without I/O error based on sector sizes (512 bytes on legacy\n\t * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one\n\t * mirror could be repaired by taking 512 byte of a different\n\t * mirror, even if other 512 byte sectors in the same PAGE_SIZE\n\t * area are unreadable.\n\t */\n\tsuccess = 1;\n\tfor (page_num = 0; page_num < sblock_bad->page_count;\n\t     page_num++) {\n\t\tstruct scrub_page *page_bad = sblock_bad->pagev[page_num];\n\t\tstruct scrub_block *sblock_other = NULL;\n\n\t\t/* skip no-io-error page in scrub */\n\t\tif (!page_bad->io_error && !sctx->is_dev_replace)\n\t\t\tcontinue;\n\n\t\t/* try to find no-io-error page in mirrors */\n\t\tif (page_bad->io_error) {\n\t\t\tfor (mirror_index = 0;\n\t\t\t     mirror_index < BTRFS_MAX_MIRRORS &&\n\t\t\t     sblocks_for_recheck[mirror_index].page_count > 0;\n\t\t\t     mirror_index++) {\n\t\t\t\tif (!sblocks_for_recheck[mirror_index].\n\t\t\t\t    pagev[page_num]->io_error) {\n\t\t\t\t\tsblock_other = sblocks_for_recheck +\n\t\t\t\t\t\t       mirror_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sblock_other)\n\t\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (sctx->is_dev_replace) {\n\t\t\t/*\n\t\t\t * did not find a mirror to fetch the page\n\t\t\t * from. scrub_write_page_to_dev_replace()\n\t\t\t * handles this case (page->io_error), by\n\t\t\t * filling the block with zeros before\n\t\t\t * submitting the write request\n\t\t\t */\n\t\t\tif (!sblock_other)\n\t\t\t\tsblock_other = sblock_bad;\n\n\t\t\tif (scrub_write_page_to_dev_replace(sblock_other,\n\t\t\t\t\t\t\t    page_num) != 0) {\n\t\t\t\tbtrfs_dev_replace_stats_inc(\n\t\t\t\t\t&fs_info->dev_replace.num_write_errors);\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t} else if (sblock_other) {\n\t\t\tret = scrub_repair_page_from_good_copy(sblock_bad,\n\t\t\t\t\t\t\t       sblock_other,\n\t\t\t\t\t\t\t       page_num, 0);\n\t\t\tif (0 == ret)\n\t\t\t\tpage_bad->io_error = 0;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t}\n\t}\n\n\tif (success && !sctx->is_dev_replace) {\n\t\tif (is_metadata || have_csum) {\n\t\t\t/*\n\t\t\t * need to verify the checksum now that all\n\t\t\t * sectors on disk are repaired (the write\n\t\t\t * request for data to be repaired is on its way).\n\t\t\t * Just be lazy and use scrub_recheck_block()\n\t\t\t * which re-reads the data before the checksum\n\t\t\t * is verified, but most likely the data comes out\n\t\t\t * of the page cache.\n\t\t\t */\n\t\t\tscrub_recheck_block(fs_info, sblock_bad, 1);\n\t\t\tif (!sblock_bad->header_error &&\n\t\t\t    !sblock_bad->checksum_error &&\n\t\t\t    sblock_bad->no_io_error_seen)\n\t\t\t\tgoto corrected_error;\n\t\t\telse\n\t\t\t\tgoto did_not_correct_error;\n\t\t} else {\ncorrected_error:\n\t\t\tspin_lock(&sctx->stat_lock);\n\t\t\tsctx->stat.corrected_errors++;\n\t\t\tsblock_to_check->data_corrected = 1;\n\t\t\tspin_unlock(&sctx->stat_lock);\n\t\t\tbtrfs_err_rl_in_rcu(fs_info,\n\t\t\t\t"fixed up error at logical %llu on dev %s",\n\t\t\t\tlogical, rcu_str_deref(dev->name));\n\t\t}\n\t} else {\ndid_not_correct_error:\n\t\tspin_lock(&sctx->stat_lock);\n\t\tsctx->stat.uncorrectable_errors++;\n\t\tspin_unlock(&sctx->stat_lock);\n\t\tbtrfs_err_rl_in_rcu(fs_info,\n\t\t\t"unable to fixup (regular) error at logical %llu on dev %s",\n\t\t\tlogical, rcu_str_deref(dev->name));\n\t}\n\nout:\n\tif (sblocks_for_recheck) {\n\t\tfor (mirror_index = 0; mirror_index < BTRFS_MAX_MIRRORS;\n\t\t     mirror_index++) {\n\t\t\tstruct scrub_block *sblock = sblocks_for_recheck +\n\t\t\t\t\t\t     mirror_index;\n\t\t\tstruct scrub_recover *recover;\n\t\t\tint page_index;\n\n\t\t\tfor (page_index = 0; page_index < sblock->page_count;\n\t\t\t     page_index++) {\n\t\t\t\tsblock->pagev[page_index]->sblock = NULL;\n\t\t\t\trecover = sblock->pagev[page_index]->recover;\n\t\t\t\tif (recover) {\n\t\t\t\t\tscrub_put_recover(fs_info, recover);\n\t\t\t\t\tsblock->pagev[page_index]->recover =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\tscrub_page_put(sblock->pagev[page_index]);\n\t\t\t}\n\t\t}\n\t\tkfree(sblocks_for_recheck);\n\t}\n\n\tret = unlock_full_stripe(fs_info, logical, full_stripe_locked);\n	f
56054	1845	nfs_commit_release_pages	fs/nfs/write.c	cinfo.mds	1	11	\N	\N	\tstruct nfs_page\t*req;\n\tint status = data->task.tk_status;\n\tstruct nfs_commit_info cinfo;\n\tstruct nfs_server *nfss;\n\n\twhile (!list_empty(&data->pages)) {\n\t\treq = nfs_list_entry(data->pages.next);\n\t\tnfs_list_remove_request(req);\n\t\tif (req->wb_page)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\n\t\tdprintk("NFS:       commit (%s/%llu %d@%lld)",\n\t\t\treq->wb_context->dentry->d_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(d_inode(req->wb_context->dentry)),\n\t\t\treq->wb_bytes,\n\t\t\t(long long)req_offset(req));\n\t\tif (status < 0) {\n\t\t\tnfs_context_set_write_error(req->wb_context, status);\n\t\t\tif (req->wb_page)\n\t\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk_cont(", error = %d\\n", status);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* Okay, COMMIT succeeded, apparently. Check the verifier\n\t\t * returned by the server against all stored verfs. */\n\t\tif (!nfs_write_verifier_cmp(&req->wb_verf, &data->verf.verifier)) {\n\t\t\t/* We have a match */\n\t\t\tif (req->wb_page)\n\t\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk_cont(" OK\\n");\n\t\t\tgoto next;\n\t\t}\n\t\t/* We have a mismatch. Write the page again */\n\t\tdprintk_cont(" mismatch\\n");\n\t\tnfs_mark_request_dirty(req);\n\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &req->wb_context->flags);\n\tnext:\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\tnfss = NFS_SERVER(data->inode);\n\tif (atomic_long_read(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(data->inode), BLK_RW_ASYNC);\n\n\tnfs_init_cinfo(&cinfo, data->inode, data->dreq);\n\tnfs_commit_end(cinfo.mds);\n	f
58312	961	dynamic_debug_init_debugfs	lib/dynamic_debug.c	dir	1	11	\N	\N	\tstruct dentry *dir, *file;\n\n\tif (!ddebug_init_success)\n\t\treturn -ENODEV;\n\n\tdir = debugfs_create_dir("dynamic_debug", NULL);\n\tif (!dir)\n	t
59701	81	sm_disk_count_is_more_than_one	drivers/md/persistent-data/dm-space-map-disk.c	count	1	11	\N	\N	\tint r;\n\tuint32_t count;\n\n\tr = sm_disk_get_count(sm, b, &count);\n\tif (r)\n\t\treturn r;\n\n\t*result = count > 1;\n	t
8865	740	memblock_setclr_flag	mm/memblock.c	end_rgn	1	13	\N	\N	\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n	f
44209	2926	diExtendFS	fs/jfs/jfs_imap.c	diExtendFS_$iagp$obj$9	0	13	\N	\N	\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info("diExtendFS: nextiag:%d numinos:%d numfree:%d",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t/*\n\t *\treconstruct imap\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\n\t/* init per AG control information im_agctl[] */\n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t/* number of backed inodes */\n\t\timap->im_agctl[i].numfree = 0;\t/* number of free backed inodes */\n\t}\n\n\t/*\n\t *\tprocess each iag page of the map.\n\t *\n\t * rebuild AG Free Inode List, AG Free Inode Extent List;\n\t */\n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, "unexpected value of iagnum\\n");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* leave free iag in the free iag list */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t/* compute backed inodes */\n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t/* merge AG backed inodes */\n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t/* if any backed free inodes, insert at AG free inode list */\n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n	f
22056	195	acpi_processor_hotadd_init	drivers/acpi/acpi_processor.c	acpi_processor_hotadd_init_$sta$obj$and$1	0	11	\N	\N	\tunsigned long long sta;\n\tacpi_status status;\n\tint ret;\n\n\tif (invalid_phys_cpuid(pr->phys_id))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_integer(pr->handle, "_STA", NULL, &sta);\n\tif (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_PRESENT))\n	t
56059	1305	dspio_clear_response_queue	sound/pci/hda/patch_ca0132.c	status	1	11	\N	\N	\tunsigned int dummy = 0;\n\tint status = -1;\n\n\t/* clear all from the response queue */\n\tdo {\n\t\tstatus = dspio_read(codec, &dummy);\n\t} while (status == 0);\n	f
30203	128	abp060mg_get_measurement	drivers/iio/pressure/abp060mg.c	pressure	1	11	\N	\N	\tstruct i2c_client *client = state->client;\n\t__be16 buf[2];\n\tu16 pressure;\n\tint ret;\n\n\tbuf[0] = 0;\n\tret = i2c_master_send(client, (u8 *)&buf, state->mreq_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep_interruptible(ABP060MG_RESP_TIME_MS);\n\n\tret = i2c_master_recv(client, (u8 *)&buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpressure = be16_to_cpu(buf[0]);\n\tif (pressure & ABP060MG_ERROR_MASK)\n	t
30762	5334	cik_mc_program	drivers/gpu/drm/radeon/cik.c	&save	1	11	\N	\N	\tstruct evergreen_mc_save save;\n\tu32 tmp;\n\tint i, j;\n\n\t/* Initialize HDP */\n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\tWREG32(HDP_REG_COHERENCY_FLUSH_CNTL, 0);\n\n\tevergreen_mc_stop(rdev, &save);\n	t
35230	547	rtw_dev_remove	drivers/staging/rtl8723bs/os_dep/sdio_intf.c	err	1	11	\N	\N	\tstruct dvobj_priv *dvobj = sdio_get_drvdata(func);\n\tstruct adapter *padapter = dvobj->if1;\n\n\tRT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("+rtw_dev_remove\\n"));\n\n\tdvobj->processing_dev_remove = true;\n\n\trtw_unregister_netdevs(dvobj);\n\n\tif (padapter->bSurpriseRemoved == false) {\n\t\tint err;\n\n\t\t/* test surprise remove */\n\t\tsdio_claim_host(func);\n\t\tsdio_readb(func, 0, &err);\n\t\tsdio_release_host(func);\n\t\tif (err == -ENOMEDIUM) {\n	t
39028	350	i915_gem_shrinker_scan	drivers/gpu/drm/i915/i915_gem_shrinker.c	freed	1	11	\N	\N	\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(shrinker, struct drm_i915_private, mm.shrinker);\n\tunsigned long freed;\n\tbool unlock;\n\n\tsc->nr_scanned = 0;\n\n\tif (!shrinker_lock(dev_priv, &unlock))\n\t\treturn SHRINK_STOP;\n\n\tfreed = i915_gem_shrink(dev_priv,\n\t\t\t\tsc->nr_to_scan,\n\t\t\t\t&sc->nr_scanned,\n\t\t\t\tI915_SHRINK_BOUND |\n\t\t\t\tI915_SHRINK_UNBOUND |\n\t\t\t\tI915_SHRINK_PURGEABLE);\n\tif (freed < sc->nr_to_scan)\n	t
-206	286	meson_sar_adc_wait_busy_clear	drivers/iio/adc/meson_saradc.c	regval	4	20	\N	\N	\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint regval, timeout = 10000;\n\n\t/*\n\t * NOTE: we need a small delay before reading the status, otherwise\n\t * the sample engine may not have started internally (which would\n\t * seem to us that sampling is already finished).\n\t */\n\tdo {\n\t\tudelay(1);\n\t\tregmap_read(priv->regmap, MESON_SAR_ADC_REG0, &regval);\n\t} while (FIELD_GET(MESON_SAR_ADC_REG0_BUSY_MASK, regval) && timeout--);\n	f
-202	364	rt274_jack_detect	sound/soc/codecs/rt274.c	buf	4	20	\N	\N	\tunsigned int buf;\n\n\t*hp = false;\n\t*mic = false;\n\n\tif (!rt274->codec)\n\t\treturn -EINVAL;\n\n\tregmap_read(rt274->regmap, RT274_GET_HP_SENSE, &buf);\n\t*hp = buf & 0x80000000;\n	f
56108	783	mxs_dma_probe	drivers/dma/mxs-dma.c	ret	1	-11	\N	\N	\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct platform_device_id *id_entry;\n\tconst struct of_device_id *of_id;\n\tconst struct mxs_dma_type *dma_type;\n\tstruct mxs_dma_engine *mxs_dma;\n\tstruct resource *iores;\n\tint ret, i;\n\n\tmxs_dma = devm_kzalloc(&pdev->dev, sizeof(*mxs_dma), GFP_KERNEL);\n\tif (!mxs_dma)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, "dma-channels", &mxs_dma->nr_channels);\n\tif (ret) {\n	t
44629	2071	xfrm_add_pol_expire	net/xfrm/xfrm_user.c	mark	6	12	\N	\N	\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n	t
52719	3583	reiserfs_flush_old_commits	fs/reiserfs/journal.c	&th	1	11	\N	\N	\ttime_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = get_seconds();\n\t/*\n\t * safety check so we don't flush while we are replaying the log during\n\t * mount\n\t */\n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t/*\n\t * check the current transaction.  If there are no writers, and it is\n\t * too old, finish it, and force the commit blocks to disk\n\t */\n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n	t
60842	215	check_partial_mapping	drivers/gpu/drm/i915/i915_gem.c	check_partial_mapping_$err$obj	0	11	\N	\N	\tstruct address_space *mapping = obj->base.filp->f_mapping;\n\tdrm_dma_handle_t *phys;\n\tstruct sg_table *st;\n\tstruct scatterlist *sg;\n\tchar *vaddr;\n\tint i;\n\n\tif (WARN_ON(i915_gem_object_needs_bit17_swizzle(obj)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Always aligning to the object size, allows a single allocation\n\t * to handle all possible callers, and given typical object sizes,\n\t * the alignment of the buddy allocation will naturally match.\n\t */\n\tphys = drm_pci_alloc(obj->base.dev,\n\t\t\t     obj->base.size,\n\t\t\t     roundup_pow_of_two(obj->base.size));\n\tif (!phys)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvaddr = phys->vaddr;\n\tfor (i = 0; i < obj->base.size / PAGE_SIZE; i++) {\n\t\tstruct page *page;\n\t\tchar *src;\n\n\t\tpage = shmem_read_mapping_page(mapping, i);\n\t\tif (IS_ERR(page)) {\n\t\t\tst = ERR_CAST(page);\n\t\t\tgoto err_phys;\n\t\t}\n\n\t\tsrc = kmap_atomic(page);\n\t\tmemcpy(vaddr, src, PAGE_SIZE);\n\t\tdrm_clflush_virt_range(vaddr, PAGE_SIZE);\n\t\tkunmap_atomic(src);\n\n\t\tput_page(page);\n\t\tvaddr += PAGE_SIZE;\n\t}\n\n\ti915_gem_chipset_flush(to_i915(obj->base.dev));\n\n\tst = kmalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st) {\n\t\tst = ERR_PTR(-ENOMEM);\n\t\tgoto err_phys;\n\t}\n\n\tif (sg_alloc_table(st, 1, GFP_KERNEL)) {\n	t
9191	329	asoc_simple_card_parse_aux_devs	sound/soc/generic/simple-card.c	aux_node	1	11	\N	\N	\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *aux_node;\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tint i, n, len;\n\n\tif (!of_find_property(node, PREFIX "aux-devs", &len))\n\t\treturn 0;\t\t/* Ok to have no aux-devs */\n\n\tn = len / sizeof(__be32);\n\tif (n <= 0)\n\t\treturn -EINVAL;\n\n\tcard->aux_dev = devm_kzalloc(dev,\n\t\t\tn * sizeof(*card->aux_dev), GFP_KERNEL);\n\tif (!card->aux_dev)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++) {\n\t\taux_node = of_parse_phandle(node, PREFIX "aux-devs", i);\n\t\tif (!aux_node)\n	t
20347	308	init_cleancache	mm/cleancache.c	root	1	11	\N	\N	#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *root = debugfs_create_dir("cleancache", NULL);\n\tif (root == NULL)\n	t
24076	1175	snd_via82xx_probe	sound/pci/via82xx_modem.c	card->driver	1	11	\N	\N	\tstruct snd_card *card;\n\tstruct via82xx_modem *chip;\n\tint chip_type = 0, card_type;\n\tunsigned int i;\n\tint err;\n\n\terr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard_type = pci_id->driver_data;\n\tswitch (card_type) {\n\tcase TYPE_CARD_VIA82XX_MODEM:\n\t\tstrcpy(card->driver, "VIA82XX-MODEM");\n	t
29593	1342	fusb302_handle_togdone_snk	drivers/staging/typec/fusb302/fusb302.c	bc_lvl	1	11	\N	\N	\tint ret = 0;\n\tu8 status0;\n\tu8 bc_lvl;\n\tenum typec_cc_polarity cc_polarity;\n\tenum typec_cc_status cc_status_active, cc1, cc2;\n\n\t/* set pull_up, pull_down */\n\tret = fusb302_set_cc_pull(chip, false, true);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, "cannot set cc to pull down, ret=%d", ret);\n\t\treturn ret;\n\t}\n\t/* set polarity */\n\tcc_polarity = (togdone_result == FUSB_REG_STATUS1A_TOGSS_SNK1) ?\n\t\t      TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2;\n\tret = fusb302_set_cc_polarity(chip, cc_polarity);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, "cannot set cc polarity %s, ret=%d",\n\t\t\t    cc_polarity_name[cc_polarity], ret);\n\t\treturn ret;\n\t}\n\t/* fusb302_set_cc_polarity() has set the correct measure block */\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbc_lvl = status0 & FUSB_REG_STATUS0_BC_LVL_MASK;\n\tcc_status_active = fusb302_bc_lvl_to_cc(bc_lvl);\n	t
38248	519	aac_init_adapter	drivers/scsi/aacraid/comminit.c	status	1	11	\N	\N	\tu32 status[5];\n\tstruct Scsi_Host * host = dev->scsi_host_ptr;\n\textern int aac_sync_mode;\n\n\t/*\n\t *\tCheck the preferred comm settings, defaults from template.\n\t */\n\tdev->management_fib_count = 0;\n\tspin_lock_init(&dev->manage_lock);\n\tspin_lock_init(&dev->sync_lock);\n\tspin_lock_init(&dev->iq_lock);\n\tdev->max_fib_size = sizeof(struct hw_fib);\n\tdev->sg_tablesize = host->sg_tablesize = (dev->max_fib_size\n\t\t- sizeof(struct aac_fibhdr)\n\t\t- sizeof(struct aac_write) + sizeof(struct sgentry))\n\t\t\t/ sizeof(struct sgentry);\n\tdev->comm_interface = AAC_COMM_PRODUCER;\n\tdev->raw_io_interface = dev->raw_io_64 = 0;\n\n\n\t/*\n\t * Enable INTX mode, if not done already Enabled\n\t */\n\tif (aac_is_msix_mode(dev)) {\n\t\taac_change_to_intx(dev);\n\t\tdev_info(&dev->pdev->dev, "Changed firmware to INTX mode");\n\t}\n\n\tif ((!aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES,\n\t\t0, 0, 0, 0, 0, 0,\n\t\tstatus+0, status+1, status+2, status+3, status+4)) &&\n\t\t(status[0] == 0x00000001)) {\n	t
45177	63	journal_read_bucket	drivers/md/bcache/journal.c	bio	1	11	\N	\N	\tstruct journal_device *ja = &ca->journal;\n\tstruct bio *bio = &ja->bio;\n\n\tstruct journal_replay *i;\n\tstruct jset *j, *data = ca->set->journal.w[0].data;\n\tstruct closure cl;\n\tunsigned len, left, offset = 0;\n\tint ret = 0;\n\tsector_t bucket = bucket_to_sector(ca->set, ca->sb.d[bucket_index]);\n\n\tclosure_init_stack(&cl);\n\n\tpr_debug("reading %u", bucket_index);\n\n\twhile (offset < ca->sb.bucket_size) {\nreread:\t\tleft = ca->sb.bucket_size - offset;\n\t\tlen = min_t(unsigned, left, PAGE_SECTORS << JSET_BITS);\n\n\t\tbio_reset(bio);\n\t\tbio->bi_iter.bi_sector\t= bucket + offset;\n\t\tbio_set_dev(bio, ca->bdev);\n\t\tbio->bi_iter.bi_size\t= len << 9;\n\n\t\tbio->bi_end_io\t= journal_read_endio;\n\t\tbio->bi_private = &cl;\n\t\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\t\tbch_bio_map(bio, data);\n	t
54133	202	ext4_mpage_readpages	fs/ext4/readpage.c	blocks	1	11	\N	\N	\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tint length;\n\tunsigned relative_block = 0;\n\tstruct ext4_map_blocks map;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tint fully_mapped = 1;\n\t\tunsigned first_hole = blocks_per_page;\n\n\t\tprefetchw(&page->flags);\n\t\tif (pages) {\n\t\t\tpage = list_entry(pages->prev, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping, page->index,\n\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (page_has_buffers(page))\n\t\t\tgoto confused;\n\n\t\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\t\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\t\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\t\tif (last_block > last_block_in_file)\n\t\t\tlast_block = last_block_in_file;\n\t\tpage_block = 0;\n\n\t\t/*\n\t\t * Map blocks using the previous result first.\n\t\t */\n\t\tif ((map.m_flags & EXT4_MAP_MAPPED) &&\n\t\t    block_in_file > map.m_lblk &&\n\t\t    block_in_file < (map.m_lblk + map.m_len)) {\n\t\t\tunsigned map_offset = block_in_file - map.m_lblk;\n\t\t\tunsigned last = map.m_len - map_offset;\n\n\t\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\t\tif (relative_block == last) {\n\t\t\t\t\t/* needed? */\n\t\t\t\t\tmap.m_flags &= ~EXT4_MAP_MAPPED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (page_block == blocks_per_page)\n\t\t\t\t\tbreak;\n\t\t\t\tblocks[page_block] = map.m_pblk + map_offset +\n\t\t\t\t\trelative_block;\n\t\t\t\tpage_block++;\n\t\t\t\tblock_in_file++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Then do more ext4_map_blocks() calls until we are\n\t\t * done with this page.\n\t\t */\n\t\twhile (page_block < blocks_per_page) {\n\t\t\tif (block_in_file < last_block) {\n\t\t\t\tmap.m_lblk = block_in_file;\n\t\t\t\tmap.m_len = last_block - block_in_file;\n\n\t\t\t\tif (ext4_map_blocks(NULL, inode, &map, 0) < 0) {\n\t\t\t\tset_error_page:\n\t\t\t\t\tSetPageError(page);\n\t\t\t\t\tzero_user_segment(page, 0,\n\t\t\t\t\t\t\t  PAGE_SIZE);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto next_page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((map.m_flags & EXT4_MAP_MAPPED) == 0) {\n\t\t\t\tfully_mapped = 0;\n\t\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\t\tfirst_hole = page_block;\n\t\t\t\tpage_block++;\n\t\t\t\tblock_in_file++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (first_hole != blocks_per_page)\n\t\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t\t/* Contiguous blocks? */\n\t\t\tif (page_block && blocks[page_block-1] != map.m_pblk-1)\n	t
7168	52	arcpgu_drm_hdmi_init	drivers/gpu/drm/arc/arcpgu_hdmi.c	encoder	6	12	\N	var name reuse; incorrect func resolve	\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *bridge;\n\n\tint ret = 0;\n\n\tencoder = devm_kzalloc(drm->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (encoder == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Locate drm bridge from the hdmi encoder DT node */\n\tbridge = of_drm_find_bridge(np);\n\tif (!bridge)\n\t\treturn -EPROBE_DEFER;\n\n\tencoder->possible_crtcs = 1;\n\tencoder->possible_clones = 0;\n\tret = drm_encoder_init(drm, encoder, &arcpgu_drm_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_TMDS, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Link drm_bridge to encoder */\n\tret = drm_bridge_attach(encoder, bridge, NULL);\n\tif (ret)\n\t\tdrm_encoder_cleanup(encoder);\n	t
38015	351	iwl_dbgfs_nic_temp_read	drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c	temp	2	-11	\N	\N	\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[16];\n\tint pos, ret;\n\ts32 temp;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_get_temp(mvm, &temp);\n\tmutex_unlock(&mvm->mutex);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\tpos = scnprintf(buf , sizeof(buf), "%d\\n", temp);\n	t
55268	466	rmi_f01_probe	drivers/input/rmi4/rmi_f01.c	rmi_f01_probe_$f01$obj$0$7$obj	0	11	\N	\N	\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *driver_data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct f01_data *f01;\n\tint error;\n\tu16 ctrl_base_addr = fn->fd.control_base_addr;\n\tu8 device_status;\n\tu8 temp;\n\n\tif (fn->dev.of_node) {\n\t\terror = rmi_f01_of_probe(&fn->dev, pdata);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tf01 = devm_kzalloc(&fn->dev, sizeof(struct f01_data), GFP_KERNEL);\n\tif (!f01)\n\t\treturn -ENOMEM;\n\n\tf01->num_of_irq_regs = driver_data->num_of_irq_regs;\n\n\t/*\n\t * Set the configured bit and (optionally) other important stuff\n\t * in the device control register.\n\t */\n\n\terror = rmi_read(rmi_dev, fn->fd.control_base_addr,\n\t\t\t &f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev, "Failed to read F01 control: %d\\n", error);\n\t\treturn error;\n\t}\n\n\tswitch (pdata->power_management.nosleep) {\n\tcase RMI_REG_STATE_DEFAULT:\n\t\tbreak;\n\tcase RMI_REG_STATE_OFF:\n\t\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_NOSLEEP_BIT;\n\t\tbreak;\n\tcase RMI_REG_STATE_ON:\n\t\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_NOSLEEP_BIT;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Sleep mode might be set as a hangover from a system crash or\n\t * reboot without power cycle.  If so, clear it so the sensor\n\t * is certain to function.\n\t */\n\tif ((f01->device_control.ctrl0 & RMI_F01_CTRL0_SLEEP_MODE_MASK) !=\n\t\t\tRMI_SLEEP_MODE_NORMAL) {\n\t\tdev_warn(&fn->dev,\n\t\t\t "WARNING: Non-zero sleep mode found. Clearing...\\n");\n\t\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\n\t}\n\n\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_CONFIGURED_BIT;\n\n\terror = rmi_write(rmi_dev, fn->fd.control_base_addr,\n\t\t\t  f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev, "Failed to write F01 control: %d\\n", error);\n\t\treturn error;\n\t}\n\n\t/* Dummy read in order to clear irqs */\n\terror = rmi_read(rmi_dev, fn->fd.data_base_addr + 1, &temp);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, "Failed to read Interrupt Status.\\n");\n\t\treturn error;\n\t}\n\n\terror = rmi_f01_read_properties(rmi_dev, fn->fd.query_base_addr,\n\t\t\t\t\t&f01->properties);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, "Failed to read F01 properties.\\n");\n\t\treturn error;\n\t}\n\n\tdev_info(&fn->dev, "found RMI device, manufacturer: %s, product: %s, fw id: %d\\n",\n	t
-218	224	stm32_tt_read_frequency	drivers/iio/trigger/stm32-timer-trigger.c	psc	4	20	\N	\N	\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct stm32_timer_trigger *priv = iio_trigger_get_drvdata(trig);\n\tu32 psc, arr, cr1;\n\tunsigned long long freq = 0;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\tif (cr1 & TIM_CR1_CEN) {\n\t\tfreq = (unsigned long long)clk_get_rate(priv->clk);\n\t\tdo_div(freq, psc + 1);\n	f
46656	3708	ip_vs_genl_get_cmd	net/netfilter/ipvs/ip_vs_ctl.c	msg	1	11	\N	\N	\tstruct sk_buff *msg;\n\tvoid *reply;\n\tint ret, cmd, reply_cmd;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tcmd = info->genlhdr->cmd;\n\n\tif (cmd == IPVS_CMD_GET_SERVICE)\n\t\treply_cmd = IPVS_CMD_NEW_SERVICE;\n\telse if (cmd == IPVS_CMD_GET_INFO)\n\t\treply_cmd = IPVS_CMD_SET_INFO;\n\telse if (cmd == IPVS_CMD_GET_CONFIG)\n\t\treply_cmd = IPVS_CMD_SET_CONFIG;\n\telse {\n\t\tpr_err("unknown Generic Netlink command\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\treply = genlmsg_put_reply(msg, info, &ip_vs_genl_family, 0, reply_cmd);\n	t
-201	1759	rt5651_i2c_probe	sound/soc/codecs/rt5651.c	ret	5	20	\N	\N	\tstruct rt5651_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct rt5651_priv *rt5651;\n\tint ret;\n\n\trt5651 = devm_kzalloc(&i2c->dev, sizeof(*rt5651),\n\t\t\t\tGFP_KERNEL);\n\tif (NULL == rt5651)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt5651);\n\n\tif (pdata)\n\t\trt5651->pdata = *pdata;\n\telse if (i2c->dev.of_node)\n\t\trt5651_parse_dt(rt5651, i2c->dev.of_node);\n\n\trt5651->regmap = devm_regmap_init_i2c(i2c, &rt5651_regmap);\n\tif (IS_ERR(rt5651->regmap)) {\n\t\tret = PTR_ERR(rt5651->regmap);\n\t\tdev_err(&i2c->dev, "Failed to allocate register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt5651->regmap, RT5651_DEVICE_ID, &ret);\n\tif (ret != RT5651_DEVICE_ID_VALUE) {\n	f
-214	140	stm32_timer_start	drivers/iio/trigger/stm32-timer-trigger.c	cr1	4	20	\N	\N	\tunsigned long long prd, div;\n\tint prescaler = 0;\n\tu32 ccer, cr1;\n\n\t/* Period and prescaler values depends of clock rate */\n\tdiv = (unsigned long long)clk_get_rate(priv->clk);\n\n\tdo_div(div, frequency);\n\n\tprd = div;\n\n\t/*\n\t * Increase prescaler value until we get a result that fit\n\t * with auto reload register maximum value.\n\t */\n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, (prescaler + 1));\n\t}\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC) {\n\t\tdev_err(priv->dev, "prescaler exceeds the maximum value\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if nobody else use the timer */\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tif (ccer & TIM_CCER_CCXE)\n\t\treturn -EBUSY;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tif (!(cr1 & TIM_CR1_CEN))\n	f
-210	789	meson_sar_adc_irq	drivers/iio/adc/meson_saradc.c	regval	4	20	\N	\N	\tstruct iio_dev *indio_dev = data;\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned int cnt, threshold;\n\tu32 regval;\n\n\tregmap_read(priv->regmap, MESON_SAR_ADC_REG0, &regval);\n\tcnt = FIELD_GET(MESON_SAR_ADC_REG0_FIFO_COUNT_MASK, regval);\n	f
56990	247	getorigdst	net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	getorigdst_$ct$obj$6$0$2$3$1$0	0	11	\N	\N	\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct nf_conntrack_tuple_hash *h;\n\tstruct nf_conntrack_tuple tuple;\n\n\tmemset(&tuple, 0, sizeof(tuple));\n\ttuple.src.u3.ip = inet->inet_rcv_saddr;\n\ttuple.src.u.tcp.port = inet->inet_sport;\n\ttuple.dst.u3.ip = inet->inet_daddr;\n\ttuple.dst.u.tcp.port = inet->inet_dport;\n\ttuple.src.l3num = PF_INET;\n\ttuple.dst.protonum = sk->sk_protocol;\n\n\t/* We only do TCP and SCTP at the moment: is there a better way? */\n\tif (sk->sk_protocol != IPPROTO_TCP && sk->sk_protocol != IPPROTO_SCTP) {\n\t\tpr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\\n");\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif ((unsigned int) *len < sizeof(struct sockaddr_in)) {\n\t\tpr_debug("SO_ORIGINAL_DST: len %d not %zu\\n",\n\t\t\t *len, sizeof(struct sockaddr_in));\n\t\treturn -EINVAL;\n\t}\n\n\th = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);\n\tif (h) {\n\t\tstruct sockaddr_in sin;\n\t\tstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]\n\t\t\t.tuple.dst.u.tcp.port;\n	t
28081	2469	ib_uverbs_post_recv	drivers/infiniband/core/uverbs_cmd.c	ib_uverbs_post_recv_$wr$obj$0	0	11	\N	\N	\tstruct ib_uverbs_post_recv      cmd;\n\tstruct ib_uverbs_post_recv_resp resp;\n\tstruct ib_recv_wr              *wr, *next, *bad_wr;\n\tstruct ib_qp                   *qp;\n\tssize_t                         ret = -EINVAL;\n\n\tif (copy_from_user(&cmd, buf, sizeof cmd))\n\t\treturn -EFAULT;\n\n\twr = ib_uverbs_unmarshall_recv(buf + sizeof cmd,\n\t\t\t\t       in_len - sizeof cmd, cmd.wr_count,\n\t\t\t\t       cmd.sge_count, cmd.wqe_size);\n\tif (IS_ERR(wr))\n\t\treturn PTR_ERR(wr);\n\n\tqp = uobj_get_obj_read(qp, cmd.qp_handle, file->ucontext);\n\tif (!qp)\n\t\tgoto out;\n\n\tresp.bad_wr = 0;\n\tret = qp->device->post_recv(qp->real_qp, wr, &bad_wr);\n\n\tuobj_put_obj_read(qp);\n\tif (ret) {\n\t\tfor (next = wr; next; next = next->next) {\n\t\t\t++resp.bad_wr;\n\t\t\tif (next == bad_wr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (copy_to_user((void __user *) (unsigned long) cmd.response,\n\t\t\t &resp, sizeof resp))\n\t\tret = -EFAULT;\n\nout:\n\twhile (wr) {\n\t\tnext = wr->next;\n	t
9458	1717	smiapp_propagate	drivers/media/i2c/smiapp/smiapp-core.c	crops	1	11	\N	\N	\tstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\n\tstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\n\tstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\n\n\tsmiapp_get_crop_compose(subdev, cfg, crops, &comp, which);\n\n\tswitch (target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tcomp->width = crops[SMIAPP_PAD_SINK]->width;\n	t
9829	246	rx8025_set_time	drivers/rtc/rtc-rx8025.c	date	1	11	\N	\N	\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret;\n\n\tif ((dt->tm_year < 100) || (dt->tm_year > 199))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Here the read-only bits are written as "0".  I'm not sure if that\n\t * is sound.\n\t */\n\tdate[RX8025_REG_SEC] = bin2bcd(dt->tm_sec);\n\tdate[RX8025_REG_MIN] = bin2bcd(dt->tm_min);\n\tif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\n\t\tdate[RX8025_REG_HOUR] = bin2bcd(dt->tm_hour);\n\telse\n\t\tdate[RX8025_REG_HOUR] = (dt->tm_hour >= 12 ? 0x20 : 0)\n\t\t\t| bin2bcd((dt->tm_hour + 11) % 12 + 1);\n\n\tdate[RX8025_REG_WDAY] = bin2bcd(dt->tm_wday);\n\tdate[RX8025_REG_MDAY] = bin2bcd(dt->tm_mday);\n\tdate[RX8025_REG_MONTH] = bin2bcd(dt->tm_mon + 1);\n\tdate[RX8025_REG_YEAR] = bin2bcd(dt->tm_year - 100);\n\n\tdev_dbg(dev,\n	t
28480	2084	leaf_dealloc	fs/gfs2/dir.c	dibh->b_data	1	11	\N	\N	\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,\n\t\t\t       PAGE_KERNEL);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t/*  Count the number of leaves  */\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);\n\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_free_meta(dip, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t/* On the last dealloc, make this a regular file in case we crash.\n\t   (We don't want to free these blocks a second time.)  */\n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n	t
30651	5672	btrfs_find_next_key	fs/btrfs/ctree.c	gen	1	11	\N	\N	\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n	t
36584	278	sja1000_isa_init	drivers/net/can/sja1000/sja1000_isa.c	err	1	11	\N	\N	\tint idx, err;\n\n\tfor (idx = 0; idx < MAXDEV; idx++) {\n\t\tif ((port[idx] || mem[idx]) && irq[idx]) {\n\t\t\tsja1000_isa_devs[idx] =\n\t\t\t\tplatform_device_alloc(DRV_NAME, idx);\n\t\t\tif (!sja1000_isa_devs[idx]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto exit_free_devices;\n\t\t\t}\n\t\t\terr = platform_device_add(sja1000_isa_devs[idx]);\n\t\t\tif (err) {\n	t
-200	1523	iommu_unmap_page	drivers/iommu/amd_iommu.c	unmap_size	4	20	\N	\N	\tunsigned long long unmapped;\n\tunsigned long unmap_size;\n\tu64 *pte;\n\n\tBUG_ON(!is_power_of_2(page_size));\n\n\tunmapped = 0;\n\n\twhile (unmapped < page_size) {\n\n\t\tpte = fetch_pte(dom, bus_addr, &unmap_size);\n\n\t\tif (pte) {\n\t\t\tint i, count;\n\n\t\t\tcount = PAGE_SIZE_PTE_COUNT(unmap_size);\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpte[i] = 0ULL;\n\t\t}\n\n\t\tbus_addr  = (bus_addr & ~(unmap_size - 1)) + unmap_size;\n	f
53862	2061	SYSC_epoll_ctl	fs/eventpoll.c	epds.events	1	11	\N	\N	\tint error;\n\tint full_check = 0;\n\tstruct fd f, tf;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\tstruct eventpoll *tep = NULL;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\terror = -EBADF;\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\tgoto error_return;\n\n\t/* Get the "struct file *" for the target file */\n\ttf = fdget(fd);\n\tif (!tf.file)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tf.file->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/* Check if EPOLLWAKEUP is allowed */\n\tif (ep_op_has_event(op))\n\t\tep_take_care_of_epollwakeup(&epds);\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (f.file == tf.file || !is_file_epoll(f.file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,\n\t * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.\n\t * Also, we do not currently supported nested exclusive wakeups.\n\t */\n\tif (ep_op_has_event(op) && (epds.events & EPOLLEXCLUSIVE)) {\n	t
25163	2380	ib_send_cm_dreq	drivers/infiniband/core/cm.c	ib_send_cm_dreq_$msg$obj$4	0	11	\N	\N	\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tunsigned long flags;\n\tint ret;\n\n\tif (private_data && private_data_len > IB_CM_DREQ_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id->state != IB_CM_ESTABLISHED) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (cm_id->lap_state == IB_CM_LAP_SENT ||\n\t    cm_id->lap_state == IB_CM_MRA_LAP_RCVD)\n\t\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\n\tret = cm_alloc_msg(cm_id_priv, &msg);\n\tif (ret) {\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tgoto out;\n\t}\n\n\tcm_format_dreq((struct cm_dreq_msg *) msg->mad, cm_id_priv,\n\t\t       private_data, private_data_len);\n\tmsg->timeout_ms = cm_id_priv->timeout_ms;\n\tmsg->context[1] = (void *) (unsigned long) IB_CM_DREQ_SENT;\n	t
20192	718	ath6kl_wmi_get_new_buf	drivers/net/wireless/ath/ath6kl/wmi.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\n\tskb = ath6kl_buf_alloc(size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put(skb, size);\n	t
26043	661	ata_cmd_ioctl	drivers/ata/libata-scsi.c	sshdr.asc	1	11	\N	\N	\tint rc = 0;\n\tu8 scsi_cmd[MAX_COMMAND_SIZE];\n\tu8 args[4], *argbuf = NULL, *sensebuf = NULL;\n\tint argsize = 0;\n\tenum dma_data_direction data_dir;\n\tstruct scsi_sense_hdr sshdr;\n\tint cmd_result;\n\n\tif (arg == NULL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(args, arg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\n\tif (!sensebuf)\n\t\treturn -ENOMEM;\n\n\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\n\tif (args[3]) {\n\t\targsize = ATA_SECT_SIZE * args[3];\n\t\targbuf = kmalloc(argsize, GFP_KERNEL);\n\t\tif (argbuf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tscsi_cmd[1]  = (4 << 1); /* PIO Data-in */\n\t\tscsi_cmd[2]  = 0x0e;     /* no off.line or cc, read from dev,\n\t\t\t\t\t    block count in sector count field */\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t} else {\n\t\tscsi_cmd[1]  = (3 << 1); /* Non-data */\n\t\tscsi_cmd[2]  = 0x20;     /* cc but no off.line or data xfer */\n\t\tdata_dir = DMA_NONE;\n\t}\n\n\tscsi_cmd[0] = ATA_16;\n\n\tscsi_cmd[4] = args[2];\n\tif (args[0] == ATA_CMD_SMART) { /* hack -- ide driver does this too */\n\t\tscsi_cmd[6]  = args[3];\n\t\tscsi_cmd[8]  = args[1];\n\t\tscsi_cmd[10] = 0x4f;\n\t\tscsi_cmd[12] = 0xc2;\n\t} else {\n\t\tscsi_cmd[6]  = args[1];\n\t}\n\tscsi_cmd[14] = args[0];\n\n\t/* Good values for timeout and retries?  Values below\n\t   from scsi_ioctl_send_command() for default case... */\n\tcmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,\n\t\t\t\t  sensebuf, &sshdr, (10*HZ), 5, 0, 0, NULL);\n\n\tif (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */\n\t\tu8 *desc = sensebuf + 8;\n\t\tcmd_result &= ~(0xFF<<24); /* DRIVER_SENSE is not an error */\n\n\t\t/* If we set cc then ATA pass-through will cause a\n\t\t * check condition even if no error. Filter that. */\n\t\tif (cmd_result & SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (sshdr.sense_key == RECOVERED_ERROR &&\n	t
40189	166	wcn36xx_debugfs_init	drivers/net/wireless/ath/wcn36xx/debug.c	dump	1	11	\N	\N	\tstruct wcn36xx_dfs_entry *dfs = &wcn->dfs;\n\n\tdfs->rootdir = debugfs_create_dir(KBUILD_MODNAME,\n\t\t\t\t\t  wcn->hw->wiphy->debugfsdir);\n\tif (IS_ERR(dfs->rootdir)) {\n\t\twcn36xx_warn("Create the debugfs failed\\n");\n\t\tdfs->rootdir = NULL;\n\t}\n\n\tADD_FILE(bmps_switcher, S_IRUSR | S_IWUSR,\n\t\t &fops_wcn36xx_bmps, wcn);\n\tADD_FILE(dump, S_IWUSR, &fops_wcn36xx_dump, wcn);\n	t
32372	4265	gfx_v8_0_cp_gfx_start	drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c	ring	2	-11	\N	\N	\tstruct amdgpu_ring *ring = &adev->gfx.gfx_ring[0];\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint r, i;\n\n\t/* init the CP */\n\tWREG32(mmCP_MAX_CONTEXT, adev->gfx.config.max_hw_contexts - 1);\n\tWREG32(mmCP_ENDIAN_SWAP, 0);\n\tWREG32(mmCP_DEVICE_ID, 1);\n\n\tgfx_v8_0_cp_gfx_enable(adev, true);\n\n\tr = amdgpu_ring_alloc(ring, gfx_v8_0_get_csb_size(adev) + 4);\n\tif (r) {\n\t\tDRM_ERROR("amdgpu: cp failed to lock ring (%d).\\n", r);\n\t\treturn r;\n\t}\n\n\t/* clear state buffer */\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, 0x80000000);\n\tamdgpu_ring_write(ring, 0x80000000);\n\n\tfor (sect = vi_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       PACKET3(PACKET3_SET_CONTEXT_REG,\n\t\t\t\t\t       ext->reg_count));\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       ext->reg_index - PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tamdgpu_ring_write(ring, ext->extent[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tamdgpu_ring_write(ring, mmPA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tswitch (adev->asic_type) {\n\tcase CHIP_TONGA:\n\tcase CHIP_POLARIS10:\n\t\tamdgpu_ring_write(ring, 0x16000012);\n\t\tamdgpu_ring_write(ring, 0x0000002A);\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\tamdgpu_ring_write(ring, 0x16000012);\n\t\tamdgpu_ring_write(ring, 0x00000000);\n\t\tbreak;\n\tcase CHIP_FIJI:\n\t\tamdgpu_ring_write(ring, 0x3a00161a);\n\t\tamdgpu_ring_write(ring, 0x0000002e);\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\tamdgpu_ring_write(ring, 0x00000002);\n\t\tamdgpu_ring_write(ring, 0x00000000);\n\t\tbreak;\n\tcase CHIP_TOPAZ:\n\t\tamdgpu_ring_write(ring, adev->gfx.config.num_rbs == 1 ?\n\t\t\t\t0x00000000 : 0x00000002);\n\t\tamdgpu_ring_write(ring, 0x00000000);\n	t
51780	178	qede_ptp_task	drivers/net/ethernet/qlogic/qede/qede_ptp.c	timestamp	1	13	\N	\N	\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\tu64 timestamp, ns;\n\tint rc;\n\n\tptp = container_of(work, struct qede_ptp, work);\n\tedev = ptp->edev;\n\n\t/* Read Tx timestamp registers */\n\tspin_lock_bh(&ptp->lock);\n\trc = ptp->ops->read_tx_ts(edev->cdev, &timestamp);\n\tspin_unlock_bh(&ptp->lock);\n\tif (rc) {\n\t\t/* Reschedule to keep checking for a valid timestamp value */\n\t\tschedule_work(&ptp->work);\n\t\treturn;\n\t}\n\n\tns = timecounter_cyc2time(&ptp->tc, timestamp);\n	f
2743	1003	iov_iter_gap_alignment	lib/iov_iter.c	v	1	11	\N	\N	\tunsigned long res = 0;\n\tsize_t size = i->count;\n\n\tif (unlikely(i->type & ITER_PIPE)) {\n\t\tWARN_ON(1);\n\t\treturn ~0U;\n\t}\n\n\titerate_all_kinds(i, size, v,\n	t
-242	97	stm32_pwm_config	drivers/pwm/pwm-stm32.c	psc	5	20	\N	\N	\tunsigned long long prd, div, dty;\n\tunsigned int prescaler = 0;\n\tu32 ccmr, mask, shift;\n\n\t/* Period and prescaler values depends on clock rate */\n\tdiv = (unsigned long long)clk_get_rate(priv->clk) * period_ns;\n\n\tdo_div(div, NSEC_PER_SEC);\n\tprd = div;\n\n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, prescaler + 1);\n\t}\n\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC)\n\t\treturn -EINVAL;\n\n\t/*\n\t * All channels share the same prescaler and counter so when two\n\t * channels are active at the same time we can't change them\n\t */\n\tif (active_channels(priv) & ~(1 << ch * 4)) {\n\t\tu32 psc, arr;\n\n\t\tregmap_read(priv->regmap, TIM_PSC, &psc);\n	f
56143	932	ceph_direct_read_write	fs/ceph/file.c	req	1	11	\N	\N	\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tstruct ceph_aio_request *aio_req = NULL;\n\tint num_pages = 0;\n\tint flags;\n\tint ret;\n\tstruct timespec mtime = current_time(inode);\n\tsize_t count = iov_iter_count(iter);\n\tloff_t pos = iocb->ki_pos;\n\tbool write = iov_iter_rw(iter) == WRITE;\n\n\tif (write && ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout("sync_direct_%s on file %p %lld~%u snapc %p seq %lld\\n",\n\t     (write ? "write" : "read"), file, pos, (unsigned)count,\n\t     snapc, snapc->seq);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (write) {\n\t\tint ret2 = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT,\n\t\t\t\t\t(pos + count) >> PAGE_SHIFT);\n\t\tif (ret2 < 0)\n\t\t\tdout("invalidate_inode_pages2_range returned %d\\n", ret2);\n\n\t\tflags = /* CEPH_OSD_FLAG_ORDERSNAP | */ CEPH_OSD_FLAG_WRITE;\n\t} else {\n\t\tflags = CEPH_OSD_FLAG_READ;\n\t}\n\n\twhile (iov_iter_count(iter) > 0) {\n\t\tu64 size = dio_get_pagev_size(iter);\n\t\tsize_t start = 0;\n\t\tssize_t len;\n\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &size, 0,\n\t\t\t\t\t    1,\n\t\t\t\t\t    write ? CEPH_OSD_OP_WRITE :\n\t\t\t\t\t\t    CEPH_OSD_OP_READ,\n\t\t\t\t\t    flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tsize = min_t(u64, size, fsc->mount_options->wsize);\n\t\telse\n\t\t\tsize = min_t(u64, size, fsc->mount_options->rsize);\n\n\t\tlen = size;\n\t\tpages = dio_get_pages_alloc(iter, len, &start, &num_pages);\n\t\tif (IS_ERR(pages)) {\n\t\t\tceph_osdc_put_request(req);\n\t\t\tret = PTR_ERR(pages);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * To simplify error handling, allow AIO when IO within i_size\n\t\t * or IO can be satisfied by single OSD request.\n\t\t */\n\t\tif (pos == iocb->ki_pos && !is_sync_kiocb(iocb) &&\n\t\t    (len == count || pos + count <= i_size_read(inode))) {\n\t\t\taio_req = kzalloc(sizeof(*aio_req), GFP_KERNEL);\n\t\t\tif (aio_req) {\n\t\t\t\taio_req->iocb = iocb;\n\t\t\t\taio_req->write = write;\n\t\t\t\tINIT_LIST_HEAD(&aio_req->osd_reqs);\n\t\t\t\tif (write) {\n\t\t\t\t\taio_req->mtime = mtime;\n\t\t\t\t\tswap(aio_req->prealloc_cf, *pcf);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ignore error */\n\t\t}\n\n\t\tif (write) {\n\t\t\t/*\n\t\t\t * throw out any page cache pages in this range. this\n\t\t\t * may block.\n\t\t\t */\n\t\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t\t(pos+len) | (PAGE_SIZE - 1));\n\n\t\t\treq->r_mtime = mtime;\n\t\t}\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, start,\n	f
57275	631	blinkm_probe	drivers/leds/leds-blinkm.c	blinkm_probe_$led$0$obj$1$0$obj	0	-11	\N	\N	\tstruct blinkm_data *data;\n\tstruct blinkm_led *led[3];\n\tint err, i;\n\tchar blinkm_led_name[28];\n\n\tdata = devm_kzalloc(&client->dev,\n\t\t\tsizeof(struct blinkm_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdata->i2c_addr = 0x09;\n\tdata->i2c_addr = 0x08;\n\t/* i2c addr  - use fake addr of 0x08 initially (real is 0x09) */\n\tdata->fw_ver = 0xfe;\n\t/* firmware version - use fake until we read real value\n\t * (currently broken - BlinkM confused!) */\n\tdata->script_id = 0x01;\n\tdata->i2c_client = client;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t/* Register sysfs hooks */\n\terr = sysfs_create_group(&client->dev.kobj, &blinkm_group);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, "couldn't register sysfs group\\n");\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\t/* RED = 0, GREEN = 1, BLUE = 2 */\n\t\tled[i] = &data->blinkm_leds[i];\n\t\tled[i]->i2c_client = client;\n\t\tled[i]->id = i;\n\t\tled[i]->led_cdev.max_brightness = 255;\n\t\tled[i]->led_cdev.flags = LED_CORE_SUSPENDRESUME;\n\t\tswitch (i) {\n\t\tcase RED:\n\t\t\tsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\n\t\t\t\t\t "blinkm-%d-%d-red",\n\t\t\t\t\t client->adapter->nr,\n\t\t\t\t\t client->addr);\n\t\t\tled[i]->led_cdev.name = blinkm_led_name;\n\t\t\tled[i]->led_cdev.brightness_set_blocking =\n\t\t\t\t\t\t\tblinkm_led_red_set;\n\t\t\terr = led_classdev_register(&client->dev,\n\t\t\t\t\t\t    &led[i]->led_cdev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n	t
30891	365	nilfs_sufile_alloc	fs/nilfs2/sufile.c	su_bh->b_page	1	11	\N	\N	\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\ttrace_nilfs2_segment_usage_check(sufile, segnum, cnt);\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n	t
51717	1623	ath6kl_wmi_set_txe_notify	drivers/net/wireless/ath/ath6kl/wmi.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_txe_notify_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_txe_notify_cmd *) skb->data;\n\tcmd->rate = cpu_to_le32(rate);\n\tcmd->pkts = cpu_to_le32(pkts);\n\tcmd->intvl = cpu_to_le32(intvl);\n\n\treturn ath6kl_wmi_cmd_send(wmi, idx, skb, WMI_SET_TXE_NOTIFY_CMDID,\n	t
42973	3768	cifs_readpages	fs/cifs/file.c	rsize	1	11	\N	\N	\tint rc;\n\tstruct list_head tmplist;\n\tstruct cifsFileInfo *open_file = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server;\n\tpid_t pid;\n\n\t/*\n\t * Reads as many pages as possible from fscache. Returns -ENOBUFS\n\t * immediately if the cookie is negative\n\t *\n\t * After this point, every page in the list might have PG_fscache set,\n\t * so we will need to clean that up off of every page we don't use.\n\t */\n\trc = cifs_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &num_pages);\n\tif (rc == 0)\n\t\treturn rc;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\trc = 0;\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tcifs_dbg(FYI, "%s: file=%p mapping=%p num_pages=%u\\n",\n\t\t __func__, file, mapping, num_pages);\n\n\t/*\n\t * Start with the page at end of list and move it to private\n\t * list. Do the same with any following pages until we hit\n\t * the rsize limit, hit an index discontinuity, or run out of\n\t * pages. Issue the async read and then start the loop again\n\t * until the list is empty.\n\t *\n\t * Note that list order is important. The page_list is in\n\t * the order of declining indexes. When we put the pages in\n\t * the rdata->pages, then we want them in increasing order.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tunsigned int i, nr_pages, bytes, rsize;\n\t\tloff_t offset;\n\t\tstruct page *page, *tpage;\n\t\tstruct cifs_readdata *rdata;\n\t\tunsigned credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Give up immediately if rsize is too small to read an entire\n\t\t * page. The VFS will fall back to readpage. We should never\n\t\t * reach this point however since we set ra_pages to 0 when the\n\t\t * rsize is smaller than a cache page.\n\t\t */\n\t\tif (unlikely(rsize < PAGE_SIZE)) {\n	t
9558	743	set_temp_offset	drivers/hwmon/adm1031.c	set_temp_offset_$__UNIQUE_ID_min1_141$obj	0	11	\N	\N	\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, -15000, 15000);\n	t
56260	787	dccp_sendmsg	net/dccp/proto.c	skb	1	11	\N	\N	\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\n\t/*\n\t * We have to use sk_stream_wait_connect here to set sk_write_pending,\n\t * so that the trick in dccp_rcv_request_sent_state_process.\n\t */\n\t/* Wait for a connection to finish. */\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\n\tskb_reserve(skb, sk->sk_prot->max_header);\n	f
21366	136	irlap_send_snrm_frame	drivers/staging/irda/net/irlap_frame.c	tx_skb	1	11	\N	\N	\tstruct sk_buff *tx_skb;\n\tstruct snrm_frame *frame;\n\tint ret;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\n\n\t/* Allocate frame */\n\ttx_skb = alloc_skb(sizeof(struct snrm_frame) +\n\t\t\t   IRLAP_NEGOCIATION_PARAMS_LEN,\n\t\t\t   GFP_ATOMIC);\n\tif (!tx_skb)\n\t\treturn;\n\n\tframe = skb_put(tx_skb, 2);\n	t
26881	475	show_turbo	drivers/platform/x86/msi-laptop.c	rdata	1	11	\N	\N	\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, "%i\\n", !!(rdata & MSI_STANDARD_EC_TURBO_MASK));\n	t
40416	5776	efx_ef10_poll_bist	drivers/net/ethernet/sfc/ef10.c	outlen	1	11	\N	\N	\tint rc;\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_POLL_BIST_OUT_LEN);\n\tsize_t outlen;\n\tu32 result;\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,\n\t\t\t   outbuf, sizeof(outbuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_POLL_BIST_OUT_LEN)\n	t
45588	2581	qla82xx_unprotect_flash	drivers/scsi/qla2xxx/qla_nx.c	val	1	11	\N	\N	\tint ret;\n\tuint32_t val;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tret = ql82xx_rom_lock_d(ha);\n\tif (ret < 0) {\n\t\tql_log(ql_log_warn, vha, 0xb014,\n\t\t    "ROM Lock failed.\\n");\n\t\treturn ret;\n\t}\n\n\tret = qla82xx_read_status_reg(ha, &val);\n\tif (ret < 0)\n\t\tgoto done_unprotect;\n\n\tval &= ~(BLOCK_PROTECT_BITS << 2);\n\tret = qla82xx_write_status_reg(ha, val);\n	t
-219	225	stm32_tt_read_frequency	drivers/iio/trigger/stm32-timer-trigger.c	arr	4	20	\N	\N	\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct stm32_timer_trigger *priv = iio_trigger_get_drvdata(trig);\n\tu32 psc, arr, cr1;\n\tunsigned long long freq = 0;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\tif (cr1 & TIM_CR1_CEN) {\n\t\tfreq = (unsigned long long)clk_get_rate(priv->clk);\n\t\tdo_div(freq, psc + 1);\n\t\tdo_div(freq, arr + 1);\n	f
-217	222	stm32_tt_read_frequency	drivers/iio/trigger/stm32-timer-trigger.c	cr1	4	20	\N	\N	\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct stm32_timer_trigger *priv = iio_trigger_get_drvdata(trig);\n\tu32 psc, arr, cr1;\n\tunsigned long long freq = 0;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\tif (cr1 & TIM_CR1_CEN) {\n	f
-203	1133	rt274_i2c_probe	sound/soc/codecs/rt274.c	val	4	20	\N	\N	\tstruct rt274_priv *rt274;\n\n\tint ret;\n\tunsigned int val;\n\n\trt274 = devm_kzalloc(&i2c->dev,\tsizeof(*rt274),\n\t\t\t\tGFP_KERNEL);\n\tif (rt274 == NULL)\n\t\treturn -ENOMEM;\n\n\trt274->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt274_regmap);\n\tif (IS_ERR(rt274->regmap)) {\n\t\tret = PTR_ERR(rt274->regmap);\n\t\tdev_err(&i2c->dev, "Failed to allocate register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt274->regmap,\n\t\tRT274_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &val);\n\tif (val != RT274_VENDOR_ID) {\n	f
44345	999	usbtmc_ioctl_clear_out_halt	drivers/usb/class/usbtmc.c	rv	1	13	\N	\N	\tint rv;\n\n\trv = usb_clear_halt(data->usb_dev,\n\t\t\t    usb_sndbulkpipe(data->usb_dev, data->bulk_out));\n\n\tif (rv < 0) {\n	f
904	230	cfi_chip_setup	drivers/mtd/chips/cfi_probe.c	cfi_chip_setup_$cfi.addr$obj$9$obj	0	11	\N	\N	\tint ofs_factor = cfi->interleave*cfi->device_type;\n\t__u32 base = 0;\n\tint num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);\n\tint i;\n\tint addr_unlock1 = 0x555, addr_unlock2 = 0x2AA;\n\n\txip_enable(base, map, cfi);\n#ifdef DEBUG_CFI\n\tprintk("Number of erase regions: %d\\n", num_erase_regions);\n#endif\n\tif (!num_erase_regions)\n\t\treturn 0;\n\n\tcfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);\n\tif (!cfi->cfiq)\n\t\treturn 0;\n\n\tmemset(cfi->cfiq,0,sizeof(struct cfi_ident));\n\n\tcfi->cfi_mode = CFI_MODE_CFI;\n\n\tcfi->sector_erase_cmd = CMD(0x30);\n\n\t/* Read the CFI info structure */\n\txip_disable_qry(base, map, cfi);\n\tfor (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++)\n\t\t((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);\n\n\t/* Do any necessary byteswapping */\n\tcfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);\n\n\tcfi->cfiq->P_ADR = le16_to_cpu(cfi->cfiq->P_ADR);\n\tcfi->cfiq->A_ID = le16_to_cpu(cfi->cfiq->A_ID);\n\tcfi->cfiq->A_ADR = le16_to_cpu(cfi->cfiq->A_ADR);\n\tcfi->cfiq->InterfaceDesc = le16_to_cpu(cfi->cfiq->InterfaceDesc);\n\tcfi->cfiq->MaxBufWriteSize = le16_to_cpu(cfi->cfiq->MaxBufWriteSize);\n\n#ifdef DEBUG_CFI\n\t/* Dump the information therein */\n\tprint_cfi_ident(cfi->cfiq);\n#endif\n\n\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\n\t\tcfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);\n\n#ifdef DEBUG_CFI\n\t\tprintk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\\n",\n\t\t       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,\n\t\t       (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1);\n#endif\n\t}\n\n\tif (cfi->cfiq->P_ID == P_ID_SST_OLD) {\n\t\taddr_unlock1 = 0x5555;\n\t\taddr_unlock2 = 0x2AAA;\n\t}\n\n\t/*\n\t * Note we put the device back into Read Mode BEFORE going into Auto\n\t * Select Mode, as some devices support nesting of modes, others\n\t * don't. This way should always work.\n\t * On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and\n\t * so should be treated as nops or illegal (and so put the device\n\t * back into Read Mode, which is a nop in this case).\n\t */\n\tcfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xaa, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, addr_unlock2, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x90, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\n\tcfi->mfr = cfi_read_query16(map, base);\n\tcfi->id = cfi_read_query16(map, base + ofs_factor);\n\n\t/* Get AMD/Spansion extended JEDEC ID */\n\tif (cfi->mfr == CFI_MFR_AMD && (cfi->id & 0xff) == 0x7e)\n	t
53963	969	be_get_dump_data	drivers/net/ethernet/emulex/benet/be_ethtool.c	status	1	11	\N	\N	\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status;\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = be_read_dump_data(adapter, dump->len, buf);\n\treturn be_cmd_status(status);\n	t
29403	2150	ath6kl_wmi_bssfilter_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_bssfilter_cmd_$cmd$obj	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_bss_filter_cmd *cmd;\n\tint ret;\n\n\tif (filter >= LAST_BSS_FILTER)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bss_filter_cmd *) skb->data;\n\tcmd->bss_filter = filter;\n	t
54942	1264	cgroup1_mount	kernel/cgroup/cgroup-v1.c	&root->cgrp.self.refcnt	1	13	\N	\N	\tstruct super_block *pinned_sb = NULL;\n\tstruct cgroup_sb_opts opts;\n\tstruct cgroup_root *root;\n\tstruct cgroup_subsys *ss;\n\tstruct dentry *dentry;\n\tint i, ret;\n\tbool new_root = false;\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\t/* First find the desired set of subsystems */\n\tret = parse_cgroupfs_options(data, &opts);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Destruction of cgroup root is asynchronous, so subsystems may\n\t * still be dying after the previous unmount.  Let's drain the\n\t * dying subsystems.  We just need to ensure that the ones\n\t * unmounted previously finish dying and don't care about new ones\n\t * starting.  Testing ref liveliness is good enough.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (!(opts.subsys_mask & (1 << i)) ||\n\t\t    ss->root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\tif (!percpu_ref_tryget_live(&ss->root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\t\tcgroup_put(&ss->root->cgrp);\n\t}\n\n\tfor_each_root(root) {\n\t\tbool name_match = false;\n\n\t\tif (root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we asked for a name then it must match.  Also, if\n\t\t * name matches but sybsys_mask doesn't, we should fail.\n\t\t * Remember whether name matched.\n\t\t */\n\t\tif (opts.name) {\n\t\t\tif (strcmp(opts.name, root->name))\n\t\t\t\tcontinue;\n\t\t\tname_match = true;\n\t\t}\n\n\t\t/*\n\t\t * If we asked for subsystems (or explicitly for no\n\t\t * subsystems) then they must match.\n\t\t */\n\t\tif ((opts.subsys_mask || opts.none) &&\n\t\t    (opts.subsys_mask != root->subsys_mask)) {\n\t\t\tif (!name_match)\n\t\t\t\tcontinue;\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (root->flags ^ opts.flags)\n\t\t\tpr_warn("new mount options do not match the existing superblock, will be ignored\\n");\n\n\t\t/*\n\t\t * We want to reuse @root whose lifetime is governed by its\n\t\t * ->cgrp.  Let's check whether @root is alive and keep it\n\t\t * that way.  As cgroup_kill_sb() can happen anytime, we\n\t\t * want to block it by pinning the sb so that @root doesn't\n\t\t * get killed before mount is complete.\n\t\t *\n\t\t * With the sb pinned, tryget_live can reliably indicate\n\t\t * whether @root can be reused.  If it's being killed,\n\t\t * drain it.  We can use wait_queue for the wait but this\n\t\t * path is super cold.  Let's just sleep a bit and retry.\n\t\t */\n\t\tpinned_sb = kernfs_pin_sb(root->kf_root, NULL);\n\t\tif (IS_ERR(pinned_sb) ||\n\t\t    !percpu_ref_tryget_live(&root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tif (!IS_ERR_OR_NULL(pinned_sb))\n\t\t\t\tdeactivate_super(pinned_sb);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * No such thing, create a new one.  name= matching without subsys\n\t * specification is allowed for already existing hierarchies but we\n\t * can't create new one without subsys specification.\n\t */\n\tif (!opts.subsys_mask && !opts.none) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Hierarchies may only be created in the initial cgroup namespace. */\n\tif (ns != &init_cgroup_ns) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tnew_root = true;\n\n\tinit_cgroup_root(root, &opts);\n\n\tret = cgroup_setup_root(root, opts.subsys_mask, PERCPU_REF_INIT_DEAD);\n\tif (ret)\n\t\tcgroup_free_root(root);\n\nout_unlock:\n\tmutex_unlock(&cgroup_mutex);\nout_free:\n\tkfree(opts.release_agent);\n\tkfree(opts.name);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdentry = cgroup_do_mount(&cgroup_fs_type, flags, root,\n\t\t\t\t CGROUP_SUPER_MAGIC, ns);\n\n\t/*\n\t * There's a race window after we release cgroup_mutex and before\n\t * allocating a superblock. Make sure a concurrent process won't\n\t * be able to re-use the root during this window by delaying the\n\t * initialization of root refcnt.\n\t */\n\tif (new_root) {\n\t\tmutex_lock(&cgroup_mutex);\n\t\tpercpu_ref_reinit(&root->cgrp.self.refcnt);\n	f
56661	2172	bond_miimon_commit	drivers/net/bonding/bond_main.c	slave->speed	1	11	\N	\N	\tstruct list_head *iter;\n\tstruct slave *slave, *primary;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tswitch (slave->new_link) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\tif (bond_update_speed_duplex(slave) &&\n\t\t\t    bond_needs_speed_duplex(bond)) {\n\t\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tnetdev_warn(bond->dev,\n\t\t\t\t\t\t    "failed to get link speed/duplex for %s\\n",\n\t\t\t\t\t\t    slave->dev->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_UP,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\tslave->last_link_up = jiffies;\n\n\t\t\tprimary = rtnl_dereference(bond->primary_slave);\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t} else if (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t\t\t/* make it immediately active */\n\t\t\t\tbond_set_active_slave(slave);\n\t\t\t} else if (slave != primary) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t}\n\n\t\t\tnetdev_info(bond->dev, "link status definitely up for interface %s, %u Mbps %s duplex\\n",\n\t\t\t\t    slave->dev->name,\n\t\t\t\t    slave->speed == SPEED_UNKNOWN ? 0 : slave->speed,\n	f
45440	293	xhci_pci_probe	drivers/usb/host/xhci-pci.c	retval	1	11	\N	\N	\tint retval;\n\tstruct xhci_hcd *xhci;\n\tstruct hc_driver *driver;\n\tstruct usb_hcd *hcd;\n\n\tdriver = (struct hc_driver *)id->driver_data;\n\n\t/* For some HW implementation, a XHCI reset is just not enough... */\n\tif (usb_xhci_needs_pci_reset(dev)) {\n\t\tdev_info(&dev->dev, "Resetting\\n");\n\t\tif (pci_reset_function_locked(dev))\n\t\t\tdev_warn(&dev->dev, "Reset failed");\n\t}\n\n\t/* Prevent runtime suspending between USB-2 and USB-3 initialization */\n\tpm_runtime_get_noresume(&dev->dev);\n\n\t/* Register the USB 2.0 roothub.\n\t * FIXME: USB core must know to register the USB 2.0 roothub first.\n\t * This is sort of silly, because we could just set the HCD driver flags\n\t * to say USB 2.0, but I'm not sure what the implications would be in\n\t * the other parts of the HCD code.\n\t */\n\tretval = usb_hcd_pci_probe(dev, id);\n\n\tif (retval)\n	t
49351	791	databuf_lo_scan_elements	fs/gfs2/lops.c	bh_ip->b_data	1	11	\N	\N	\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tunsigned int blks = be32_to_cpu(ld->ld_data1);\n\tstruct buffer_head *bh_log, *bh_ip;\n\tu64 blkno;\n\tu64 esc;\n\tint error = 0;\n\n\tif (pass != 1 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_JDATA)\n\t\treturn 0;\n\n\tgfs2_replay_incr_blk(jd, &start);\n\tfor (; blks; gfs2_replay_incr_blk(jd, &start), blks--) {\n\t\tblkno = be64_to_cpu(*ptr++);\n\t\tesc = be64_to_cpu(*ptr++);\n\n\t\tjd->jd_found_blocks++;\n\n\t\tif (gfs2_revoke_check(jd, blkno, start))\n\t\t\tcontinue;\n\n\t\terror = gfs2_replay_read_block(jd, start, &bh_log);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tbh_ip = gfs2_meta_new(gl, blkno);\n\t\tmemcpy(bh_ip->b_data, bh_log->b_data, bh_log->b_size);\n	t
20429	722	adu_probe	drivers/usb/misc/adutux.c	adu_probe_	0	11	\N	\N	\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct adu_device *dev = NULL;\n\tint retval = -ENOMEM;\n\tint in_end_size;\n\tint out_end_size;\n\tint res;\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(struct adu_device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->mtx);\n\tspin_lock_init(&dev->buflock);\n\tdev->udev = udev;\n\tinit_waitqueue_head(&dev->read_wait);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\tres = usb_find_common_endpoints_reverse(&interface->altsetting[0],\n\t\t\tNULL, NULL,\n\t\t\t&dev->interrupt_in_endpoint,\n\t\t\t&dev->interrupt_out_endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, "interrupt endpoints not found\\n");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tin_end_size = usb_endpoint_maxp(dev->interrupt_in_endpoint);\n\tout_end_size = usb_endpoint_maxp(dev->interrupt_out_endpoint);\n\n\tdev->read_buffer_primary = kmalloc((4 * in_end_size), GFP_KERNEL);\n\tif (!dev->read_buffer_primary)\n\t\tgoto error;\n\n\t/* debug code prime the buffer */\n\tmemset(dev->read_buffer_primary, 'a', in_end_size);\n\tmemset(dev->read_buffer_primary + in_end_size, 'b', in_end_size);\n\tmemset(dev->read_buffer_primary + (2 * in_end_size), 'c', in_end_size);\n\tmemset(dev->read_buffer_primary + (3 * in_end_size), 'd', in_end_size);\n\n\tdev->read_buffer_secondary = kmalloc((4 * in_end_size), GFP_KERNEL);\n\tif (!dev->read_buffer_secondary)\n\t\tgoto error;\n\n\t/* debug code prime the buffer */\n\tmemset(dev->read_buffer_secondary, 'e', in_end_size);\n\tmemset(dev->read_buffer_secondary + in_end_size, 'f', in_end_size);\n\tmemset(dev->read_buffer_secondary + (2 * in_end_size), 'g', in_end_size);\n\tmemset(dev->read_buffer_secondary + (3 * in_end_size), 'h', in_end_size);\n\n\tdev->interrupt_in_buffer = kmalloc(in_end_size, GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\n\t/* debug code prime the buffer */\n\tmemset(dev->interrupt_in_buffer, 'i', in_end_size);\n\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc(out_end_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\n\tif (!usb_string(udev, udev->descriptor.iSerialNumber, dev->serial_number,\n	f
36752	623	at91_read_msg	drivers/net/can/at91_can.c	cf	2	-11	\N	\N	\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_can_skb(dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tat91_read_mb(dev, mb, cf);\n	t
55898	95	udf_truncate_tail_extent	fs/udf/truncate.c	lbcount	1	11	\N	\N	\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n	t
60145	6542	ath10k_wmi_op_gen_peer_flush	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_peer_flush_$cmd$obj	0	11	\N	\N	\tstruct wmi_peer_flush_tids_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_peer_flush_tids_cmd *)skb->data;\n\tcmd->vdev_id         = __cpu_to_le32(vdev_id);\n	t
56777	3605	lpfc_sli_handle_slow_ring_event_s4	drivers/scsi/lpfc/lpfc_sli.c	irspiocbq	1	11	\N	\N	\tstruct lpfc_iocbq *irspiocbq;\n\tstruct hbq_dmabuf *dmabuf;\n\tstruct lpfc_cq_event *cq_event;\n\tunsigned long iflag;\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tphba->hba_flag &= ~HBA_SP_QUEUE_EVT;\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\twhile (!list_empty(&phba->sli4_hba.sp_queue_event)) {\n\t\t/* Get the response iocb from the head of work queue */\n\t\tspin_lock_irqsave(&phba->hbalock, iflag);\n\t\tlist_remove_head(&phba->sli4_hba.sp_queue_event,\n\t\t\t\t cq_event, struct lpfc_cq_event, list);\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\n\t\tswitch (bf_get(lpfc_wcqe_c_code, &cq_event->cqe.wcqe_cmpl)) {\n\t\tcase CQE_CODE_COMPL_WQE:\n\t\t\tirspiocbq = container_of(cq_event, struct lpfc_iocbq,\n\t\t\t\t\t\t cq_event);\n\t\t\t/* Translate ELS WCQE to response IOCBQ */\n\t\t\tirspiocbq = lpfc_sli4_els_wcqe_to_rspiocbq(phba,\n\t\t\t\t\t\t\t\t   irspiocbq);\n\t\t\tif (irspiocbq)\n\t\t\t\tlpfc_sli_sp_handle_rspiocb(phba, pring,\n	f
21518	52	br_send_bpdu	net/bridge/br_stp_bpdu.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(length+LLC_RESERVE);\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = p->dev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tskb_reserve(skb, LLC_RESERVE);\n	t
26844	840	tm_attr_store	drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c	val	1	11	\N	\N	\tstruct port_info *pi = netdev_priv(to_net_dev(d));\n\tstruct adapter *adap = pi->adapter;\n\tunsigned int val;\n\tssize_t ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = kstrtouint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val > 10000000)\n	t
29533	1304	mmc_regulator_set_ocr	drivers/mmc/core/core.c	min_uV	1	11	\N	\N	\tint\t\t\tresult = 0;\n\tint\t\t\tmin_uV, max_uV;\n\n\tif (vdd_bit) {\n\t\tmmc_ocrbitnum_to_vdd(vdd_bit, &min_uV, &max_uV);\n\n\t\tresult = regulator_set_voltage(supply, min_uV, max_uV);\n	t
41941	339	inet_lookup	net/ipv4/inet_diag.c	nlh	1	11	\N	\N	\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct inet_diag_msg *r;\n\tstruct nlmsghdr *nlh;\n\tlong tmo;\n\n\tnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\n\t\t\tnlmsg_flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n	t
42390	569	asix_mdio_write_nopm	drivers/net/usb/asix_common.c	ret	1	11	\N	\N	\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tu8 smsr;\n\tint i = 0;\n\tint ret;\n\n\tnetdev_dbg(dev->net, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n",\n\t\t\tphy_id, loc, val);\n\n\tmutex_lock(&dev->phy_mutex);\n\tdo {\n\t\tret = asix_set_sw_mii(dev, 1);\n\t\tif (ret == -ENODEV)\n	t
-204	646	sun8i_dwmac_set_syscon	drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c	val	4	20	\N	\N	\tstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\n\tstruct device_node *node = priv->device->of_node;\n\tint ret;\n\tu32 reg, val;\n\n\tregmap_read(gmac->regmap, SYSCON_EMAC_REG, &val);\n\treg = gmac->variant->default_syscon_value;\n\tif (reg != val)\n	f
20494	1854	range_read	security/selinux/ss/policydb.c	nel	2	-11	\N	\N	\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint i, rc;\n\t__le32 buf[2];\n\tu32 nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\tfor (i = 0; i < nel; i++) {\n	t
26997	602	toshiba_kbd_illum_status_get	drivers/platform/x86/toshiba_acpi.c	result	2	-11	\N	\N	\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_KBD_ILLUM_STATUS, time);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n	t
49283	193	power_vag_event	sound/soc/codecs/sgtl5000.c	power_vag_event_$and$10	0	13	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\n\tconst u32 mask = SGTL5000_DAC_POWERUP | SGTL5000_ADC_POWERUP;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\n\t\t\tSGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);\n\t\tmsleep(400);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\t/*\n\t\t * Don't clear VAG_POWERUP, when both DAC and ADC are\n\t\t * operational to prevent inadvertently starving the\n\t\t * other one of them.\n\t\t */\n\t\tif ((snd_soc_read(codec, SGTL5000_CHIP_ANA_POWER) &\n	f
52901	296	cafe_nand_cmdfunc	drivers/mtd/nand/cafe_nand.c	irqs	1	13	\N	\N	\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tint adrbytes = 0;\n\tuint32_t ctl1;\n\tuint32_t doneint = 0x80000000;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, "cmdfunc %02x, 0x%x, 0x%x\\n",\n\t\tcommand, column, page_addr);\n\n\tif (command == NAND_CMD_ERASE2 || command == NAND_CMD_PAGEPROG) {\n\t\t/* Second half of a command we already calculated */\n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | command, NAND_CTRL2);\n\t\tctl1 = cafe->ctl1;\n\t\tcafe->ctl2 &= ~(1<<30);\n\t\tcafe_dev_dbg(&cafe->pdev->dev, "Continue command, ctl1 %08x, #data %d\\n",\n\t\t\t  cafe->ctl1, cafe->nr_data);\n\t\tgoto do_command;\n\t}\n\t/* Reset ECC engine */\n\tcafe_writel(cafe, 0, NAND_CTRL2);\n\n\t/* Emulate NAND_CMD_READOOB on large-page chips */\n\tif (mtd->writesize > 512 &&\n\t    command == NAND_CMD_READOOB) {\n\t\tcolumn += mtd->writesize;\n\t\tcommand = NAND_CMD_READ0;\n\t}\n\n\t/* FIXME: Do we need to send read command before sending data\n\t   for small-page chips, to position the buffer correctly? */\n\n\tif (column != -1) {\n\t\tcafe_writel(cafe, column, NAND_ADDR1);\n\t\tadrbytes = 2;\n\t\tif (page_addr != -1)\n\t\t\tgoto write_adr2;\n\t} else if (page_addr != -1) {\n\t\tcafe_writel(cafe, page_addr & 0xffff, NAND_ADDR1);\n\t\tpage_addr >>= 16;\n\twrite_adr2:\n\t\tcafe_writel(cafe, page_addr, NAND_ADDR2);\n\t\tadrbytes += 2;\n\t\tif (mtd->size > mtd->writesize << 16)\n\t\t\tadrbytes++;\n\t}\n\n\tcafe->data_pos = cafe->datalen = 0;\n\n\t/* Set command valid bit, mask in the chip select bit  */\n\tctl1 = 0x80000000 | command | (cafe->ctl1 & CTRL1_CHIPSELECT);\n\n\t/* Set RD or WR bits as appropriate */\n\tif (command == NAND_CMD_READID || command == NAND_CMD_STATUS) {\n\t\tctl1 |= (1<<26); /* rd */\n\t\t/* Always 5 bytes, for now */\n\t\tcafe->datalen = 4;\n\t\t/* And one address cycle -- even for STATUS, since the controller doesn't work without */\n\t\tadrbytes = 1;\n\t} else if (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 ||\n\t\t   command == NAND_CMD_READOOB || command == NAND_CMD_RNDOUT) {\n\t\tctl1 |= 1<<26; /* rd */\n\t\t/* For now, assume just read to end of page */\n\t\tcafe->datalen = mtd->writesize + mtd->oobsize - column;\n\t} else if (command == NAND_CMD_SEQIN)\n\t\tctl1 |= 1<<25; /* wr */\n\n\t/* Set number of address bytes */\n\tif (adrbytes)\n\t\tctl1 |= ((adrbytes-1)|8) << 27;\n\n\tif (command == NAND_CMD_SEQIN || command == NAND_CMD_ERASE1) {\n\t\t/* Ignore the first command of a pair; the hardware\n\t\t   deals with them both at once, later */\n\t\tcafe->ctl1 = ctl1;\n\t\tcafe_dev_dbg(&cafe->pdev->dev, "Setup for delayed command, ctl1 %08x, dlen %x\\n",\n\t\t\t  cafe->ctl1, cafe->datalen);\n\t\treturn;\n\t}\n\t/* RNDOUT and READ0 commands need a following byte */\n\tif (command == NAND_CMD_RNDOUT)\n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_RNDOUTSTART, NAND_CTRL2);\n\telse if (command == NAND_CMD_READ0 && mtd->writesize > 512)\n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_READSTART, NAND_CTRL2);\n\n do_command:\n\tcafe_dev_dbg(&cafe->pdev->dev, "dlen %x, ctl1 %x, ctl2 %x\\n",\n\t\tcafe->datalen, ctl1, cafe_readl(cafe, NAND_CTRL2));\n\n\t/* NB: The datasheet lies -- we really should be subtracting 1 here */\n\tcafe_writel(cafe, cafe->datalen, NAND_DATA_LEN);\n\tcafe_writel(cafe, 0x90000000, NAND_IRQ);\n\tif (usedma && (ctl1 & (3<<25))) {\n\t\tuint32_t dmactl = 0xc0000000 + cafe->datalen;\n\t\t/* If WR or RD bits set, set up DMA */\n\t\tif (ctl1 & (1<<26)) {\n\t\t\t/* It's a read */\n\t\t\tdmactl |= (1<<29);\n\t\t\t/* ... so it's done when the DMA is done, not just\n\t\t\t   the command. */\n\t\t\tdoneint = 0x10000000;\n\t\t}\n\t\tcafe_writel(cafe, dmactl, NAND_DMA_CTRL);\n\t}\n\tcafe->datalen = 0;\n\n\tif (unlikely(regdebug)) {\n\t\tint i;\n\t\tprintk("About to write command %08x to register 0\\n", ctl1);\n\t\tfor (i=4; i< 0x5c; i+=4)\n\t\t\tprintk("Register %x: %08x\\n", i, readl(cafe->mmio + i));\n\t}\n\n\tcafe_writel(cafe, ctl1, NAND_CTRL1);\n\t/* Apply this short delay always to ensure that we do wait tWB in\n\t * any case on any machine. */\n\tndelay(100);\n\n\tif (1) {\n\t\tint c;\n\t\tuint32_t irqs;\n\n\t\tfor (c = 500000; c != 0; c--) {\n\t\t\tirqs = cafe_readl(cafe, NAND_IRQ);\n\t\t\tif (irqs & doneint)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t\tif (!(c % 100000))\n\t\t\t\tcafe_dev_dbg(&cafe->pdev->dev, "Wait for ready, IRQ %x\\n", irqs);\n\t\t\tcpu_relax();\n\t\t}\n\t\tcafe_writel(cafe, doneint, NAND_IRQ);\n\t\tcafe_dev_dbg(&cafe->pdev->dev, "Command %x completed after %d usec, irqs %x (%x)\\n",\n	f
-251	838	max17042_thread_handler	drivers/power/supply/max17042_battery.c	val	5	20	\N	\N	\tstruct max17042_chip *chip = dev;\n\tu32 val;\n\n\tregmap_read(chip->regmap, MAX17042_STATUS, &val);\n\tif ((val & STATUS_INTR_SOCMIN_BIT) ||\n	f
-215	169	stm32_timer_stop	drivers/iio/trigger/stm32-timer-trigger.c	ccer	4	20	\N	\N	\tu32 ccer, cr1;\n\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tif (ccer & TIM_CCER_CCXE)\n	f
-209	631	meson_sar_adc_init	drivers/iio/adc/meson_saradc.c	regval	4	20	\N	\N	\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint regval, ret;\n\n\t/*\n\t * make sure we start at CH7 input since the other muxes are only used\n\t * for internal calibration.\n\t */\n\tmeson_sar_adc_set_chan7_mux(indio_dev, CHAN7_MUX_CH7_INPUT);\n\n\tif (priv->data->has_bl30_integration) {\n\t\t/*\n\t\t * leave sampling delay and the input clocks as configured by\n\t\t * BL30 to make sure BL30 gets the values it expects when\n\t\t * reading the temperature sensor.\n\t\t */\n\t\tregmap_read(priv->regmap, MESON_SAR_ADC_REG3, &regval);\n\t\tif (regval & MESON_SAR_ADC_REG3_BL30_INITIALIZED)\n	f
61366	857	netlbl_unlabel_list	net/netlabel/netlabel_unlabeled.c	ans_skb	1	13	\N	\N	\tint ret_val = -EINVAL;\n\tstruct sk_buff *ans_skb;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\tgoto list_failure;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\n	f
54752	627	cpcap_charger_probe	drivers/power/supply/cpcap-charger.c	ddata	1	11	\N	\N	\tstruct cpcap_charger_ddata *ddata;\n\tconst struct of_device_id *of_id;\n\tstruct power_supply_config psy_cfg = {};\n\tint error;\n\n\tof_id = of_match_device(of_match_ptr(cpcap_charger_id_table),\n\t\t\t\t&pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->dev = &pdev->dev;\n\n\tddata->reg = dev_get_regmap(ddata->dev->parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\tINIT_LIST_HEAD(&ddata->irq_list);\n\tINIT_DELAYED_WORK(&ddata->detect_work, cpcap_usb_detect);\n\tINIT_DELAYED_WORK(&ddata->vbus_work, cpcap_charger_vbus_work);\n\tplatform_set_drvdata(pdev, ddata);\n\n\terror = cpcap_charger_init_iio(ddata);\n	t
28974	155	mn88473_set_frontend	drivers/media/dvb-frontends/mn88473.c	conf_val_ptr[i]	1	11	\N	\N	\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tunsigned int uitmp;\n\tu32 if_frequency;\n\tu8 delivery_system_val, if_val[3], *conf_val_ptr;\n\tu8 reg_bank2_2d_val, reg_bank0_d2_val;\n\n\tdev_dbg(&client->dev,\n\t\t"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%d stream_id=%d\\n",\n\t\tc->delivery_system, c->modulation, c->frequency,\n\t\tc->bandwidth_hz, c->symbol_rate, c->inversion, c->stream_id);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tdelivery_system_val = 0x02;\n\t\treg_bank2_2d_val = 0x23;\n\t\treg_bank0_d2_val = 0x2a;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tdelivery_system_val = 0x03;\n\t\treg_bank2_2d_val = 0x3b;\n\t\treg_bank0_d2_val = 0x29;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tdelivery_system_val = 0x04;\n\t\treg_bank2_2d_val = 0x3b;\n\t\treg_bank0_d2_val = 0x29;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tconf_val_ptr = "\\xe9\\x55\\x55\\x1c\\x29\\x1c\\x29";\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tconf_val_ptr = "\\xc8\\x00\\x00\\x17\\x0a\\x17\\x0a";\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tconf_val_ptr = "\\xaf\\x00\\x00\\x11\\xec\\x11\\xec";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tconf_val_ptr = "\\x10\\xab\\x0d\\xae\\x1d\\x9d";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Program tuner */\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, "get_if_frequency=%u\\n", if_frequency);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* Calculate IF registers */\n\tuitmp = DIV_ROUND_CLOSEST_ULL((u64) if_frequency * 0x1000000, dev->clk);\n\tif_val[0] = (uitmp >> 16) & 0xff;\n\tif_val[1] = (uitmp >>  8) & 0xff;\n\tif_val[2] = (uitmp >>  0) & 0xff;\n\n\tret = regmap_write(dev->regmap[2], 0x05, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xfb, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xef, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xf9, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x00, 0x18);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x02, 0x21);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x03, delivery_system_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x0b, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < sizeof(if_val); i++) {\n\t\tret = regmap_write(dev->regmap[2], 0x10 + i, if_val[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tret = regmap_write(dev->regmap[2], 0x13 + i,\n	t
5438	314	nvkm_volt_ctor	drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c	nvkm_volt_ctor_$volt.addr$obj$19$0$0$obj	0	13	\N	\N	\tstruct nvkm_bios *bios = device->bios;\n\tint i;\n\n\tnvkm_subdev_ctor(&nvkm_volt, device, index, &volt->subdev);\n\tvolt->func = func;\n\n\t/* Assuming the non-bios device should build the voltage table later */\n\tif (bios) {\n\t\tu8 ver, hdr, cnt, len;\n\t\tstruct nvbios_vmap vmap;\n\n\t\tnvkm_volt_parse_bios(bios, volt);\n\t\tnvkm_debug(&volt->subdev, "min: %iuv max: %iuv\\n",\n\t\t\t   volt->min_uv, volt->max_uv);\n\n\t\tif (nvbios_vmap_parse(bios, &ver, &hdr, &cnt, &len, &vmap)) {\n\t\t\tvolt->max0_id = vmap.max0;\n\t\t\tvolt->max1_id = vmap.max1;\n\t\t\tvolt->max2_id = vmap.max2;\n\t\t} else {\n\t\t\tvolt->max0_id = 0xff;\n\t\t\tvolt->max1_id = 0xff;\n\t\t\tvolt->max2_id = 0xff;\n\t\t}\n\t}\n\n\tif (volt->vid_nr) {\n\t\tfor (i = 0; i < volt->vid_nr; i++) {\n\t\t\tnvkm_debug(&volt->subdev, "VID %02x: %duv\\n",\n	f
49365	534	hfs_file_truncate	fs/hfs/extent.c	&fd	1	11	\N	\N	\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, "truncate: %lu, %Lu -> %Lu\\n",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n	t
23938	355	igmpv3_newpack	net/ipv4/igmp.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\tunsigned int size = mtu;\n\n\twhile (1) {\n\t\tskb = alloc_skb(size + hlen + tlen,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tskb->priority = TC_PRIO_CONTROL;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n	f
25317	813	register_for_each_vma	kernel/events/uprobes.c	mm->mmap_sem	7	12	\N	\N	\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n	t
-619	290	__shadow_block	drivers/md/persistent-data/dm-transaction-manager.c	new	2	3	\N	\N	\tint r;\n\tdm_block_t new;\n\tstruct dm_block *orig_block;\n\n\tr = dm_sm_new_block(tm->sm, &new);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_dec_block(tm->sm, orig);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_bm_read_lock(tm->bm, orig, v, &orig_block);\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * It would be tempting to use dm_bm_unlock_move here, but some\n\t * code, such as the space maps, keeps using the old data structures\n\t * secure in the knowledge they won't be changed until the next\n\t * transaction.  Using unlock_move would force a synchronous read\n\t * since the old block would no longer be in the cache.\n\t */\n\tr = dm_bm_write_lock_zero(tm->bm, new, v, result);\n	f
56817	519	keyspan_pda_write	drivers/usb/serial/keyspan_pda.c	priv->tx_room	1	11	\N	\N	\tstruct usb_serial *serial = port->serial;\n\tint request_unthrottle = 0;\n\tint rc = 0;\n\tstruct keyspan_pda_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\t/* guess how much room is left in the device's ring buffer, and if we\n\t   want to send more than that, check first, updating our notion of\n\t   what is left. If our write will result in no room left, ask the\n\t   device to give us an interrupt when the room available rises above\n\t   a threshold, and hold off all writers (eventually, those using\n\t   select() or poll() too) until we receive that unthrottle interrupt.\n\t   Block if we can't write anything at all, otherwise write as much as\n\t   we can. */\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, "write request of 0 bytes\\n");\n\t\treturn 0;\n\t}\n\n\t/* we might block because of:\n\t   the TX urb is in-flight (wait until it completes)\n\t   the device is full (wait until it says there is room)\n\t*/\n\tspin_lock_bh(&port->lock);\n\tif (!test_bit(0, &port->write_urbs_free) || priv->tx_throttled) {\n\t\tspin_unlock_bh(&port->lock);\n\t\treturn 0;\n\t}\n\tclear_bit(0, &port->write_urbs_free);\n\tspin_unlock_bh(&port->lock);\n\n\t/* At this point the URB is in our control, nobody else can submit it\n\t   again (the only sudden transition was the one from EINPROGRESS to\n\t   finished).  Also, the tx process is not throttled. So we are\n\t   ready to write. */\n\n\tcount = (count > port->bulk_out_size) ? port->bulk_out_size : count;\n\n\t/* Check if we might overrun the Tx buffer.   If so, ask the\n\t   device how much room it really has.  This is done only on\n\t   scheduler time, since usb_control_msg() sleeps. */\n\tif (count > priv->tx_room && !in_interrupt()) {\n\t\tu8 *room;\n\n\t\troom = kmalloc(1, GFP_KERNEL);\n\t\tif (!room) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = usb_control_msg(serial->dev,\n\t\t\t\t     usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t     6, /* write_room */\n\t\t\t\t     USB_TYPE_VENDOR | USB_RECIP_INTERFACE\n\t\t\t\t     | USB_DIR_IN,\n\t\t\t\t     0, /* value: 0 means "remaining room" */\n\t\t\t\t     0, /* index */\n\t\t\t\t     room,\n\t\t\t\t     1,\n\t\t\t\t     2000);\n\t\tif (rc > 0) {\n\t\t\tdev_dbg(&port->dev, "roomquery says %d\\n", *room);\n\t\t\tpriv->tx_room = *room;\n\t\t}\n\t\tkfree(room);\n\t\tif (rc < 0) {\n\t\t\tdev_dbg(&port->dev, "roomquery failed\\n");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tdev_dbg(&port->dev, "roomquery returned 0 bytes\\n");\n\t\t\trc = -EIO; /* device didn't return any data */\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (count > priv->tx_room) {\n	f
48933	459	lola_parse_tree	sound/pci/lola/lola.c	val	1	11	\N	\N	\tunsigned int val;\n\tint nid, err;\n\n\terr = lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, "Can't read VENDOR_ID\\n");\n\t\treturn err;\n\t}\n\tval >>= 16;\n\tif (val != 0x1369) {\n	t
8923	455	elan_smbus_write_fw_block	drivers/input/mouse/elan_i2c_smbus.c	error	1	11	\N	\N	\tstruct device *dev = &client->dev;\n\tint error;\n\tu16 result;\n\tu8 val[3];\n\n\t/*\n\t * Due to the limitation of smbus protocol limiting\n\t * transfer to 32 bytes at a time, we must split block\n\t * in 2 transfers.\n\t */\n\terror = i2c_smbus_write_block_data(client,\n\t\t\t\t\t   ETP_SMBUS_WRITE_FW_BLOCK,\n\t\t\t\t\t   ETP_FW_PAGE_SIZE / 2,\n\t\t\t\t\t   page);\n\tif (error) {\n\t\tdev_err(dev, "Failed to write page %d (part %d): %d\\n",\n\t\t\tidx, 1, error);\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_block_data(client,\n\t\t\t\t\t   ETP_SMBUS_WRITE_FW_BLOCK,\n\t\t\t\t\t   ETP_FW_PAGE_SIZE / 2,\n\t\t\t\t\t   page + ETP_FW_PAGE_SIZE / 2);\n\tif (error) {\n\t\tdev_err(dev, "Failed to write page %d (part %d): %d\\n",\n\t\t\tidx, 2, error);\n\t\treturn error;\n\t}\n\n\n\t/* Wait for F/W to update one page ROM data. */\n\tusleep_range(8000, 10000);\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  ETP_SMBUS_IAP_CTRL_CMD, val);\n\tif (error < 0) {\n	t
39356	4131	ixgbevf_probe	drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c	err	1	13	\N	\N	\tstruct net_device *netdev;\n\tstruct ixgbevf_adapter *adapter = NULL;\n\tstruct ixgbe_hw *hw = NULL;\n\tconst struct ixgbevf_info *ii = ixgbevf_info_tbl[ent->driver_data];\n\tint err, pci_using_dac;\n\tbool disable_dev = false;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tpci_using_dac = 1;\n\t} else {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, "No usable DMA configuration, aborting\\n");\n\t\t\tgoto err_dma;\n\t\t}\n\t\tpci_using_dac = 0;\n\t}\n\n\terr = pci_request_regions(pdev, ixgbevf_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, "pci_request_regions failed 0x%x\\n", err);\n\t\tgoto err_pci_reg;\n\t}\n\n\tpci_set_master(pdev);\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct ixgbevf_adapter),\n\t\t\t\t   MAX_TX_QUEUES);\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tadapter = netdev_priv(netdev);\n\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\thw = &adapter->hw;\n\thw->back = adapter;\n\tadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\t/* call save state here in standalone driver because it relies on\n\t * adapter struct to exist, and needs to call netdev_priv\n\t */\n\tpci_save_state(pdev);\n\n\thw->hw_addr = ioremap(pci_resource_start(pdev, 0),\n\t\t\t      pci_resource_len(pdev, 0));\n\tadapter->io_addr = hw->hw_addr;\n\tif (!hw->hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tixgbevf_assign_netdev_ops(netdev);\n\n\t/* Setup HW API */\n\tmemcpy(&hw->mac.ops, ii->mac_ops, sizeof(hw->mac.ops));\n\thw->mac.type  = ii->mac;\n\n\tmemcpy(&hw->mbx.ops, &ixgbevf_mbx_ops,\n\t       sizeof(struct ixgbe_mbx_operations));\n\n\t/* setup the private structure */\n\terr = ixgbevf_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\t/* The HW MAC address was set and/or determined in sw_init */\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tpr_err("invalid MAC address\\n");\n\t\terr = -EIO;\n\t\tgoto err_sw_init;\n\t}\n\n\tnetdev->hw_features = NETIF_F_SG |\n\t\t\t      NETIF_F_TSO |\n\t\t\t      NETIF_F_TSO6 |\n\t\t\t      NETIF_F_RXCSUM |\n\t\t\t      NETIF_F_HW_CSUM |\n\t\t\t      NETIF_F_SCTP_CRC;\n\n#define IXGBEVF_GSO_PARTIAL_FEATURES (NETIF_F_GSO_GRE | \\\n\t\t\t\t      NETIF_F_GSO_GRE_CSUM | \\\n\t\t\t\t      NETIF_F_GSO_IPXIP4 | \\\n\t\t\t\t      NETIF_F_GSO_IPXIP6 | \\\n\t\t\t\t      NETIF_F_GSO_UDP_TUNNEL | \\\n\t\t\t\t      NETIF_F_GSO_UDP_TUNNEL_CSUM)\n\n\tnetdev->gso_partial_features = IXGBEVF_GSO_PARTIAL_FEATURES;\n\tnetdev->hw_features |= NETIF_F_GSO_PARTIAL |\n\t\t\t       IXGBEVF_GSO_PARTIAL_FEATURES;\n\n\tnetdev->features = netdev->hw_features;\n\n\tif (pci_using_dac)\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\n\tnetdev->vlan_features |= netdev->features | NETIF_F_TSO_MANGLEID;\n\tnetdev->mpls_features |= NETIF_F_SG |\n\t\t\t\t NETIF_F_TSO |\n\t\t\t\t NETIF_F_TSO6 |\n\t\t\t\t NETIF_F_HW_CSUM;\n\tnetdev->mpls_features |= IXGBEVF_GSO_PARTIAL_FEATURES;\n\tnetdev->hw_enc_features |= netdev->vlan_features;\n\n\t/* set this bit last since it cannot be part of vlan_features */\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t/* MTU range: 68 - 1504 or 9710 */\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tswitch (adapter->hw.api_version) {\n\tcase ixgbe_mbox_api_11:\n\tcase ixgbe_mbox_api_12:\n\tcase ixgbe_mbox_api_13:\n\t\tnetdev->max_mtu = IXGBE_MAX_JUMBO_FRAME_SIZE -\n\t\t\t\t  (ETH_HLEN + ETH_FCS_LEN);\n\t\tbreak;\n\tdefault:\n\t\tif (adapter->hw.mac.type != ixgbe_mac_82599_vf)\n\t\t\tnetdev->max_mtu = IXGBE_MAX_JUMBO_FRAME_SIZE -\n\t\t\t\t\t  (ETH_HLEN + ETH_FCS_LEN);\n\t\telse\n\t\t\tnetdev->max_mtu = ETH_DATA_LEN + ETH_FCS_LEN;\n\t\tbreak;\n\t}\n\n\tif (IXGBE_REMOVED(hw->hw_addr)) {\n\t\terr = -EIO;\n\t\tgoto err_sw_init;\n\t}\n\n\tsetup_timer(&adapter->service_timer, &ixgbevf_service_timer,\n\t\t    (unsigned long)adapter);\n\n\tINIT_WORK(&adapter->service_task, ixgbevf_service_task);\n\tset_bit(__IXGBEVF_SERVICE_INITED, &adapter->state);\n\tclear_bit(__IXGBEVF_SERVICE_SCHED, &adapter->state);\n\n\terr = ixgbevf_init_interrupt_scheme(adapter);\n\tif (err)\n	f
26170	1043	dapm_new_dai_link	sound/soc/soc-dapm.c	kcontrol	1	11	\N	\N	\tint i, ret;\n\tstruct snd_kcontrol *kcontrol;\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct snd_card *card = dapm->card->snd_card;\n\n\t/* create control for links with > 1 config */\n\tif (w->num_params <= 1)\n\t\treturn 0;\n\n\t/* add kcontrol */\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tkcontrol = snd_soc_cnew(&w->kcontrol_news[i], w,\n\t\t\t\t\tw->name, NULL);\n\t\tret = snd_ctl_add(card, kcontrol);\n	t
38090	477	b1dma_handle_rx	drivers/isdn/hardware/avm/b1dma.c	skb	1	11	\N	\N	\tavmctrl_info *cinfo = &card->ctrlinfo[0];\n\tavmcard_dmainfo *dma = card->dma;\n\tstruct capi_ctr *ctrl = &cinfo->capi_ctrl;\n\tstruct sk_buff *skb;\n\tvoid *p = dma->recvbuf.dmabuf + 4;\n\tu32 ApplId, MsgLen, DataB3Len, NCCI, WindowSize;\n\tu8 b1cmd =  _get_byte(&p);\n\n#ifdef AVM_B1DMA_DEBUG\n\tprintk(KERN_DEBUG "rx: 0x%x %lu\\n", b1cmd, (unsigned long)dma->recvlen);\n#endif\n\n\tswitch (b1cmd) {\n\tcase RECEIVE_DATA_B3_IND:\n\n\t\tApplId = (unsigned) _get_word(&p);\n\t\tMsgLen = _get_slice(&p, card->msgbuf);\n\t\tDataB3Len = _get_slice(&p, card->databuf);\n\n\t\tif (MsgLen < 30) { /* not CAPI 64Bit */\n\t\t\tmemset(card->msgbuf + MsgLen, 0, 30 - MsgLen);\n\t\t\tMsgLen = 30;\n\t\t\tCAPIMSG_SETLEN(card->msgbuf, 30);\n\t\t}\n\t\tif (!(skb = alloc_skb(DataB3Len + MsgLen, GFP_ATOMIC))) {\n\t\t\tprintk(KERN_ERR "%s: incoming packet dropped\\n",\n\t\t\t       card->name);\n\t\t} else {\n\t\t\tskb_put_data(skb, card->msgbuf, MsgLen);\n	t
24625	1173	destroy_component	drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c	rmsg->h.type	6	12	\N	\N	\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tVCHI_HELD_MSG_T rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_DESTROY;\n\tm.u.component_destroy.component_handle = component->handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_destroy),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n	t
33281	190	da9052_rtc_read_time	drivers/rtc/rtc-da9052.c	rtc_tm	6	12	\N	\N	\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\tuint8_t v[2][6];\n\tint idx = 1;\n\tint timeout = DA9052_GET_TIME_RETRIES;\n\n\tret = da9052_group_read(rtc->da9052, DA9052_COUNT_S_REG, 6, &v[0][0]);\n\tif (ret) {\n\t\trtc_err(rtc, "Failed to read RTC time : %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tret = da9052_group_read(rtc->da9052,\n\t\t\t\t\tDA9052_COUNT_S_REG, 6, &v[idx][0]);\n\t\tif (ret) {\n\t\t\trtc_err(rtc, "Failed to read RTC time : %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(&v[0][0], &v[1][0], 6) == 0) {\n\t\t\trtc_tm->tm_year = (v[0][5] & DA9052_RTC_YEAR) + 100;\n\t\t\trtc_tm->tm_mon  = (v[0][4] & DA9052_RTC_MONTH) - 1;\n\t\t\trtc_tm->tm_mday = v[0][3] & DA9052_RTC_DAY;\n\t\t\trtc_tm->tm_hour = v[0][2] & DA9052_RTC_HOUR;\n\t\t\trtc_tm->tm_min  = v[0][1] & DA9052_RTC_MIN;\n\t\t\trtc_tm->tm_sec  = v[0][0] & DA9052_RTC_SEC;\n\n\t\t\tret = rtc_valid_tm(rtc_tm);\n	t
57744	193	my3126_phy_reset	drivers/net/ethernet/chelsio/cxgb/my3126.c	val	8	12	\N	\N	\tu32 val;\n\n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~4;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n	t
56821	3901	btrfs_clone_files	fs/btrfs/ioctl.c	ret	1	11	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct inode *src = file_inode(file_src);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = fs_info->sb->s_blocksize;\n\tint same_inode = src == inode;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (file_src->f_path.mnt != file->f_path.mnt ||\n\t    src->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\treturn -EINVAL;\n\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!same_inode) {\n\t\tbtrfs_double_inode_lock(src, inode);\n\t} else {\n\t\tinode_lock(src);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n	f
38503	1121	debug_objects_replace_static_objects	lib/debugobjects.c	debug_objects_replace_static_objects_$__mptr112$obj	0	11	\N	\N	\tstruct debug_bucket *db = obj_hash;\n\tstruct hlist_node *tmp;\n\tstruct debug_obj *obj, *new;\n\tHLIST_HEAD(objects);\n\tint i, cnt = 0;\n\n\tfor (i = 0; i < ODEBUG_POOL_SIZE; i++) {\n\t\tobj = kmem_cache_zalloc(obj_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\tgoto free;\n\t\tkmemleak_ignore(obj);\n\t\thlist_add_head(&obj->node, &objects);\n\t}\n\n\t/*\n\t * When debug_objects_mem_init() is called we know that only\n\t * one CPU is up, so disabling interrupts is enough\n\t * protection. This avoids the lockdep hell of lock ordering.\n\t */\n\tlocal_irq_disable();\n\n\t/* Remove the statically allocated objects from the pool */\n\thlist_for_each_entry_safe(obj, tmp, &obj_pool, node)\n\t\thlist_del(&obj->node);\n\t/* Move the allocated objects to the pool */\n\thlist_move_list(&objects, &obj_pool);\n\n\t/* Replace the active object references */\n\tfor (i = 0; i < ODEBUG_HASH_SIZE; i++, db++) {\n\t\thlist_move_list(&db->list, &objects);\n\n\t\thlist_for_each_entry(obj, &objects, node) {\n\t\t\tnew = hlist_entry(obj_pool.first, typeof(*obj), node);\n\t\t\thlist_del(&new->node);\n\t\t\t/* copy object data */\n\t\t\t*new = *obj;\n\t\t\thlist_add_head(&new->node, &db->list);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\tpr_debug("%d of %d active objects replaced\\n",\n\t\t cnt, obj_pool_used);\n\treturn 0;\nfree:\n\thlist_for_each_entry_safe(obj, tmp, &objects, node) {\n	t
25010	817	lstcon_group_info	drivers/staging/lustre/lnet/selftest/console.c	lstcon_group_info_$__mptr$obj	0	11	\N	\N	\tstruct lstcon_ndlist_ent *gentp;\n\tstruct lstcon_group *grp;\n\tstruct lstcon_ndlink *ndl;\n\tint rc;\n\n\trc = lstcon_group_find(name, &grp);\n\tif (rc) {\n\t\tCDEBUG(D_NET, "Can't find group %s\\n", name);\n\t\treturn rc;\n\t}\n\n\tif (dents_up) {\n\t\t/* verbose query */\n\t\trc = lstcon_nodes_getent(&grp->grp_ndl_list,\n\t\t\t\t\t index_p, count_p, dents_up);\n\t\tlstcon_group_decref(grp);\n\n\t\treturn rc;\n\t}\n\n\t/* non-verbose query */\n\tLIBCFS_ALLOC(gentp, sizeof(struct lstcon_ndlist_ent));\n\tif (!gentp) {\n\t\tCERROR("Can't allocate ndlist_ent\\n");\n\t\tlstcon_group_decref(grp);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(ndl, &grp->grp_ndl_list, ndl_link)\n	t
4350	6458	get_strength	drivers/media/dvb-frontends/drxk_hard.c	get_strength_$scu_lvl$obj$add$%scu_coc$obj	0	11	\N	\N	\tint status;\n\tstruct s_cfg_agc   rf_agc, if_agc;\n\tu32          total_gain  = 0;\n\tu32          atten      = 0;\n\tu32          agc_range   = 0;\n\tu16            scu_lvl  = 0;\n\tu16            scu_coc  = 0;\n\t/* FIXME: those are part of the tuner presets */\n\tu16 tuner_rf_gain         = 50; /* Default value on az6007 driver */\n\tu16 tuner_if_gain         = 40; /* Default value on az6007 driver */\n\n\t*strength = 0;\n\n\tif (is_dvbt(state)) {\n\t\trf_agc = state->m_dvbt_rf_agc_cfg;\n\t\tif_agc = state->m_dvbt_if_agc_cfg;\n\t} else if (is_qam(state)) {\n\t\trf_agc = state->m_qam_rf_agc_cfg;\n\t\tif_agc = state->m_qam_if_agc_cfg;\n\t} else {\n\t\trf_agc = state->m_atv_rf_agc_cfg;\n\t\tif_agc = state->m_atv_if_agc_cfg;\n\t}\n\n\tif (rf_agc.ctrl_mode == DRXK_AGC_CTRL_AUTO) {\n\t\t/* SCU output_level */\n\t\tstatus = read16(state, SCU_RAM_AGC_RF_IACCU_HI__A, &scu_lvl);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\t/* SCU c.o.c. */\n\t\tstatus = read16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, &scu_coc);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (((u32) scu_lvl + (u32) scu_coc) < 0xffff)\n	t
39680	6082	mvpp2_rx_refill	drivers/net/ethernet/marvell/mvpp2.c	phys_addr	2	-11	\N	\N	\tdma_addr_t dma_addr;\n\tphys_addr_t phys_addr;\n\tvoid *buf;\n\n\t/* No recycle or too many buffers are in use, so allocate a new skb */\n\tbuf = mvpp2_buf_alloc(port, bm_pool, &dma_addr, &phys_addr,\n\t\t\t      GFP_ATOMIC);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmvpp2_bm_pool_put(port, pool, dma_addr, phys_addr);\n	t
29576	622	ov534_reg_write	drivers/media/usb/gspca/ov534.c	ret	1	11	\N	\N	\tstruct usb_device *udev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tPDEBUG(D_USBO, "SET 01 0000 %04x %02x", reg, val);\n\tgspca_dev->usb_buf[0] = val;\n\tret = usb_control_msg(udev,\n\t\t\t      usb_sndctrlpipe(udev, 0),\n\t\t\t      0x01,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\n\tif (ret < 0) {\n	t
34928	127	cw1200_request_irq	drivers/net/wireless/st/cw1200/cw1200_sdio.c	ret	6	12	\N	\N	\tint ret;\n\tu8 cccr;\n\n\tcccr = sdio_f0_readb(self->func, SDIO_CCCR_IENx, &ret);\n\tif (WARN_ON(ret))\n	t
48501	1326	do_compat_pselect	fs/select.c	ts.tv_sec	1	11	\N	\N	\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\tstruct timespec end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n	t
56226	144	dnv_handle_irq	drivers/tty/serial/8250/8250_mid.c	status	1	11	\N	\N	\tstruct mid8250 *mid = p->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int fisr = serial_port_in(p, INTEL_MID_UART_DNV_FISR);\n\tu32 status;\n\tint ret = 0;\n\tint err;\n\n\tif (fisr & BIT(2)) {\n\t\terr = hsu_dma_get_status(&mid->dma_chip, 1, &status);\n\t\tif (err > 0) {\n\t\t\tserial8250_rx_dma_flush(up);\n\t\t\tret |= 1;\n\t\t} else if (err == 0)\n\t\t\tret |= hsu_dma_do_irq(&mid->dma_chip, 1, status);\n	t
56846	1574	ieee80211_rx_mgmt_probe_req	net/mac80211/ibss.c	skb->data	1	11	\N	\N	\tstruct ieee80211_mgmt *mgmt = (void *)req->data;\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tint tx_last_beacon, len = req->len;\n\tstruct sk_buff *skb;\n\tstruct beacon_data *presp;\n\tu8 *pos, *end;\n\n\tsdata_assert_lock(sdata);\n\n\tpresp = rcu_dereference_protected(ifibss->presp,\n\t\t\t\t\t  lockdep_is_held(&sdata->wdev.mtx));\n\n\tif (ifibss->state != IEEE80211_IBSS_MLME_JOINED ||\n\t    len < 24 + 2 || !presp)\n\t\treturn;\n\n\ttx_last_beacon = drv_tx_last_beacon(local);\n\n\tibss_dbg(sdata,\n\t\t "RX ProbeReq SA=%pM DA=%pM BSSID=%pM (tx_last_beacon=%d)\\n",\n\t\t mgmt->sa, mgmt->da, mgmt->bssid, tx_last_beacon);\n\n\tif (!tx_last_beacon && is_multicast_ether_addr(mgmt->da))\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, ifibss->bssid) &&\n\t    !is_broadcast_ether_addr(mgmt->bssid))\n\t\treturn;\n\n\tend = ((u8 *) mgmt) + len;\n\tpos = mgmt->u.probe_req.variable;\n\tif (pos[0] != WLAN_EID_SSID ||\n\t    pos + 2 + pos[1] > end) {\n\t\tibss_dbg(sdata, "Invalid SSID IE in ProbeReq from %pM\\n",\n\t\t\t mgmt->sa);\n\t\treturn;\n\t}\n\tif (pos[1] != 0 &&\n\t    (pos[1] != ifibss->ssid_len ||\n\t     memcmp(pos + 2, ifibss->ssid, ifibss->ssid_len))) {\n\t\t/* Ignore ProbeReq for foreign SSID */\n\t\treturn;\n\t}\n\n\t/* Reply with ProbeResp */\n\tskb = dev_alloc_skb(local->tx_headroom + presp->head_len);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->tx_headroom);\n\tskb_put_data(skb, presp->head, presp->head_len);\n\n\tmemcpy(((struct ieee80211_mgmt *) skb->data)->da, mgmt->sa, ETH_ALEN);\n	f
58762	2210	t4_ethrx_handler	drivers/net/ethernet/chelsio/cxgb4/sge.c	t4_ethrx_handler_$skb$obj$2$obj	0	11	\N	\N	\tbool csum_ok;\n\tstruct sk_buff *skb;\n\tconst struct cpl_rx_pkt *pkt;\n\tstruct sge_eth_rxq *rxq = container_of(q, struct sge_eth_rxq, rspq);\n\tstruct adapter *adapter = q->adap;\n\tstruct sge *s = &q->adap->sge;\n\tint cpl_trace_pkt = is_t4(q->adap->params.chip) ?\n\t\t\t    CPL_TRACE_PKT : CPL_TRACE_PKT_T5;\n\tu16 err_vec;\n\tstruct port_info *pi;\n\tint ret = 0;\n\n\tif (unlikely(*(u8 *)rsp == cpl_trace_pkt))\n\t\treturn handle_trace_pkt(q->adap, si);\n\n\tpkt = (const struct cpl_rx_pkt *)rsp;\n\t/* Compressed error vector is enabled for T6 only */\n\tif (q->adap->params.tp.rx_pkt_encap)\n\t\terr_vec = T6_COMPR_RXERR_VEC_G(be16_to_cpu(pkt->err_vec));\n\telse\n\t\terr_vec = be16_to_cpu(pkt->err_vec);\n\n\tcsum_ok = pkt->csum_calc && !err_vec &&\n\t\t  (q->netdev->features & NETIF_F_RXCSUM);\n\tif ((pkt->l2info & htonl(RXF_TCP_F)) &&\n\t    (q->netdev->features & NETIF_F_GRO) && csum_ok && !pkt->ip_frag) {\n\t\tdo_gro(rxq, si, pkt);\n\t\treturn 0;\n\t}\n\n\tskb = cxgb4_pktgl_to_skb(si, RX_PKT_SKB_LEN, RX_PULL_LEN);\n\tif (unlikely(!skb)) {\n\t\tt4_pktgl_free(si);\n\t\trxq->stats.rx_drops++;\n\t\treturn 0;\n\t}\n\tpi = netdev_priv(q->netdev);\n\n\t/* Handle PTP Event Rx packet */\n\tif (unlikely(pi->ptp_enable)) {\n\t\tret = t4_rx_hststamp(adapter, rsp, rxq, skb);\n\t\tif (ret == RX_PTP_PKT_ERR)\n\t\t\treturn 0;\n\t}\n\tif (likely(!ret))\n\t\t__skb_pull(skb, s->pktshift); /* remove ethernet header pad */\n\n\t/* Handle the PTP Event Tx Loopback packet */\n\tif (unlikely(pi->ptp_enable && !ret &&\n\t\t     (pkt->l2info & htonl(RXF_UDP_F)) &&\n\t\t     cxgb4_ptp_is_ptp_rx(skb))) {\n\t\tif (!t4_tx_hststamp(adapter, skb, q->netdev))\n\t\t\treturn 0;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, q->netdev);\n\tskb_record_rx_queue(skb, q->idx);\n\tif (skb->dev->features & NETIF_F_RXHASH)\n	t
-237	164	iproc_adc_interrupt_thread	drivers/iio/adc/bcm_iproc_adc.c	instr_mask	5	20	\N	\N	\tu32 channel_intr_status;\n\tu32 intr_status;\n\tu32 intr_mask;\n\tstruct iio_dev *indio_dev = data;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\t/*\n\t * This interrupt is shared with the touchscreen driver.\n\t * Make sure this interrupt is intended for us.\n\t * Handle only ADC channel specific interrupts.\n\t */\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &intr_mask);\n\tintr_status = intr_status & intr_mask;\n\tchannel_intr_status = (intr_status & IPROC_ADC_INTR_MASK) >>\n\t\t\t\tIPROC_ADC_INTR;\n\tif (channel_intr_status)\n	f
25426	253	oprofilefs_fill_super	drivers/oprofile/oprofilefs.c	root_inode	1	11	\N	\N	\tstruct inode *root_inode;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = OPROFILEFS_MAGIC;\n\tsb->s_op = &s_ops;\n\tsb->s_time_gran = 1;\n\n\troot_inode = oprofilefs_get_inode(sb, S_IFDIR | 0755);\n\tif (!root_inode)\n\t\treturn -ENOMEM;\n\troot_inode->i_op = &simple_dir_inode_operations;\n\troot_inode->i_fop = &simple_dir_operations;\n\tsb->s_root = d_make_root(root_inode);\n	t
53065	1132	mtk_jpeg_probe	drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c	jpeg	6	12	\N	\N	\tstruct mtk_jpeg_dev *jpeg;\n\tstruct resource *res;\n\tint dec_irq;\n\tint ret;\n\n\tjpeg = devm_kzalloc(&pdev->dev, sizeof(*jpeg), GFP_KERNEL);\n\tif (!jpeg)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&jpeg->lock);\n\tspin_lock_init(&jpeg->hw_lock);\n\tjpeg->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tjpeg->dec_reg_base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(jpeg->dec_reg_base)) {\n\t\tret = PTR_ERR(jpeg->dec_reg_base);\n\t\treturn ret;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tdec_irq = platform_get_irq(pdev, 0);\n\tif (!res || dec_irq < 0) {\n\t\tdev_err(&pdev->dev, "Failed to get dec_irq %d.\\n", dec_irq);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, dec_irq, mtk_jpeg_dec_irq, 0,\n\t\t\t       pdev->name, jpeg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "Failed to request dec_irq %d (%d)\\n",\n\t\t\tdec_irq, ret);\n\t\tret = -EINVAL;\n\t\tgoto err_req_irq;\n\t}\n\n\tret = mtk_jpeg_clk_init(jpeg);\n	t
57094	37	trace_event_raw_event_consume_skb	net/core/net-traces.c	CONFIG_IPV6	0	11	\N	\N	\N	t
53238	117	fat_alloc_new_dir	fs/fat/dir.c	bh	1	11	\N	\N	\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tif (*bh)\n\t\tbrelse(*bh);\n\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0, false);\n\tif (err || !phys)\n\t\treturn -1;\t/* beyond EOF or error */\n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t"Directory bread(block %llu) failed", (llu)phys);\n\t\t/* skip this block */\n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n	t
59139	404	ch341_set_termios	drivers/usb/serial/ch341.c	r	1	11	\N	\N	\tstruct ch341_private *priv = usb_get_serial_port_data(port);\n\tunsigned baud_rate;\n\tunsigned long flags;\n\tu8 lcr;\n\tint r;\n\n\t/* redundant changes may cause the chip to lose bytes */\n\tif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\n\t\treturn;\n\n\tbaud_rate = tty_get_baud_rate(tty);\n\n\tlcr = CH341_LCR_ENABLE_RX | CH341_LCR_ENABLE_TX;\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\t\tlcr |= CH341_LCR_CS5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr |= CH341_LCR_CS6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr |= CH341_LCR_CS7;\n\t\tbreak;\n\tcase CS8:\n\t\tlcr |= CH341_LCR_CS8;\n\t\tbreak;\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\tlcr |= CH341_LCR_ENABLE_PAR;\n\t\tif (C_PARODD(tty) == 0)\n\t\t\tlcr |= CH341_LCR_PAR_EVEN;\n\t\tif (C_CMSPAR(tty))\n\t\t\tlcr |= CH341_LCR_MARK_SPACE;\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tlcr |= CH341_LCR_STOP_BITS_2;\n\n\tif (baud_rate) {\n\t\tpriv->baud_rate = baud_rate;\n\n\t\tr = ch341_set_baudrate_lcr(port->serial->dev, priv, lcr);\n\t\tif (r < 0 && old_termios) {\n	t
26575	239	jhead_scan	fs/gfs2/recovery.c	head->lh_sequence	1	11	\N	\N	\tunsigned int blk = head->lh_blkno;\n\tstruct gfs2_log_header_host lh;\n\tint error;\n\n\tfor (;;) {\n\t\tif (++blk == jd->jd_blocks)\n\t\t\tblk = 0;\n\n\t\terror = get_log_header(jd, blk, &lh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 1)\n\t\t\tcontinue;\n\n\t\tif (lh.lh_sequence == head->lh_sequence) {\n	t
35304	323	mt7601u_bbp_temp	drivers/net/wireless/mediatek/mt7601u/phy.c	ret	1	11	\N	\N	\tconst struct reg_table *t;\n\tint ret;\n\n\tif (dev->temp_mode == mode)\n\t\treturn 0;\n\n\tdev->temp_mode = mode;\n\ttrace_temp_mode(dev, mode);\n\n\tt = bbp_mode_table[dev->temp_mode];\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t      t[2].regs, t[2].n);\n\tif (ret)\n	t
36714	595	do_coredump	fs/coredump.c	&cn	1	11	\N	\N	\tstruct core_state core_state;\n\tstruct core_name cn;\n\tstruct mm_struct *mm = current->mm;\n\tstruct linux_binfmt * binfmt;\n\tconst struct cred *old_cred;\n\tstruct cred *cred;\n\tint retval = 0;\n\tint ispipe;\n\tstruct files_struct *displaced;\n\t/* require nonrelative corefile path and be extra careful */\n\tbool need_suid_safe = false;\n\tbool core_dumped = false;\n\tstatic atomic_t core_dump_count = ATOMIC_INIT(0);\n\tstruct coredump_params cprm = {\n\t\t.siginfo = siginfo,\n\t\t.regs = signal_pt_regs(),\n\t\t.limit = rlimit(RLIMIT_CORE),\n\t\t/*\n\t\t * We must use the same mm->flags while dumping core to avoid\n\t\t * inconsistency of bit flags, since this flag is not protected\n\t\t * by any locks.\n\t\t */\n\t\t.mm_flags = mm->flags,\n\t};\n\n\taudit_core_dumps(siginfo->si_signo);\n\n\tbinfmt = mm->binfmt;\n\tif (!binfmt || !binfmt->core_dump)\n\t\tgoto fail;\n\tif (!__get_dumpable(cprm.mm_flags))\n\t\tgoto fail;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\tgoto fail;\n\t/*\n\t * We cannot trust fsuid as being the "true" uid of the process\n\t * nor do we know its entire history. We only know it was tainted\n\t * so we dump it as root in mode 2, and only into a controlled\n\t * environment (pipe handler or fully qualified path).\n\t */\n\tif (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {\n\t\t/* Setuid core dump mode */\n\t\tcred->fsuid = GLOBAL_ROOT_UID;\t/* Dump root private */\n\t\tneed_suid_safe = true;\n\t}\n\n\tretval = coredump_wait(siginfo->si_signo, &core_state);\n\tif (retval < 0)\n\t\tgoto fail_creds;\n\n\told_cred = override_creds(cred);\n\n\tispipe = format_corename(&cn, &cprm);\n	t
40212	300	twl_direction_in	drivers/gpio/gpio-twl4030.c	ret	1	11	\N	\N	\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tif (offset < TWL4030_GPIO_MAX)\n\t\tret = twl4030_set_gpio_direction(offset, 1);\n\telse\n\t\tret = -EINVAL;\t/* LED outputs can't be set as input */\n\n\tif (!ret)\n	t
44167	2543	ath10k_wmi_tlv_op_gen_pktlog_enable	drivers/net/wireless/ath/ath10k/wmi-tlv.c	tlv->tag	1	11	\N	\N	\tstruct wmi_tlv_pktlog_enable *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_PKTLOG_ENABLE_CMD);\n	t
48041	351	snd_ivtv_pcm_create	drivers/media/pci/ivtv/ivtv-alsa-pcm.c	sp->info_flags	1	11	\N	\N	\tstruct snd_pcm *sp;\n\tstruct snd_card *sc = itvsc->sc;\n\tstruct v4l2_device *v4l2_dev = itvsc->v4l2_dev;\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tint ret;\n\n\tret = snd_pcm_new(sc, "CX2341[56] PCM",\n\t\t\t  0, /* PCM device 0, the only one for this card */\n\t\t\t  0, /* 0 playback substreams */\n\t\t\t  1, /* 1 capture substream */\n\t\t\t  &sp);\n\tif (ret) {\n\t\tIVTV_ALSA_ERR("%s: snd_ivtv_pcm_create() failed with err %d\\n",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit;\n\t}\n\n\tspin_lock_init(&itvsc->slock);\n\n\tsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_ivtv_pcm_capture_ops);\n\tsp->info_flags = 0;\n	t
57076	478	i40iw_vchnl_recv_pf	drivers/infiniband/hw/i40iw/i40iw_virtchnl.c	vf_dev->stats_initialized	1	11	\N	\N	\tstruct i40iw_virtchnl_op_buf *vchnl_msg = (struct i40iw_virtchnl_op_buf *)msg;\n\tstruct i40iw_vfdev *vf_dev = NULL;\n\tstruct i40iw_hmc_fcn_info hmc_fcn_info;\n\tu16 iw_vf_idx;\n\tu16 first_avail_iw_vf = I40IW_MAX_PE_ENABLED_VF_COUNT;\n\tstruct i40iw_virt_mem vf_dev_mem;\n\tstruct i40iw_virtchnl_work_info work_info;\n\tstruct i40iw_vsi_pestat *stats;\n\tenum i40iw_status_code ret_code;\n\n\tif (!dev || !msg || !len)\n\t\treturn I40IW_ERR_PARAM;\n\n\tif (!dev->vchnl_up)\n\t\treturn I40IW_ERR_NOT_READY;\n\tif (vchnl_msg->iw_op_code == I40IW_VCHNL_OP_GET_VER) {\n\t\tvchnl_pf_send_get_ver_resp(dev, vf_id, vchnl_msg);\n\t\treturn I40IW_SUCCESS;\n\t}\n\tfor (iw_vf_idx = 0; iw_vf_idx < I40IW_MAX_PE_ENABLED_VF_COUNT; iw_vf_idx++) {\n\t\tif (!dev->vf_dev[iw_vf_idx]) {\n\t\t\tif (first_avail_iw_vf == I40IW_MAX_PE_ENABLED_VF_COUNT)\n\t\t\t\tfirst_avail_iw_vf = iw_vf_idx;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dev->vf_dev[iw_vf_idx]->vf_id == vf_id) {\n\t\t\tvf_dev = dev->vf_dev[iw_vf_idx];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (vf_dev) {\n\t\tif (!vf_dev->msg_count) {\n\t\t\tvf_dev->msg_count++;\n\t\t} else {\n\t\t\ti40iw_debug(dev, I40IW_DEBUG_VIRT,\n\t\t\t\t    "VF%u already has a channel message in progress.\\n",\n\t\t\t\t    vf_id);\n\t\t\treturn I40IW_SUCCESS;\n\t\t}\n\t}\n\tswitch (vchnl_msg->iw_op_code) {\n\tcase I40IW_VCHNL_OP_GET_HMC_FCN:\n\t\tif (!vf_dev &&\n\t\t    (first_avail_iw_vf != I40IW_MAX_PE_ENABLED_VF_COUNT)) {\n\t\t\tret_code = i40iw_allocate_virt_mem(dev->hw, &vf_dev_mem, sizeof(struct i40iw_vfdev) +\n\t\t\t\t\t\t\t   (sizeof(struct i40iw_hmc_obj_info) * I40IW_HMC_IW_MAX));\n\t\t\tif (!ret_code) {\n\t\t\t\tvf_dev = vf_dev_mem.va;\n\t\t\t\tvf_dev->stats_initialized = false;\n	t
51672	1238	ctnetlink_get_conntrack	net/netfilter/nf_conntrack_netlink.c	ct	1	11	\N	\N	\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conn *ct;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\n\tu_int8_t u3 = nfmsg->nfgen_family;\n\tstruct nf_conntrack_zone zone;\n\tint err;\n\n\tif (nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnetlink_dump_table,\n\t\t\t.done = ctnetlink_done,\n\t\t};\n\n\t\tif (cda[CTA_MARK] && cda[CTA_MARK_MASK]) {\n\t\t\tstruct ctnetlink_filter *filter;\n\n\t\t\tfilter = ctnetlink_alloc_filter(cda);\n\t\t\tif (IS_ERR(filter))\n\t\t\t\treturn PTR_ERR(filter);\n\n\t\t\tc.data = filter;\n\t\t}\n\t\treturn netlink_dump_start(ctnl, skb, nlh, &c);\n\t}\n\n\terr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_TUPLE_ORIG])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_ORIG,\n\t\t\t\t\t    u3, &zone);\n\telse if (cda[CTA_TUPLE_REPLY])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_REPLY,\n\t\t\t\t\t    u3, &zone);\n\telse\n\t\treturn -EINVAL;\n\n\tif (err < 0)\n\t\treturn err;\n\n\th = nf_conntrack_find_get(net, &zone, &tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\terr = -ENOMEM;\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb2 == NULL) {\n\t\tnf_ct_put(ct);\n	t
43874	367	ceph_parse_options	net/ceph/ceph_common.c	s	1	13	\N	\N	\tstruct ceph_options *opt;\n\tconst char *c;\n\tint err = -ENOMEM;\n\tsubstring_t argstr[MAX_OPT_ARGS];\n\n\topt = kzalloc(sizeof(*opt), GFP_KERNEL);\n\tif (!opt)\n\t\treturn ERR_PTR(-ENOMEM);\n\topt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),\n\t\t\t\tGFP_KERNEL);\n\tif (!opt->mon_addr)\n\t\tgoto out;\n\n\tdout("parse_options %p options '%s' dev_name '%s'\\n", opt, options,\n\t     dev_name);\n\n\t/* start with defaults */\n\topt->flags = CEPH_OPT_DEFAULT;\n\topt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;\n\topt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;\n\topt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;\n\topt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;\n\n\t/* get mon ip(s) */\n	f
1802	1335	ll_rw_extents_stats_pp_seq_show	drivers/staging/lustre/lustre/llite/lproc_llite.c	ll_rw_extents_stats_pp_seq_show_$now$1$obj	0	11	\N	\N	\tstruct timespec64 now;\n\tstruct ll_sb_info *sbi = seq->private;\n\tstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\n\tint k;\n\n\tktime_get_real_ts64(&now);\n\n\tif (!sbi->ll_rw_stats_on) {\n\t\tseq_printf(seq, "disabled\\n"\n\t\t\t   "write anything in this file to activate, then 0 or \\"[D/d]isabled\\" to deactivate\\n");\n\t\treturn 0;\n\t}\n\tseq_printf(seq, "snapshot_time:\t %llu.%09lu (secs.usecs)\\n",\n	t
33291	306	tx_device_task	drivers/staging/ks7010/ks7010_sdio.c	ret	1	11	\N	\N	\tstruct tx_device_buffer *sp;\n\tint ret;\n\n\tDPRINTK(4, "\\n");\n\tif (cnt_txqbody(priv) <= 0 ||\n\t    atomic_read(&priv->psstatus.status) == PS_SNOOZE)\n\t\treturn;\n\n\tsp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];\n\tif (priv->dev_state >= DEVICE_STATE_BOOT) {\n\t\tret = write_to_device(priv, sp->sendp, sp->size);\n\t\tif (ret) {\n	t
-411	564	opti82c46x_set_piomode	drivers/ata/pata_legacy.c	&tp	2	3	\N	\N	\tu8 active, recover, setup;\n\tstruct ata_timing t;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint clock;\n\tint khz[4] = { 50000, 40000, 33000, 25000 };\n\tu8 rc;\n\tu8 sysclk;\n\n\t/* Get the clock */\n\tsysclk = (opti_syscfg(0xAC) & 0xC0) >> 6;\t/* BIOS set */\n\n\t/* Enter configuration mode */\n\tioread16(ap->ioaddr.error_addr);\n\tioread16(ap->ioaddr.error_addr);\n\tiowrite8(3, ap->ioaddr.nsect_addr);\n\n\t/* Read VLB clock strapping */\n\tclock = 1000000000 / khz[sysclk];\n\n\t/* Get the timing data in cycles */\n\tata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\n\n\t/* Setup timing is shared */\n\tif (pair) {\n\t\tstruct ata_timing tp;\n\t\tata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\n\n\t\tata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\n	f
59341	546	osc_deviation	drivers/media/pci/ngene/ngene-cards.c	data	1	13	\N	\N	\tstruct ngene_channel *chan = priv;\n\tstruct i2c_adapter *adap = &chan->i2c_adapter;\n\tu16 data = 0;\n\n\tif (flag) {\n\t\tdata = (u16) deviation;\n\t\tpr_info(DEVICE_NAME ": write deviation %d\\n",\n\t\t       deviation);\n\t\teeprom_write_ushort(adap, 0x1000 + chan->number, data);\n\t} else {\n\t\tif (eeprom_read_ushort(adap, 0x1000 + chan->number, &data))\n\t\t\tdata = 0;\n\t\tpr_info(DEVICE_NAME ": read deviation %d\\n",\n	f
-208	454	meson_sar_adc_lock	drivers/iio/adc/meson_saradc.c	val	4	20	\N	\N	\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint val, timeout = 10000;\n\n\tmutex_lock(&indio_dev->mlock);\n\n\tif (priv->data->has_bl30_integration) {\n\t\t/* prevent BL30 from using the SAR ADC while we are using it */\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t\tMESON_SAR_ADC_DELAY_KERNEL_BUSY,\n\t\t\t\tMESON_SAR_ADC_DELAY_KERNEL_BUSY);\n\n\t\t/*\n\t\t * wait until BL30 releases it's lock (so we can use the SAR\n\t\t * ADC)\n\t\t */\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tregmap_read(priv->regmap, MESON_SAR_ADC_DELAY, &val);\n\t\t} while (val & MESON_SAR_ADC_DELAY_BL30_BUSY && timeout--);\n	f
57225	159	_aead_recvmsg	crypto/algif_aead.c	err	1	11	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct aead_tfm *aeadc = pask->private;\n\tstruct crypto_aead *tfm = aeadc->aead;\n\tstruct crypto_skcipher *null_tfm = aeadc->null_tfm;\n\tunsigned int as = crypto_aead_authsize(tfm);\n\tstruct af_alg_async_req *areq;\n\tstruct af_alg_tsgl *tsgl;\n\tstruct scatterlist *src;\n\tint err = 0;\n\tsize_t used = 0;\t\t/* [in]  TX bufs to be en/decrypted */\n\tsize_t outlen = 0;\t\t/* [out] RX bufs produced by kernel */\n\tsize_t usedpages = 0;\t\t/* [in]  RX bufs to be used from user */\n\tsize_t processed = 0;\t\t/* [in]  TX bufs to be consumed */\n\n\t/*\n\t * Data length provided by caller via sendmsg/sendpage that has not\n\t * yet been processed.\n\t */\n\tused = ctx->used;\n\n\t/*\n\t * Make sure sufficient data is present -- note, the same check is\n\t * is also present in sendmsg/sendpage. The checks in sendpage/sendmsg\n\t * shall provide an information to the data sender that something is\n\t * wrong, but they are irrelevant to maintain the kernel integrity.\n\t * We need this check here too in case user space decides to not honor\n\t * the error message in sendmsg/sendpage and still call recvmsg. This\n\t * check here protects the kernel integrity.\n\t */\n\tif (!aead_sufficient_data(sk))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Calculate the minimum output buffer size holding the result of the\n\t * cipher operation. When encrypting data, the receiving buffer is\n\t * larger by the tag length compared to the input buffer as the\n\t * encryption operation generates the tag. For decryption, the input\n\t * buffer provides the tag which is consumed resulting in only the\n\t * plaintext without a buffer for the tag returned to the caller.\n\t */\n\tif (ctx->enc)\n\t\toutlen = used + as;\n\telse\n\t\toutlen = used - as;\n\n\t/*\n\t * The cipher operation input data is reduced by the associated data\n\t * length as this data is processed separately later on.\n\t */\n\tused -= ctx->aead_assoclen;\n\n\t/* Allocate cipher request for current operation. */\n\tareq = af_alg_alloc_areq(sk, sizeof(struct af_alg_async_req) +\n\t\t\t\t     crypto_aead_reqsize(tfm));\n\tif (IS_ERR(areq))\n\t\treturn PTR_ERR(areq);\n\n\t/* convert iovecs of output buffers into RX SGL */\n\terr = af_alg_get_rsgl(sk, msg, flags, areq, outlen, &usedpages);\n\tif (err)\n	f
57120	132	bert_init	drivers/acpi/apei/bert.c	region_len	1	11	\N	\N	\tstruct apei_resources bert_resources;\n\tstruct acpi_bert_region *boot_error_region;\n\tstruct acpi_table_bert *bert_tab;\n\tunsigned int region_len;\n\tacpi_status status;\n\tint rc = 0;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tif (bert_disable) {\n\t\tpr_info("Boot Error Record Table support is disabled.\\n");\n\t\treturn 0;\n\t}\n\n\tstatus = acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab);\n\tif (status == AE_NOT_FOUND)\n\t\treturn 0;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err("get table failed, %s.\\n", acpi_format_exception(status));\n\t\treturn -EINVAL;\n\t}\n\n\trc = bert_check_table(bert_tab);\n\tif (rc) {\n\t\tpr_err(FW_BUG "table invalid.\\n");\n\t\treturn rc;\n\t}\n\n\tregion_len = bert_tab->region_length;\n\tapei_resources_init(&bert_resources);\n\trc = apei_resources_add(&bert_resources, bert_tab->address,\n	t
35254	3597	enable_MAC	drivers/net/wireless/cisco/airo.c	enable_MAC_$rsp$3$obj	0	11	\N	\N	\tint rc;\n\tCmd cmd;\n\tResp rsp;\n\n\t/* FLAG_RADIO_OFF : Radio disabled via /proc or Wireless Extensions\n\t * FLAG_RADIO_DOWN : Radio disabled via "ifconfig ethX down"\n\t * Note : we could try to use !netif_running(dev) in enable_MAC()\n\t * instead of this flag, but I don't trust it *within* the\n\t * open/close functions, and testing both flags together is\n\t * "cheaper" - Jean II */\n\tif (ai->flags & FLAG_RADIO_MASK) return SUCCESS;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (!test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_ENABLE;\n\t\trc = issuecommand(ai, &cmd, &rsp);\n\t\tif (rc == SUCCESS)\n\t\t\tset_bit(FLAG_ENABLED, &ai->flags);\n\t} else\n\t\trc = SUCCESS;\n\n\tif (lock)\n\t    up(&ai->sem);\n\n\tif (rc)\n\t\tairo_print_err(ai->dev->name, "Cannot enable MAC");\n\telse if ((rsp.status & 0xFF00) != 0) {\n\t\tairo_print_err(ai->dev->name, "Bad MAC enable reason=%x, "\n	t
-226	165	mdio_sc_cfg_reg_write	drivers/net/ethernet/hisilicon/hns_mdio.c	reg_value	5	20	\N	\N	\tu32 time_cnt;\n\tu32 reg_value;\n\n\tregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\n\n\tfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\n\t\tregmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\n\t\treg_value &= st_msk;\n\t\tif ((!!check_st) == (!!reg_value))\n	f
32248	603	amdgpu_atombios_encoder_setup_dig_encoder	drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	frev	1	11	\N	\N	\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_device *adev = dev->dev_private;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\tstruct drm_connector *connector = amdgpu_get_connector_for_encoder(encoder);\n\tunion dig_encoder_control args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);\n\tuint8_t frev, crev;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint hpd_id = AMDGPU_HPD_NONE;\n\n\tif (connector) {\n\t\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\t\tstruct amdgpu_connector_atom_dig *dig_connector =\n\t\t\tamdgpu_connector->con_priv;\n\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\thpd_id = amdgpu_connector->hpd.hpd;\n\t}\n\n\t/* no dig encoder assigned */\n\tif (dig->dig_encoder == -1)\n\t\treturn;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n	t
32942	610	vlsi_fill_rx	drivers/staging/irda/drivers/vlsi_ir.c	rd->skb	1	11	\N	\N	\tstruct ring_descr *rd;\n\n\tfor (rd = ring_last(r); rd != NULL; rd = ring_put(r)) {\n\t\tif (rd_is_active(rd)) {\n\t\t\tnet_warn_ratelimited("%s: driver bug: rx descr race with hw\\n",\n\t\t\t\t\t     __func__);\n\t\t\tvlsi_ring_debug(r);\n\t\t\tbreak;\n\t\t}\n\t\tif (!rd->skb) {\n\t\t\trd->skb = dev_alloc_skb(IRLAP_SKB_ALLOCSIZE);\n\t\t\tif (rd->skb) {\n\t\t\t\tskb_reserve(rd->skb,1);\n	t
42776	2421	wm8996_micd	sound/soc/codecs/wm8996.c	val	1	11	\N	\N	\tstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\n\tint val, reg;\n\n\tval = snd_soc_read(codec, WM8996_MIC_DETECT_3);\n\n\tdev_dbg(codec->dev, "Microphone event: %x\\n", val);\n\n\tif (!(val & WM8996_MICD_VALID)) {\n\t\tdev_warn(codec->dev, "Microphone detection state invalid\\n");\n\t\treturn;\n\t}\n\n\t/* No accessory, reset everything and report removal */\n\tif (!(val & WM8996_MICD_STS)) {\n\t\tdev_dbg(codec->dev, "Jack removal detected\\n");\n\t\twm8996->jack_mic = false;\n\t\twm8996->detecting = true;\n\t\twm8996->jack_flips = 0;\n\t\tsnd_soc_jack_report(wm8996->jack, 0,\n\t\t\t\t    SND_JACK_LINEOUT | SND_JACK_HEADSET |\n\t\t\t\t    SND_JACK_BTN_0);\n\n\t\tsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\n\t\t\t\t    WM8996_MICD_RATE_MASK |\n\t\t\t\t    WM8996_MICD_BIAS_STARTTIME_MASK,\n\t\t\t\t    WM8996_MICD_RATE_MASK |\n\t\t\t\t    9 << WM8996_MICD_BIAS_STARTTIME_SHIFT);\n\t\treturn;\n\t}\n\n\t/* If the measurement is very high we've got a microphone,\n\t * either we just detected one or if we already reported then\n\t * we've got a button release event.\n\t */\n\tif (val & 0x400) {\n	t
48270	786	vfat_create	fs/fat/namei_vfat.c	sinfo.de	1	11	\N	\N	\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = current_time(dir);\n\terr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tdir->i_version++;\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n	t
-212	122	sii902x_connector_detect	drivers/gpu/drm/bridge/sii902x.c	status	5	20	\N	\N	\tstruct sii902x *sii902x = connector_to_sii902x(connector);\n\tunsigned int status;\n\n\tregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\n\n\treturn (status & SII902X_PLUGGED_STATUS) ?\n	f
-408	873	lan78xx_write_raw_otp	drivers/net/usb/lan78xx.c	buf	2	3	\N	\N	\tint i;\n\tint ret;\n\tu32 buf;\n\tunsigned long timeout;\n\n\tret = lan78xx_read_reg(dev, OTP_PWR_DN, &buf);\n\n\tif (buf & OTP_PWR_DN_PWRDN_N_) {\n	f
52451	866	xfs_trans_get_qoff_item	fs/xfs/xfs_trans_dquot.c	&q->qql_item	1	11	\N	\N	\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n	t
43360	525	mxl111sf_lg2160_frontend_attach	drivers/media/usb/dvb-usb-v2/mxl111sf.c	mxl111sf_lg2160_frontend_attach_$tmp42$obj	0	11	\N	\N	\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug("%s()\\n", __func__);\n\n\t/* save a pointer to the dvb_usb_device in device state */\n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err("set interface failed");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_TUNER_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n	t
55856	2738	drbd_adm_disconnect	drivers/block/drbd/drbd_nl.c	&adm_ctx	1	11	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tstruct disconnect_parms parms;\n\tstruct drbd_connection *connection;\n\tenum drbd_state_rv rv;\n\tenum drbd_ret_code retcode;\n\tint err;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_CONNECTION);\n	t
-248	804	ctrl_cx2341x_getv4lflags	drivers/media/usb/pvrusb2/pvrusb2-hdw.c	qctrl.flags	5	20	\N	\N	\tstruct v4l2_queryctrl qctrl;\n\tstruct pvr2_ctl_info *info;\n\tqctrl.id = cptr->info->v4l_id;\n\tcx2341x_ctrl_query(&cptr->hdw->enc_ctl_state,&qctrl);\n\t/* Strip out the const so we can adjust a function pointer.  It's\n\t   OK to do this here because we know this is a dynamically created\n\t   control, so the underlying storage for the info pointer is (a)\n\t   private to us, and (b) not in read-only storage.  Either we do\n\t   this or we significantly complicate the underlying control\n\t   implementation. */\n\tinfo = (struct pvr2_ctl_info *)(cptr->info);\n\tif (qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY) {\n	f
32586	1531	_scsih_display_sata_capabilities	drivers/scsi/mpt3sas/mpt3sas_scsih.c	_scsih_display_sata_capabilities_$flags$obj$and$16	0	11	\N	\N	\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tu16 flags;\n\tu32 device_info;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tpr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\\n",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tpr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\\n",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tflags = le16_to_cpu(sas_device_pg0.Flags);\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\n\tsdev_printk(KERN_INFO, sdev,\n	t
31434	4460	reshape_request	drivers/md/raid10.c	max_sectors	1	11	\N	\N	\t/* We simply copy at most one chunk (smallest of old and new)\n\t * at a time, possibly less if that exceeds RESYNC_PAGES,\n\t * or we hit a bad block or something.\n\t * This might mean we pause for normal IO in the middle of\n\t * a chunk, but that is not a problem as mddev->reshape_position\n\t * can record any location.\n\t *\n\t * If we will want to write to a location that isn't\n\t * yet recorded as 'safe' (i.e. in metadata on disk) then\n\t * we need to flush all reshape requests and update the metadata.\n\t *\n\t * When reshaping forwards (e.g. to more devices), we interpret\n\t * 'safe' as the earliest block which might not have been copied\n\t * down yet.  We divide this by previous stripe size and multiply\n\t * by previous stripe length to get lowest device offset that we\n\t * cannot write to yet.\n\t * We interpret 'sector_nr' as an address that we want to write to.\n\t * From this we use last_device_address() to find where we might\n\t * write to, and first_device_address on the  'safe' position.\n\t * If this 'next' write position is after the 'safe' position,\n\t * we must update the metadata to increase the 'safe' position.\n\t *\n\t * When reshaping backwards, we round in the opposite direction\n\t * and perform the reverse test:  next write position must not be\n\t * less than current safe position.\n\t *\n\t * In all this the minimum difference in data offsets\n\t * (conf->offset_diff - always positive) allows a bit of slack,\n\t * so next can be after 'safe', but not by more than offset_diff\n\t *\n\t * We need to prepare all the bios here before we start any IO\n\t * to ensure the size we choose is acceptable to all devices.\n\t * The means one for each copy for write-out and an extra one for\n\t * read-in.\n\t * We store the read-in bio in ->master_bio and the others in\n\t * ->devs[x].bio and ->devs[x].repl_bio.\n\t */\n\tstruct r10conf *conf = mddev->private;\n\tstruct r10bio *r10_bio;\n\tsector_t next, safe, last;\n\tint max_sectors;\n\tint nr_sectors;\n\tint s;\n\tstruct md_rdev *rdev;\n\tint need_flush = 0;\n\tstruct bio *blist;\n\tstruct bio *bio, *read_bio;\n\tint sectors_done = 0;\n\tstruct page **pages;\n\n\tif (sector_nr == 0) {\n\t\t/* If restarting in the middle, skip the initial sectors */\n\t\tif (mddev->reshape_backwards &&\n\t\t    conf->reshape_progress < raid10_size(mddev, 0, 0)) {\n\t\t\tsector_nr = (raid10_size(mddev, 0, 0)\n\t\t\t\t     - conf->reshape_progress);\n\t\t} else if (!mddev->reshape_backwards &&\n\t\t\t   conf->reshape_progress > 0)\n\t\t\tsector_nr = conf->reshape_progress;\n\t\tif (sector_nr) {\n\t\t\tmddev->curr_resync_completed = sector_nr;\n\t\t\tsysfs_notify(&mddev->kobj, NULL, "sync_completed");\n\t\t\t*skipped = 1;\n\t\t\treturn sector_nr;\n\t\t}\n\t}\n\n\t/* We don't use sector_nr to track where we are up to\n\t * as that doesn't work well for ->reshape_backwards.\n\t * So just use ->reshape_progress.\n\t */\n\tif (mddev->reshape_backwards) {\n\t\t/* 'next' is the earliest device address that we might\n\t\t * write to for this chunk in the new layout\n\t\t */\n\t\tnext = first_dev_address(conf->reshape_progress - 1,\n\t\t\t\t\t &conf->geo);\n\n\t\t/* 'safe' is the last device address that we might read from\n\t\t * in the old layout after a restart\n\t\t */\n\t\tsafe = last_dev_address(conf->reshape_safe - 1,\n\t\t\t\t\t&conf->prev);\n\n\t\tif (next + conf->offset_diff < safe)\n\t\t\tneed_flush = 1;\n\n\t\tlast = conf->reshape_progress - 1;\n\t\tsector_nr = last & ~(sector_t)(conf->geo.chunk_mask\n\t\t\t\t\t       & conf->prev.chunk_mask);\n\t\tif (sector_nr + RESYNC_BLOCK_SIZE/512 < last)\n\t\t\tsector_nr = last + 1 - RESYNC_BLOCK_SIZE/512;\n\t} else {\n\t\t/* 'next' is after the last device address that we\n\t\t * might write to for this chunk in the new layout\n\t\t */\n\t\tnext = last_dev_address(conf->reshape_progress, &conf->geo);\n\n\t\t/* 'safe' is the earliest device address that we might\n\t\t * read from in the old layout after a restart\n\t\t */\n\t\tsafe = first_dev_address(conf->reshape_safe, &conf->prev);\n\n\t\t/* Need to update metadata if 'next' might be beyond 'safe'\n\t\t * as that would possibly corrupt data\n\t\t */\n\t\tif (next > safe + conf->offset_diff)\n\t\t\tneed_flush = 1;\n\n\t\tsector_nr = conf->reshape_progress;\n\t\tlast  = sector_nr | (conf->geo.chunk_mask\n\t\t\t\t     & conf->prev.chunk_mask);\n\n\t\tif (sector_nr + RESYNC_BLOCK_SIZE/512 <= last)\n\t\t\tlast = sector_nr + RESYNC_BLOCK_SIZE/512 - 1;\n\t}\n\n\tif (need_flush ||\n\t    time_after(jiffies, conf->reshape_checkpoint + 10*HZ)) {\n\t\t/* Need to update reshape_position in metadata */\n\t\twait_barrier(conf);\n\t\tmddev->reshape_position = conf->reshape_progress;\n\t\tif (mddev->reshape_backwards)\n\t\t\tmddev->curr_resync_completed = raid10_size(mddev, 0, 0)\n\t\t\t\t- conf->reshape_progress;\n\t\telse\n\t\t\tmddev->curr_resync_completed = conf->reshape_progress;\n\t\tconf->reshape_checkpoint = jiffies;\n\t\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\t\tmd_wakeup_thread(mddev->thread);\n\t\twait_event(mddev->sb_wait, mddev->sb_flags == 0 ||\n\t\t\t   test_bit(MD_RECOVERY_INTR, &mddev->recovery));\n\t\tif (test_bit(MD_RECOVERY_INTR, &mddev->recovery)) {\n\t\t\tallow_barrier(conf);\n\t\t\treturn sectors_done;\n\t\t}\n\t\tconf->reshape_safe = mddev->reshape_position;\n\t\tallow_barrier(conf);\n\t}\n\nread_more:\n\t/* Now schedule reads for blocks from sector_nr to last */\n\tr10_bio = raid10_alloc_init_r10buf(conf);\n\tr10_bio->state = 0;\n\traise_barrier(conf, sectors_done != 0);\n\tatomic_set(&r10_bio->remaining, 0);\n\tr10_bio->mddev = mddev;\n\tr10_bio->sector = sector_nr;\n\tset_bit(R10BIO_IsReshape, &r10_bio->state);\n\tr10_bio->sectors = last - sector_nr + 1;\n\trdev = read_balance(conf, r10_bio, &max_sectors);\n\tBUG_ON(!test_bit(R10BIO_Previous, &r10_bio->state));\n\n\tif (!rdev) {\n\t\t/* Cannot read from here, so need to record bad blocks\n\t\t * on all the target devices.\n\t\t */\n\t\t// FIXME\n\t\tmempool_free(r10_bio, conf->r10buf_pool);\n\t\tset_bit(MD_RECOVERY_INTR, &mddev->recovery);\n\t\treturn sectors_done;\n\t}\n\n\tread_bio = bio_alloc_mddev(GFP_KERNEL, RESYNC_PAGES, mddev);\n\n\tbio_set_dev(read_bio, rdev->bdev);\n\tread_bio->bi_iter.bi_sector = (r10_bio->devs[r10_bio->read_slot].addr\n\t\t\t       + rdev->data_offset);\n\tread_bio->bi_private = r10_bio;\n\tread_bio->bi_end_io = end_reshape_read;\n\tbio_set_op_attrs(read_bio, REQ_OP_READ, 0);\n\tread_bio->bi_flags &= (~0UL << BIO_RESET_BITS);\n\tread_bio->bi_status = 0;\n\tread_bio->bi_vcnt = 0;\n\tread_bio->bi_iter.bi_size = 0;\n\tr10_bio->master_bio = read_bio;\n\tr10_bio->read_slot = r10_bio->devs[r10_bio->read_slot].devnum;\n\n\t/* Now find the locations in the new layout */\n\t__raid10_find_phys(&conf->geo, r10_bio);\n\n\tblist = read_bio;\n\tread_bio->bi_next = NULL;\n\n\trcu_read_lock();\n\tfor (s = 0; s < conf->copies*2; s++) {\n\t\tstruct bio *b;\n\t\tint d = r10_bio->devs[s/2].devnum;\n\t\tstruct md_rdev *rdev2;\n\t\tif (s&1) {\n\t\t\trdev2 = rcu_dereference(conf->mirrors[d].replacement);\n\t\t\tb = r10_bio->devs[s/2].repl_bio;\n\t\t} else {\n\t\t\trdev2 = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tb = r10_bio->devs[s/2].bio;\n\t\t}\n\t\tif (!rdev2 || test_bit(Faulty, &rdev2->flags))\n\t\t\tcontinue;\n\n\t\tbio_set_dev(b, rdev2->bdev);\n\t\tb->bi_iter.bi_sector = r10_bio->devs[s/2].addr +\n\t\t\trdev2->new_data_offset;\n\t\tb->bi_end_io = end_reshape_write;\n\t\tbio_set_op_attrs(b, REQ_OP_WRITE, 0);\n\t\tb->bi_next = blist;\n\t\tblist = b;\n\t}\n\n\t/* Now add as many pages as possible to all of these bios. */\n\n\tnr_sectors = 0;\n\tpages = get_resync_pages(r10_bio->devs[0].bio)->pages;\n\tfor (s = 0 ; s < max_sectors; s += PAGE_SIZE >> 9) {\n	t
33662	553	sh_dmae_chan_probe	drivers/dma/sh/shdmac.c	schan	1	11	\N	\N	\tconst struct sh_dmae_channel *chan_pdata = &shdev->pdata->channel[id];\n\tstruct shdma_dev *sdev = &shdev->shdma_dev;\n\tstruct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);\n\tstruct sh_dmae_chan *sh_chan;\n\tstruct shdma_chan *schan;\n\tint err;\n\n\tsh_chan = devm_kzalloc(sdev->dma_dev.dev, sizeof(struct sh_dmae_chan),\n\t\t\t       GFP_KERNEL);\n\tif (!sh_chan)\n\t\treturn -ENOMEM;\n\n\tschan = &sh_chan->shdma_chan;\n\tschan->max_xfer_len = SH_DMA_TCR_MAX + 1;\n\n\tshdma_chan_probe(sdev, schan, id);\n\n\tsh_chan->base = shdev->chan_reg + chan_pdata->offset;\n\n\t/* set up channel irq */\n\tif (pdev->id >= 0)\n\t\tsnprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),\n\t\t\t "sh-dmae%d.%d", pdev->id, id);\n\telse\n\t\tsnprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),\n\t\t\t "sh-dma%d", id);\n\n\terr = shdma_request_irq(schan, irq, flags, sh_chan->dev_id);\n	t
39062	6588	raid5_store_group_thread_cnt	drivers/md/raid5.c	new	1	11	\N	\N	\tstruct r5conf *conf;\n\tunsigned int new;\n\tint err;\n\tstruct r5worker_group *new_groups, *old_groups;\n\tint group_cnt, worker_cnt_per_group;\n\n\tif (len >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\tif (kstrtouint(page, 10, &new))\n\t\treturn -EINVAL;\n\t/* 8192 should be big enough */\n\tif (new > 8192)\n	t
57236	91	ecryptfs_filldir	fs/ecryptfs/file.c	name	1	11	\N	\N	\tstruct ecryptfs_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct ecryptfs_getdents_callback, ctx);\n\tsize_t name_size;\n\tchar *name;\n\tint rc;\n\n\tbuf->filldir_called++;\n\trc = ecryptfs_decode_and_decrypt_filename(&name, &name_size,\n\t\t\t\t\t\t  buf->sb, lower_name,\n\t\t\t\t\t\t  lower_namelen);\n\tif (rc) {\n\t\tprintk(KERN_ERR "%s: Error attempting to decode and decrypt "\n\t\t       "filename [%s]; rc = [%d]\\n", __func__, lower_name,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tbuf->caller->pos = buf->ctx.pos;\n\trc = !dir_emit(buf->caller, name, name_size, ino, d_type);\n	f
46214	1861	usbat_probe	drivers/usb/storage/shuttle_usbat.c	us->transport_name	1	13	\N	\N	\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - usbat_usb_ids) + usbat_unusual_dev_list,\n\t\t\t&usbat_host_template);\n\tif (result)\n\t\treturn result;\n\n\t/*\n\t * The actual transport will be determined later by the\n\t * initialization routine; this is just a placeholder.\n\t */\n\tus->transport_name = "Shuttle USBAT";\n	f
50692	489	mcp23s08_irq	drivers/pinctrl/pinctrl-mcp23s08.c	intf	7	12	\N	\N	\tstruct mcp23s08 *mcp = data;\n\tint intcap, intcon, intf, i, gpio, gpio_orig, intcap_mask, defval;\n\tunsigned int child_irq;\n\tbool intf_set, intcap_changed, gpio_bit_changed,\n\t\tdefval_changed, gpio_set;\n\n\tmutex_lock(&mcp->lock);\n\tif (mcp_read(mcp, MCP_INTF, &intf) < 0) {\n\t\tmutex_unlock(&mcp->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (mcp_read(mcp, MCP_INTCAP, &intcap) < 0) {\n\t\tmutex_unlock(&mcp->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (mcp_read(mcp, MCP_INTCON, &intcon) < 0) {\n\t\tmutex_unlock(&mcp->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (mcp_read(mcp, MCP_DEFVAL, &defval) < 0) {\n\t\tmutex_unlock(&mcp->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* This clears the interrupt(configurable on S18) */\n\tif (mcp_read(mcp, MCP_GPIO, &gpio) < 0) {\n\t\tmutex_unlock(&mcp->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\tgpio_orig = mcp->cached_gpio;\n\tmcp->cached_gpio = gpio;\n\tmutex_unlock(&mcp->lock);\n\n\tif (intf == 0) {\n	t
39348	1865	de21041_get_srom_info	drivers/net/ethernet/dec/tulip/de2104x.c	ib->opts	1	11	\N	\N	\tunsigned i, sa_offset = 0, ofs;\n\tu8 ee_data[DE_EEPROM_SIZE + 6] = {};\n\tunsigned ee_addr_size = tulip_read_eeprom(de->regs, 0xff, 8) & 0x40000 ? 8 : 6;\n\tstruct de_srom_info_leaf *il;\n\tvoid *bufp;\n\n\t/* download entire eeprom */\n\tfor (i = 0; i < DE_EEPROM_WORDS; i++)\n\t\t((__le16 *)ee_data)[i] =\n\t\t\tcpu_to_le16(tulip_read_eeprom(de->regs, i, ee_addr_size));\n\n\t/* DEC now has a specification but early board makers\n\t   just put the address in the first EEPROM locations. */\n\t/* This does  memcmp(eedata, eedata+16, 8) */\n\n#ifndef CONFIG_MIPS_COBALT\n\n\tfor (i = 0; i < 8; i ++)\n\t\tif (ee_data[i] != ee_data[16+i])\n\t\t\tsa_offset = 20;\n\n#endif\n\n\t/* store MAC address */\n\tfor (i = 0; i < 6; i ++)\n\t\tde->dev->dev_addr[i] = ee_data[i + sa_offset];\n\n\t/* get offset of controller 0 info leaf.  ignore 2nd byte. */\n\tofs = ee_data[SROMC0InfoLeaf];\n\tif (ofs >= (sizeof(ee_data) - sizeof(struct de_srom_info_leaf) - sizeof(struct de_srom_media_block)))\n\t\tgoto bad_srom;\n\n\t/* get pointer to info leaf */\n\til = (struct de_srom_info_leaf *) &ee_data[ofs];\n\n\t/* paranoia checks */\n\tif (il->n_blocks == 0)\n\t\tgoto bad_srom;\n\tif ((sizeof(ee_data) - ofs) <\n\t    (sizeof(struct de_srom_info_leaf) + (sizeof(struct de_srom_media_block) * il->n_blocks)))\n\t\tgoto bad_srom;\n\n\t/* get default media type */\n\tswitch (get_unaligned(&il->default_media)) {\n\tcase 0x0001:  de->media_type = DE_MEDIA_BNC; break;\n\tcase 0x0002:  de->media_type = DE_MEDIA_AUI; break;\n\tcase 0x0204:  de->media_type = DE_MEDIA_TP_FD; break;\n\tdefault: de->media_type = DE_MEDIA_TP_AUTO; break;\n\t}\n\n\tif (netif_msg_probe(de))\n\t\tpr_info("de%d: SROM leaf offset %u, default media %s\\n",\n\t\t       de->board_idx, ofs, media_name[de->media_type]);\n\n\t/* init SIA register values to defaults */\n\tfor (i = 0; i < DE_MAX_MEDIA; i++) {\n\t\tde->media[i].type = DE_MEDIA_INVALID;\n\t\tde->media[i].csr13 = 0xffff;\n\t\tde->media[i].csr14 = 0xffff;\n\t\tde->media[i].csr15 = 0xffff;\n\t}\n\n\t/* parse media blocks to see what medias are supported,\n\t * and if any custom CSR values are provided\n\t */\n\tbufp = ((void *)il) + sizeof(*il);\n\tfor (i = 0; i < il->n_blocks; i++) {\n\t\tstruct de_srom_media_block *ib = bufp;\n\t\tunsigned idx;\n\n\t\t/* index based on media type in media block */\n\t\tswitch(ib->opts & MediaBlockMask) {\n	t
50711	242	xfs_fs_get_dqblk	fs/xfs/xfs_quotaops.c	qdq	1	11	\N	\N	\tstruct xfs_mount\t*mp = XFS_M(sb);\n\txfs_dqid_t\t\tid;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\tid = from_kqid(&init_user_ns, qid);\n\treturn xfs_qm_scall_getquota(mp, &id,\n	t
1463	966	fib_info_hash_move	net/ipv4/fib_semantics.c	fib_info_hash_move_$__mptr62$obj	0	11	\N	\N	\tstruct hlist_head *old_info_hash, *old_laddrhash;\n\tunsigned int old_size = fib_info_hash_size;\n\tunsigned int i, bytes;\n\n\tspin_lock_bh(&fib_info_lock);\n\told_info_hash = fib_info_hash;\n\told_laddrhash = fib_info_laddrhash;\n\tfib_info_hash_size = new_size;\n\n\tfor (i = 0; i < old_size; i++) {\n\t\tstruct hlist_head *head = &fib_info_hash[i];\n\t\tstruct hlist_node *n;\n\t\tstruct fib_info *fi;\n\n\t\thlist_for_each_entry_safe(fi, n, head, fib_hash) {\n\t\t\tstruct hlist_head *dest;\n\t\t\tunsigned int new_hash;\n\n\t\t\tnew_hash = fib_info_hashfn(fi);\n\t\t\tdest = &new_info_hash[new_hash];\n\t\t\thlist_add_head(&fi->fib_hash, dest);\n\t\t}\n\t}\n\tfib_info_hash = new_info_hash;\n\n\tfor (i = 0; i < old_size; i++) {\n\t\tstruct hlist_head *lhead = &fib_info_laddrhash[i];\n\t\tstruct hlist_node *n;\n\t\tstruct fib_info *fi;\n\n\t\thlist_for_each_entry_safe(fi, n, lhead, fib_lhash) {\n	t
57360	673	bgpio_pdev_probe	drivers/gpio/gpio-mmio.c	pdata->label	1	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tvoid __iomem *dat;\n\tvoid __iomem *set;\n\tvoid __iomem *clr;\n\tvoid __iomem *dirout;\n\tvoid __iomem *dirin;\n\tunsigned long sz;\n\tunsigned long flags = 0;\n\tint err;\n\tstruct gpio_chip *gc;\n\tstruct bgpio_pdata *pdata;\n\n\tpdata = bgpio_parse_dt(pdev, &flags);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tif (!pdata) {\n\t\tpdata = dev_get_platdata(dev);\n\t\tflags = pdev->id_entry->driver_data;\n\t}\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");\n\tif (!r)\n\t\treturn -EINVAL;\n\n\tsz = resource_size(r);\n\n\tdat = bgpio_map(pdev, "dat", sz);\n\tif (IS_ERR(dat))\n\t\treturn PTR_ERR(dat);\n\n\tset = bgpio_map(pdev, "set", sz);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tclr = bgpio_map(pdev, "clr", sz);\n\tif (IS_ERR(clr))\n\t\treturn PTR_ERR(clr);\n\n\tdirout = bgpio_map(pdev, "dirout", sz);\n\tif (IS_ERR(dirout))\n\t\treturn PTR_ERR(dirout);\n\n\tdirin = bgpio_map(pdev, "dirin", sz);\n\tif (IS_ERR(dirin))\n\t\treturn PTR_ERR(dirin);\n\n\tgc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\terr = bgpio_init(gc, dev, sz, dat, set, clr, dirout, dirin, flags);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata) {\n\t\tif (pdata->label)\n	t
36884	212	lapbeth_data_transmit	drivers/net/wan/lapbether.c	skb	1	11	\N	not stack varaible	\tstruct lapbethdev *lapbeth = netdev_priv(ndev);\n\tunsigned char *ptr;\n\tstruct net_device *dev;\n\tint size = skb->len;\n\n\tskb->protocol = htons(ETH_P_X25);\n\n\tptr = skb_push(skb, 2);\n\n\t*ptr++ = size % 256;\n\t*ptr++ = size / 256;\n\n\tndev->stats.tx_packets++;\n\tndev->stats.tx_bytes += size;\n\n\tskb->dev = dev = lapbeth->ethdev;\n\n\tdev_hard_header(skb, dev, ETH_P_DEC, bcast_addr, NULL, 0);\n\n\tdev_queue_xmit(skb);\n	t
-601	1925	cnl_ddi_vswing_program	drivers/gpu/drm/i915/intel_ddi.c	n_entries	2	3	\N	\N	\tconst struct cnl_ddi_buf_trans *ddi_translations = NULL;\n\tu32 n_entries, val, voltage;\n\tint ln;\n\n\t/*\n\t * Values for each port type are listed in\n\t * voltage swing programming tables.\n\t * Vccio voltage found in PORT_COMP_DW3.\n\t */\n\tvoltage = I915_READ(CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;\n\n\tif (type == INTEL_OUTPUT_HDMI) {\n\t\tddi_translations = cnl_get_buf_trans_hdmi(dev_priv,\n\t\t\t\t\t\t\t  voltage, &n_entries);\n\t} else if (type == INTEL_OUTPUT_DP) {\n\t\tddi_translations = cnl_get_buf_trans_dp(dev_priv,\n\t\t\t\t\t\t\tvoltage, &n_entries);\n\t} else if (type == INTEL_OUTPUT_EDP) {\n\t\tddi_translations = cnl_get_buf_trans_edp(dev_priv,\n\t\t\t\t\t\t\t voltage, &n_entries);\n\t}\n\n\tif (ddi_translations == NULL) {\n\t\tMISSING_CASE(voltage);\n\t\treturn;\n\t}\n\n\tif (level >= n_entries) {\n\t\tDRM_DEBUG_KMS("DDI translation not found for level %d. Using %d instead.", level, n_entries - 1);\n	f
62243	1374	nf_tables_addchain	net/netfilter/nf_tables_api.c	hook.dev->name	1	11	\N	\N	\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_table *table = ctx->table;\n\tstruct nft_af_info *afi = ctx->afi;\n\tstruct nft_base_chain *basechain;\n\tstruct nft_stats __percpu *stats;\n\tstruct net *net = ctx->net;\n\tstruct nft_chain *chain;\n\tunsigned int i;\n\tint err;\n\n\tif (table->use == UINT_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (nla[NFTA_CHAIN_HOOK]) {\n\t\tstruct nft_chain_hook hook;\n\t\tstruct nf_hook_ops *ops;\n\t\tnf_hookfn *hookfn;\n\n\t\terr = nft_chain_parse_hook(net, nla, afi, &hook, create);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbasechain = kzalloc(sizeof(*basechain), GFP_KERNEL);\n\t\tif (basechain == NULL) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (hook.dev != NULL)\n\t\t\tstrncpy(basechain->dev_name, hook.dev->name, IFNAMSIZ);\n	t
30160	537	hdpvr_poll	drivers/media/usb/hdpvr/hdpvr-video.c	hdpvr_poll_	1	11	\N	\N	\tunsigned long req_events = poll_requested_events(wait);\n\tstruct hdpvr_buffer *buf = NULL;\n\tstruct hdpvr_device *dev = video_drvdata(filp);\n\tunsigned int mask = v4l2_ctrl_poll(filp, wait);\n\n\tif (!(req_events & (POLLIN | POLLRDNORM)))\n\t\treturn mask;\n\n\tmutex_lock(&dev->io_mutex);\n\n\tif (dev->status == STATUS_IDLE) {\n\t\tif (hdpvr_start_streaming(dev)) {\n	t
49815	347	snd_cs8427_reset	sound/i2c/cs8427.c	data	1	11	\N	\N	\tstruct cs8427 *chip;\n\tunsigned long end_time;\n\tint data, aes3input = 0;\n\n\tif (snd_BUG_ON(!cs8427))\n\t\treturn;\n\tchip = cs8427->private_data;\n\tsnd_i2c_lock(cs8427->bus);\n\tif ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==\n\t    CS8427_RXDAES3INPUT)  /* AES3 bit is set */\n\t\taes3input = 1;\n\tchip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);\n\tsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\n\t\t\t     chip->regmap[CS8427_REG_CLOCKSOURCE]);\n\tudelay(200);\n\tchip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;\n\tsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\n\t\t\t     chip->regmap[CS8427_REG_CLOCKSOURCE]);\n\tudelay(200);\n\tsnd_i2c_unlock(cs8427->bus);\n\tend_time = jiffies + chip->reset_timeout;\n\twhile (time_after_eq(end_time, jiffies)) {\n\t\tsnd_i2c_lock(cs8427->bus);\n\t\tdata = snd_cs8427_reg_read(cs8427, CS8427_REG_RECVERRORS);\n\t\tsnd_i2c_unlock(cs8427->bus);\n\t\tif (!(data & CS8427_UNLOCK))\n	t
-228	486	max17042_write_verify_reg	drivers/power/supply/max17042_battery.c	read_value	5	20	\N	\N	\tint retries = 8;\n\tint ret;\n\tu32 read_value;\n\n\tdo {\n\t\tret = regmap_write(map, reg, value);\n\t\tregmap_read(map, reg, &read_value);\n\t\tif (read_value != value) {\n	f
37229	7941	tracing_init_dentry	kernel/trace/trace.c	tr->dir	2	-11	\N	\N	\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount("tracing", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n	t
-223	1255	isc_interrupt	drivers/media/platform/atmel/atmel-isc.c	isc_intmask	4	20	\N	\N	\tstruct isc_device *isc = (struct isc_device *)dev_id;\n\tstruct regmap *regmap = isc->regmap;\n\tu32 isc_intsr, isc_intmask, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(regmap, ISC_INTSR, &isc_intsr);\n\tregmap_read(regmap, ISC_INTMASK, &isc_intmask);\n\n\tpending = isc_intsr & isc_intmask;\n	f
45100	2208	proc_ioctl_compat	drivers/usb/core/devio.c	&ctrl	1	13	\N	\N	\tstruct usbdevfs_ioctl32 ioc32;\n\tstruct usbdevfs_ioctl ctrl;\n\n\tif (copy_from_user(&ioc32, compat_ptr(arg), sizeof(ioc32)))\n\t\treturn -EFAULT;\n\tctrl.ifno = ioc32.ifno;\n\tctrl.ioctl_code = ioc32.ioctl_code;\n\tctrl.data = compat_ptr(ioc32.data);\n\treturn proc_ioctl(ps, &ctrl);\n	f
57500	1422	atl2_probe	drivers/net/ethernet/atheros/atlx/atl2.c	atl2_probe_	1	11	\N	\N	\tstruct net_device *netdev;\n\tstruct atl2_adapter *adapter;\n\tstatic int cards_found;\n\tunsigned long mmio_start;\n\tint mmio_len;\n\tint err;\n\n\tcards_found = 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA\n\t * until the kernel has the proper infrastructure to support 64-bit DMA\n\t * on these devices.\n\t */\n\tif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&\n\t\tpci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_ERR "atl2: No usable DMA configuration, aborting\\n");\n\t\terr = -EIO;\n\t\tgoto err_dma;\n\t}\n\n\t/* Mark all PCI regions associated with PCI device\n\t * pdev as being reserved by owner atl2_driver_name */\n\terr = pci_request_regions(pdev, atl2_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\t/* Enables bus-mastering on the device and calls\n\t * pcibios_set_master to do the needed arch specific settings */\n\tpci_set_master(pdev);\n\n\tnetdev = alloc_etherdev(sizeof(struct atl2_adapter));\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.back = adapter;\n\n\tmmio_start = pci_resource_start(pdev, 0x0);\n\tmmio_len = pci_resource_len(pdev, 0x0);\n\n\tadapter->hw.mem_rang = (u32)mmio_len;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tatl2_setup_pcicmd(pdev);\n\n\tnetdev->netdev_ops = &atl2_netdev_ops;\n\tnetdev->ethtool_ops = &atl2_ethtool_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tnetdev->min_mtu = 40;\n\tnetdev->max_mtu = ETH_DATA_LEN + VLAN_HLEN;\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\tadapter->bd_number = cards_found;\n\tadapter->pci_using_64 = false;\n\n\t/* setup the private structure */\n\terr = atl2_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\tnetdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;\n\tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\n\n\t/* Init PHY as early as possible due to power saving issue  */\n\tatl2_phy_init(&adapter->hw);\n\n\t/* reset the controller to\n\t * put the device in a known good starting state */\n\n\tif (atl2_reset_hw(&adapter->hw)) {\n	f
57535	647	bl_alloc_lseg	fs/nfs/blocklayout/blocklayout.c	p	1	11	\N	\N	\tstruct layout_verification lv = {\n\t\t.mode = lgr->range.iomode,\n\t\t.start = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.inval = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.cowread = lgr->range.offset >> SECTOR_SHIFT,\n\t};\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tstruct pnfs_layout_segment *lseg;\n\tstruct xdr_buf buf;\n\tstruct xdr_stream xdr;\n\tstruct page *scratch;\n\tint status, i;\n\tuint32_t count;\n\t__be32 *p;\n\tLIST_HEAD(extents);\n\n\tdprintk("---> %s\\n", __func__);\n\n\tlseg = kzalloc(sizeof(*lseg), gfp_mask);\n\tif (!lseg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = -ENOMEM;\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf,\n\t\t\tlgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&xdr, page_address(scratch), PAGE_SIZE);\n\n\tstatus = -EIO;\n\tp = xdr_inline_decode(&xdr, 4);\n\tif (unlikely(!p))\n	t
21708	790	blogic_init_mm_probeinfo	drivers/scsi/BusLogic.c	id.fw_ver_digit1	10	12	\N	\N	\tstruct blogic_probeinfo *pr_probeinfo =\n\t\t&blogic_probeinfo_list[blogic_probeinfo_count];\n\tint nonpr_mmindex = blogic_probeinfo_count + 1;\n\tint nonpr_mmcount = 0, mmcount = 0;\n\tbool force_scan_order = false;\n\tbool force_scan_order_checked = false;\n\tbool addr_seen[6];\n\tstruct pci_dev *pci_device = NULL;\n\tint i;\n\tif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\n\t\treturn 0;\n\tblogic_probeinfo_count++;\n\tfor (i = 0; i < 6; i++)\n\t\taddr_seen[i] = false;\n\t/*\n\t   Iterate over the MultiMaster PCI Host Adapters.  For each\n\t   enumerated host adapter, determine whether its ISA Compatible\n\t   I/O Port is enabled and if so, whether it is assigned the\n\t   Primary I/O Address.  A host adapter that is assigned the\n\t   Primary I/O Address will always be the preferred boot device.\n\t   The MultiMaster BIOS will first recognize a host adapter at\n\t   the Primary I/O Address, then any other PCI host adapters,\n\t   and finally any host adapters located at the remaining\n\t   standard ISA I/O Addresses.  When a PCI host adapter is found\n\t   with its ISA Compatible I/O Port enabled, a command is issued\n\t   to disable the ISA Compatible I/O Port, and it is noted that the\n\t   particular standard ISA I/O Address need not be probed.\n\t */\n\tpr_probeinfo->io_addr = 0;\n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tstruct blogic_adapter *host_adapter = adapter;\n\t\tstruct blogic_adapter_info adapter_info;\n\t\tenum blogic_isa_ioport mod_ioaddr_req;\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long base_addr0;\n\t\tunsigned long base_addr1;\n\t\tunsigned long io_addr;\n\t\tunsigned long pci_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = base_addr0 = pci_resource_start(pci_device, 0);\n\t\tpci_addr = base_addr1 = pci_resource_start(pci_device, 1);\n\n\t\tif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\n\t\t\tblogic_err("BusLogic: Base Address0 0x%X not I/O for " "MultiMaster Host Adapter\\n", NULL, base_addr0);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\n\t\t\tblogic_err("BusLogic: Base Address1 0x%X not Memory for " "MultiMaster Host Adapter\\n", NULL, base_addr1);\n\t\t\tblogic_err("at PCI Bus %d Device %d PCI Address 0x%X\\n", NULL, bus, device, pci_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (irq_ch == 0) {\n\t\t\tblogic_err("BusLogic: IRQ Channel %d invalid for " "MultiMaster Host Adapter\\n", NULL, irq_ch);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (blogic_global_options.trace_probe) {\n\t\t\tblogic_notice("BusLogic: PCI MultiMaster Host Adapter " "detected at\\n", NULL);\n\t\t\tblogic_notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\\n", NULL, bus, device, io_addr, pci_addr);\n\t\t}\n\t\t/*\n\t\t   Issue the Inquire PCI Host Adapter Information command to determine\n\t\t   the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is\n\t\t   known and enabled, note that the particular Standard ISA I/O\n\t\t   Address should not be probed.\n\t\t */\n\t\thost_adapter->io_addr = io_addr;\n\t\tblogic_intreset(host_adapter);\n\t\tif (blogic_cmd(host_adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\n\t\t\t\t&adapter_info, sizeof(adapter_info)) ==\n\t\t\t\tsizeof(adapter_info)) {\n\t\t\tif (adapter_info.isa_port < 6)\n\t\t\t\taddr_seen[adapter_info.isa_port] = true;\n\t\t} else\n\t\t\tadapter_info.isa_port = BLOGIC_IO_DISABLE;\n\t\t/*\n\t\t   Issue the Modify I/O Address command to disable the\n\t\t   ISA Compatible I/O Port. On PCI Host Adapters, the\n\t\t   Modify I/O Address command allows modification of the\n\t\t   ISA compatible I/O Address that the Host Adapter\n\t\t   responds to; it does not affect the PCI compliant\n\t\t   I/O Address assigned at system initialization.\n\t\t */\n\t\tmod_ioaddr_req = BLOGIC_IO_DISABLE;\n\t\tblogic_cmd(host_adapter, BLOGIC_MOD_IOADDR, &mod_ioaddr_req,\n\t\t\t\tsizeof(mod_ioaddr_req), NULL, 0);\n\t\t/*\n\t\t   For the first MultiMaster Host Adapter enumerated,\n\t\t   issue the Fetch Host Adapter Local RAM command to read\n\t\t   byte 45 of the AutoSCSI area, for the setting of the\n\t\t   "Use Bus And Device # For PCI Scanning Seq." option.\n\t\t   Issue the Inquire Board ID command since this option is\n\t\t   only valid for the BT-948/958/958D.\n\t\t */\n\t\tif (!force_scan_order_checked) {\n\t\t\tstruct blogic_fetch_localram fetch_localram;\n\t\t\tstruct blogic_autoscsi_byte45 autoscsi_byte45;\n\t\t\tstruct blogic_board_id id;\n\n\t\t\tfetch_localram.offset = BLOGIC_AUTOSCSI_BASE + 45;\n\t\t\tfetch_localram.count = sizeof(autoscsi_byte45);\n\t\t\tblogic_cmd(host_adapter, BLOGIC_FETCH_LOCALRAM,\n\t\t\t\t\t&fetch_localram, sizeof(fetch_localram),\n\t\t\t\t\t&autoscsi_byte45,\n\t\t\t\t\tsizeof(autoscsi_byte45));\n\t\t\tblogic_cmd(host_adapter, BLOGIC_GET_BOARD_ID, NULL, 0,\n\t\t\t\t\t&id, sizeof(id));\n\t\t\tif (id.fw_ver_digit1 == '5')\n	t
57126	324	ctr_crypt	arch/x86/crypto/cast5_avx_glue.c	&walk	5	12	\N	\N	\tbool fpu_enabled = false;\n\tstruct blkcipher_walk walk;\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, CAST5_BLOCK_SIZE);\n\tdesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\twhile ((nbytes = walk.nbytes) >= CAST5_BLOCK_SIZE) {\n\t\tfpu_enabled = cast5_fpu_begin(fpu_enabled, nbytes);\n\t\tnbytes = __ctr_crypt(desc, &walk);\n\t\terr = blkcipher_walk_done(desc, &walk, nbytes);\n	t
-222	1255	isc_interrupt	drivers/media/platform/atmel/atmel-isc.c	isc_intsr	4	20	\N	\N	\tstruct isc_device *isc = (struct isc_device *)dev_id;\n\tstruct regmap *regmap = isc->regmap;\n\tu32 isc_intsr, isc_intmask, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(regmap, ISC_INTSR, &isc_intsr);\n\tregmap_read(regmap, ISC_INTMASK, &isc_intmask);\n\n\tpending = isc_intsr & isc_intmask;\n	f
29613	1774	iwl_mvm_get_wakeup_status	drivers/net/wireless/intel/iwlwifi/mvm/d3.c	err_info.valid	1	11	\N	\N	\tu32 base = mvm->error_event_table[0];\n\tstruct error_table_start {\n\t\t/* cf. struct iwl_error_event_table */\n\t\tu32 valid;\n\t\tu32 error_id;\n\t} err_info;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WOWLAN_GET_STATUSES,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\tstruct iwl_wowlan_status *status, *fw_status;\n\tint ret, len, status_size;\n\n\tiwl_trans_read_mem_bytes(mvm->trans, base,\n\t\t\t\t &err_info, sizeof(err_info));\n\n\tif (err_info.valid) {\n	t
49484	276	do_gfs2_set_flags	fs/gfs2/file.c	bh->b_data	1	11	\N	\N	\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\terror = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto out;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif ((new_flags ^ flags) & ~GFS2_FLAGS_USER_SET)\n\t\tgoto out;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) && (new_flags & GFS2_DIF_IMMUTABLE))\n\t\tgoto out;\n\tif (IS_APPEND(inode) && (new_flags & GFS2_DIF_APPENDONLY))\n\t\tgoto out;\n\tif (((new_flags ^ flags) & GFS2_DIF_IMMUTABLE) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n	t
57651	736	ipvlan_l3_rcv	drivers/net/ipvlan/ipvlan_core.c	err	1	11	\N	\N	\tstruct ipvl_addr *addr;\n\tstruct net_device *sdev;\n\n\taddr = ipvlan_skb_to_addr(skb, dev);\n\tif (!addr)\n\t\tgoto out;\n\n\tsdev = addr->master->dev;\n\tswitch (proto) {\n\tcase AF_INET:\n\t{\n\t\tint err;\n\t\tstruct iphdr *ip4h = ip_hdr(skb);\n\n\t\terr = ip_route_input_noref(skb, ip4h->daddr, ip4h->saddr,\n\t\t\t\t\t   ip4h->tos, sdev);\n\t\tif (unlikely(err))\n	t
31508	1751	e1000_phy_force_speed_duplex	drivers/net/ethernet/intel/e1000/e1000_hw.c	phy_data	1	11	\N	\N	\tu32 ctrl;\n\ts32 ret_val;\n\tu16 mii_ctrl_reg;\n\tu16 mii_status_reg;\n\tu16 phy_data;\n\tu16 i;\n\n\t/* Turn off Flow control if we are forcing speed and duplex. */\n\thw->fc = E1000_FC_NONE;\n\n\te_dbg("hw->fc = %d\\n", hw->fc);\n\n\t/* Read the Device Control Register. */\n\tctrl = er32(CTRL);\n\n\t/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */\n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~(DEVICE_SPEED_MASK);\n\n\t/* Clear the Auto Speed Detect Enable bit. */\n\tctrl &= ~E1000_CTRL_ASDE;\n\n\t/* Read the MII Control Register. */\n\tret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t/* We need to disable autoneg in order to force link and duplex. */\n\n\tmii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;\n\n\t/* Are we forcing Full or Half Duplex? */\n\tif (hw->forced_speed_duplex == e1000_100_full ||\n\t    hw->forced_speed_duplex == e1000_10_full) {\n\t\t/* We want to force full duplex so we SET the full duplex bits\n\t\t * in the Device and MII Control Registers.\n\t\t */\n\t\tctrl |= E1000_CTRL_FD;\n\t\tmii_ctrl_reg |= MII_CR_FULL_DUPLEX;\n\t\te_dbg("Full Duplex\\n");\n\t} else {\n\t\t/* We want to force half duplex so we CLEAR the full duplex bits\n\t\t * in the Device and MII Control Registers.\n\t\t */\n\t\tctrl &= ~E1000_CTRL_FD;\n\t\tmii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;\n\t\te_dbg("Half Duplex\\n");\n\t}\n\n\t/* Are we forcing 100Mbps??? */\n\tif (hw->forced_speed_duplex == e1000_100_full ||\n\t    hw->forced_speed_duplex == e1000_100_half) {\n\t\t/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */\n\t\tctrl |= E1000_CTRL_SPD_100;\n\t\tmii_ctrl_reg |= MII_CR_SPEED_100;\n\t\tmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);\n\t\te_dbg("Forcing 100mb ");\n\t} else {\n\t\t/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */\n\t\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\t\tmii_ctrl_reg |= MII_CR_SPEED_10;\n\t\tmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);\n\t\te_dbg("Forcing 10mb ");\n\t}\n\n\te1000_config_collision_dist(hw);\n\n\t/* Write the configured values back to the Device Control Reg. */\n\tew32(CTRL, ctrl);\n\n\tif (hw->phy_type == e1000_phy_m88) {\n\t\tret_val =\n\t\t    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\t/* Clear Auto-Crossover to force MDI manually. M88E1000 requires\n\t\t * MDI forced whenever speed are duplex are forced.\n\t\t */\n\t\tphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\n\t\tret_val =\n\t\t    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\n	t
57668	241	aq_ring_rx_clean	drivers/net/ethernet/aquantia/atlantic/aq_ring.c	skb->data	1	11	\N	\N	\tstruct net_device *ndev = aq_nic_get_ndev(self->aq_nic);\n\tint err = 0;\n\tbool is_rsc_completed = true;\n\n\tfor (; (self->sw_head != self->hw_head) && budget;\n\t\tself->sw_head = aq_ring_next_dx(self, self->sw_head),\n\t\t--budget, ++(*work_done)) {\n\t\tstruct aq_ring_buff_s *buff = &self->buff_ring[self->sw_head];\n\t\tstruct sk_buff *skb = NULL;\n\t\tunsigned int next_ = 0U;\n\t\tunsigned int i = 0U;\n\t\tstruct aq_ring_buff_s *buff_ = NULL;\n\n\t\tif (buff->is_error) {\n\t\t\t__free_pages(buff->page, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buff->is_cleaned)\n\t\t\tcontinue;\n\n\t\tif (!buff->is_eop) {\n\t\t\tfor (next_ = buff->next,\n\t\t\t     buff_ = &self->buff_ring[next_]; true;\n\t\t\t     next_ = buff_->next,\n\t\t\t     buff_ = &self->buff_ring[next_]) {\n\t\t\t\tis_rsc_completed =\n\t\t\t\t\taq_ring_dx_in_range(self->sw_head,\n\t\t\t\t\t\t\t    next_,\n\t\t\t\t\t\t\t    self->hw_head);\n\n\t\t\t\tif (unlikely(!is_rsc_completed)) {\n\t\t\t\t\tis_rsc_completed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (buff_->is_eop)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!is_rsc_completed) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\n\t\t/* for single fragment packets use build_skb() */\n\t\tif (buff->is_eop) {\n\t\t\tskb = build_skb(page_address(buff->page),\n\t\t\t\t\tbuff->len + AQ_SKB_ALIGN);\n\t\t\tif (unlikely(!skb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tskb_put(skb, buff->len);\n\t\t} else {\n\t\t\tskb = netdev_alloc_skb(ndev, ETH_HLEN);\n\t\t\tif (unlikely(!skb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskb_put(skb, ETH_HLEN);\n\t\t\tmemcpy(skb->data, page_address(buff->page), ETH_HLEN);\n	t
57800	548	gfs2_recover_func	fs/gfs2/recovery.c	head.lh_blkno	1	11	\N	\N	\tstruct gfs2_jdesc *jd = container_of(work, struct gfs2_jdesc, jd_work);\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_holder j_gh, ji_gh, thaw_gh;\n\tunsigned long t;\n\tint ro = 0;\n\tunsigned int pass;\n\tint error;\n\tint jlocked = 0;\n\n\tif (sdp->sd_args.ar_spectator ||\n\t    (jd->jd_jid != sdp->sd_lockstruct.ls_jid)) {\n\t\tfs_info(sdp, "jid=%u: Trying to acquire journal lock...\\n",\n\t\t\tjd->jd_jid);\n\t\tjlocked = 1;\n\t\t/* Acquire the journal lock so we can do recovery */\n\n\t\terror = gfs2_glock_nq_num(sdp, jd->jd_jid, &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t\t  LM_FLAG_NOEXP | LM_FLAG_TRY | GL_NOCACHE,\n\t\t\t\t\t  &j_gh);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase GLR_TRYFAILED:\n\t\t\tfs_info(sdp, "jid=%u: Busy\\n", jd->jd_jid);\n\t\t\terror = 0;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t};\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_NOCACHE, &ji_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_j;\n\t} else {\n\t\tfs_info(sdp, "jid=%u, already locked for use\\n", jd->jd_jid);\n\t}\n\n\tfs_info(sdp, "jid=%u: Looking at journal...\\n", jd->jd_jid);\n\n\terror = gfs2_jdesc_check(jd);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tfs_info(sdp, "jid=%u: Acquiring the transaction lock...\\n",\n\t\t\tjd->jd_jid);\n\n\t\tt = jiffies;\n\n\t\t/* Acquire a shared hold on the freeze lock */\n\n\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | LM_FLAG_PRIORITY,\n\t\t\t\t\t   &thaw_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_ji;\n\n\t\tif (test_bit(SDF_RORECOVERY, &sdp->sd_flags)) {\n\t\t\tro = 1;\n\t\t} else if (test_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags)) {\n\t\t\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\t\t\tro = 1;\n\t\t} else {\n\t\t\tif (sb_rdonly(sdp->sd_vfs)) {\n\t\t\t\t/* check if device itself is read-only */\n\t\t\t\tro = bdev_read_only(sdp->sd_vfs->s_bdev);\n\t\t\t\tif (!ro) {\n\t\t\t\t\tfs_info(sdp, "recovery required on "\n\t\t\t\t\t\t"read-only filesystem.\\n");\n\t\t\t\t\tfs_info(sdp, "write access will be "\n\t\t\t\t\t\t"enabled during recovery.\\n");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ro) {\n\t\t\tfs_warn(sdp, "jid=%u: Can't replay: read-only block "\n\t\t\t\t"device\\n", jd->jd_jid);\n\t\t\terror = -EROFS;\n\t\t\tgoto fail_gunlock_thaw;\n\t\t}\n\n\t\tfs_info(sdp, "jid=%u: Replaying journal...\\n", jd->jd_jid);\n\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlops_before_scan(jd, &head, pass);\n\t\t\terror = foreach_descriptor(jd, head.lh_tail,\n	t
60156	1804	hpi_cobranet_get_static_ip_address	sound/pci/asihpi/hpifunc.c	err	1	11	\N	\N	\tu32 byte_count;\n\tu32 iP;\n\tu16 err;\n\terr = hpi_cobranet_hmi_read(h_control,\n\t\tHPI_COBRANET_HMI_cobra_ip_mon_staticIP, 4, &byte_count,\n\t\t(u8 *)&iP);\n\n\t*pdw_ip_address =\n\t\t((iP & 0xff000000) >> 8) | ((iP & 0x00ff0000) << 8) | ((iP &\n\t\t\t0x0000ff00) >> 8) | ((iP & 0x000000ff) << 8);\n\n\tif (err)\n	t
44221	3239	ath6kl_wmi_mcast_filter_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_mcast_filter_cmd_$cmd$obj	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_mcast_filter_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mcast_filter_cmd *) skb->data;\n\tcmd->mcast_all_enable = mc_all_on;\n	t
56642	2429	ipmr_rtm_getroute	net/ipv4/ipmr.c	tb	1	11	\N	\N	\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct sk_buff *skb = NULL;\n\tstruct mfc_cache *cache;\n\tstruct mr_table *mrt;\n\tstruct rtmsg *rtm;\n\t__be32 src, grp;\n\tu32 tableid;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t  rtm_ipv4_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n	t
57319	3954	snd_cs46xx_create	sound/pci/cs46xx/cs46xx_lib.c	ss_vendor	1	11	\N	\N	\tstruct snd_cs46xx *chip;\n\tint err, idx;\n\tstruct snd_cs46xx_region *region;\n\tstruct cs_card_type *cp;\n\tu16 ss_card, ss_vendor;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_cs46xx_dev_free,\n\t};\n\t\n\t*rchip = NULL;\n\n\t/* enable PCI device */\n\tif ((err = pci_enable_device(pci)) < 0)\n\t\treturn err;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL) {\n\t\tpci_disable_device(pci);\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_init(&chip->reg_lock);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tmutex_init(&chip->spos_mutex);\n#endif\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->ba0_addr = pci_resource_start(pci, 0);\n\tchip->ba1_addr = pci_resource_start(pci, 1);\n\tif (chip->ba0_addr == 0 || chip->ba0_addr == (unsigned long)~0 ||\n\t    chip->ba1_addr == 0 || chip->ba1_addr == (unsigned long)~0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t"wrong address(es) - ba0 = 0x%lx, ba1 = 0x%lx\\n",\n\t\t\t   chip->ba0_addr, chip->ba1_addr);\n\t    \tsnd_cs46xx_free(chip);\n\t    \treturn -ENOMEM;\n\t}\n\n\tregion = &chip->region.name.ba0;\n\tstrcpy(region->name, "CS46xx_BA0");\n\tregion->base = chip->ba0_addr;\n\tregion->size = CS46XX_BA0_SIZE;\n\n\tregion = &chip->region.name.data0;\n\tstrcpy(region->name, "CS46xx_BA1_data0");\n\tregion->base = chip->ba1_addr + BA1_SP_DMEM0;\n\tregion->size = CS46XX_BA1_DATA0_SIZE;\n\n\tregion = &chip->region.name.data1;\n\tstrcpy(region->name, "CS46xx_BA1_data1");\n\tregion->base = chip->ba1_addr + BA1_SP_DMEM1;\n\tregion->size = CS46XX_BA1_DATA1_SIZE;\n\n\tregion = &chip->region.name.pmem;\n\tstrcpy(region->name, "CS46xx_BA1_pmem");\n\tregion->base = chip->ba1_addr + BA1_SP_PMEM;\n\tregion->size = CS46XX_BA1_PRG_SIZE;\n\n\tregion = &chip->region.name.reg;\n\tstrcpy(region->name, "CS46xx_BA1_reg");\n\tregion->base = chip->ba1_addr + BA1_SP_REG;\n\tregion->size = CS46XX_BA1_REG_SIZE;\n\n\t/* set up amp and clkrun hack */\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &ss_vendor);\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_ID, &ss_card);\n\n\tfor (cp = &cards[0]; cp->name; cp++) {\n\t\tif (cp->vendor == ss_vendor && cp->id == ss_card) {\n	t
845	335	axp288_charger_is_online	drivers/power/supply/axp288_charger.c	val	1	11	\N	\N	\tint ret, online = 0;\n\tunsigned int val;\n\n\tret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & PS_STAT_VBUS_VALID)\n	t
46042	227	pn_raw_send	net/phonet/af_phonet.c	skb	1	11	\N	\N	\tstruct sk_buff *skb = alloc_skb(MAX_PHONET_HEADER + len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (phonet_address_lookup(dev_net(dev), pn_addr(dst)) == 0)\n\t\tskb->pkt_type = PACKET_LOOPBACK;\n\n\tskb_reserve(skb, MAX_PHONET_HEADER);\n	t
48181	3426	clone_copy_inline_extent	fs/btrfs/ioctl.c	ext_len	2	-11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(dst->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(dst)->root;\n\tconst u64 aligned_end = ALIGN(new_key->offset + datal,\n\t\t\t\t      fs_info->sectorsize);\n\tint ret;\n\tstruct btrfs_key key;\n\n\tif (new_key->offset > 0)\n\t\treturn -EOPNOTSUPP;\n\n\tkey.objectid = btrfs_ino(BTRFS_I(dst));\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\tgoto copy_inline_extent;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == btrfs_ino(BTRFS_I(dst)) &&\n\t\t    key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tASSERT(key.offset > 0);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (i_size_read(dst) <= datal) {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu64 ext_len;\n\n\t\t/*\n\t\t * If the file size is <= datal, make sure there are no other\n\t\t * extents following (can happen do to an fallocate call with\n\t\t * the flag FALLOC_FL_KEEP_SIZE).\n\t\t */\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\t/*\n\t\t * If it's an inline extent, it can not have other extents\n\t\t * following it.\n\t\t */\n\t\tif (btrfs_file_extent_type(path->nodes[0], ei) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tgoto copy_inline_extent;\n\n\t\text_len = btrfs_file_extent_num_bytes(path->nodes[0], ei);\n\t\tif (ext_len > aligned_end)\n	t
63665	281	fat_get_parent	fs/fat/nfs.c	parent_logstart	1	11	\N	\N	\tstruct super_block *sb = child_dir->d_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent_inode = NULL;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (!fat_get_dotdot_entry(d_inode(child_dir), &bh, &de)) {\n\t\tint parent_logstart = fat_get_start(sbi, de);\n\t\tparent_inode = fat_dget(sb, parent_logstart);\n	t
102697	1771	get_memory_layout	drivers/edac/sb_edac.c	reg	1	11	\N	\N	\tstruct sbridge_pvt *pvt = mci->pvt_info;\n\tint i, j, k, n_sads, n_tads, sad_interl;\n\tu32 reg;\n\tu64 limit, prv = 0;\n\tu64 tmp_mb;\n\tu32 gb, mb;\n\tu32 rir_way;\n\n\t/*\n\t * Step 1) Get TOLM/TOHM ranges\n\t */\n\n\tpvt->tolm = pvt->info.get_tolm(pvt);\n\ttmp_mb = (1 + pvt->tolm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tolm);\n\n\t/* Address range is already 45:25 */\n\tpvt->tohm = pvt->info.get_tohm(pvt);\n\ttmp_mb = (1 + pvt->tohm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tohm);\n\n\t/*\n\t * Step 2) Get SAD range and SAD Interleave list\n\t * TAD registers contain the interleave wayness. However, it\n\t * seems simpler to just discover it indirectly, with the\n\t * algorithm bellow.\n\t */\n\tprv = 0;\n\tfor (n_sads = 0; n_sads < pvt->info.max_sad; n_sads++) {\n\t\t/* SAD_LIMIT Address range is 45:26 */\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.dram_rule[n_sads],\n\t\t\t\t      &reg);\n\t\tlimit = pvt->info.sad_limit(reg);\n\n\t\tif (!DRAM_RULE_ENABLE(reg))\n	t
-231	164	stm32_pwm_lp_get_state	drivers/pwm/pwm-stm32-lp.c	val	5	20	\N	\N	\tstruct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);\n\tunsigned long rate = clk_get_rate(priv->clk);\n\tu32 val, presc, prd;\n\tu64 tmp;\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CR, &val);\n\tstate->enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);\n	f
-227	325	axi_clkgen_recalc_rate	drivers/clk/clk-axi-clkgen.c	d	5	20	\N	\N	\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\tunsigned int d, m, dout;\n\tunsigned int reg;\n\tunsigned long long tmp;\n\n\taxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLKOUT0_1, &reg);\n\tdout = (reg & 0x3f) + ((reg >> 6) & 0x3f);\n\taxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLK_DIV, &reg);\n\td = (reg & 0x3f) + ((reg >> 6) & 0x3f);\n\taxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLK_FB1, &reg);\n\tm = (reg & 0x3f) + ((reg >> 6) & 0x3f);\n\n\tif (d == 0 || dout == 0)\n	f
-225	58	am335x_tscadc_need_adc	drivers/mfd/ti_am335x_tscadc.c	reg	5	20	\N	\N	\tDEFINE_WAIT(wait);\n\tu32 reg;\n\n\tregmap_read(tscadc->regmap, REG_ADCFSM, &reg);\n\tif (reg & SEQ_STATUS) {\n	f
58156	93	call_usermodehelper_exec_async	kernel/umh.c	new	0	11	\N	\N	\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/*\n\t * Our parent (unbound workqueue) runs with elevated scheduling\n\t * priority. Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n	f
47490	1889	cm_chan_msg_rcv	drivers/rapidio/rio_cm.c	cm_chan_msg_rcv_$__UNIQUE_ID_min1_267$obj	0	11	\N	\N	\tstruct rio_cm_msg msg;\n\tstruct rio_channel *ch;\n\tvoid *buf;\n\tlong rxto;\n\tint ret = 0, msg_size;\n\n\tif (copy_from_user(&msg, arg, sizeof(msg)))\n\t\treturn -EFAULT;\n\n\tif (msg.ch_num == 0 || msg.size == 0)\n\t\treturn -EINVAL;\n\n\tch = riocm_get_channel(msg.ch_num);\n\tif (!ch)\n\t\treturn -ENODEV;\n\n\trxto = msg.rxto ? msecs_to_jiffies(msg.rxto) : MAX_SCHEDULE_TIMEOUT;\n\n\tret = riocm_ch_receive(ch, &buf, rxto);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg_size = min(msg.size, (u16)(RIO_MAX_MSG_SIZE));\n	t
58012	307	cap11xx_init_leds	drivers/input/keyboard/cap11xx.c	reg	1	11	\N	\N	\tstruct device_node *node = dev->of_node, *child;\n\tstruct cap11xx_led *led;\n\tint cnt = of_get_child_count(node);\n\tint error;\n\n\tif (!num_leds || !cnt)\n\t\treturn 0;\n\n\tif (cnt > num_leds)\n\t\treturn -EINVAL;\n\n\tled = devm_kcalloc(dev, cnt, sizeof(struct cap11xx_led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tpriv->leds = led;\n\n\terror = regmap_update_bits(priv->regmap,\n\t\t\t\tCAP11XX_REG_LED_OUTPUT_CONTROL, 0xff, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_update_bits(priv->regmap, CAP11XX_REG_LED_DUTY_CYCLE_4,\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_MASK,\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_VALUE <<\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_MASK_SHIFT);\n\tif (error)\n\t\treturn error;\n\n\tfor_each_child_of_node(node, child) {\n\t\tu32 reg;\n\n\t\tled->cdev.name =\n\t\t\tof_get_property(child, "label", NULL) ? : child->name;\n\t\tled->cdev.default_trigger =\n\t\t\tof_get_property(child, "linux,default-trigger", NULL);\n\t\tled->cdev.flags = 0;\n\t\tled->cdev.brightness_set = cap11xx_led_set;\n\t\tled->cdev.max_brightness = 1;\n\t\tled->cdev.brightness = LED_OFF;\n\n\t\terror = of_property_read_u32(child, "reg", &reg);\n\t\tif (error != 0 || reg >= num_leds) {\n	f
3314	383	m5mols_set_mode	drivers/media/i2c/m5mols/m5mols_core.c	reg	1	11	\N	\N	\tstruct v4l2_subdev *sd = &info->sd;\n\tint ret = -EINVAL;\n\tu8 reg;\n\n\tif (mode < REG_PARAMETER || mode > REG_CAPTURE)\n\t\treturn ret;\n\n\tret = m5mols_read_u8(sd, SYSTEM_SYSMODE, &reg);\n\tif (ret || reg == mode)\n	t
-235	35	rt5033_battery_get_present	drivers/power/supply/rt5033_battery.c	val	5	20	\N	\N	\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\tu32 val;\n\n\tregmap_read(battery->regmap, RT5033_FUEL_REG_CONFIG_L, &val);\n\n\treturn (val & RT5033_FUEL_BAT_PRESENT) ? true : false;\n	f
46253	562	lstcon_nodes_add	drivers/staging/lustre/lnet/selftest/console.c	grp->grp_ref	1	11	\N	\N	\tstruct lstcon_group *grp;\n\tint rc;\n\n\tLASSERT(count > 0);\n\tLASSERT(ids_up);\n\n\trc = lstcon_group_find(name, &grp);\n\tif (rc) {\n\t\tCDEBUG(D_NET, "Can't find group %s\\n", name);\n\t\treturn rc;\n\t}\n\n\tif (grp->grp_ref > 2) {\n	t
-236	164	iproc_adc_interrupt_thread	drivers/iio/adc/bcm_iproc_adc.c	intr_status	5	20	\N	\N	\tu32 channel_intr_status;\n\tu32 intr_status;\n\tu32 intr_mask;\n\tstruct iio_dev *indio_dev = data;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\t/*\n\t * This interrupt is shared with the touchscreen driver.\n\t * Make sure this interrupt is intended for us.\n\t * Handle only ADC channel specific interrupts.\n\t */\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &intr_mask);\n\tintr_status = intr_status & intr_mask;\n\tchannel_intr_status = (intr_status & IPROC_ADC_INTR_MASK) >>\n\t\t\t\tIPROC_ADC_INTR;\n\tif (channel_intr_status)\n	f
48176	197	dwc3_exynos_probe	drivers/usb/dwc3/dwc3-exynos.c	exynos->usb3_phy	1	11	\N	\N	\tstruct dwc3_exynos\t*exynos;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct device_node\t*node = dev->of_node;\n\n\tint\t\t\tret;\n\n\texynos = devm_kzalloc(dev, sizeof(*exynos), GFP_KERNEL);\n\tif (!exynos)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, exynos);\n\n\texynos->dev\t= dev;\n\n\texynos->clk = devm_clk_get(dev, "usbdrd30");\n\tif (IS_ERR(exynos->clk)) {\n\t\tdev_err(dev, "couldn't get clock\\n");\n\t\treturn -EINVAL;\n\t}\n\tret = clk_prepare_enable(exynos->clk);\n\tif (ret)\n\t\treturn ret;\n\n\texynos->susp_clk = devm_clk_get(dev, "usbdrd30_susp_clk");\n\tif (IS_ERR(exynos->susp_clk))\n\t\texynos->susp_clk = NULL;\n\tret = clk_prepare_enable(exynos->susp_clk);\n\tif (ret)\n\t\tgoto susp_clk_err;\n\n\tif (of_device_is_compatible(node, "samsung,exynos7-dwusb3")) {\n\t\texynos->axius_clk = devm_clk_get(dev, "usbdrd30_axius_clk");\n\t\tif (IS_ERR(exynos->axius_clk)) {\n\t\t\tdev_err(dev, "no AXI UpScaler clk specified\\n");\n\t\t\tret = -ENODEV;\n\t\t\tgoto axius_clk_err;\n\t\t}\n\t\tret = clk_prepare_enable(exynos->axius_clk);\n\t\tif (ret)\n\t\t\tgoto axius_clk_err;\n\t} else {\n\t\texynos->axius_clk = NULL;\n\t}\n\n\texynos->vdd33 = devm_regulator_get(dev, "vdd33");\n\tif (IS_ERR(exynos->vdd33)) {\n\t\tret = PTR_ERR(exynos->vdd33);\n\t\tgoto vdd33_err;\n\t}\n\tret = regulator_enable(exynos->vdd33);\n\tif (ret) {\n\t\tdev_err(dev, "Failed to enable VDD33 supply\\n");\n\t\tgoto vdd33_err;\n\t}\n\n\texynos->vdd10 = devm_regulator_get(dev, "vdd10");\n\tif (IS_ERR(exynos->vdd10)) {\n\t\tret = PTR_ERR(exynos->vdd10);\n\t\tgoto vdd10_err;\n\t}\n\tret = regulator_enable(exynos->vdd10);\n\tif (ret) {\n\t\tdev_err(dev, "Failed to enable VDD10 supply\\n");\n\t\tgoto vdd10_err;\n\t}\n\n\tret = dwc3_exynos_register_phys(exynos);\n\tif (ret) {\n\t\tdev_err(dev, "couldn't register PHYs\\n");\n\t\tgoto phys_err;\n\t}\n\n\tif (node) {\n\t\tret = of_platform_populate(node, NULL, NULL, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, "failed to add dwc3 core\\n");\n\t\t\tgoto populate_err;\n\t\t}\n\t} else {\n\t\tdev_err(dev, "no device node, failed to add dwc3 core\\n");\n\t\tret = -ENODEV;\n\t\tgoto populate_err;\n\t}\n\n\treturn 0;\n\npopulate_err:\n\tplatform_device_unregister(exynos->usb2_phy);\n\tplatform_device_unregister(exynos->usb3_phy);\n	t
58134	154	__dwc3_set_mode	drivers/usb/dwc3/core.c	ret	1	11	\N	\N	\tstruct dwc3 *dwc = work_to_dwc(work);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!dwc->desired_dr_role)\n\t\treturn;\n\n\tif (dwc->desired_dr_role == dwc->current_dr_role)\n\t\treturn;\n\n\tif (dwc->dr_mode != USB_DR_MODE_OTG)\n\t\treturn;\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tdwc3_host_exit(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tdwc3_gadget_exit(dwc);\n\t\tdwc3_event_buffers_cleanup(dwc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\n\tdwc3_set_prtcap(dwc, dwc->desired_dr_role);\n\n\tdwc->current_dr_role = dwc->desired_dr_role;\n\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tswitch (dwc->desired_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tret = dwc3_host_init(dwc);\n\t\tif (ret) {\n	f
59599	10540	ipr_probe	drivers/scsi/ipr.c	rc	1	11	\N	\N	\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long flags;\n\tint rc, i;\n\n\trc = ipr_probe_ioa(pdev, dev_id);\n\n\tif (rc)\n	t
3679	504	get_signal_parameters	drivers/media/dvb-frontends/stv0910.c	tmp	7	12	\N	\N	\tu8 tmp;\n\n\tif (!state->started)\n\t\treturn -EINVAL;\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tread_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);\n\t\tstate->mod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);\n\t\tstate->pilots = (tmp & 0x01) != 0;\n	t
50750	1565	snd_asihpi_volume_mute_get	sound/pci/asihpi/asihpi.c	mute	6	12	\N	\N	\tu32 h_control = kcontrol->private_value;\n\tu32 mute;\n\n\thpi_handle_error(hpi_volume_get_mute(h_control, &mute));\n\tucontrol->value.integer.value[0] = mute ? 0 : 1;\n	t
34310	24	nf_do_netdev_egress	net/netfilter/nf_dup_netdev.c	skb	1	11	\N	\N	\tif (skb_mac_header_was_set(skb))\n\t\tskb_push(skb, skb->mac_len);\n\n\tskb->dev = dev;\n\tdev_queue_xmit(skb);\n	t
53685	1544	userfaultfd_unregister	fs/userfaultfd.c	userfaultfd_unregister_$vma$obj$0$obj	0	11	\N	\N	\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n	t
35615	173	if_sdio_read_rx_unit	drivers/net/wireless/marvell/libertas/if_sdio.c	ret	1	11	\N	\N	\tint ret;\n\tu8 rx_unit;\n\n\trx_unit = sdio_readb(card->func, IF_SDIO_RX_UNIT, &ret);\n\n\tif (ret)\n	t
28561	2642	ieee80211_rx_h_data	net/mac80211/rx.c	port_control	1	13	\N	\N	\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct net_device *dev = sdata->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\t__le16 fc = hdr->frame_control;\n\tbool port_control;\n\tint err;\n\n\tif (unlikely(!ieee80211_is_data(hdr->frame_control)))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn RX_DROP_MONITOR;\n\n\t/*\n\t * Send unexpected-4addr-frame event to hostapd. For older versions,\n\t * also drop the frame to cooked monitor interfaces.\n\t */\n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tif (rx->sta &&\n\t\t    !test_and_set_sta_flag(rx->sta, WLAN_STA_4ADDR_EVENT))\n\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\trx->sdata->dev, rx->sta->sta.addr, GFP_ATOMIC);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\terr = __ieee80211_data_to_8023(rx, &port_control);\n\tif (unlikely(err))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (!ieee80211_frame_allowed(rx, fc))\n\t\treturn RX_DROP_MONITOR;\n\n\t/* directly handle TDLS channel switch requests/responses */\n\tif (unlikely(((struct ethhdr *)rx->skb->data)->h_proto ==\n\t\t\t\t\t\tcpu_to_be16(ETH_P_TDLS))) {\n\t\tstruct ieee80211_tdls_data *tf = (void *)rx->skb->data;\n\n\t\tif (pskb_may_pull(rx->skb,\n\t\t\t\t  offsetof(struct ieee80211_tdls_data, u)) &&\n\t\t    tf->payload_type == WLAN_TDLS_SNAP_RFTYPE &&\n\t\t    tf->category == WLAN_CATEGORY_TDLS &&\n\t\t    (tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST ||\n\t\t     tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE)) {\n\t\t\tskb_queue_tail(&local->skb_queue_tdls_chsw, rx->skb);\n\t\t\tschedule_work(&local->tdls_chsw_work);\n\t\t\tif (rx->sta)\n\t\t\t\trx->sta->rx_stats.packets++;\n\n\t\t\treturn RX_QUEUED;\n\t\t}\n\t}\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    unlikely(port_control) && sdata->bss) {\n	f
35763	966	nilfs_cpfile_get_stat	fs/nilfs2/cpfile.c	nilfs_cpfile_get_stat_$bh$obj$2	0	11	\N	\N	\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n	t
59138	841	hci_sock_release	net/bluetooth/hci_sock.c	skb	1	11	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\n\tBT_DBG("sock %p sk %p", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\thdev = hci_pi(sk)->hdev;\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_MONITOR:\n\t\tatomic_dec(&monitor_promisc);\n\t\tbreak;\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\t\t/* Send event to monitor */\n\t\tskb = create_monitor_ctrl_close(sk);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n	f
29425	3060	tcp_send_active_reset	net/ipv4/tcp_output.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_OUTRSTS);\n\n\t/* NOTE: No TCP options attached and we never retransmit this. */\n\tskb = alloc_skb(MAX_TCP_HEADER, priority);\n\tif (!skb) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTFAILED);\n\t\treturn;\n\t}\n\n\t/* Reserve space for headers and prepare control bits. */\n\tskb_reserve(skb, MAX_TCP_HEADER);\n	t
-249	507	hpet_msi_resume	arch/x86/kernel/hpet.c	msg.f2	5	20	\N	\N	\tstruct hpet_dev *hdev = EVT_TO_HPET_DEV(evt);\n\tstruct irq_data *data = irq_get_irq_data(hdev->irq);\n\tstruct msi_msg msg;\n\n\t/* Restore the MSI msg and unmask the interrupt */\n\tirq_chip_compose_msi_msg(data, &msg);\n\thpet_msi_write(hdev, &msg);\n	f
42518	125	via_driver_irq_handler	drivers/gpu/drm/via/via_irq.c	&cur_vblank	1	11	\N	\N	\tstruct drm_device *dev = (struct drm_device *) arg;\n\tdrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\n\tu32 status;\n\tint handled = 0;\n\tstruct timeval cur_vblank;\n\tdrm_via_irq_t *cur_irq = dev_priv->via_irqs;\n\tint i;\n\n\tstatus = VIA_READ(VIA_REG_INTERRUPT);\n\tif (status & VIA_IRQ_VBLANK_PENDING) {\n\t\tatomic_inc(&dev_priv->vbl_received);\n\t\tif (!(atomic_read(&dev_priv->vbl_received) & 0x0F)) {\n\t\t\tdo_gettimeofday(&cur_vblank);\n\t\t\tif (dev_priv->last_vblank_valid) {\n\t\t\t\tdev_priv->usec_per_vblank =\n\t\t\t\t\ttime_diff(&cur_vblank,\n	t
33473	981	icmpv6_sk_init	net/ipv6/icmp.c	sk	5	12	\N	propagation	\tstruct sock *sk;\n\tint err, i, j;\n\n\tnet->ipv6.icmp_sk =\n\t\tkzalloc(nr_cpu_ids * sizeof(struct sock *), GFP_KERNEL);\n\tif (!net->ipv6.icmp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\t\tif (err < 0) {\n\t\t\tpr_err("Failed to initialize the ICMP6 control socket (err %d)\\n",\n\t\t\t       err);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnet->ipv6.icmp_sk[i] = sk;\n\n\t\t/* Enough space for 2 64K ICMP packets, including\n\t\t * sk_buff struct overhead.\n\t\t */\n\t\tsk->sk_sndbuf = 2 * SKB_TRUESIZE(64 * 1024);\n\t}\n\treturn 0;\n\n fail:\n\tfor (j = 0; j < i; j++)\n\t\tinet_ctl_sock_destroy(net->ipv6.icmp_sk[j]);\n	t
44766	745	genwqe_set_interrupt_capability	drivers/misc/genwqe/card_utils.c	rc	1	11	\N	\N	\tint rc;\n\n\trc = pci_alloc_irq_vectors(cd->pci_dev, 1, count, PCI_IRQ_MSI);\n\tif (rc < 0)\n	t
31914	437	arch_copy_kprobe	arch/x86/kernel/kprobes/core.c	&insn	1	13	\N	\N	\tstruct insn insn;\n\tint len;\n\n\tset_memory_rw((unsigned long)p->ainsn.insn & PAGE_MASK, 1);\n\n\t/* Copy an instruction with recovering if other optprobe modifies it.*/\n\tlen = __copy_instruction(p->ainsn.insn, p->addr, &insn);\n	f
59491	57	encrypt	arch/x86/crypto/salsa20_glue.c	&walk	1	11	\N	\N	\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n	f
-245	312	stm32_pwm_detect_channels	drivers/pwm/pwm-stm32.c	ccer	5	20	\N	\N	\tu32 ccer;\n\tint npwm = 0;\n\n\t/*\n\t * If channels enable bits don't exist writing 1 will have no\n\t * effect so we can detect and count them.\n\t */\n\tregmap_update_bits(priv->regmap,\n\t\t\t   TIM_CCER, TIM_CCER_CCXE, TIM_CCER_CCXE);\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tregmap_update_bits(priv->regmap, TIM_CCER, TIM_CCER_CCXE, 0);\n\n\tif (ccer & TIM_CCER_CC1E)\n	f
51790	37	do_sys_name_to_handle	fs/fhandle.c	do_sys_name_to_handle_$f_handle$0$obj	0	11	\N	\N	\tlong retval;\n\tstruct file_handle f_handle;\n\tint handle_dwords, handle_bytes;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * We need to make sure whether the file system\n\t * support decoding of the file handle\n\t */\n\tif (!path->dentry->d_sb->s_export_op ||\n\t    !path->dentry->d_sb->s_export_op->fh_to_dentry)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle)))\n\t\treturn -EFAULT;\n\n\tif (f_handle.handle_bytes > MAX_HANDLE_SZ)\n	t
823	989	smb347_usb_get_property	drivers/power/supply/smb347-charger.c	ret	1	11	\N	\N	\tstruct smb347_charger *smb = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = smb->usb_online;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = get_const_charge_voltage(smb);\n\t\tif (ret < 0)\n	t
7567	447	atlas_read_raw	drivers/iio/chemical/atlas-ph-sensor.c	ret	1	11	\N	\N	\tstruct atlas_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\t\t__be32 reg;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = regmap_bulk_read(data->regmap, chan->address,\n\t\t\t\t\t      (u8 *) &reg, sizeof(reg));\n\t\t\tbreak;\n\t\tcase IIO_PH:\n\t\tcase IIO_CONCENTRATION:\n\t\tcase IIO_ELECTRICALCONDUCTIVITY:\n\t\tcase IIO_VOLTAGE:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = atlas_read_measurement(data, chan->address, &reg);\n\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (!ret) {\n	t
25539	1488	port_disable	drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c	ret	1	11	\N	\N	\tint ret;\n\tstruct list_head *q, *buf_head;\n\tunsigned long flags = 0;\n\n\tif (!port->enabled)\n\t\treturn 0;\n\n\tport->enabled = false;\n\n\tret = port_action_port(instance, port,\n\t\t\t       MMAL_MSG_PORT_ACTION_TYPE_DISABLE);\n\tif (ret == 0) {\n	t
31998	1384	calc_target	net/ceph/osd_client.c	pgid.seed	1	11	\N	\N	\tstruct ceph_pg_pool_info *pi;\n\tstruct ceph_pg pgid, last_pgid;\n\tstruct ceph_osds up, acting;\n\tbool force_resend = false;\n\tbool unpaused = false;\n\tbool legacy_change;\n\tbool split = false;\n\tbool sort_bitwise = ceph_osdmap_flag(osdc, CEPH_OSDMAP_SORTBITWISE);\n\tbool recovery_deletes = ceph_osdmap_flag(osdc,\n\t\t\t\t\t\t CEPH_OSDMAP_RECOVERY_DELETES);\n\tenum calc_target_result ct_res;\n\tint ret;\n\n\tt->epoch = osdc->osdmap->epoch;\n\tpi = ceph_pg_pool_by_id(osdc->osdmap, t->base_oloc.pool);\n\tif (!pi) {\n\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\tgoto out;\n\t}\n\n\tif (osdc->osdmap->epoch == pi->last_force_request_resend) {\n\t\tif (t->last_force_resend < pi->last_force_request_resend) {\n\t\t\tt->last_force_resend = pi->last_force_request_resend;\n\t\t\tforce_resend = true;\n\t\t} else if (t->last_force_resend == 0) {\n\t\t\tforce_resend = true;\n\t\t}\n\t}\n\n\t/* apply tiering */\n\tceph_oid_copy(&t->target_oid, &t->base_oid);\n\tceph_oloc_copy(&t->target_oloc, &t->base_oloc);\n\tif ((t->flags & CEPH_OSD_FLAG_IGNORE_OVERLAY) == 0) {\n\t\tif (t->flags & CEPH_OSD_FLAG_READ && pi->read_tier >= 0)\n\t\t\tt->target_oloc.pool = pi->read_tier;\n\t\tif (t->flags & CEPH_OSD_FLAG_WRITE && pi->write_tier >= 0)\n\t\t\tt->target_oloc.pool = pi->write_tier;\n\n\t\tpi = ceph_pg_pool_by_id(osdc->osdmap, t->target_oloc.pool);\n\t\tif (!pi) {\n\t\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __ceph_object_locator_to_pg(pi, &t->target_oid, &t->target_oloc,\n\t\t\t\t\t  &pgid);\n\tif (ret) {\n\t\tWARN_ON(ret != -ENOENT);\n\t\tt->osd = CEPH_HOMELESS_OSD;\n\t\tct_res = CALC_TARGET_POOL_DNE;\n\t\tgoto out;\n\t}\n\tlast_pgid.pool = pgid.pool;\n\tlast_pgid.seed = ceph_stable_mod(pgid.seed, t->pg_num, t->pg_num_mask);\n	t
40418	46	xen_pcifront_enable_irq	arch/x86/pci/xen.c	gsi	1	11	\N	\N	\tint rc;\n\tint share = 1;\n\tint pirq;\n\tu8 gsi;\n\n\trc = pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &gsi);\n\tif (rc < 0) {\n\t\tdev_warn(&dev->dev, "Xen PCI: failed to read interrupt line: %d\\n",\n\t\t\t rc);\n\t\treturn rc;\n\t}\n\t/* In PV DomU the Xen PCI backend puts the PIRQ in the interrupt line.*/\n\tpirq = gsi;\n\n\tif (gsi < nr_legacy_irqs())\n	t
21949	514	batadv_frag_send_packet	net/batman-adv/fragmentation.c	&frag_header	0	11	\N	\N	\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_frag_packet frag_header;\n\tstruct sk_buff *skb_fragment;\n\tunsigned int mtu = neigh_node->if_incoming->net_dev->mtu;\n\tunsigned int header_size = sizeof(frag_header);\n\tunsigned int max_fragment_size, num_fragments;\n\tint ret;\n\n\t/* To avoid merge and refragmentation at next-hops we never send\n\t * fragments larger than BATADV_FRAG_MAX_FRAG_SIZE\n\t */\n\tmtu = min_t(unsigned int, mtu, BATADV_FRAG_MAX_FRAG_SIZE);\n\tmax_fragment_size = mtu - header_size;\n\n\tif (skb->len == 0 || max_fragment_size == 0)\n\t\treturn -EINVAL;\n\n\tnum_fragments = (skb->len - 1) / max_fragment_size + 1;\n\tmax_fragment_size = (skb->len - 1) / num_fragments + 1;\n\n\t/* Don't even try to fragment, if we need more than 16 fragments */\n\tif (num_fragments > BATADV_FRAG_MAX_FRAGMENTS) {\n\t\tret = -EAGAIN;\n\t\tgoto free_skb;\n\t}\n\n\tbat_priv = orig_node->bat_priv;\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if) {\n\t\tret = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\t/* Create one header to be copied to all fragments */\n\tfrag_header.packet_type = BATADV_UNICAST_FRAG;\n\tfrag_header.version = BATADV_COMPAT_VERSION;\n\tfrag_header.ttl = BATADV_TTL;\n\tfrag_header.seqno = htons(atomic_inc_return(&bat_priv->frag_seqno));\n\tfrag_header.reserved = 0;\n\tfrag_header.no = 0;\n\tfrag_header.total_size = htons(skb->len);\n\n\t/* skb->priority values from 256->263 are magic values to\n\t * directly indicate a specific 802.1d priority.  This is used\n\t * to allow 802.1d priority to be passed directly in from VLAN\n\t * tags, etc.\n\t */\n\tif (skb->priority >= 256 && skb->priority <= 263)\n\t\tfrag_header.priority = skb->priority - 256;\n\n\tether_addr_copy(frag_header.orig, primary_if->net_dev->dev_addr);\n\tether_addr_copy(frag_header.dest, orig_node->orig);\n\n\t/* Eat and send fragments from the tail of skb */\n\twhile (skb->len > max_fragment_size) {\n\t\t/* The initial check in this function should cover this case */\n\t\tif (unlikely(frag_header.no == BATADV_FRAG_MAX_FRAGMENTS - 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_primary_if;\n\t\t}\n\n\t\tskb_fragment = batadv_frag_create(skb, &frag_header,\n	f
59688	4130	rbd_queue_workfn	drivers/block/rbd.c	img_request	1	11	\N	\N	\tstruct request *rq = blk_mq_rq_from_pdu(work);\n\tstruct rbd_device *rbd_dev = rq->q->queuedata;\n\tstruct rbd_img_request *img_request;\n\tstruct ceph_snap_context *snapc = NULL;\n\tu64 offset = (u64)blk_rq_pos(rq) << SECTOR_SHIFT;\n\tu64 length = blk_rq_bytes(rq);\n\tenum obj_operation_type op_type;\n\tu64 mapping_size;\n\tbool must_be_locked;\n\tint result;\n\n\tswitch (req_op(rq)) {\n\tcase REQ_OP_DISCARD:\n\tcase REQ_OP_WRITE_ZEROES:\n\t\top_type = OBJ_OP_DISCARD;\n\t\tbreak;\n\tcase REQ_OP_WRITE:\n\t\top_type = OBJ_OP_WRITE;\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\top_type = OBJ_OP_READ;\n\t\tbreak;\n\tdefault:\n\t\tdout("%s: non-fs request type %d\\n", __func__, req_op(rq));\n\t\tresult = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Ignore/skip any zero-length requests */\n\n\tif (!length) {\n\t\tdout("%s: zero-length request\\n", __func__);\n\t\tresult = 0;\n\t\tgoto err_rq;\n\t}\n\n\t/* Only reads are allowed to a read-only device */\n\n\tif (op_type != OBJ_OP_READ) {\n\t\tif (rbd_dev->mapping.read_only) {\n\t\t\tresult = -EROFS;\n\t\t\tgoto err_rq;\n\t\t}\n\t\trbd_assert(rbd_dev->spec->snap_id == CEPH_NOSNAP);\n\t}\n\n\t/*\n\t * Quit early if the mapped snapshot no longer exists.  It's\n\t * still possible the snapshot will have disappeared by the\n\t * time our request arrives at the osd, but there's no sense in\n\t * sending it if we already know.\n\t */\n\tif (!test_bit(RBD_DEV_FLAG_EXISTS, &rbd_dev->flags)) {\n\t\tdout("request for non-existent snapshot");\n\t\trbd_assert(rbd_dev->spec->snap_id != CEPH_NOSNAP);\n\t\tresult = -ENXIO;\n\t\tgoto err_rq;\n\t}\n\n\tif (offset && length > U64_MAX - offset + 1) {\n\t\trbd_warn(rbd_dev, "bad request range (%llu~%llu)", offset,\n\t\t\t length);\n\t\tresult = -EINVAL;\n\t\tgoto err_rq;\t/* Shouldn't happen */\n\t}\n\n\tblk_mq_start_request(rq);\n\n\tdown_read(&rbd_dev->header_rwsem);\n\tmapping_size = rbd_dev->mapping.size;\n\tif (op_type != OBJ_OP_READ) {\n\t\tsnapc = rbd_dev->header.snapc;\n\t\tceph_get_snap_context(snapc);\n\t}\n\tup_read(&rbd_dev->header_rwsem);\n\n\tif (offset + length > mapping_size) {\n\t\trbd_warn(rbd_dev, "beyond EOD (%llu~%llu > %llu)", offset,\n\t\t\t length, mapping_size);\n\t\tresult = -EIO;\n\t\tgoto err_rq;\n\t}\n\n\tmust_be_locked =\n\t    (rbd_dev->header.features & RBD_FEATURE_EXCLUSIVE_LOCK) &&\n\t    (op_type != OBJ_OP_READ || rbd_dev->opts->lock_on_read);\n\tif (must_be_locked) {\n\t\tdown_read(&rbd_dev->lock_rwsem);\n\t\tif (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED &&\n\t\t    !test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags)) {\n\t\t\tif (rbd_dev->opts->exclusive) {\n\t\t\t\trbd_warn(rbd_dev, "exclusive lock required");\n\t\t\t\tresult = -EROFS;\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\trbd_wait_state_locked(rbd_dev);\n\t\t}\n\t\tif (test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags)) {\n\t\t\tresult = -EBLACKLISTED;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\timg_request = rbd_img_request_create(rbd_dev, offset, length, op_type,\n\t\t\t\t\t     snapc);\n\tif (!img_request) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\timg_request->rq = rq;\n\tsnapc = NULL; /* img_request consumes a ref */\n\n\tif (op_type == OBJ_OP_DISCARD)\n\t\tresult = rbd_img_request_fill(img_request, OBJ_REQUEST_NODATA,\n	t
47816	871	diva_mnt_add_xdi_adapter	drivers/isdn/hardware/eicon/debug.c	diva_mnt_add_xdi_adapter_$serial$obj$and$-16777216$lshr$24$add$1	0	11	\N	\N	\N	t
2984	71	libcfs_param_debug_mb_set	drivers/staging/lustre/lnet/libcfs/debug.c	num	1	11	\N	\N	\tint rc;\n\tunsigned int num;\n\n\trc = kstrtouint(val, 0, &num);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!*((unsigned int *)kp->arg)) {\n\t\t*((unsigned int *)kp->arg) = num;\n\t\treturn 0;\n\t}\n\n\trc = cfs_trace_set_debug_mb(num);\n	t
9165	5457	bnx2x_check_fallback_to_cl37	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	rx_status	1	11	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu16 rx_status, ustat_val, cl37_fsm_received;\n\tDP(NETIF_MSG_LINK, "bnx2x_check_fallback_to_cl37\\n");\n\t/* Step 1: Make sure signal is detected */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_RX0,\n\t\t\t  MDIO_RX0_RX_STATUS,\n\t\t\t  &rx_status);\n\tif ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=\n	t
21707	754	blogic_init_mm_probeinfo	drivers/scsi/BusLogic.c	adapter_info.isa_port	1	11	\N	\N	\tstruct blogic_probeinfo *pr_probeinfo =\n\t\t&blogic_probeinfo_list[blogic_probeinfo_count];\n\tint nonpr_mmindex = blogic_probeinfo_count + 1;\n\tint nonpr_mmcount = 0, mmcount = 0;\n\tbool force_scan_order = false;\n\tbool force_scan_order_checked = false;\n\tbool addr_seen[6];\n\tstruct pci_dev *pci_device = NULL;\n\tint i;\n\tif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\n\t\treturn 0;\n\tblogic_probeinfo_count++;\n\tfor (i = 0; i < 6; i++)\n\t\taddr_seen[i] = false;\n\t/*\n\t   Iterate over the MultiMaster PCI Host Adapters.  For each\n\t   enumerated host adapter, determine whether its ISA Compatible\n\t   I/O Port is enabled and if so, whether it is assigned the\n\t   Primary I/O Address.  A host adapter that is assigned the\n\t   Primary I/O Address will always be the preferred boot device.\n\t   The MultiMaster BIOS will first recognize a host adapter at\n\t   the Primary I/O Address, then any other PCI host adapters,\n\t   and finally any host adapters located at the remaining\n\t   standard ISA I/O Addresses.  When a PCI host adapter is found\n\t   with its ISA Compatible I/O Port enabled, a command is issued\n\t   to disable the ISA Compatible I/O Port, and it is noted that the\n\t   particular standard ISA I/O Address need not be probed.\n\t */\n\tpr_probeinfo->io_addr = 0;\n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tstruct blogic_adapter *host_adapter = adapter;\n\t\tstruct blogic_adapter_info adapter_info;\n\t\tenum blogic_isa_ioport mod_ioaddr_req;\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long base_addr0;\n\t\tunsigned long base_addr1;\n\t\tunsigned long io_addr;\n\t\tunsigned long pci_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = base_addr0 = pci_resource_start(pci_device, 0);\n\t\tpci_addr = base_addr1 = pci_resource_start(pci_device, 1);\n\n\t\tif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\n\t\t\tblogic_err("BusLogic: Base Address0 0x%X not I/O for " "MultiMaster Host Adapter\\n", NULL, base_addr0);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\n\t\t\tblogic_err("BusLogic: Base Address1 0x%X not Memory for " "MultiMaster Host Adapter\\n", NULL, base_addr1);\n\t\t\tblogic_err("at PCI Bus %d Device %d PCI Address 0x%X\\n", NULL, bus, device, pci_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (irq_ch == 0) {\n\t\t\tblogic_err("BusLogic: IRQ Channel %d invalid for " "MultiMaster Host Adapter\\n", NULL, irq_ch);\n\t\t\tblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\\n", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (blogic_global_options.trace_probe) {\n\t\t\tblogic_notice("BusLogic: PCI MultiMaster Host Adapter " "detected at\\n", NULL);\n\t\t\tblogic_notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\\n", NULL, bus, device, io_addr, pci_addr);\n\t\t}\n\t\t/*\n\t\t   Issue the Inquire PCI Host Adapter Information command to determine\n\t\t   the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is\n\t\t   known and enabled, note that the particular Standard ISA I/O\n\t\t   Address should not be probed.\n\t\t */\n\t\thost_adapter->io_addr = io_addr;\n\t\tblogic_intreset(host_adapter);\n\t\tif (blogic_cmd(host_adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\n\t\t\t\t&adapter_info, sizeof(adapter_info)) ==\n\t\t\t\tsizeof(adapter_info)) {\n\t\t\tif (adapter_info.isa_port < 6)\n	t
28719	921	mdc_dma_probe	drivers/dma/img-mdc-dma.c	ret	1	11	\N	\N	\tstruct mdc_dma *mdma;\n\tstruct resource *res;\n\tunsigned int i;\n\tu32 val;\n\tint ret;\n\n\tmdma = devm_kzalloc(&pdev->dev, sizeof(*mdma), GFP_KERNEL);\n\tif (!mdma)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, mdma);\n\n\tmdma->soc = of_device_get_match_data(&pdev->dev);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tmdma->regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(mdma->regs))\n\t\treturn PTR_ERR(mdma->regs);\n\n\tmdma->periph_regs = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t    "img,cr-periph");\n\tif (IS_ERR(mdma->periph_regs))\n\t\treturn PTR_ERR(mdma->periph_regs);\n\n\tmdma->clk = devm_clk_get(&pdev->dev, "sys");\n\tif (IS_ERR(mdma->clk))\n\t\treturn PTR_ERR(mdma->clk);\n\n\tret = clk_prepare_enable(mdma->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_cap_zero(mdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_SLAVE, mdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, mdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, mdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, mdma->dma_dev.cap_mask);\n\n\tval = mdc_readl(mdma, MDC_GLOBAL_CONFIG_A);\n\tmdma->nr_channels = (val >> MDC_GLOBAL_CONFIG_A_DMA_CONTEXTS_SHIFT) &\n\t\tMDC_GLOBAL_CONFIG_A_DMA_CONTEXTS_MASK;\n\tmdma->nr_threads =\n\t\t1 << ((val >> MDC_GLOBAL_CONFIG_A_THREAD_ID_WIDTH_SHIFT) &\n\t\t      MDC_GLOBAL_CONFIG_A_THREAD_ID_WIDTH_MASK);\n\tmdma->bus_width =\n\t\t(1 << ((val >> MDC_GLOBAL_CONFIG_A_SYS_DAT_WIDTH_SHIFT) &\n\t\t       MDC_GLOBAL_CONFIG_A_SYS_DAT_WIDTH_MASK)) / 8;\n\t/*\n\t * Although transfer sizes of up to MDC_TRANSFER_SIZE_MASK + 1 bytes\n\t * are supported, this makes it possible for the value reported in\n\t * MDC_ACTIVE_TRANSFER_SIZE to be ambiguous - an active transfer size\n\t * of MDC_TRANSFER_SIZE_MASK may indicate either that 0 bytes or\n\t * MDC_TRANSFER_SIZE_MASK + 1 bytes are remaining.  To eliminate this\n\t * ambiguity, restrict transfer sizes to one bus-width less than the\n\t * actual maximum.\n\t */\n\tmdma->max_xfer_size = MDC_TRANSFER_SIZE_MASK + 1 - mdma->bus_width;\n\n\tof_property_read_u32(pdev->dev.of_node, "dma-channels",\n\t\t\t     &mdma->nr_channels);\n\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t   "img,max-burst-multiplier",\n\t\t\t\t   &mdma->max_burst_mult);\n\tif (ret)\n	t
37744	713	mcs_net_open	drivers/staging/irda/drivers/mcs7780.c	ret	1	11	\N	\N	\tstruct mcs_cb *mcs = netdev_priv(netdev);\n\tchar hwname[16];\n\tint ret = 0;\n\n\tret = usb_clear_halt(mcs->usbdev,\n\t\t\t     usb_sndbulkpipe(mcs->usbdev, mcs->ep_in));\n\tif (ret)\n	t
25684	889	do_bufconfig_ioctl	drivers/staging/comedi/comedi_fops.c	bc.maximum_size	1	13	\N	\N	\tstruct comedi_bufconfig bc;\n\tstruct comedi_async *async;\n\tstruct comedi_subdevice *s;\n\tint retval = 0;\n\n\tif (copy_from_user(&bc, arg, sizeof(bc)))\n\t\treturn -EFAULT;\n\n\tif (bc.subdevice >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\n\ts = &dev->subdevices[bc.subdevice];\n\tasync = s->async;\n\n\tif (!async) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t"subdevice does not have async capability\\n");\n\t\tbc.size = 0;\n\t\tbc.maximum_size = 0;\n\t\tgoto copyback;\n\t}\n\n\tif (bc.maximum_size) {\n	f
51241	65	read_block	fs/ubifs/file.c	&key	1	11	\N	\N	\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err, len, out_len;\n\tunion ubifs_key key;\n\tunsigned int dlen;\n\n\tdata_key_init(c, &key, inode->i_ino, block);\n	t
56034	370	ael2005_get_module_type	drivers/net/ethernet/chelsio/cxgb3/ael1002.c	stat	1	11	\N	\N	\tint v;\n\tunsigned int stat;\n\n\tv = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, &stat);\n\tif (v)\n\t\treturn v;\n\n\tif (stat & (1 << 8))\t\t\t/* module absent */\n	t
1857	81	memory_bm_set_bit	kernel/power/snapshot.c	memory_bm_set_bit_$nr.addr.i$obj	0	11	\N	\N	\tif (hibernate_restore_protection_active)\n\t\tset_memory_rw((unsigned long)page_address, 1);\n}\n#else\nstatic inline void hibernate_restore_protection_begin(void) {}\nstatic inline void hibernate_restore_protection_end(void) {}\nstatic inline void hibernate_restore_protect_page(void *page_address) {}\nstatic inline void hibernate_restore_unprotect_page(void *page_address) {}\n#endif /* CONFIG_STRICT_KERNEL_RWX  && CONFIG_ARCH_HAS_SET_MEMORY */\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\n	t
43780	198	mwave_ioctl	drivers/char/mwave/mwavedd.c	mwave_ioctl_$pusBuffer$obj	0	11	\N	\N	\tunsigned int retval = 0;\n\tpMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\n\tvoid __user *arg = (void __user *)ioarg;\n\n\tPRINTK_4(TRACE_MWAVE,\n\t\t"mwavedd::mwave_ioctl, entry file %p cmd %x arg %x\\n",\n\t\tfile, iocmd, (int) ioarg);\n\n\tswitch (iocmd) {\n\n\t\tcase IOCTL_MW_RESET:\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_RESET"\n\t\t\t\t" calling tp3780I_ResetDSP\\n");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ResetDSP(&pDrvData->rBDData);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_RESET"\n\t\t\t\t" retval %x from tp3780I_ResetDSP\\n",\n\t\t\t\tretval);\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_RUN:\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_RUN"\n\t\t\t\t" calling tp3780I_StartDSP\\n");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_StartDSP(&pDrvData->rBDData);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_RUN"\n\t\t\t\t" retval %x from tp3780I_StartDSP\\n",\n\t\t\t\tretval);\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_DSP_ABILITIES: {\n\t\t\tMW_ABILITIES rAbilities;\n\t\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl,"\n\t\t\t\t" IOCTL_MW_DSP_ABILITIES calling"\n\t\t\t\t" tp3780I_QueryAbilities\\n");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_QueryAbilities(&pDrvData->rBDData,\n\t\t\t\t\t&rAbilities);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"\n\t\t\t\t" retval %x from tp3780I_QueryAbilities\\n",\n\t\t\t\tretval);\n\t\t\tif (retval == 0) {\n\t\t\t\tif( copy_to_user(arg, &rAbilities,\n\t\t\t\t\t\t\tsizeof(MW_ABILITIES)) )\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"\n\t\t\t\t" exit retval %x\\n",\n\t\t\t\tretval);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_READ_DATA:\n\t\tcase IOCTL_MW_READCLEAR_DATA: {\n\t\t\tMW_READWRITE rReadData;\n\t\t\tunsigned short __user *pusBuffer = NULL;\n\t\n\t\t\tif( copy_from_user(&rReadData, arg,\n\t\t\t\t\t\tsizeof(MW_READWRITE)) )\n\t\t\t\treturn -EFAULT;\n\t\t\tpusBuffer = (unsigned short __user *) (rReadData.pBuf);\n\t\n\t\t\tPRINTK_4(TRACE_MWAVE,\n	t
30975	458	minix_inode_by_name	fs/minix/dir.c	minix_inode_by_name_$page$obj$1	0	11	\N	\N	\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n	t
28663	579	adv7183_probe	drivers/media/i2c/adv7183.c	hdl	1	13	\N	\N	\tstruct adv7183 *decoder;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint ret;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst unsigned *pin_array;\n\n\t/* Check if the adapter supports the needed features */\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, "chip found @ 0x%02x (%s)\\n",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tpin_array = client->dev.platform_data;\n\tif (pin_array == NULL)\n\t\treturn -EINVAL;\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (decoder == NULL)\n\t\treturn -ENOMEM;\n\n\tdecoder->reset_pin = pin_array[0];\n\tdecoder->oe_pin = pin_array[1];\n\n\tif (devm_gpio_request_one(&client->dev, decoder->reset_pin,\n\t\t\t\t  GPIOF_OUT_INIT_LOW, "ADV7183 Reset")) {\n\t\tv4l_err(client, "failed to request GPIO %d\\n", decoder->reset_pin);\n\t\treturn -EBUSY;\n\t}\n\n\tif (devm_gpio_request_one(&client->dev, decoder->oe_pin,\n\t\t\t\t  GPIOF_OUT_INIT_HIGH,\n\t\t\t\t  "ADV7183 Output Enable")) {\n\t\tv4l_err(client, "failed to request GPIO %d\\n", decoder->oe_pin);\n\t\treturn -EBUSY;\n\t}\n\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7183_ops);\n\n\thdl = &decoder->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n	f
4489	1443	store_temp_auto_boost	drivers/hwmon/lm93.c	val	1	11	\N	\N	\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->boost[nr] = LM93_TEMP_TO_REG(val);\n	t
6888	460	proc_create_mount_point	fs/proc/generic.c	proc_create_mount_point_	6	12	\N	\N	\tumode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tstruct proc_dir_entry *ent, *parent = NULL;\n\n\tent = __proc_create(&parent, name, mode, 2);\n\tif (ent) {\n\t\tent->data = NULL;\n\t\tent->proc_fops = NULL;\n\t\tent->proc_iops = NULL;\n\t\tparent->nlink++;\n\t\tif (proc_register(parent, ent) < 0) {\n	t
26708	1068	xadc_parse_dt	drivers/iio/adc/xilinx-xadc-core.c	ret	1	11	\N	\N	\tstruct xadc *xadc = iio_priv(indio_dev);\n\tstruct iio_chan_spec *channels, *chan;\n\tstruct device_node *chan_node, *child;\n\tunsigned int num_channels;\n\tconst char *external_mux;\n\tu32 ext_mux_chan;\n\tint reg;\n\tint ret;\n\n\t*conf = 0;\n\n\tret = of_property_read_string(np, "xlnx,external-mux", &external_mux);\n\tif (ret < 0 || strcasecmp(external_mux, "none") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_NONE;\n\telse if (strcasecmp(external_mux, "single") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_SINGLE;\n\telse if (strcasecmp(external_mux, "dual") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_DUAL;\n\telse\n\t\treturn -EINVAL;\n\n\tif (xadc->external_mux_mode != XADC_EXTERNAL_MUX_NONE) {\n\t\tret = of_property_read_u32(np, "xlnx,external-mux-channel",\n\t\t\t\t\t&ext_mux_chan);\n\t\tif (ret < 0)\n	t
29579	641	ov534_reg_read	drivers/media/usb/gspca/ov534.c	ret	1	11	\N	\N	\tstruct usb_device *udev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn 0;\n\tret = usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x01,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\n\tPDEBUG(D_USBI, "GET 01 0000 %04x %02x", reg, gspca_dev->usb_buf[0]);\n\tif (ret < 0) {\n	t
28671	2232	adv7842_cec_isr	drivers/media/i2c/adv7842.c	msg.len	1	13	\N	\N	\tu8 cec_irq;\n\n\t/* cec controller */\n\tcec_irq = io_read(sd, 0x93) & 0x0f;\n\tif (!cec_irq)\n\t\treturn;\n\n\tv4l2_dbg(1, debug, sd, "%s: cec: irq 0x%x\\n", __func__, cec_irq);\n\tadv7842_cec_tx_raw_status(sd, cec_irq);\n\tif (cec_irq & 0x08) {\n\t\tstruct adv7842_state *state = to_state(sd);\n\t\tstruct cec_msg msg;\n\n\t\tmsg.len = cec_read(sd, 0x25) & 0x1f;\n\t\tif (msg.len > 16)\n	f
44264	1413	nr_pages_store	drivers/hwtracing/intel_th/msu.c	val	2	-11	\N	\N	\tstruct msc *msc = dev_get_drvdata(dev);\n\tunsigned long val, *win = NULL, *rewin;\n\tsize_t len = size;\n\tconst char *p = buf;\n\tchar *end, *s;\n\tint ret, nr_wins = 0;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tret = msc_buffer_free_unless_used(msc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* scan the comma-separated list of allocation sizes */\n\tend = memchr(buf, '\\n', len);\n\tif (end)\n\t\tlen = end - buf;\n\n\tdo {\n\t\tend = memchr(p, ',', len);\n\t\ts = kstrndup(p, end ? end - p : len, GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_win;\n\t\t}\n\n\t\tret = kstrtoul(s, 10, &val);\n\t\tkfree(s);\n\n\t\tif (ret || !val)\n	t
-243	98	stm32_pwm_config	drivers/pwm/pwm-stm32.c	arr	5	20	\N	\N	\tunsigned long long prd, div, dty;\n\tunsigned int prescaler = 0;\n\tu32 ccmr, mask, shift;\n\n\t/* Period and prescaler values depends on clock rate */\n\tdiv = (unsigned long long)clk_get_rate(priv->clk) * period_ns;\n\n\tdo_div(div, NSEC_PER_SEC);\n\tprd = div;\n\n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, prescaler + 1);\n\t}\n\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC)\n\t\treturn -EINVAL;\n\n\t/*\n\t * All channels share the same prescaler and counter so when two\n\t * channels are active at the same time we can't change them\n\t */\n\tif (active_channels(priv) & ~(1 << ch * 4)) {\n\t\tu32 psc, arr;\n\n\t\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\t\tregmap_read(priv->regmap, TIM_ARR, &arr);\n	f
59985	393	exofs_sync_fs	fs/exofs/super.c	ios->length	1	11	\N	\N	\tstruct exofs_sb_info *sbi;\n\tstruct exofs_fscb *fscb;\n\tstruct ore_comp one_comp;\n\tstruct ore_components oc;\n\tstruct ore_io_state *ios;\n\tint ret = -ENOMEM;\n\n\tfscb = kmalloc(sizeof(*fscb), GFP_KERNEL);\n\tif (unlikely(!fscb))\n\t\treturn -ENOMEM;\n\n\tsbi = sb->s_fs_info;\n\n\t/* NOTE: We no longer dirty the super_block anywhere in exofs. The\n\t * reason we write the fscb here on unmount is so we can stay backwards\n\t * compatible with fscb->s_version == 1. (What we are not compatible\n\t * with is if a new version FS crashed and then we try to mount an old\n\t * version). Otherwise the exofs_fscb is read-only from mkfs time. All\n\t * the writeable info is set in exofs_sbi_write_stats() above.\n\t */\n\n\texofs_init_comps(&oc, &one_comp, sbi, EXOFS_SUPER_ID);\n\n\tret = ore_get_io_state(&sbi->layout, &oc, &ios);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tios->length = offsetof(struct exofs_fscb, s_dev_table_oid);\n\tmemset(fscb, 0, ios->length);\n	t
34622	394	btrfs_del_root_ref	fs/btrfs/root-tree.c	ptr	1	11	\N	\N	\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\tint err = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\n\tBUG_ON(ret < 0);\n\tif (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\tref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\n\t\tWARN_ON(btrfs_root_ref_dirid(leaf, ref) != dirid);\n\t\tWARN_ON(btrfs_root_ref_name_len(leaf, ref) != name_len);\n\t\tptr = (unsigned long)(ref + 1);\n\t\tret = btrfs_is_name_len_valid(leaf, path->slots[0], ptr,\n	t
60168	646	crb_pm_suspend	drivers/char/tpm/tpm_crb.c	ret	1	11	\N	\N	\tint ret;\n\n\tret = tpm_pm_suspend(dev);\n\tif (ret)\n	f
45824	146	check_free_space_extents	fs/btrfs/tests/free-space-tree-tests.c	flags	1	11	\N	\N	\tstruct btrfs_free_space_info *info;\n\tu32 flags;\n\tint ret;\n\n\tinfo = search_free_space_info(trans, fs_info, cache, path, 0);\n\tif (IS_ERR(info)) {\n\t\ttest_msg("Could not find free space info\\n");\n\t\tbtrfs_release_path(path);\n\t\treturn PTR_ERR(info);\n\t}\n\tflags = btrfs_free_space_flags(path->nodes[0], info);\n\tbtrfs_release_path(path);\n\n\tret = __check_free_space_extents(trans, fs_info, cache, path, extents,\n\t\t\t\t\t num_extents);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Flip it to the other format and check that for good measure. */\n\tif (flags & BTRFS_FREE_SPACE_USING_BITMAPS) {\n	t
60252	4801	sony_pic_add	drivers/platform/x86/sony-laptop.c	result	1	11	\N	\N	\tint result;\n\tstruct sony_pic_ioport *io, *tmp_io;\n\tstruct sony_pic_irq *irq, *tmp_irq;\n\n\tspic_dev.acpi_dev = device;\n\tstrcpy(acpi_device_class(device), "sony/hotkey");\n\tsony_pic_detect_device_type(&spic_dev);\n\tmutex_init(&spic_dev.lock);\n\n\t/* read _PRS resources */\n\tresult = sony_pic_possible_resources(device);\n\tif (result) {\n\t\tpr_err("Unable to read possible resources\\n");\n\t\tgoto err_free_resources;\n\t}\n\n\t/* setup input devices and helper fifo */\n\tresult = sony_laptop_setup_input(device);\n\tif (result) {\n\t\tpr_err("Unable to create input devices\\n");\n\t\tgoto err_free_resources;\n\t}\n\n\tresult = sonypi_compat_init();\n\tif (result)\n\t\tgoto err_remove_input;\n\n\t/* request io port */\n\tlist_for_each_entry_reverse(io, &spic_dev.ioports, list) {\n\t\tif (request_region(io->io1.minimum, io->io1.address_length,\n\t\t\t\t\t"Sony Programmable I/O Device")) {\n\t\t\tdprintk("I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\\n",\n\t\t\t\t\tio->io1.minimum, io->io1.maximum,\n\t\t\t\t\tio->io1.address_length);\n\t\t\t/* Type 1 have 2 ioports */\n\t\t\tif (io->io2.minimum) {\n\t\t\t\tif (request_region(io->io2.minimum,\n\t\t\t\t\t\tio->io2.address_length,\n\t\t\t\t\t\t"Sony Programmable I/O Device")) {\n\t\t\t\t\tdprintk("I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\\n",\n\t\t\t\t\t\t\tio->io2.minimum, io->io2.maximum,\n\t\t\t\t\t\t\tio->io2.address_length);\n\t\t\t\t\tspic_dev.cur_ioport = io;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdprintk("Unable to get I/O port2: "\n\t\t\t\t\t\t\t"0x%.4x (0x%.4x) + 0x%.2x\\n",\n\t\t\t\t\t\t\tio->io2.minimum, io->io2.maximum,\n\t\t\t\t\t\t\tio->io2.address_length);\n\t\t\t\t\trelease_region(io->io1.minimum,\n\t\t\t\t\t\t\tio->io1.address_length);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspic_dev.cur_ioport = io;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spic_dev.cur_ioport) {\n\t\tpr_err("Failed to request_region\\n");\n\t\tresult = -ENODEV;\n\t\tgoto err_remove_compat;\n\t}\n\n\t/* request IRQ */\n\tlist_for_each_entry_reverse(irq, &spic_dev.interrupts, list) {\n\t\tif (!request_irq(irq->irq.interrupts[0], sony_pic_irq,\n\t\t\t\t\t0, "sony-laptop", &spic_dev)) {\n\t\t\tdprintk("IRQ: %d - triggering: %d - "\n\t\t\t\t\t"polarity: %d - shr: %d\\n",\n\t\t\t\t\tirq->irq.interrupts[0],\n\t\t\t\t\tirq->irq.triggering,\n\t\t\t\t\tirq->irq.polarity,\n\t\t\t\t\tirq->irq.sharable);\n\t\t\tspic_dev.cur_irq = irq;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!spic_dev.cur_irq) {\n\t\tpr_err("Failed to request_irq\\n");\n\t\tresult = -ENODEV;\n\t\tgoto err_release_region;\n\t}\n\n\t/* set resource status _SRS */\n\tresult = sony_pic_enable(device, spic_dev.cur_ioport, spic_dev.cur_irq);\n\tif (result) {\n\t\tpr_err("Couldn't enable device\\n");\n\t\tgoto err_free_irq;\n\t}\n\n\tspic_dev.bluetooth_power = -1;\n\t/* create device attributes */\n\tresult = sony_pf_add();\n\tif (result)\n	t
50868	719	ct_mixer_kcontrol_new	sound/pci/ctxfi/ctmixer.c	kctl->id.iface	1	13	\N	\N	\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\tkctl = snd_ctl_new1(new, mixer->atc);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\n\tif (SNDRV_CTL_ELEM_IFACE_PCM == kctl->id.iface)\n	f
9923	953	__ov8858_get_pll1_values	drivers/staging/media/atomisp/i2c/ov8858.c	ret	1	11	\N	\N	\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tunsigned int prediv_idx;\n\tunsigned int multiplier;\n\tunsigned int sys_prediv;\n\tunsigned int prediv_coef[] = {2, 3, 4, 5, 6, 8, 12, 16};\n\tint ret;\n\n\tret = ov8858_get_register_8bit(sd, OV8858_PLL1_PREDIV0, reglist);\n\tif (ret < 0)\n	t
48042	641	mxs_lradc_ts_probe	drivers/input/touchscreen/mxs-lradc-ts.c	ret	1	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->parent->of_node;\n\tstruct mxs_lradc *lradc = dev_get_drvdata(dev->parent);\n\tstruct mxs_lradc_ts *ts;\n\tstruct resource *iores;\n\tint ret, irq, virq, i;\n\tu32 ts_wires = 0, adapt;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ts);\n\n\tts->lradc = lradc;\n\tts->dev = dev;\n\tspin_lock_init(&ts->lock);\n\n\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iores)\n\t\treturn -EINVAL;\n\tts->base = devm_ioremap(dev, iores->start, resource_size(iores));\n\tif (!ts->base)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(node, "fsl,lradc-touchscreen-wires",\n\t\t\t\t   &ts_wires);\n\tif (ret)\n	t
60565	97	mma7455_trigger_handler	drivers/iio/accel/mma7455_core.c	ret	1	11	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mma7455_data *mma7455 = iio_priv(indio_dev);\n\tu8 buf[16]; /* 3 x 16-bit channels + padding + ts */\n\tint ret;\n\n\tret = mma7455_drdy(mma7455);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_bulk_read(mma7455->regmap, MMA7455_REG_XOUTL, buf,\n\t\t\t       sizeof(__le16) * 3);\n\tif (ret)\n	f
9698	456	iwl_dbgfs_disable_power_off_write	drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c	val	1	13	\N	\N	\tint ret, val;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (!strncmp("disable_power_off_d0=", buf, 21)) {\n\t\tif (sscanf(buf + 21, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tmvm->disable_power_off = val;\n	f
22710	4497	xlog_recover_ophdr_to_trans	fs/xfs/xfs_log_recover.c	&trans->r_itemq	1	13	\N	\N	\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t/*\n\t * skip over non-start transaction headers - we could be\n\t * processing slack space before the next transaction starts\n\t */\n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t/*\n\t * This is a new transaction so allocate a new recovery container to\n\t * hold the recovery ops that will follow.\n\t */\n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), KM_SLEEP);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n	f
30949	131	uio_pdrv_genirq_probe	drivers/uio/uio_pdrv_genirq.c	uioinfo->handler	1	11	\N	\N	\tstruct uio_info *uioinfo = dev_get_platdata(&pdev->dev);\n\tstruct uio_pdrv_genirq_platdata *priv;\n\tstruct uio_mem *uiomem;\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (pdev->dev.of_node) {\n\t\t/* alloc uioinfo for one device */\n\t\tuioinfo = devm_kzalloc(&pdev->dev, sizeof(*uioinfo),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!uioinfo) {\n\t\t\tdev_err(&pdev->dev, "unable to kmalloc\\n");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tuioinfo->name = pdev->dev.of_node->name;\n\t\tuioinfo->version = "devicetree";\n\t\t/* Multiple IRQs are not supported */\n\t}\n\n\tif (!uioinfo || !uioinfo->name || !uioinfo->version) {\n\t\tdev_err(&pdev->dev, "missing platform_data\\n");\n\t\treturn ret;\n\t}\n\n\tif (uioinfo->handler || uioinfo->irqcontrol ||\n	t
62535	294	drbd_request_endio	drivers/block/drbd/drbd_worker.c	drbd_request_endio_$m$0$obj	0	11	\N	\N	\tunsigned long flags;\n\tstruct drbd_request *req = bio->bi_private;\n\tstruct drbd_device *device = req->device;\n\tstruct bio_and_error m;\n\tenum drbd_req_event what;\n\n\t/* If this request was aborted locally before,\n\t * but now was completed "successfully",\n\t * chances are that this caused arbitrary data corruption.\n\t *\n\t * "aborting" requests, or force-detaching the disk, is intended for\n\t * completely blocked/hung local backing devices which do no longer\n\t * complete requests at all, not even do error completions.  In this\n\t * situation, usually a hard-reset and failover is the only way out.\n\t *\n\t * By "aborting", basically faking a local error-completion,\n\t * we allow for a more graceful swichover by cleanly migrating services.\n\t * Still the affected node has to be rebooted "soon".\n\t *\n\t * By completing these requests, we allow the upper layers to re-use\n\t * the associated data pages.\n\t *\n\t * If later the local backing device "recovers", and now DMAs some data\n\t * from disk into the original request pages, in the best case it will\n\t * just put random data into unused pages; but typically it will corrupt\n\t * meanwhile completely unrelated data, causing all sorts of damage.\n\t *\n\t * Which means delayed successful completion,\n\t * especially for READ requests,\n\t * is a reason to panic().\n\t *\n\t * We assume that a delayed *error* completion is OK,\n\t * though we still will complain noisily about it.\n\t */\n\tif (unlikely(req->rq_state & RQ_LOCAL_ABORTED)) {\n\t\tif (__ratelimit(&drbd_ratelimit_state))\n\t\t\tdrbd_emerg(device, "delayed completion of aborted local request; disk-timeout may be too aggressive\\n");\n\n\t\tif (!bio->bi_status)\n\t\t\tdrbd_panic_after_delayed_completion_of_aborted_request(device);\n\t}\n\n\t/* to avoid recursion in __req_mod */\n\tif (unlikely(bio->bi_status)) {\n\t\tswitch (bio_op(bio)) {\n\t\tcase REQ_OP_WRITE_ZEROES:\n\t\tcase REQ_OP_DISCARD:\n\t\t\tif (bio->bi_status == BLK_STS_NOTSUPP)\n\t\t\t\twhat = DISCARD_COMPLETED_NOTSUPP;\n\t\t\telse\n\t\t\t\twhat = DISCARD_COMPLETED_WITH_ERROR;\n\t\t\tbreak;\n\t\tcase REQ_OP_READ:\n\t\t\tif (bio->bi_opf & REQ_RAHEAD)\n\t\t\t\twhat = READ_AHEAD_COMPLETED_WITH_ERROR;\n\t\t\telse\n\t\t\t\twhat = READ_COMPLETED_WITH_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twhat = WRITE_COMPLETED_WITH_ERROR;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\twhat = COMPLETED_OK;\n\t}\n\n\tbio_put(req->private_bio);\n\treq->private_bio = ERR_PTR(blk_status_to_errno(bio->bi_status));\n\n\t/* not req_mod(), we need irqsave here! */\n\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\t__req_mod(req, what, &m);\n\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\tput_ldev(device);\n\n\tif (m.bio)\n	t
51362	480	trace_event_raw_event_ocfs2_split_extent	fs/ocfs2/super.c	ML_ERROR	1	11	\N	\N	\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\t/* FIXME: Should ERROR_RO_FS */\n\t\t\tmlog(ML_ERROR, "Unable to load system inode %d, "\n	t
-241	299	iproc_adc_do_read	drivers/iio/adc/bcm_iproc_adc.c	val_check	6	20	\N	\N	\tint read_len = 0;\n\tu32 val;\n\tu32 mask;\n\tu32 val_check;\n\tint failed_cnt = 0;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tmutex_lock(&adc_priv->mutex);\n\n\t/*\n\t * After a read is complete the ADC interrupts will be disabled so\n\t * we can assume this section of code is safe from interrupts.\n\t */\n\tadc_priv->chan_val = -1;\n\tadc_priv->chan_id = channel;\n\n\treinit_completion(&adc_priv->completion);\n\t/* Clear any pending interrupt */\n\tregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\n\t\t\tIPROC_ADC_INTR_MASK | IPROC_ADC_AUXDATA_RDY_INTR,\n\t\t\t((0x0 << channel) << IPROC_ADC_INTR) |\n\t\t\tIPROC_ADC_AUXDATA_RDY_INTR);\n\n\t/* Configure channel for snapshot mode and enable  */\n\tval = (BIT(IPROC_ADC_CHANNEL_ROUNDS) |\n\t\t(IPROC_ADC_CHANNEL_MODE_SNAPSHOT << IPROC_ADC_CHANNEL_MODE) |\n\t\t(0x1 << IPROC_ADC_CHANNEL_ENABLE));\n\n\tmask = IPROC_ADC_CHANNEL_ROUNDS_MASK | IPROC_ADC_CHANNEL_MODE_MASK |\n\t\tIPROC_ADC_CHANNEL_ENABLE_MASK;\n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL1 +\n\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel),\n\t\t\t\tmask, val);\n\n\t/* Set the Watermark for a channel */\n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL2 +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel),\n\t\t\t\t\tIPROC_ADC_CHANNEL_WATERMARK_MASK,\n\t\t\t\t\t0x1);\n\n\t/* Enable water mark interrupt */\n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_INTERRUPT_MASK +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tchannel),\n\t\t\t\t\tIPROC_ADC_CHANNEL_WTRMRK_INTR_MASK,\n\t\t\t\t\tIPROC_ADC_WATER_MARK_INTR_ENABLE);\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val);\n\n\t/* Enable ADC interrupt for a channel */\n\tval |= (BIT(channel) << IPROC_ADC_INTR);\n\tregmap_write(adc_priv->regmap, IPROC_INTERRUPT_MASK, val);\n\n\t/*\n\t * There seems to be a very rare issue where writing to this register\n\t * does not take effect.  To work around the issue we will try multiple\n\t * writes.  In total we will spend about 10*10 = 100 us attempting this.\n\t * Testing has shown that this may loop a few time, but we have never\n\t * hit the full count.\n\t */\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\n\twhile (val_check != val) {\n	f
61805	644	tcf_ife_decode	net/sched/act_ife.c	mtype	1	11	\N	\N	\tstruct tcf_ife_info *ife = to_ife(a);\n\tint action = ife->tcf_action;\n\tu8 *ifehdr_end;\n\tu8 *tlv_data;\n\tu16 metalen;\n\n\tspin_lock(&ife->tcf_lock);\n\tbstats_update(&ife->tcf_bstats, skb);\n\ttcf_lastuse_update(&ife->tcf_tm);\n\tspin_unlock(&ife->tcf_lock);\n\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_push(skb, skb->dev->hard_header_len);\n\n\ttlv_data = ife_decode(skb, &metalen);\n\tif (unlikely(!tlv_data)) {\n\t\tspin_lock(&ife->tcf_lock);\n\t\tife->tcf_qstats.drops++;\n\t\tspin_unlock(&ife->tcf_lock);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tifehdr_end = tlv_data + metalen;\n\tfor (; tlv_data < ifehdr_end; tlv_data = ife_tlv_meta_next(tlv_data)) {\n\t\tu8 *curr_data;\n\t\tu16 mtype;\n\t\tu16 dlen;\n\n\t\tcurr_data = ife_tlv_meta_decode(tlv_data, &mtype, &dlen, NULL);\n\n\t\tif (find_decode_metaid(skb, ife, mtype, dlen, curr_data)) {\n	t
35384	1467	zd_usb_resume	drivers/net/wireless/zydas/zd1211rw/zd_usb.c	r	1	13	\N	\N	\tstruct zd_mac *mac = zd_usb_to_mac(usb);\n\tint r;\n\n\tdev_dbg_f(zd_usb_dev(usb), "\\n");\n\n\tr = zd_op_start(zd_usb_to_hw(usb));\n\tif (r < 0) {\n	f
-233	689	max17042_load_new_capacity_params	drivers/power/supply/max17042_battery.c	full_cap0	5	20	\N	\N	\tu32 full_cap0, rep_cap, dq_acc, vfSoc;\n\tu32 rem_cap;\n\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_read(map, MAX17042_FullCAP0, &full_cap0);\n\tregmap_read(map, MAX17042_VFSOC, &vfSoc);\n\n\t/* fg_vfSoc needs to shifted by 8 bits to get the\n\t * perc in 1% accuracy, to get the right rem_cap multiply\n\t * full_cap0, fg_vfSoc and devide by 100\n\t */\n\trem_cap = ((vfSoc >> 8) * full_cap0) / 100;\n\tmax17042_write_verify_reg(map, MAX17042_RemCap, rem_cap);\n	f
29456	2040	b43_do_interrupt_thread	drivers/net/wireless/broadcom/b43/main.c	dma_reason	1	11	\N	\N	\tu32 reason;\n\tu32 dma_reason[ARRAY_SIZE(dev->dma_reason)];\n\tu32 merged_dma_reason = 0;\n\tint i;\n\n\tif (unlikely(b43_status(dev) != B43_STAT_STARTED))\n\t\treturn;\n\n\treason = dev->irq_reason;\n\tfor (i = 0; i < ARRAY_SIZE(dma_reason); i++) {\n\t\tdma_reason[i] = dev->dma_reason[i];\n\t\tmerged_dma_reason |= dma_reason[i];\n\t}\n\n\tif (unlikely(reason & B43_IRQ_MAC_TXERR))\n\t\tb43err(dev->wl, "MAC transmission error\\n");\n\n\tif (unlikely(reason & B43_IRQ_PHY_TXERR)) {\n\t\tb43err(dev->wl, "PHY transmission error\\n");\n\t\trmb();\n\t\tif (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) {\n\t\t\tatomic_set(&dev->phy.txerr_cnt,\n\t\t\t\t   B43_PHY_TX_BADNESS_LIMIT);\n\t\t\tb43err(dev->wl, "Too many PHY TX errors, "\n\t\t\t\t\t"restarting the controller\\n");\n\t\t\tb43_controller_restart(dev, "PHY TX errors");\n\t\t}\n\t}\n\n\tif (unlikely(merged_dma_reason & (B43_DMAIRQ_FATALMASK))) {\n\t\tb43err(dev->wl,\n\t\t\t"Fatal DMA error: 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X\\n",\n\t\t\tdma_reason[0], dma_reason[1],\n\t\t\tdma_reason[2], dma_reason[3],\n\t\t\tdma_reason[4], dma_reason[5]);\n\t\tb43err(dev->wl, "This device does not support DMA "\n\t\t\t       "on your system. It will now be switched to PIO.\\n");\n\t\t/* Fall back to PIO transfers if we get fatal DMA errors! */\n\t\tdev->use_pio = true;\n\t\tb43_controller_restart(dev, "DMA error");\n\t\treturn;\n\t}\n\n\tif (unlikely(reason & B43_IRQ_UCODE_DEBUG))\n\t\thandle_irq_ucode_debug(dev);\n\tif (reason & B43_IRQ_TBTT_INDI)\n\t\thandle_irq_tbtt_indication(dev);\n\tif (reason & B43_IRQ_ATIM_END)\n\t\thandle_irq_atim_end(dev);\n\tif (reason & B43_IRQ_BEACON)\n\t\thandle_irq_beacon(dev);\n\tif (reason & B43_IRQ_PMQ)\n\t\thandle_irq_pmq(dev);\n\tif (reason & B43_IRQ_TXFIFO_FLUSH_OK)\n\t\t;/* TODO */\n\tif (reason & B43_IRQ_NOISESAMPLE_OK)\n\t\thandle_irq_noise(dev);\n\n\t/* Check the DMA reason registers for received data. */\n\tif (dma_reason[0] & B43_DMAIRQ_RDESC_UFLOW) {\n	t
35596	629	arp_xmit_finish	net/ipv4/arp.c	skb	1	11	\N	\N	\treturn dev_queue_xmit(skb);\n	t
60573	336	inet6_bind	net/ipv6/af_inet6.c	chk_addr_ret	1	11	\N	\N	\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tunsigned short snum;\n\tint addr_type = 0;\n\tint err = 0;\n\n\t/* If the socket has its own bind function then use it. */\n\tif (sk->sk_prot->bind)\n\t\treturn sk->sk_prot->bind(sk, uaddr, addr_len);\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\tif ((addr_type & IPV6_ADDR_MULTICAST) && sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\n\tsnum = ntohs(addr->sin6_port);\n\tif (snum && snum < inet_prot_sock(net) &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\tlock_sock(sk);\n\n\t/* Check these errors (active socket, double bind). */\n\tif (sk->sk_state != TCP_CLOSE || inet->inet_num) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if the address belongs to the host. */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tint chk_addr_ret;\n\n\t\t/* Binding to v4-mapped address on a v6-only socket\n\t\t * makes no sense\n\t\t */\n\t\tif (sk->sk_ipv6only) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Reproduce AF_INET checks to make the bindings consistent */\n\t\tv4addr = addr->sin6_addr.s6_addr32[3];\n\t\tchk_addr_ret = inet_addr_type(net, v4addr);\n\t\tif (!net->ipv4.sysctl_ip_nonlocal_bind &&\n\t\t    !(inet->freebind || inet->transparent) &&\n\t\t    v4addr != htonl(INADDR_ANY) &&\n\t\t    chk_addr_ret != RTN_LOCAL &&\n	f
58378	11244	bnx2x_54618se_config_init	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	autoneg_val	1	-11	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 autoneg_val, an_1000_val, an_10_100_val, fc_val, temp;\n\tu32 cfg_pin;\n\n\tDP(NETIF_MSG_LINK, "54618SE cfg init\\n");\n\tusleep_range(1000, 2000);\n\n\t/* This works with E3 only, no need to check the chip\n\t * before determining the port.\n\t */\n\tport = params->port;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t/* Drive pin high to bring the GPHY out of reset. */\n\tbnx2x_set_cfg_pin(bp, cfg_pin, 1);\n\n\t/* wait for GPHY to reset */\n\tmsleep(50);\n\n\t/* reset phy */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t MDIO_PMA_REG_CTRL, 0x8000);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t/* Wait for GPHY to reset */\n\tmsleep(50);\n\n\n\tbnx2x_54618se_specific_func(phy, params, PHY_INIT);\n\t/* Flip the signal detect polarity (set 0x1c.0x1e[8]). */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_AUTO_DET_MED);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t&temp);\n\ttemp |= MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD;\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\n\t/* Set up fc */\n\t/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tfc_val = 0;\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\n\t/* Read all advertisement */\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x04,\n\t\t\t&an_10_100_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL,\n\t\t\t&autoneg_val);\n\n\t/* Disable forced speed */\n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8) | (1<<10) |\n\t\t\t   (1<<11));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, "Advertising 1G\\n");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x09,\n\t\t\tan_1000_val);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\t/* Advertise 10/100 link speed */\n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 10M-HD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 10M-FD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 100M-HD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 100M-FD\\n");\n\t\t}\n\t}\n\n\t/* Only 10/100 are allowed to work in FORCE mode */\n\tif (phy->req_line_speed == SPEED_100) {\n\t\tautoneg_val |= (1<<13);\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, "Setting 100M force\\n");\n\t}\n\tif (phy->req_line_speed == SPEED_10) {\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, "Setting 10M force\\n");\n\t}\n\n\tif ((phy->flags & FLAGS_EEE) && bnx2x_eee_has_cap(params)) {\n\t\tint rc;\n\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS,\n\t\t\t\t MDIO_REG_GPHY_EXP_ACCESS_TOP |\n\t\t\t\t MDIO_REG_GPHY_EXP_TOP_2K_BUF);\n\t\tbnx2x_cl22_read(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, &temp);\n\t\ttemp &= 0xfffe;\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, temp);\n\n\t\trc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_1G_ADV);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, "Failed to configure EEE timers\\n");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t} else if ((params->eee_mode & EEE_MODE_ADV_LPI) &&\n\t\t\t   (phy->req_duplex == DUPLEX_FULL) &&\n\t\t\t   (bnx2x_eee_calc_timer(params) ||\n\t\t\t    !(params->eee_mode & EEE_MODE_ENABLE_LPI))) {\n\t\t\t/* Need to advertise EEE only when requested,\n\t\t\t * and either no LPI assertion was requested,\n\t\t\t * or it was requested and a valid timer was set.\n\t\t\t * Also notice full duplex is required for EEE.\n\t\t\t */\n\t\t\tbnx2x_eee_advertise(phy, params, vars,\n\t\t\t\t\t    SHMEM_EEE_1G_ADV);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, "Don't Advertise 1GBase-T EEE\\n");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t}\n\t} else {\n\t\tvars->eee_status &= ~SHMEM_EEE_1G_ADV <<\n\t\t\t\t    SHMEM_EEE_SUPPORTED_SHIFT;\n\n\t\tif (phy->flags & FLAGS_EEE) {\n\t\t\t/* Handle legacy auto-grEEEn */\n\t\t\tif (params->feature_config_flags &\n\t\t\t    FEATURE_CONFIG_AUTOGREEEN_ENABLED) {\n\t\t\t\ttemp = 6;\n\t\t\t\tDP(NETIF_MSG_LINK, "Enabling Auto-GrEEEn\\n");\n\t\t\t} else {\n\t\t\t\ttemp = 0;\n\t\t\t\tDP(NETIF_MSG_LINK, "Don't Adv. EEE\\n");\n\t\t\t}\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\t MDIO_AN_REG_EEE_ADV, temp);\n\t\t}\n\t}\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x04,\n\t\t\tan_10_100_val | fc_val);\n\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\tautoneg_val |= (1<<8);\n\n\tbnx2x_cl22_write(bp, phy,\n	t
28707	920	ql_core_dump	drivers/net/ethernet/qlogic/qlge/qlge_dbg.c	status	1	13	\N	\N	\tint status;\n\tint i;\n\n\tif (!mpi_coredump) {\n\t\tnetif_err(qdev, drv, qdev->ndev, "No memory allocated\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Try to get the spinlock, but dont worry if\n\t * it isn't available.  If the firmware died it\n\t * might be holding the sem.\n\t */\n\tql_sem_spinlock(qdev, SEM_PROC_REG_MASK);\n\n\tstatus = ql_pause_mpi_risc(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  "Failed RISC pause. Status = 0x%.08x\\n", status);\n\t\tgoto err;\n\t}\n\n\t/* Insert the global header */\n\tmemset(&(mpi_coredump->mpi_global_header), 0,\n\t\tsizeof(struct mpi_coredump_global_header));\n\tmpi_coredump->mpi_global_header.cookie = MPI_COREDUMP_COOKIE;\n\tmpi_coredump->mpi_global_header.headerSize =\n\t\tsizeof(struct mpi_coredump_global_header);\n\tmpi_coredump->mpi_global_header.imageSize =\n\t\tsizeof(struct ql_mpi_coredump);\n\tstrncpy(mpi_coredump->mpi_global_header.idString, "MPI Coredump",\n\t\tsizeof(mpi_coredump->mpi_global_header.idString));\n\n\t/* Get generic NIC reg dump */\n\tql_build_coredump_seg_header(&mpi_coredump->nic_regs_seg_hdr,\n\t\t\tNIC1_CONTROL_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->nic_regs), "NIC1 Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->nic2_regs_seg_hdr,\n\t\t\tNIC2_CONTROL_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->nic2_regs), "NIC2 Registers");\n\n\t/* Get XGMac registers. (Segment 18, Rev C. step 21) */\n\tql_build_coredump_seg_header(&mpi_coredump->xgmac1_seg_hdr,\n\t\t\tNIC1_XGMAC_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->xgmac1), "NIC1 XGMac Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xgmac2_seg_hdr,\n\t\t\tNIC2_XGMAC_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->xgmac2), "NIC2 XGMac Registers");\n\n\tif (qdev->func & 1) {\n\t\t/* Odd means our function is NIC 2 */\n\t\tfor (i = 0; i < NIC_REGS_DUMP_WORD_COUNT; i++)\n\t\t\tmpi_coredump->nic2_regs[i] =\n\t\t\t\t\t ql_read32(qdev, i * sizeof(u32));\n\n\t\tfor (i = 0; i < NIC_REGS_DUMP_WORD_COUNT; i++)\n\t\t\tmpi_coredump->nic_regs[i] =\n\t\t\tql_read_other_func_reg(qdev, (i * sizeof(u32)) / 4);\n\n\t\tql_get_xgmac_regs(qdev, &mpi_coredump->xgmac2[0], 0);\n\t\tql_get_xgmac_regs(qdev, &mpi_coredump->xgmac1[0], 1);\n\t} else {\n\t\t/* Even means our function is NIC 1 */\n\t\tfor (i = 0; i < NIC_REGS_DUMP_WORD_COUNT; i++)\n\t\t\tmpi_coredump->nic_regs[i] =\n\t\t\t\t\tql_read32(qdev, i * sizeof(u32));\n\t\tfor (i = 0; i < NIC_REGS_DUMP_WORD_COUNT; i++)\n\t\t\tmpi_coredump->nic2_regs[i] =\n\t\t\tql_read_other_func_reg(qdev, (i * sizeof(u32)) / 4);\n\n\t\tql_get_xgmac_regs(qdev, &mpi_coredump->xgmac1[0], 0);\n\t\tql_get_xgmac_regs(qdev, &mpi_coredump->xgmac2[0], 1);\n\t}\n\n\t/* Rev C. Step 20a */\n\tql_build_coredump_seg_header(&mpi_coredump->xaui_an_hdr,\n\t\t\tXAUI_AN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xaui_an),\n\t\t\t"XAUI AN Registers");\n\n\t/* Rev C. Step 20b */\n\tql_build_coredump_seg_header(&mpi_coredump->xaui_hss_pcs_hdr,\n\t\t\tXAUI_HSS_PCS_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xaui_hss_pcs),\n\t\t\t"XAUI HSS PCS Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_an_hdr, XFI_AN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_an),\n\t\t\t"XFI AN Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_train_hdr,\n\t\t\tXFI_TRAIN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_train),\n\t\t\t"XFI TRAIN Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_hss_pcs_hdr,\n\t\t\tXFI_HSS_PCS_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_hss_pcs),\n\t\t\t"XFI HSS PCS Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_hss_tx_hdr,\n\t\t\tXFI_HSS_TX_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_hss_tx),\n\t\t\t"XFI HSS TX Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_hss_rx_hdr,\n\t\t\tXFI_HSS_RX_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_hss_rx),\n\t\t\t"XFI HSS RX Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi_hss_pll_hdr,\n\t\t\tXFI_HSS_PLL_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes_xfi_hss_pll),\n\t\t\t"XFI HSS PLL Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xaui2_an_hdr,\n\t\t\tXAUI2_AN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xaui_an),\n\t\t\t"XAUI2 AN Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xaui2_hss_pcs_hdr,\n\t\t\tXAUI2_HSS_PCS_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xaui_hss_pcs),\n\t\t\t"XAUI2 HSS PCS Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_an_hdr,\n\t\t\tXFI2_AN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_an),\n\t\t\t"XFI2 AN Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_train_hdr,\n\t\t\tXFI2_TRAIN_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_train),\n\t\t\t"XFI2 TRAIN Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_hss_pcs_hdr,\n\t\t\tXFI2_HSS_PCS_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_hss_pcs),\n\t\t\t"XFI2 HSS PCS Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_hss_tx_hdr,\n\t\t\tXFI2_HSS_TX_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_hss_tx),\n\t\t\t"XFI2 HSS TX Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_hss_rx_hdr,\n\t\t\tXFI2_HSS_RX_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_hss_rx),\n\t\t\t"XFI2 HSS RX Registers");\n\n\tql_build_coredump_seg_header(&mpi_coredump->xfi2_hss_pll_hdr,\n\t\t\tXFI2_HSS_PLL_SEG_NUM,\n\t\t\tsizeof(struct mpi_coredump_segment_header) +\n\t\t\tsizeof(mpi_coredump->serdes2_xfi_hss_pll),\n\t\t\t"XFI2 HSS PLL Registers");\n\n\tstatus = ql_get_serdes_regs(qdev, mpi_coredump);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  "Failed Dump of Serdes Registers. Status = 0x%.08x\\n",\n\t\t\t  status);\n\t\tgoto err;\n\t}\n\n\tql_build_coredump_seg_header(&mpi_coredump->core_regs_seg_hdr,\n\t\t\t\tCORE_SEG_NUM,\n\t\t\t\tsizeof(mpi_coredump->core_regs_seg_hdr) +\n\t\t\t\tsizeof(mpi_coredump->mpi_core_regs) +\n\t\t\t\tsizeof(mpi_coredump->mpi_core_sh_regs),\n\t\t\t\t"Core Registers");\n\n\t/* Get the MPI Core Registers */\n\tstatus = ql_get_mpi_regs(qdev, &mpi_coredump->mpi_core_regs[0],\n\t\t\t\t MPI_CORE_REGS_ADDR, MPI_CORE_REGS_CNT);\n\tif (status)\n\t\tgoto err;\n\t/* Get the 16 MPI shadow registers */\n\tstatus = ql_get_mpi_shadow_regs(qdev,\n\t\t\t\t\t&mpi_coredump->mpi_core_sh_regs[0]);\n\tif (status)\n	f
31208	614	__open_metadata	drivers/md/dm-thin-metadata.c	sblock	1	11	\N	\N	\tint r;\n\tstruct dm_block *sblock;\n\tstruct thin_disk_superblock *disk_super;\n\n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r < 0) {\n\t\tDMERR("couldn't read superblock");\n\t\treturn r;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n	t
46838	3307	nonpaging_map	arch/x86/kvm/mmu.c	map_writable	1	11	\N	\N	\tint r;\n\tint level;\n\tbool force_pt_level = false;\n\tkvm_pfn_t pfn;\n\tunsigned long mmu_seq;\n\tbool map_writable, write = error_code & PFERR_WRITE_MASK;\n\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\t/*\n\t\t * This path builds a PAE pagetable - so we can map\n\t\t * 2mb pages at maximum. Therefore check if the level\n\t\t * is larger than that.\n\t\t */\n\t\tif (level > PT_DIRECTORY_LEVEL)\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, v, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n	t
35184	1550	efx_mcdi_get_board_cfg	drivers/net/ethernet/sfc/mcdi.c	efx_mcdi_get_board_cfg_$__UNIQUE_ID_min2_335$obj	0	11	\N	\N	\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_BOARD_CFG_OUT_LENMAX);\n\tsize_t outlen, i;\n\tint port_num = efx_port_num(efx);\n\tint rc;\n\n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);\n\t/* we need __aligned(2) for ether_addr_copy */\n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST & 1);\n\tBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST & 1);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (outlen < MC_CMD_GET_BOARD_CFG_OUT_LENMIN) {\n\t\trc = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (mac_address)\n\t\tether_addr_copy(mac_address,\n\t\t\t\tport_num ?\n\t\t\t\tMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1) :\n\t\t\t\tMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0));\n\tif (fw_subtype_list) {\n\t\tfor (i = 0;\n\t\t     i < MCDI_VAR_ARRAY_LEN(outlen,\n	t
53768	874	dccp_v4_rcv	net/dccp/ipv4.c	refcounted	1	11	\N	\N	\tconst struct dccp_hdr *dh;\n\tconst struct iphdr *iph;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\tiph = ip_hdr(skb);\n\t/* Step 1: If header checksum is incorrect, drop packet and return */\n\tif (dccp_v4_csum_finish(skb, iph->saddr, iph->daddr)) {\n\t\tDCCP_WARN("dropped packet with invalid checksum\\n");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tdccp_pr_debug("%8.8s src=%pI4@%-5d dst=%pI4@%-5d seq=%llu",\n\t\t      dccp_packet_name(dh->dccph_type),\n\t\t      &iph->saddr, ntohs(dh->dccph_sport),\n\t\t      &iph->daddr, ntohs(dh->dccph_dport),\n\t\t      (unsigned long long) DCCP_SKB_CB(skb)->dccpd_seq);\n\n\tif (dccp_packet_without_ack(skb)) {\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\t\tdccp_pr_debug_cat("\\n");\n\t} else {\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\t\tdccp_pr_debug_cat(", ack=%llu\\n", (unsigned long long)\n\t\t\t\t  DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\t}\n\nlookup:\n\tsk = __inet_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t       dh->dccph_sport, dh->dccph_dport, 0, &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug("failed to look up flow ID in table and "\n\t\t\t      "get corresponding socket\\n");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug("sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v4_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov && (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug("Packet CsCov %d does not satisfy MinCsCov %d\\n",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: "Such packets SHOULD be reported using Data Dropped\n\t\t *         options (Section 11.7) with Drop Code 0, Protocol\n\t\t *         Constraints."                                     */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\tnf_reset(skb);\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4, refcounted);\n	t
57951	1675	nilfs_btree_check_delete	fs/nilfs2/btree.c	node	1	11	\N	\N	\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *root, *node;\n\t__u64 maxkey, nextmaxkey;\n\t__u64 ptr;\n\tint nchildren, ret;\n\n\troot = nilfs_btree_get_root(btree);\n\tswitch (nilfs_btree_height(btree)) {\n\tcase 2:\n\t\tbh = NULL;\n\t\tnode = root;\n\t\tbreak;\n\tcase 3:\n\t\tnchildren = nilfs_btree_node_get_nchildren(root);\n\t\tif (nchildren > 1)\n\t\t\treturn 0;\n\t\tptr = nilfs_btree_node_get_ptr(root, nchildren - 1,\n\t\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t\tret = nilfs_btree_get_block(btree, ptr, &bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n	t
61353	744	amdgpu_vce_ring_parse_cs	drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c	*size * 2	1	11	\N	\N	\tstruct amdgpu_ib *ib = &p->job->ibs[ib_idx];\n\tunsigned fb_idx = 0, bs_idx = 0;\n\tint session_idx = -1;\n\tuint32_t destroyed = 0;\n\tuint32_t created = 0;\n\tuint32_t allocated = 0;\n\tuint32_t tmp, handle = 0;\n\tuint32_t *size = &tmp;\n\tint i, r, idx = 0;\n\n\tp->job->vm = NULL;\n\tib->gpu_addr = amdgpu_sa_bo_gpu_addr(ib->sa_bo);\n\n\tr = amdgpu_cs_sysvm_access_required(p);\n\tif (r)\n\t\treturn r;\n\n\twhile (idx < ib->length_dw) {\n\t\tuint32_t len = amdgpu_get_ib_value(p, ib_idx, idx);\n\t\tuint32_t cmd = amdgpu_get_ib_value(p, ib_idx, idx + 1);\n\n\t\tif ((len < 8) || (len & 3)) {\n\t\t\tDRM_ERROR("invalid VCE command length (%d)!\\n", len);\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase 0x00000001: /* session */\n\t\t\thandle = amdgpu_get_ib_value(p, ib_idx, idx + 2);\n\t\t\tsession_idx = amdgpu_vce_validate_handle(p, handle,\n\t\t\t\t\t\t\t\t &allocated);\n\t\t\tif (session_idx < 0) {\n\t\t\t\tr = session_idx;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize = &p->adev->vce.img_size[session_idx];\n\t\t\tbreak;\n\n\t\tcase 0x00000002: /* task info */\n\t\t\tfb_idx = amdgpu_get_ib_value(p, ib_idx, idx + 6);\n\t\t\tbs_idx = amdgpu_get_ib_value(p, ib_idx, idx + 7);\n\t\t\tbreak;\n\n\t\tcase 0x01000001: /* create */\n\t\t\tcreated |= 1 << session_idx;\n\t\t\tif (destroyed & (1 << session_idx)) {\n\t\t\t\tdestroyed &= ~(1 << session_idx);\n\t\t\t\tallocated |= 1 << session_idx;\n\n\t\t\t} else if (!(allocated & (1 << session_idx))) {\n\t\t\t\tDRM_ERROR("Handle already in use!\\n");\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*size = amdgpu_get_ib_value(p, ib_idx, idx + 8) *\n\t\t\t\tamdgpu_get_ib_value(p, ib_idx, idx + 10) *\n\t\t\t\t8 * 3 / 2;\n\t\t\tbreak;\n\n\t\tcase 0x04000001: /* config extension */\n\t\tcase 0x04000002: /* pic control */\n\t\tcase 0x04000005: /* rate control */\n\t\tcase 0x04000007: /* motion estimation */\n\t\tcase 0x04000008: /* rdo */\n\t\tcase 0x04000009: /* vui */\n\t\tcase 0x05000002: /* auxiliary buffer */\n\t\tcase 0x05000009: /* clock table */\n\t\t\tbreak;\n\n\t\tcase 0x0500000c: /* hw config */\n\t\t\tswitch (p->adev->asic_type) {\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\t\t\tcase CHIP_KAVERI:\n\t\t\tcase CHIP_MULLINS:\n#endif\n\t\t\tcase CHIP_CARRIZO:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x03000001: /* encode */\n\t\t\tr = amdgpu_vce_cs_reloc(p, ib_idx, idx + 10, idx + 9,\n\t\t\t\t\t\t*size, 0);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\n\t\t\tr = amdgpu_vce_cs_reloc(p, ib_idx, idx + 12, idx + 11,\n\t\t\t\t\t\t*size / 3, 0);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 0x02000001: /* destroy */\n\t\t\tdestroyed |= 1 << session_idx;\n\t\t\tbreak;\n\n\t\tcase 0x05000001: /* context buffer */\n\t\t\tr = amdgpu_vce_cs_reloc(p, ib_idx, idx + 3, idx + 2,\n	f
55	118	__memblock_find_range_bottom_up	mm/memblock.c	__memblock_find_range_bottom_up_$__UNIQUE_ID_max1_240$obj	0	11	\N	\N	\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n	t
5299	300	can_probe	arch/x86/kernel/kprobes/core.c	addr	2	-11	\N	\N	\tunsigned long addr, __addr, offset = 0;\n\tstruct insn insn;\n\tkprobe_opcode_t buf[MAX_INSN_SIZE];\n\n\tif (!kallsyms_lookup_size_offset(paddr, NULL, &offset))\n\t\treturn 0;\n\n\t/* Decode instructions */\n\taddr = paddr - offset;\n\twhile (addr < paddr) {\n	t
32214	392	stmmac_probe_config_dt	drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c	stmmac_probe_config_dt_	1	11	\N	\N	\tstruct device_node *np = pdev->dev.of_node;\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_dma_cfg *dma_cfg;\n\n\tplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*mac = of_get_mac_address(np);\n\tplat->interface = of_get_phy_mode(np);\n\n\t/* Get max speed of operation from device tree */\n\tif (of_property_read_u32(np, "max-speed", &plat->max_speed))\n	t
39172	2928	vmw_cmd_dx_view_remove	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c	view	1	11	\N	\N	\tstruct vmw_resource_val_node *ctx_node = sw_context->dx_ctx_node;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tunion vmw_view_destroy body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tenum vmw_view_type view_type = vmw_view_cmd_to_type(header->id);\n\tstruct vmw_resource *view;\n\tint ret;\n\n\tif (!ctx_node) {\n\t\tDRM_ERROR("DX Context not set.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_view_remove(sw_context->man,\n\t\t\t      cmd->body.view_id, view_type,\n\t\t\t      &sw_context->staged_cmd_res,\n\t\t\t      &view);\n\tif (ret || !view)\n	t
39776	873	lan78xx_write_raw_otp	drivers/net/usb/lan78xx.c	buf	6	12	\N	\N	\tint i;\n\tint ret;\n\tu32 buf;\n\tunsigned long timeout;\n\n\tret = lan78xx_read_reg(dev, OTP_PWR_DN, &buf);\n\n\tif (buf & OTP_PWR_DN_PWRDN_N_) {\n	t
59923	4859	netdev_tx	drivers/net/ethernet/micrel/ksz884x.c	skb->data	1	-11	\N	\N	\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint left;\n\tint num = 1;\n\tint rc = 0;\n\n\tif (hw->features & SMALL_PACKET_TX_BUG) {\n\t\tstruct sk_buff *org_skb = skb;\n\n\t\tif (skb->len <= 48) {\n\t\t\tif (skb_end_pointer(skb) - skb->data >= 50) {\n\t\t\t\tmemset(&skb->data[skb->len], 0, 50 - skb->len);\n\t\t\t\tskb->len = 50;\n\t\t\t} else {\n\t\t\t\tskb = netdev_alloc_skb(dev, 50);\n\t\t\t\tif (!skb)\n\t\t\t\t\treturn NETDEV_TX_BUSY;\n\t\t\t\tmemcpy(skb->data, org_skb->data, org_skb->len);\n\t\t\t\tmemset(&skb->data[org_skb->len], 0,\n	t
2183	845	cbr_dll2	drivers/gpu/drm/ast/ast_post.c	cbr_dll2_$dllmax$0$obj$sub$%dllmin$0$obj	0	13	\N	\N	\tu32 dllmin[2], dllmax[2], dlli, data, passcnt, retry = 0;\n\tbool status = false;\n\n\tfinetuneDQSI(ast);\n\tif (finetuneDQI_L(ast, param) == false)\n\t\treturn status;\n\nCBR_START2:\n\tdllmin[0] = dllmin[1] = 0xff;\n\tdllmax[0] = dllmax[1] = 0x0;\n\tpasscnt = 0;\n\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\tast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\n\t\tast_moutdwm(ast, 0x1E6E0074, CBR_SIZE2);\n\t\tdata = cbr_scan(ast);\n\t\tif (data != 0) {\n\t\t\tif (data & 0x1) {\n\t\t\t\tif (dllmin[0] > dlli) {\n\t\t\t\t\tdllmin[0] = dlli;\n\t\t\t\t}\n\t\t\t\tif (dllmax[0] < dlli) {\n\t\t\t\t\tdllmax[0] = dlli;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (data & 0x2) {\n\t\t\t\tif (dllmin[1] > dlli) {\n\t\t\t\t\tdllmin[1] = dlli;\n\t\t\t\t}\n\t\t\t\tif (dllmax[1] < dlli) {\n\t\t\t\t\tdllmax[1] = dlli;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpasscnt++;\n\t\t} else if (passcnt >= CBR_THRESHOLD) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retry++ > 10)\n\t\tgoto CBR_DONE2;\n\tif (dllmax[0] == 0 || (dllmax[0]-dllmin[0]) < CBR_THRESHOLD) {\n	f
-250	82	set_chip_clock	drivers/staging/sm750fb/ddk750_chip.c	pll.OD	7	20	\N	\N	\tstruct pll_value pll;\n\tunsigned int ulActualMxClk;\n\n\t/* Cheok_0509: For SM750LE, the chip clock is fixed. Nothing to set. */\n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn;\n\n\tif (frequency) {\n\t\t/*\n\t\t * Set up PLL structure to hold the value to be set in clocks.\n\t\t */\n\t\tpll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */\n\t\tpll.clockType = MXCLK_PLL;\n\n\t\t/*\n\t\t * Call sm750_calc_pll_value() to fill the other fields\n\t\t * of the PLL structure. Sometimes, the chip cannot set\n\t\t * up the exact clock required by the User.\n\t\t * Return value of sm750_calc_pll_value gives the actual\n\t\t * possible clock.\n\t\t */\n\t\tulActualMxClk = sm750_calc_pll_value(frequency, &pll);\n\n\t\t/* Master Clock Control: MXCLK_PLL */\n\t\tpoke32(MXCLK_PLL_CTRL, sm750_format_pll_reg(&pll));\n	f
6736	754	drm_atomic_helper_check_planes	drivers/gpu/drm/drm_atomic_helper.c	drm_atomic_helper_check_planes_$crtc$obj$20$0$obj	0	11	\N	\N	\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state, *old_plane_state;\n\tint i, ret = 0;\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs;\n\n\t\tWARN_ON(!drm_modeset_is_locked(&plane->mutex));\n\n\t\tfuncs = plane->helper_private;\n\n\t\tdrm_atomic_helper_plane_changed(state, old_plane_state, new_plane_state, plane);\n\n\t\tif (!funcs || !funcs->atomic_check)\n\t\t\tcontinue;\n\n\t\tret = funcs->atomic_check(plane, new_plane_state);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_ATOMIC("[PLANE:%d:%s] atomic driver check failed\\n",\n\t\t\t\t\t plane->base.id, plane->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (!funcs || !funcs->atomic_check)\n\t\t\tcontinue;\n\n\t\tret = funcs->atomic_check(crtc, new_crtc_state);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_ATOMIC("[CRTC:%d:%s] atomic driver check failed\\n",\n	t
37407	262	mlx5_cq_debugfs_init	drivers/net/ethernet/mellanox/mlx5/core/debugfs.c	dev->priv.cq_debugfs	1	11	\N	\N	\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\tdev->priv.cq_debugfs = debugfs_create_dir("CQs",  dev->priv.dbg_root);\n\tif (!dev->priv.cq_debugfs)\n	t
39980	1319	sess_auth_rawntlmssp_authenticate	fs/cifs/sess.c	sess_data	1	11	\N	\N	\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tunsigned char *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, "rawntlmssp session setup authenticate phase\\n");\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Build security blob before we assemble the request */\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\trc = build_ntlmssp_auth_blob(&ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t/*\n\t * Make sure that we tell the server that we are using\n\t * the uid that it just gave us back on the response\n\t * (challenge)\n\t */\n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n	t
63221	2125	sas_ex_revalidate_domain	drivers/scsi/libsas/sas_expander.c	res	1	11	\N	\N	\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n	t
54615	815	SMB2_sess_alloc_buffer	fs/cifs/smb2pdu.c	req->hdr.sync_hdr.SessionId	7	12	\N	\N	\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\trc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t/* First session, not a reauthenticate */\n\treq->hdr.sync_hdr.SessionId = 0;\n	t
47856	4790	ceph_osdc_list_watchers	net/ceph/osd_client.c	req	1	13	\N	\N	\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint ret;\n\n\treq = ceph_osdc_alloc_request(osdc, NULL, 1, false, GFP_NOIO);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tceph_oid_copy(&req->r_base_oid, oid);\n\tceph_oloc_copy(&req->r_base_oloc, oloc);\n\treq->r_flags = CEPH_OSD_FLAG_READ;\n\n\tret = ceph_osdc_alloc_messages(req, GFP_NOIO);\n	f
26868	1805	__remove_privs	fs/inode.c	&newattrs	1	11	\N	\N	\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n	t
56791	189	crtc_crc_open	drivers/gpu/drm/drm_debugfs_crc.c	crtc_crc_open_$tmp60$obj	0	11	\N	\N	\tstruct drm_crtc *crtc = inode->i_private;\n\tstruct drm_crtc_crc *crc = &crtc->crc;\n\tstruct drm_crtc_crc_entry *entries = NULL;\n\tsize_t values_cnt;\n\tint ret = 0;\n\n\tif (drm_drv_uses_atomic_modeset(crtc->dev)) {\n\t\tret = drm_modeset_lock_interruptible(&crtc->mutex, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!crtc->state->active)\n\t\t\tret = -EIO;\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irq(&crc->lock);\n\tif (!crc->opened)\n\t\tcrc->opened = true;\n\telse\n\t\tret = -EBUSY;\n\tspin_unlock_irq(&crc->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = crtc->funcs->set_crc_source(crtc, crc->source, &values_cnt);\n\tif (ret)\n\t\tgoto err;\n\n\tif (WARN_ON(values_cnt > DRM_MAX_CRC_NR)) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable;\n\t}\n\n\tif (WARN_ON(values_cnt == 0)) {\n	t
1581	181	rtl_process_pwdb	drivers/staging/rtlwifi/stats.c	rtl_process_pwdb_$drv_priv$obj$10	0	11	\N	\N	\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *drv_priv = NULL;\n\tstruct ieee80211_sta *sta = NULL;\n\tlong undec_sm_pwdb;\n\n\trcu_read_lock();\n\tif (rtlpriv->mac80211.opmode != NL80211_IFTYPE_STATION)\n\t\tsta = rtl_find_sta(hw, pstatus->psaddr);\n\n\t/* adhoc or ap mode */\n\tif (sta) {\n\t\tdrv_priv = (struct rtl_sta_info *)sta->drv_priv;\n\t\tundec_sm_pwdb = drv_priv->rssi_stat.undec_sm_pwdb;\n	t
59274	574	trace_event_raw_event_rcu_batch_start	kernel/rcu/update.c	HZ * 60 * 10	1	-11	\N	\N	\tatomic_notifier_chain_register(&panic_notifier_list, &rcu_panic_block);\n\treturn 0;\n}\nearly_initcall(check_cpu_stall_init);\n\n#endif /* #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_TASKS_RCU\n\n/*\n * Simple variant of RCU whose quiescent states are voluntary context switch,\n * user-space execution, and idle.  As such, grace periods can take one good\n * long time.  There are no read-side primitives similar to rcu_read_lock()\n * and rcu_read_unlock() because this implementation is intended to get\n * the system into a safe state for some of the manipulations involved in\n * tracing and the like.  Finally, this implementation does not support\n * high call_rcu_tasks() rates from multiple CPUs.  If this is required,\n * per-CPU callback lists will be needed.\n */\n\n/* Global list of callbacks and associated lock. */\nstatic struct rcu_head *rcu_tasks_cbs_head;\nstatic struct rcu_head **rcu_tasks_cbs_tail = &rcu_tasks_cbs_head;\nstatic DECLARE_WAIT_QUEUE_HEAD(rcu_tasks_cbs_wq);\nstatic DEFINE_RAW_SPINLOCK(rcu_tasks_cbs_lock);\n\n/* Track exiting tasks in order to allow them to be waited for. */\nDEFINE_STATIC_SRCU(tasks_rcu_exit_srcu);\n\n/* Control stall timeouts.  Disable with <= 0, otherwise jiffies till stall. */\n#define RCU_TASK_STALL_TIMEOUT (HZ * 60 * 10)\n	t
28897	202	mmc_of_parse	drivers/mmc/core/host.c	bus_width	1	11	\N	\N	\tstruct device *dev = host->parent;\n\tu32 bus_width;\n\tint ret;\n\tbool cd_cap_invert, cd_gpio_invert = false;\n\tbool ro_cap_invert, ro_gpio_invert = false;\n\n\tif (!dev || !dev_fwnode(dev))\n\t\treturn 0;\n\n\t/* "bus-width" is translated to MMC_CAP_*_BIT_DATA flags */\n\tif (device_property_read_u32(dev, "bus-width", &bus_width) < 0) {\n\t\tdev_dbg(host->parent,\n\t\t\t"\\"bus-width\\" property is missing, assuming 1 bit.\\n");\n\t\tbus_width = 1;\n\t}\n\n\tswitch (bus_width) {\n	t
40884	227	icmpv6_xrlim_allow	net/ipv6/icmp.c	peer	1	11	\N	\N	\tstruct net *net = sock_net(sk);\n\tstruct dst_entry *dst;\n\tbool res = false;\n\n\tif (icmpv6_mask_allow(type))\n\t\treturn true;\n\n\t/*\n\t * Look up the output route.\n\t * XXX: perhaps the expire for routing entries cloned by\n\t * this lookup should be more aggressive (not longer than timeout).\n\t */\n\tdst = ip6_route_output(net, sk, fl6);\n\tif (dst->error) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t      IPSTATS_MIB_OUTNOROUTES);\n\t} else if (dst->dev && (dst->dev->flags&IFF_LOOPBACK)) {\n\t\tres = true;\n\t} else {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tint tmo = net->ipv6.sysctl.icmpv6_time;\n\t\tstruct inet_peer *peer;\n\n\t\t/* Give more bandwidth to wider prefixes. */\n\t\tif (rt->rt6i_dst.plen < 128)\n\t\t\ttmo >>= ((128 - rt->rt6i_dst.plen)>>5);\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &fl6->daddr, 1);\n\t\tres = inet_peer_xrlim_allow(peer, tmo);\n	t
61735	7156	airo_get_aplist	drivers/net/wireless/cisco/airo.c	BSSList.index	1	11	\N	\N	\tstruct airo_info *local = dev->ml_priv;\n\tstruct sockaddr *address = (struct sockaddr *) extra;\n\tstruct iw_quality *qual;\n\tBSSListRid BSSList;\n\tint i;\n\tint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\n\n\tqual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);\n\tif (!qual)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IW_MAX_AP; i++) {\n\t\tu16 dBm;\n\t\tif (readBSSListRid(local, loseSync, &BSSList))\n\t\t\tbreak;\n\t\tloseSync = 0;\n\t\tmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tdBm = le16_to_cpu(BSSList.dBm);\n\t\tif (local->rssi) {\n\t\t\tqual[i].level = 0x100 - dBm;\n\t\t\tqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\n\t\t\tqual[i].updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t} else {\n\t\t\tqual[i].level = (dBm + 321) / 2;\n\t\t\tqual[i].qual = 0;\n\t\t\tqual[i].updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t}\n\t\tqual[i].noise = local->wstats.qual.noise;\n\t\tif (BSSList.index == cpu_to_le16(0xffff))\n	t
-247	303	max8907_regulator_probe	drivers/regulator/max8907-regulator.c	val	5	20	\N	\N	\tstruct max8907 *max8907 = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8907_platform_data *pdata = dev_get_platdata(max8907->dev);\n\tint ret;\n\tstruct max8907_regulator *pmic;\n\tunsigned int val;\n\tint i;\n\tstruct regulator_config config = {};\n\tstruct regulator_init_data *idata;\n\tconst char *mbatt_rail_name = NULL;\n\n\tret = max8907_regulator_parse_dt(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pmic);\n\n\tmemcpy(pmic->desc, max8907_regulators, sizeof(pmic->desc));\n\n\t/* Backwards compatibility with MAX8907B; SD1 uses different voltages */\n\tregmap_read(max8907->regmap_gen, MAX8907_REG_II2RR, &val);\n\tif ((val & MAX8907_II2RR_VERSION_MASK) ==\n	f
37042	118	wl1251_fetch_nvs	drivers/net/wireless/ti/wl1251/main.c	fw->size	9	12	\N	\N	\tconst struct firmware *fw;\n\tstruct device *dev = wiphy_dev(wl->hw->wiphy);\n\tint ret;\n\n\tret = request_firmware(&fw, WL1251_NVS_NAME, dev);\n\n\tif (ret < 0) {\n\t\twl1251_error("could not get nvs file: %d", ret);\n\t\treturn ret;\n\t}\n\n\tif (fw->size % 4) {\n	t
24109	280	trace_event_raw_event_mm_page_alloc_extfrag	mm/slab_common.c	s->ctor	1	11	\N	\N	\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n	t
49506	324	f2fs_write_cache_pages	fs/f2fs/data.c	f2fs_write_cache_pages_1$shl$$nr.addr.i.i193$obj$and$63$and$%addr.addr.i.i194$obj$0$obj	0	11	\N	\N	\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io = sbi->write_io[btype] + temp;\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tio->fio.op = REQ_OP_WRITE;\n\t\tio->fio.op_flags = REQ_META | REQ_PRIO | REQ_SYNC;\n\t\tif (!test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.op_flags |= REQ_PREFLUSH | REQ_FUA;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}\n\nstatic void __submit_merged_write_cond(struct f2fs_sb_info *sbi,\n	t
62072	286	btrfs_get_name	fs/btrfs/export.c	name_ptr	1	11	\N	\N	\tstruct inode *inode = d_inode(child);\n\tstruct inode *dir = d_inode(parent);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_root_ref *rref;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tint name_len;\n\tint ret;\n\tu64 ino;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn -EINVAL;\n\n\tino = btrfs_ino(BTRFS_I(inode));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tkey.objectid = BTRFS_I(inode)->root->root_key.objectid;\n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = fs_info->tree_root;\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.offset = btrfs_ino(BTRFS_I(dir));\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t}\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\tpath->slots[0]--;\n\t\t} else {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tleaf = path->nodes[0];\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\trref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\t\tname_ptr = (unsigned long)(rref + 1);\n\t\tname_len = btrfs_root_ref_name_len(leaf, rref);\n\t} else {\n\t\tiref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tname_ptr = (unsigned long)(iref + 1);\n\t\tname_len = btrfs_inode_ref_name_len(leaf, iref);\n\t}\n\n\tret = btrfs_is_name_len_valid(leaf, path->slots[0], name_ptr, name_len);\n	t
49444	1920	ath10k_wmi_tlv_op_gen_vdev_sta_uapsd	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_vdev_sta_uapsd_$cmd$obj	0	-11	\N	\N	\tstruct wmi_sta_uapsd_auto_trig_cmd_fixed_param *cmd;\n\tstruct wmi_sta_uapsd_auto_trig_param *ac;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tsize_t ac_tlv_len;\n\tvoid *ptr;\n\tint i;\n\n\tac_tlv_len = num_ac * (sizeof(*tlv) + sizeof(*ac));\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + ac_tlv_len;\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_UAPSD_AUTO_TRIG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	t
1432	643	iomap_seek_data_actor	fs/iomap.c	offset	1	11	\N	\N	\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\treturn length;\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_DATA);\n\t\tif (offset < 0)\n	t
1508	530	max_write_buffer_kb_store	drivers/staging/comedi/comedi_fops.c	size	1	11	\N	\N	\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n	t
-406	6580	__e1000_resume	drivers/net/ethernet/intel/e1000e/netdev.c	phy_data	2	3	\N	\N	\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\tpci_set_master(pdev);\n\n\tif (hw->mac.type >= e1000_pch2lan)\n\t\te1000_resume_workarounds_pchlan(&adapter->hw);\n\n\te1000e_power_up_phy(adapter);\n\n\t/* report the system wakeup cause from S3/S4 */\n\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(&adapter->hw, BM_WUS, &phy_data);\n\t\tif (phy_data) {\n	f
48941	2240	sony_nc_thermal_mode_show	drivers/platform/x86/sony-laptop.c	mode	1	11	\N	\N	\tssize_t count = 0;\n\tint mode = sony_nc_thermal_mode_get();\n\n\tif (mode < 0)\n	t
40818	255	ic_open_devs	net/ipv4/ipconfig.c	ic_open_devs_$d$obj$4$obj	0	11	\N	\N	\tstruct ic_device *d, **last;\n\tstruct net_device *dev;\n\tunsigned short oflags;\n\tunsigned long start, next_msg;\n\n\tlast = &ic_first_dev;\n\trtnl_lock();\n\n\t/* bring loopback and DSA master network devices up first */\n\tfor_each_netdev(&init_net, dev) {\n\t\tif (!(dev->flags & IFF_LOOPBACK) && !netdev_uses_dsa(dev))\n\t\t\tcontinue;\n\t\tif (dev_change_flags(dev, dev->flags | IFF_UP) < 0)\n\t\t\tpr_err("IP-Config: Failed to open %s\\n", dev->name);\n\t}\n\n\tfor_each_netdev(&init_net, dev) {\n\t\tif (ic_is_init_dev(dev)) {\n\t\t\tint able = 0;\n\t\t\tif (dev->mtu >= 364)\n\t\t\t\table |= IC_BOOTP;\n\t\t\telse\n\t\t\t\tpr_warn("DHCP/BOOTP: Ignoring device %s, MTU %d too small\\n",\n\t\t\t\t\tdev->name, dev->mtu);\n\t\t\tif (!(dev->flags & IFF_NOARP))\n\t\t\t\table |= IC_RARP;\n\t\t\table &= ic_proto_enabled;\n\t\t\tif (ic_proto_enabled && !able)\n\t\t\t\tcontinue;\n\t\t\toflags = dev->flags;\n\t\t\tif (dev_change_flags(dev, oflags | IFF_UP) < 0) {\n\t\t\t\tpr_err("IP-Config: Failed to open %s\\n",\n\t\t\t\t       dev->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(d = kmalloc(sizeof(struct ic_device), GFP_KERNEL))) {\n\t\t\t\trtnl_unlock();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\td->dev = dev;\n\t\t\t*last = d;\n\t\t\tlast = &d->next;\n\t\t\td->flags = oflags;\n\t\t\td->able = able;\n\t\t\tif (able & IC_BOOTP)\n\t\t\t\tget_random_bytes(&d->xid, sizeof(__be32));\n\t\t\telse\n\t\t\t\td->xid = 0;\n\t\t\tic_proto_have_if |= able;\n\t\t\tpr_debug("IP-Config: %s UP (able=%d, xid=%08x)\\n",\n	t
60227	160	oxnas_dwmac_probe	drivers/net/ethernet/stmicro/stmmac/dwmac-oxnas.c	plat_dat	1	11	\N	\N	\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct oxnas_dwmac *dwmac;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->dev = &pdev->dev;\n\tplat_dat->bsp_priv = dwmac;\n\tplat_dat->init = oxnas_dwmac_init;\n\tplat_dat->exit = oxnas_dwmac_exit;\n\n\tdwmac->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t"oxsemi,sys-ctrl");\n\tif (IS_ERR(dwmac->regmap)) {\n\t\tdev_err(&pdev->dev, "failed to have sysctrl regmap\\n");\n\t\tret = PTR_ERR(dwmac->regmap);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->clk = devm_clk_get(&pdev->dev, "gmac");\n\tif (IS_ERR(dwmac->clk)) {\n\t\tret = PTR_ERR(dwmac->clk);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tret = oxnas_dwmac_init(pdev, plat_dat->bsp_priv);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n	t
6903	1365	adv7842_g_volatile_ctrl	drivers/media/i2c/adv7842.c	adv7842_g_volatile_ctrl_$and$1	0	11	\N	\N	\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tif (ctrl->id == V4L2_CID_DV_RX_IT_CONTENT_TYPE) {\n\t\tctrl->val = V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\n\t\tif ((io_read(sd, 0x60) & 1) && (infoframe_read(sd, 0x03) & 0x80))\n	t
62193	434	altera_cvp_probe	drivers/fpga/altera-cvp.c	cmd	1	11	\N	\N	\tstruct altera_cvp_conf *conf;\n\tu16 cmd, val;\n\tint ret;\n\n\t/*\n\t * First check if this is the expected FPGA device. PCI config\n\t * space access works without enabling the PCI device, memory\n\t * space access is enabled further down.\n\t */\n\tpci_read_config_word(pdev, VSE_PCIE_EXT_CAP_ID, &val);\n\tif (val != VSE_PCIE_EXT_CAP_ID_VAL) {\n\t\tdev_err(&pdev->dev, "Wrong EXT_CAP_ID value 0x%x\\n", val);\n\t\treturn -ENODEV;\n\t}\n\n\tconf = devm_kzalloc(&pdev->dev, sizeof(*conf), GFP_KERNEL);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Enable memory BAR access. We cannot use pci_enable_device() here\n\t * because it will make the driver unusable with FPGA devices that\n\t * have additional big IOMEM resources (e.g. 4GiB BARs) on 32-bit\n\t * platform. Such BARs will not have an assigned address range and\n\t * pci_enable_device() will fail, complaining about not claimed BAR,\n\t * even if the concerned BAR is not needed for FPGA configuration\n\t * at all. Thus, enable the device via PCI config space command.\n\t */\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (!(cmd & PCI_COMMAND_MEMORY)) {\n	f
20246	475	client_common_fill_super	drivers/staging/lustre/lustre/llite/llite_lib.c	sbi->ll_flags & LL_SBI_32BIT_API	1	11	\N	\N	\tstruct inode *root = NULL;\n\tstruct ll_sb_info *sbi = ll_s2sbi(sb);\n\tstruct obd_device *obd;\n\tstruct obd_statfs *osfs = NULL;\n\tstruct ptlrpc_request *request = NULL;\n\tstruct obd_connect_data *data = NULL;\n\tstruct obd_uuid *uuid;\n\tstruct md_op_data *op_data;\n\tstruct lustre_md lmd;\n\tu64 valid;\n\tint size, err, checksum;\n\n\tobd = class_name2obd(md);\n\tif (!obd) {\n\t\tCERROR("MD %s: not setup or attached\\n", md);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tosfs = kzalloc(sizeof(*osfs), GFP_NOFS);\n\tif (!osfs) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* indicate the features supported by this client */\n\tdata->ocd_connect_flags = OBD_CONNECT_IBITS    | OBD_CONNECT_NODEVOH  |\n\t\t\t\t  OBD_CONNECT_ATTRFID  |\n\t\t\t\t  OBD_CONNECT_VERSION  | OBD_CONNECT_BRW_SIZE |\n\t\t\t\t  OBD_CONNECT_CANCELSET | OBD_CONNECT_FID     |\n\t\t\t\t  OBD_CONNECT_AT       | OBD_CONNECT_LOV_V3   |\n\t\t\t\t  OBD_CONNECT_VBR\t| OBD_CONNECT_FULL20  |\n\t\t\t\t  OBD_CONNECT_64BITHASH |\n\t\t\t\t  OBD_CONNECT_EINPROGRESS |\n\t\t\t\t  OBD_CONNECT_JOBSTATS | OBD_CONNECT_LVB_TYPE |\n\t\t\t\t  OBD_CONNECT_LAYOUTLOCK |\n\t\t\t\t  OBD_CONNECT_PINGLESS |\n\t\t\t\t  OBD_CONNECT_MAX_EASIZE |\n\t\t\t\t  OBD_CONNECT_FLOCK_DEAD |\n\t\t\t\t  OBD_CONNECT_DISP_STRIPE | OBD_CONNECT_LFSCK |\n\t\t\t\t  OBD_CONNECT_OPEN_BY_FID |\n\t\t\t\t  OBD_CONNECT_DIR_STRIPE |\n\t\t\t\t  OBD_CONNECT_BULK_MBITS;\n\n\tif (sbi->ll_flags & LL_SBI_LRU_RESIZE)\n\t\tdata->ocd_connect_flags |= OBD_CONNECT_LRU_RESIZE;\n#ifdef CONFIG_FS_POSIX_ACL\n\tdata->ocd_connect_flags |= OBD_CONNECT_ACL | OBD_CONNECT_UMASK;\n#endif\n\n\tif (OBD_FAIL_CHECK(OBD_FAIL_MDC_LIGHTWEIGHT))\n\t\t/* flag mdc connection as lightweight, only used for test\n\t\t * purpose, use with care\n\t\t */\n\t\tdata->ocd_connect_flags |= OBD_CONNECT_LIGHTWEIGHT;\n\n\tdata->ocd_ibits_known = MDS_INODELOCK_FULL;\n\tdata->ocd_version = LUSTRE_VERSION_CODE;\n\n\tif (sb_rdonly(sb))\n\t\tdata->ocd_connect_flags |= OBD_CONNECT_RDONLY;\n\tif (sbi->ll_flags & LL_SBI_USER_XATTR)\n\t\tdata->ocd_connect_flags |= OBD_CONNECT_XATTR;\n\n\tif (sbi->ll_flags & LL_SBI_FLOCK)\n\t\tsbi->ll_fop = &ll_file_operations_flock;\n\telse if (sbi->ll_flags & LL_SBI_LOCALFLOCK)\n\t\tsbi->ll_fop = &ll_file_operations;\n\telse\n\t\tsbi->ll_fop = &ll_file_operations_noflock;\n\n\t/* always ping even if server suppress_pings */\n\tif (sbi->ll_flags & LL_SBI_ALWAYS_PING)\n\t\tdata->ocd_connect_flags &= ~OBD_CONNECT_PINGLESS;\n\n\tdata->ocd_brw_size = MD_MAX_BRW_SIZE;\n\n\terr = obd_connect(NULL, &sbi->ll_md_exp, obd, &sbi->ll_sb_uuid,\n\t\t\t  data, NULL);\n\tif (err == -EBUSY) {\n\t\tLCONSOLE_ERROR_MSG(0x14f, "An MDT (md %s) is performing recovery, of which this client is not a part. Please wait for recovery to complete, abort, or time out.\\n",\n\t\t\t\t   md);\n\t\tgoto out;\n\t} else if (err) {\n\t\tCERROR("cannot connect to %s: rc = %d\\n", md, err);\n\t\tgoto out;\n\t}\n\n\tsbi->ll_md_exp->exp_connect_data = *data;\n\n\terr = obd_fid_init(sbi->ll_md_exp->exp_obd, sbi->ll_md_exp,\n\t\t\t   LUSTRE_SEQ_METADATA);\n\tif (err) {\n\t\tCERROR("%s: Can't init metadata layer FID infrastructure, rc = %d\\n",\n\t\t       sbi->ll_md_exp->exp_obd->obd_name, err);\n\t\tgoto out_md;\n\t}\n\n\t/* For mount, we only need fs info from MDT0, and also in DNE, it\n\t * can make sure the client can be mounted as long as MDT0 is\n\t * available\n\t */\n\terr = obd_statfs(NULL, sbi->ll_md_exp, osfs,\n\t\t\t cfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\n\t\t\t OBD_STATFS_FOR_MDT0);\n\tif (err)\n\t\tgoto out_md_fid;\n\n\t/* This needs to be after statfs to ensure connect has finished.\n\t * Note that "data" does NOT contain the valid connect reply.\n\t * If connecting to a 1.8 server there will be no LMV device, so\n\t * we can access the MDC export directly and exp_connect_flags will\n\t * be non-zero, but if accessing an upgraded 2.1 server it will\n\t * have the correct flags filled in.\n\t * XXX: fill in the LMV exp_connect_flags from MDC(s).\n\t */\n\tvalid = exp_connect_flags(sbi->ll_md_exp) & CLIENT_CONNECT_MDT_REQD;\n\tif (exp_connect_flags(sbi->ll_md_exp) != 0 &&\n\t    valid != CLIENT_CONNECT_MDT_REQD) {\n\t\tchar *buf;\n\n\t\tbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_md_fid;\n\t\t}\n\t\tobd_connect_flags2str(buf, PAGE_SIZE,\n\t\t\t\t      valid ^ CLIENT_CONNECT_MDT_REQD, ",");\n\t\tLCONSOLE_ERROR_MSG(0x170, "Server %s does not support feature(s) needed for correct operation of this client (%s). Please upgrade server or downgrade client.\\n",\n\t\t\t\t   sbi->ll_md_exp->exp_obd->obd_name, buf);\n\t\tkfree(buf);\n\t\terr = -EPROTO;\n\t\tgoto out_md_fid;\n\t}\n\n\tsize = sizeof(*data);\n\terr = obd_get_info(NULL, sbi->ll_md_exp, sizeof(KEY_CONN_DATA),\n\t\t\t   KEY_CONN_DATA,  &size, data);\n\tif (err) {\n\t\tCERROR("%s: Get connect data failed: rc = %d\\n",\n\t\t       sbi->ll_md_exp->exp_obd->obd_name, err);\n\t\tgoto out_md_fid;\n\t}\n\n\tLASSERT(osfs->os_bsize);\n\tsb->s_blocksize = osfs->os_bsize;\n\tsb->s_blocksize_bits = log2(osfs->os_bsize);\n\tsb->s_magic = LL_SUPER_MAGIC;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsbi->ll_namelen = osfs->os_namelen;\n\tsbi->ll_mnt.mnt = current->fs->root.mnt;\n\n\tif ((sbi->ll_flags & LL_SBI_USER_XATTR) &&\n\t    !(data->ocd_connect_flags & OBD_CONNECT_XATTR)) {\n\t\tLCONSOLE_INFO("Disabling user_xattr feature because it is not supported on the server\\n");\n\t\tsbi->ll_flags &= ~LL_SBI_USER_XATTR;\n\t}\n\n\tif (data->ocd_connect_flags & OBD_CONNECT_ACL) {\n\t\tsb->s_flags |= MS_POSIXACL;\n\t\tsbi->ll_flags |= LL_SBI_ACL;\n\t} else {\n\t\tLCONSOLE_INFO("client wants to enable acl, but mdt not!\\n");\n\t\tsb->s_flags &= ~MS_POSIXACL;\n\t\tsbi->ll_flags &= ~LL_SBI_ACL;\n\t}\n\n\tif (data->ocd_connect_flags & OBD_CONNECT_64BITHASH)\n\t\tsbi->ll_flags |= LL_SBI_64BIT_HASH;\n\n\tif (data->ocd_connect_flags & OBD_CONNECT_BRW_SIZE)\n\t\tsbi->ll_md_brw_pages = data->ocd_brw_size >> PAGE_SHIFT;\n\telse\n\t\tsbi->ll_md_brw_pages = 1;\n\n\tif (data->ocd_connect_flags & OBD_CONNECT_LAYOUTLOCK)\n\t\tsbi->ll_flags |= LL_SBI_LAYOUT_LOCK;\n\n\tif (data->ocd_ibits_known & MDS_INODELOCK_XATTR) {\n\t\tif (!(data->ocd_connect_flags & OBD_CONNECT_MAX_EASIZE)) {\n\t\t\tLCONSOLE_INFO(\n\t\t\t\t"%s: disabling xattr cache due to unknown maximum xattr size.\\n",\n\t\t\t\tdt);\n\t\t} else {\n\t\t\tsbi->ll_flags |= LL_SBI_XATTR_CACHE;\n\t\t\tsbi->ll_xattr_cache_enabled = 1;\n\t\t}\n\t}\n\n\tobd = class_name2obd(dt);\n\tif (!obd) {\n\t\tCERROR("DT %s: not setup or attached\\n", dt);\n\t\terr = -ENODEV;\n\t\tgoto out_md_fid;\n\t}\n\n\tdata->ocd_connect_flags = OBD_CONNECT_GRANT     | OBD_CONNECT_VERSION  |\n\t\t\t\t  OBD_CONNECT_REQPORTAL | OBD_CONNECT_BRW_SIZE |\n\t\t\t\t  OBD_CONNECT_CANCELSET | OBD_CONNECT_FID      |\n\t\t\t\t  OBD_CONNECT_SRVLOCK   | OBD_CONNECT_TRUNCLOCK|\n\t\t\t\t  OBD_CONNECT_AT\t| OBD_CONNECT_OSS_CAPA |\n\t\t\t\t  OBD_CONNECT_VBR\t| OBD_CONNECT_FULL20   |\n\t\t\t\t  OBD_CONNECT_64BITHASH | OBD_CONNECT_MAXBYTES |\n\t\t\t\t  OBD_CONNECT_EINPROGRESS |\n\t\t\t\t  OBD_CONNECT_JOBSTATS | OBD_CONNECT_LVB_TYPE |\n\t\t\t\t  OBD_CONNECT_LAYOUTLOCK |\n\t\t\t\t  OBD_CONNECT_PINGLESS | OBD_CONNECT_LFSCK |\n\t\t\t\t  OBD_CONNECT_BULK_MBITS;\n\n\tif (!OBD_FAIL_CHECK(OBD_FAIL_OSC_CONNECT_CKSUM)) {\n\t\t/* OBD_CONNECT_CKSUM should always be set, even if checksums are\n\t\t * disabled by default, because it can still be enabled on the\n\t\t * fly via /sys. As a consequence, we still need to come to an\n\t\t * agreement on the supported algorithms at connect time\n\t\t */\n\t\tdata->ocd_connect_flags |= OBD_CONNECT_CKSUM;\n\n\t\tif (OBD_FAIL_CHECK(OBD_FAIL_OSC_CKSUM_ADLER_ONLY))\n\t\t\tdata->ocd_cksum_types = OBD_CKSUM_ADLER;\n\t\telse\n\t\t\tdata->ocd_cksum_types = cksum_types_supported_client();\n\t}\n\n\tdata->ocd_connect_flags |= OBD_CONNECT_LRU_RESIZE;\n\n\t/* always ping even if server suppress_pings */\n\tif (sbi->ll_flags & LL_SBI_ALWAYS_PING)\n\t\tdata->ocd_connect_flags &= ~OBD_CONNECT_PINGLESS;\n\n\tCDEBUG(D_RPCTRACE, "ocd_connect_flags: %#llx ocd_version: %d ocd_grant: %d\\n",\n\t       data->ocd_connect_flags,\n\t       data->ocd_version, data->ocd_grant);\n\n\tobd->obd_upcall.onu_owner = &sbi->ll_lco;\n\tobd->obd_upcall.onu_upcall = cl_ocd_update;\n\n\tdata->ocd_brw_size = DT_MAX_BRW_SIZE;\n\n\terr = obd_connect(NULL, &sbi->ll_dt_exp, obd, &sbi->ll_sb_uuid, data,\n\t\t\t  NULL);\n\tif (err == -EBUSY) {\n\t\tLCONSOLE_ERROR_MSG(0x150, "An OST (dt %s) is performing recovery, of which this client is not a part.  Please wait for recovery to complete, abort, or time out.\\n",\n\t\t\t\t   dt);\n\t\tgoto out_md;\n\t} else if (err) {\n\t\tCERROR("%s: Cannot connect to %s: rc = %d\\n",\n\t\t       sbi->ll_dt_exp->exp_obd->obd_name, dt, err);\n\t\tgoto out_md;\n\t}\n\n\tsbi->ll_dt_exp->exp_connect_data = *data;\n\n\terr = obd_fid_init(sbi->ll_dt_exp->exp_obd, sbi->ll_dt_exp,\n\t\t\t   LUSTRE_SEQ_METADATA);\n\tif (err) {\n\t\tCERROR("%s: Can't init data layer FID infrastructure, rc = %d\\n",\n\t\t       sbi->ll_dt_exp->exp_obd->obd_name, err);\n\t\tgoto out_dt;\n\t}\n\n\tmutex_lock(&sbi->ll_lco.lco_lock);\n\tsbi->ll_lco.lco_flags = data->ocd_connect_flags;\n\tsbi->ll_lco.lco_md_exp = sbi->ll_md_exp;\n\tsbi->ll_lco.lco_dt_exp = sbi->ll_dt_exp;\n\tmutex_unlock(&sbi->ll_lco.lco_lock);\n\n\tfid_zero(&sbi->ll_root_fid);\n\terr = md_getstatus(sbi->ll_md_exp, &sbi->ll_root_fid);\n\tif (err) {\n\t\tCERROR("cannot mds_connect: rc = %d\\n", err);\n\t\tgoto out_lock_cn_cb;\n\t}\n\tif (!fid_is_sane(&sbi->ll_root_fid)) {\n\t\tCERROR("%s: Invalid root fid " DFID " during mount\\n",\n\t\t       sbi->ll_md_exp->exp_obd->obd_name,\n\t\t       PFID(&sbi->ll_root_fid));\n\t\terr = -EINVAL;\n\t\tgoto out_lock_cn_cb;\n\t}\n\tCDEBUG(D_SUPER, "rootfid " DFID "\\n", PFID(&sbi->ll_root_fid));\n\n\tsb->s_op = &lustre_super_operations;\n\tsb->s_xattr = ll_xattr_handlers;\n#if THREAD_SIZE >= 8192 /*b=17630*/\n\tsb->s_export_op = &lustre_export_operations;\n#endif\n\n\t/* make root inode\n\t * XXX: move this to after cbd setup?\n\t */\n\tvalid = OBD_MD_FLGETATTR | OBD_MD_FLBLOCKS | OBD_MD_FLMODEASIZE;\n\tif (sbi->ll_flags & LL_SBI_ACL)\n\t\tvalid |= OBD_MD_FLACL;\n\n\top_data = kzalloc(sizeof(*op_data), GFP_NOFS);\n\tif (!op_data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_lock_cn_cb;\n\t}\n\n\top_data->op_fid1 = sbi->ll_root_fid;\n\top_data->op_mode = 0;\n\top_data->op_valid = valid;\n\n\terr = md_getattr(sbi->ll_md_exp, op_data, &request);\n\tkfree(op_data);\n\tif (err) {\n\t\tCERROR("%s: md_getattr failed for root: rc = %d\\n",\n\t\t       sbi->ll_md_exp->exp_obd->obd_name, err);\n\t\tgoto out_lock_cn_cb;\n\t}\n\n\terr = md_get_lustre_md(sbi->ll_md_exp, request, sbi->ll_dt_exp,\n\t\t\t       sbi->ll_md_exp, &lmd);\n\tif (err) {\n\t\tCERROR("failed to understand root inode md: rc = %d\\n", err);\n\t\tptlrpc_req_finished(request);\n\t\tgoto out_lock_cn_cb;\n\t}\n\n\tLASSERT(fid_is_sane(&sbi->ll_root_fid));\n\troot = ll_iget(sb, cl_fid_build_ino(&sbi->ll_root_fid,\n	t
39019	807	max77620_regulator_probe	drivers/regulator/max77620-regulator.c	pmic	1	11	\N	\N	\tstruct max77620_chip *max77620_chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct max77620_regulator_info *rinfo;\n\tstruct device *dev = &pdev->dev;\n\tstruct regulator_config config = { };\n\tstruct max77620_regulator *pmic;\n\tint ret = 0;\n\tint id;\n\n\tpmic = devm_kzalloc(dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pmic);\n\tpmic->dev = dev;\n\tpmic->rmap = max77620_chip->rmap;\n\tif (!dev->of_node)\n\t\tdev->of_node = pdev->dev.parent->of_node;\n\n\tswitch (max77620_chip->chip_id) {\n\tcase MAX77620:\n\t\trinfo = max77620_regs_info;\n\t\tbreak;\n\tdefault:\n\t\trinfo = max20024_regs_info;\n\t\tbreak;\n\t}\n\n\tconfig.regmap = pmic->rmap;\n\tconfig.dev = dev;\n\tconfig.driver_data = pmic;\n\n\tfor (id = 0; id < MAX77620_NUM_REGS; id++) {\n\t\tstruct regulator_dev *rdev;\n\t\tstruct regulator_desc *rdesc;\n\n\t\tif ((max77620_chip->chip_id == MAX77620) &&\n\t\t    (id == MAX77620_REGULATOR_ID_SD4))\n\t\t\tcontinue;\n\n\t\trdesc = &rinfo[id].desc;\n\t\tpmic->rinfo[id] = &max77620_regs_info[id];\n\t\tpmic->enable_power_mode[id] = MAX77620_POWER_MODE_NORMAL;\n\n\t\tret = max77620_read_slew_rate(pmic, id);\n	t
63650	1279	snd_intel8x0m_probe	sound/pci/intel8x0m.c	card->driver	1	11	\N	\N	\tstruct snd_card *card;\n\tstruct intel8x0m *chip;\n\tint err;\n\tstruct shortname_table *name;\n\n\terr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, "ICH-MODEM");\n	t
-1041	71	libcfs_param_debug_mb_set	drivers/staging/lustre/lnet/libcfs/debug.c	num	2	3	\N	\N	\tint rc;\n\tunsigned int num;\n\n\trc = kstrtouint(val, 0, &num);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!*((unsigned int *)kp->arg)) {\n\t\t*((unsigned int *)kp->arg) = num;\n\t\treturn 0;\n\t}\n\n\trc = cfs_trace_set_debug_mb(num);\n	f
-614	1173	destroy_component	drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c	rmsg->h.type	2	3	\N	\N	\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tVCHI_HELD_MSG_T rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_DESTROY;\n\tm.u.component_destroy.component_handle = component->handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_destroy),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n	f
62312	1079	handle_receive_interrupt	drivers/infiniband/hw/hfi1/driver.c	&packet	1	-11	\N	\N	\tstruct hfi1_devdata *dd = rcd->dd;\n\tu32 hdrqtail;\n\tint needset, last = RCV_PKT_OK;\n\tstruct hfi1_packet packet;\n\tint skip_pkt = 0;\n\n\t/* Control context will always use the slow path interrupt handler */\n\tneedset = (rcd->ctxt == HFI1_CTRL_CTXT) ? 0 : 1;\n\n\tinit_packet(rcd, &packet);\n\n\tif (!HFI1_CAP_KGET_MASK(rcd->flags, DMA_RTAIL)) {\n\t\tu32 seq = rhf_rcv_seq(packet.rhf);\n\n\t\tif (seq != rcd->seq_cnt) {\n\t\t\tlast = RCV_PKT_DONE;\n\t\t\tgoto bail;\n\t\t}\n\t\thdrqtail = 0;\n\t} else {\n\t\thdrqtail = get_rcvhdrtail(rcd);\n\t\tif (packet.rhqoff == hdrqtail) {\n\t\t\tlast = RCV_PKT_DONE;\n\t\t\tgoto bail;\n\t\t}\n\t\tsmp_rmb();  /* prevent speculative reads of dma'ed hdrq */\n\n\t\t/*\n\t\t * Control context can potentially receive an invalid\n\t\t * rhf. Drop such packets.\n\t\t */\n\t\tif (rcd->ctxt == HFI1_CTRL_CTXT) {\n\t\t\tu32 seq = rhf_rcv_seq(packet.rhf);\n\n\t\t\tif (seq != rcd->seq_cnt)\n\t\t\t\tskip_pkt = 1;\n\t\t}\n\t}\n\n\tprescan_rxq(rcd, &packet);\n\n\twhile (last == RCV_PKT_OK) {\n\t\tif (unlikely(dd->do_drop &&\n\t\t\t     atomic_xchg(&dd->drop_packet, DROP_PACKET_OFF) ==\n\t\t\t     DROP_PACKET_ON)) {\n\t\t\tdd->do_drop = 0;\n\n\t\t\t/* On to the next packet */\n\t\t\tpacket.rhqoff += packet.rsize;\n\t\t\tpacket.rhf_addr = (__le32 *)rcd->rcvhdrq +\n\t\t\t\t\t  packet.rhqoff +\n\t\t\t\t\t  dd->rhf_offset;\n\t\t\tpacket.rhf = rhf_to_cpu(packet.rhf_addr);\n\n\t\t} else if (skip_pkt) {\n\t\t\tlast = skip_rcv_packet(&packet, thread);\n\t\t\tskip_pkt = 0;\n\t\t} else {\n\t\t\t/* Auto activate link on non-SC15 packet receive */\n\t\t\tif (unlikely(rcd->ppd->host_link_state ==\n\t\t\t\t     HLS_UP_ARMED) &&\n\t\t\t    set_armed_to_active(rcd, &packet, dd))\n\t\t\t\tgoto bail;\n\t\t\tlast = process_rcv_packet(&packet, thread);\n\t\t}\n\n\t\tif (!HFI1_CAP_KGET_MASK(rcd->flags, DMA_RTAIL)) {\n\t\t\tu32 seq = rhf_rcv_seq(packet.rhf);\n\n\t\t\tif (++rcd->seq_cnt > 13)\n\t\t\t\trcd->seq_cnt = 1;\n\t\t\tif (seq != rcd->seq_cnt)\n\t\t\t\tlast = RCV_PKT_DONE;\n\t\t\tif (needset) {\n\t\t\t\tdd_dev_info(dd, "Switching to NO_DMA_RTAIL\\n");\n\t\t\t\tset_nodma_rtail(dd, rcd->ctxt);\n\t\t\t\tneedset = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (packet.rhqoff == hdrqtail)\n\t\t\t\tlast = RCV_PKT_DONE;\n\t\t\t/*\n\t\t\t * Control context can potentially receive an invalid\n\t\t\t * rhf. Drop such packets.\n\t\t\t */\n\t\t\tif (rcd->ctxt == HFI1_CTRL_CTXT) {\n\t\t\t\tu32 seq = rhf_rcv_seq(packet.rhf);\n\n\t\t\t\tif (++rcd->seq_cnt > 13)\n\t\t\t\t\trcd->seq_cnt = 1;\n\t\t\t\tif (!last && (seq != rcd->seq_cnt))\n\t\t\t\t\tskip_pkt = 1;\n\t\t\t}\n\n\t\t\tif (needset) {\n\t\t\t\tdd_dev_info(dd,\n\t\t\t\t\t    "Switching to DMA_RTAIL\\n");\n\t\t\t\tset_dma_rtail(dd, rcd->ctxt);\n\t\t\t\tneedset = 0;\n\t\t\t}\n\t\t}\n\n\t\tprocess_rcv_update(last, &packet);\n	t
58640	720	handle_onexec	security/apparmor/domain.c	handle_onexec_$__lvec503$obj$0$obj	0	11	\N	\N	\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t/* TODO: determine how much we want to losen this */\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n	t
28335	1701	ip6_mroute_setsockopt	net/ipv6/ip6mr.c	ip6_mroute_setsockopt_$vif$0$obj	0	11	\N	\N	\tint ret, parent = 0;\n\tstruct mif6ctl vif;\n\tstruct mf6cctl mfc;\n\tmifi_t mifi;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tif (optname != MRT6_INIT) {\n\t\tif (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (optname) {\n\tcase MRT6_INIT:\n\t\tif (optlen < sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\treturn ip6mr_sk_init(mrt, sk);\n\n\tcase MRT6_DONE:\n\t\treturn ip6mr_sk_done(sk);\n\n\tcase MRT6_ADD_MIF:\n\t\tif (optlen < sizeof(vif))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&vif, optval, sizeof(vif)))\n\t\t\treturn -EFAULT;\n\t\tif (vif.mif6c_mifi >= MAXMIFS)\n	t
62313	163	aout_core_dump	arch/x86/ia32/ia32_aout.c	&dump	0	11	\N	\N	\tmm_segment_t fs;\n\tint has_dumped = 0;\n\tunsigned long dump_start, dump_size;\n\tstruct user32 dump;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thas_dumped = 1;\n\tstrncpy(dump.u_comm, current->comm, sizeof(current->comm));\n\tdump.u_ar0 = offsetof(struct user32, regs);\n\tdump.signal = cprm->siginfo->si_signo;\n\tdump_thread32(cprm->regs, &dump);\n	f
4874	829	bq24257_sysfs_set_enable	drivers/power/supply/bq24257_charger.c	val	2	-11	\N	\N	\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\tlong val;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (strcmp(attr->attr.name, "high_impedance_enable") == 0)\n\t\tret = bq24257_field_write(bq, F_HZ_MODE, (bool)val);\n	t
28722	1071	ov2640_probe_dt	drivers/media/i2c/ov2640.c	priv->pwdn_gpio	1	11	\N	\N	\tint ret;\n\n\t/* Request the reset GPIO deasserted */\n\tpriv->resetb_gpio = devm_gpiod_get_optional(&client->dev, "resetb",\n\t\t\tGPIOD_OUT_LOW);\n\n\tif (!priv->resetb_gpio)\n\t\tdev_dbg(&client->dev, "resetb gpio is not assigned!\\n");\n\n\tret = PTR_ERR_OR_ZERO(priv->resetb_gpio);\n\tif (ret && ret != -ENOSYS) {\n\t\tdev_dbg(&client->dev,\n\t\t\t"Error %d while getting resetb gpio\\n", ret);\n\t\treturn ret;\n\t}\n\n\t/* Request the power down GPIO asserted */\n\tpriv->pwdn_gpio = devm_gpiod_get_optional(&client->dev, "pwdn",\n\t\t\tGPIOD_OUT_HIGH);\n\n\tif (!priv->pwdn_gpio)\n	t
3955	664	isc_update_profile	drivers/media/platform/atmel/atmel-isc.c	sr	9	12	\N	\N	\tstruct regmap *regmap = isc->regmap;\n\tu32 sr;\n\tint counter = 100;\n\n\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_UPPRO);\n\n\tregmap_read(regmap, ISC_CTRLSR, &sr);\n\twhile ((sr & ISC_CTRL_UPPRO) && counter--) {\n	t
47321	159	xfs_rmap_update_create_intent	fs/xfs/xfs_trans_rmap.c	&ruip->rui_item	2	-11	\N	\N	\tstruct xfs_rui_log_item\t\t*ruip;\n\n\tASSERT(tp != NULL);\n\tASSERT(count > 0);\n\n\truip = xfs_rui_init(tp->t_mountp, count);\n\tASSERT(ruip != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &ruip->rui_item);\n	t
-232	176	stm32_pwm_lp_get_state	drivers/pwm/pwm-stm32-lp.c	prd	5	20	\N	\N	\tstruct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);\n\tunsigned long rate = clk_get_rate(priv->clk);\n\tu32 val, presc, prd;\n\tu64 tmp;\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CR, &val);\n\tstate->enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);\n\t/* Keep PWM counter clock refcount in sync with PWM initial state */\n\tif (state->enabled)\n\t\tclk_enable(priv->clk);\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CFGR, &val);\n\tpresc = FIELD_GET(STM32_LPTIM_PRESC, val);\n\tstate->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);\n\n\tregmap_read(priv->regmap, STM32_LPTIM_ARR, &prd);\n\ttmp = prd + 1;\n\ttmp = (tmp << presc) * NSEC_PER_SEC;\n\tstate->period = DIV_ROUND_CLOSEST_ULL(tmp, rate);\n	f
-224	164	mdio_sc_cfg_reg_write	drivers/net/ethernet/hisilicon/hns_mdio.c	reg_value	4	20	\N	\N	\tu32 time_cnt;\n\tu32 reg_value;\n\n\tregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\n\n\tfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\n\t\tregmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\n\t\treg_value &= st_msk;\n	f
45400	155	btrfs_init_acl	fs/btrfs/acl.c	acl	7	12	\N	\N	\tstruct posix_acl *default_acl, *acl;\n\tint ret = 0;\n\n\t/* this happens with subvols */\n\tif (!dir)\n\t\treturn 0;\n\n\tret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (default_acl) {\n\t\tret = __btrfs_set_acl(trans, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n	t
61733	7144	airo_get_aplist	drivers/net/wireless/cisco/airo.c	dBm	1	11	\N	\N	\tstruct airo_info *local = dev->ml_priv;\n\tstruct sockaddr *address = (struct sockaddr *) extra;\n\tstruct iw_quality *qual;\n\tBSSListRid BSSList;\n\tint i;\n\tint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\n\n\tqual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);\n\tif (!qual)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IW_MAX_AP; i++) {\n\t\tu16 dBm;\n\t\tif (readBSSListRid(local, loseSync, &BSSList))\n\t\t\tbreak;\n\t\tloseSync = 0;\n\t\tmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tdBm = le16_to_cpu(BSSList.dBm);\n\t\tif (local->rssi) {\n\t\t\tqual[i].level = 0x100 - dBm;\n\t\t\tqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\n	t
33910	59	ath10k_htt_rx_ring_free	drivers/net/wireless/ath/ath10k/htt_rx.c	ath10k_htt_rx_ring_free_$__mptr24$obj	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct ath10k_skb_rxcb *rxcb;\n\tstruct hlist_node *n;\n\tint i;\n\n\tif (htt->rx_ring.in_ord_rx) {\n\t\thash_for_each_safe(htt->rx_ring.skb_table, i, n, rxcb, hlist) {\n	t
48188	949	encrypted_read	security/keys/encrypted-keys/encrypted.c	&mkey->sem	1	11	\N	\N	\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n	t
38517	389	atm_tc_enqueue	net/sched/sch_atm.c	&res	6	12	\N	\N	\tstruct atm_qdisc_data *p = qdisc_priv(sch);\n\tstruct atm_flow_data *flow;\n\tstruct tcf_result res;\n\tint result;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tpr_debug("atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\\n", skb, sch, p);\n\tresult = TC_ACT_OK;\t/* be nice to gcc */\n\tflow = NULL;\n\tif (TC_H_MAJ(skb->priority) != sch->handle ||\n\t    !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) {\n\t\tstruct tcf_proto *fl;\n\n\t\tlist_for_each_entry(flow, &p->flows, list) {\n\t\t\tfl = rcu_dereference_bh(flow->filter_list);\n\t\t\tif (fl) {\n\t\t\t\tresult = tcf_classify(skb, fl, &res, true);\n	t
62337	661	ipvlan_handle_mode_l2	drivers/net/ipvlan/ipvlan_core.c	addr_type	1	11	\N	\N	\tstruct sk_buff *skb = *pskb;\n\tstruct ethhdr *eth = eth_hdr(skb);\n\trx_handler_result_t ret = RX_HANDLER_PASS;\n\tvoid *lyr3h;\n\tint addr_type;\n\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tif (ipvlan_external_frame(skb, port)) {\n\t\t\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* External frames are queued for device local\n\t\t\t * distribution, but a copy is given to master\n\t\t\t * straight away to avoid sending duplicates later\n\t\t\t * when work-queue processes this frame. This is\n\t\t\t * achieved by returning RX_HANDLER_PASS.\n\t\t\t */\n\t\t\tif (nskb) {\n\t\t\t\tipvlan_skb_crossing_ns(nskb, NULL);\n\t\t\t\tipvlan_multicast_enqueue(port, nskb, false);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct ipvl_addr *addr;\n\n\t\tlyr3h = ipvlan_get_L3_hdr(skb, &addr_type);\n\t\tif (!lyr3h)\n\t\t\treturn ret;\n\n\t\taddr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);\n	t
56205	630	img_hash_digest	drivers/crypto/img-hash.c	img_hash_digest_$__mptr5$obj	0	11	\N	\N	\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct img_hash_ctx *tctx = crypto_ahash_ctx(tfm);\n\tstruct img_hash_request_ctx *ctx = ahash_request_ctx(req);\n\tstruct img_hash_dev *hdev = NULL;\n\tstruct img_hash_dev *tmp;\n\tint err;\n\n\tspin_lock(&img_hash.lock);\n\tif (!tctx->hdev) {\n\t\tlist_for_each_entry(tmp, &img_hash.dev_list, list) {\n	t
25790	555	ds_touch_bit	drivers/w1/masters/ds2490.c	err	1	11	\N	\N	\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_control(dev, COMM_BIT_IO | COMM_IM | (bit ? COMM_D : 0),\n\t\t0);\n\tif (err)\n	t
28368	2496	mrt6msg_netlink_event	net/ipv6/ip6mr.c	skb	1	11	\N	\N	\tstruct net *net = read_pnet(&mrt->net);\n\tstruct nlmsghdr *nlh;\n\tstruct rtgenmsg *rtgenm;\n\tstruct mrt6msg *msg;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tint payloadlen;\n\n\tpayloadlen = pkt->len - sizeof(struct mrt6msg);\n\tmsg = (struct mrt6msg *)skb_transport_header(pkt);\n\n\tskb = nlmsg_new(mrt6msg_netlink_msgsize(payloadlen), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWCACHEREPORT,\n	t
37320	1185	checkcard	drivers/isdn/hisax/config.c	checkcard_$cs$obj$11$obj	0	13	\N	\N	\tint ret;\n\tstruct IsdnCard *card = cards + cardnr;\n\tstruct IsdnCardState *cs;\n\n\tret = hisax_cs_new(cardnr, id, card, &cs, busy_flag, lockowner);\n\tif (!ret)\n\t\treturn 0;\n\n\tprintk(KERN_INFO\n	f
37011	10638	ixgbe_io_error_detected	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	pos + PCI_ERR_HEADER_LOG + 8	1	13	\N	\N	\tstruct ixgbe_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n#ifdef CONFIG_PCI_IOV\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct pci_dev *bdev, *vfdev;\n\tu32 dw0, dw1, dw2, dw3;\n\tint vf, pos;\n\tu16 req_id, pf_func;\n\n\tif (adapter->hw.mac.type == ixgbe_mac_82598EB ||\n\t    adapter->num_vfs == 0)\n\t\tgoto skip_bad_vf_detection;\n\n\tbdev = pdev->bus->self;\n\twhile (bdev && (pci_pcie_type(bdev) != PCI_EXP_TYPE_ROOT_PORT))\n\t\tbdev = bdev->bus->self;\n\n\tif (!bdev)\n\t\tgoto skip_bad_vf_detection;\n\n\tpos = pci_find_ext_capability(bdev, PCI_EXT_CAP_ID_ERR);\n\tif (!pos)\n\t\tgoto skip_bad_vf_detection;\n\n\tdw0 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG);\n\tdw1 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG + 4);\n\tdw2 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG + 8);\n	f
51688	18	pEII_request	net/ipx/pe2.c	skb	1	13	\N	\N	\tstruct net_device *dev = skb->dev;\n\n\tskb->protocol = htons(ETH_P_IPX);\n\tdev_hard_header(skb, dev, ETH_P_IPX, dest_node, NULL, skb->len);\n\treturn dev_queue_xmit(skb);\n	f
9128	86	mce_gen_pool_process	arch/x86/kernel/cpu/mcheck/mce-genpool.c	node	1	11	\N	\N	\tstruct llist_node *head;\n\tstruct mce_evt_llist *node, *tmp;\n\tstruct mce *mce;\n\n\thead = llist_del_all(&mce_event_llist);\n\tif (!head)\n\t\treturn;\n\n\thead = llist_reverse_order(head);\n\tllist_for_each_entry_safe(node, tmp, head, llnode) {\n	t
27771	299	hfi1_make_rc_req	drivers/infiniband/hw/hfi1/rc.c	ohdr	0	11	\N	\N	\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_ibdev *dev = to_idev(qp->ibqp.device);\n\tstruct ib_other_headers *ohdr;\n\tstruct rvt_sge_state *ss;\n\tstruct rvt_swqe *wqe;\n\tu32 hwords;\n\tu32 len;\n\tu32 bth0 = 0;\n\tu32 bth2;\n\tu32 pmtu = qp->pmtu;\n\tchar newreq;\n\tint middle = 0;\n\tint delta;\n\n\tlockdep_assert_held(&qp->s_lock);\n\tps->s_txreq = get_txreq(ps->dev, qp);\n\tif (IS_ERR(ps->s_txreq))\n\t\tgoto bail_no_tx;\n\n\tps->s_txreq->phdr.hdr.hdr_type = priv->hdr_type;\n\tif (priv->hdr_type == HFI1_PKT_TYPE_9B) {\n\t\t/* header size in 32-bit words LRH+BTH = (8+12)/4. */\n\t\thwords = 5;\n\t\tif (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.oth;\n\t} else {\n\t\t/* header size in 32-bit words 16B LRH+BTH = (16+12)/4. */\n\t\thwords = 7;\n\t\tif ((rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&\n\t\t    (hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))))\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.oth;\n\t}\n\n\t/* Sending responses has higher priority over sending requests. */\n\tif ((qp->s_flags & RVT_S_RESP_PENDING) &&\n\t    make_rc_ack(dev, qp, ohdr, ps))\n	f
40937	1039	vx_pcm_capture_update	sound/drivers/vx/vx_pcm.c	count	1	11	\N	\N	\tint size, space, count;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\tif (!pipe->running || (chip->chip_status & VX_STAT_IS_STALE))\n\t\treturn;\n\n\tsize = runtime->buffer_size - snd_pcm_capture_avail(runtime);\n\tif (! size)\n\t\treturn;\n\tsize = frames_to_bytes(runtime, size);\n\tspace = vx_query_hbuffer_size(chip, pipe);\n\tif (space < 0)\n\t\tgoto _error;\n\tif (size > space)\n\t\tsize = space;\n\tsize = (size / 3) * 3; /* align to 3 bytes */\n\tif (size < DMA_READ_ALIGN)\n\t\tgoto _error;\n\n\t/* keep the last 6 bytes, they will be read after disconnection */\n\tcount = size - DMA_READ_ALIGN;\n\t/* read bytes until the current pointer reaches to the aligned position\n\t * for word-transfer\n\t */\n\twhile (count > 0) {\n	t
20625	482	unpack_trans_table	security/apparmor/policy_unpack.c	str	1	11	\N	\N	\tvoid *saved_pos = e->pos;\n\n\t/* exec table is optional */\n\tif (unpack_nameX(e, AA_STRUCT, "xtable")) {\n\t\tint i, size;\n\n\t\tsize = unpack_array(e, NULL);\n\t\t/* currently 4 exec bits and entries 0-3 are reserved iupcx */\n\t\tif (size > 16 - 4)\n\t\t\tgoto fail;\n\t\tprofile->file.trans.table = kzalloc(sizeof(char *) * size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!profile->file.trans.table)\n\t\t\tgoto fail;\n\n\t\tprofile->file.trans.size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = unpack_strdup(e, &str, NULL);\n\t\t\t/* unpack_strdup verifies that the last character is\n\t\t\t * null termination byte.\n\t\t\t */\n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\tprofile->file.trans.table[i] = str;\n\t\t\t/* verify that name doesn't start with space */\n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t/* count internal #  of internal \\0 */\n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n	t
41293	3515	mlx4_load_one	drivers/net/ethernet/mellanox/mlx4/main.c	dev	1	11	\N	\N	\tstruct mlx4_dev *dev;\n\tunsigned sum = 0;\n\tint err;\n\tint port;\n\tint i;\n\tstruct mlx4_dev_cap *dev_cap = NULL;\n\tint existing_vfs = 0;\n\n\tdev = &priv->dev;\n\n\tINIT_LIST_HEAD(&priv->ctx_list);\n\tspin_lock_init(&priv->ctx_lock);\n\n\tmutex_init(&priv->port_mutex);\n\tmutex_init(&priv->bond_mutex);\n\n\tINIT_LIST_HEAD(&priv->pgdir_list);\n\tmutex_init(&priv->pgdir_mutex);\n\tspin_lock_init(&priv->cmd.context_lock);\n\n\tINIT_LIST_HEAD(&priv->bf_list);\n\tmutex_init(&priv->bf_mutex);\n\n\tdev->rev_id = pdev->revision;\n\tdev->numa_node = dev_to_node(&pdev->dev);\n\n\t/* Detect if this device is a virtual function */\n\tif (pci_dev_data & MLX4_PCI_DEV_IS_VF) {\n\t\tmlx4_warn(dev, "Detected virtual function - running in slave mode\\n");\n\t\tdev->flags |= MLX4_FLAG_SLAVE;\n\t} else {\n\t\t/* We reset the device and enable SRIOV only for physical\n\t\t * devices.  Try to claim ownership on the device;\n\t\t * if already taken, skip -- do not allow multiple PFs */\n\t\terr = mlx4_get_ownership(dev);\n\t\tif (err) {\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\telse {\n\t\t\t\tmlx4_warn(dev, "Multiple PFs not yet supported - Skipping PF\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tatomic_set(&priv->opreq_count, 0);\n\t\tINIT_WORK(&priv->opreq_task, mlx4_opreq_action);\n\n\t\t/*\n\t\t * Now reset the HCA before we touch the PCI capabilities or\n\t\t * attempt a firmware command, since a boot ROM may have left\n\t\t * the HCA in an undefined state.\n\t\t */\n\t\terr = mlx4_reset(dev);\n\t\tif (err) {\n\t\t\tmlx4_err(dev, "Failed to reset HCA, aborting\\n");\n\t\t\tgoto err_sriov;\n\t\t}\n\n\t\tif (total_vfs) {\n\t\t\tdev->flags = MLX4_FLAG_MASTER;\n\t\t\texisting_vfs = pci_num_vf(pdev);\n\t\t\tif (existing_vfs)\n\t\t\t\tdev->flags |= MLX4_FLAG_SRIOV;\n\t\t\tdev->persist->num_vfs = total_vfs;\n\t\t}\n\t}\n\n\t/* on load remove any previous indication of internal error,\n\t * device is up.\n\t */\n\tdev->persist->state = MLX4_DEVICE_STATE_UP;\n\nslave_start:\n\terr = mlx4_cmd_init(dev);\n\tif (err) {\n\t\tmlx4_err(dev, "Failed to init command interface, aborting\\n");\n\t\tgoto err_sriov;\n\t}\n\n\t/* In slave functions, the communication channel must be initialized\n\t * before posting commands. Also, init num_slaves before calling\n\t * mlx4_init_hca */\n\tif (mlx4_is_mfunc(dev)) {\n\t\tif (mlx4_is_master(dev)) {\n\t\t\tdev->num_slaves = MLX4_MAX_NUM_SLAVES;\n\n\t\t} else {\n\t\t\tdev->num_slaves = 0;\n\t\t\terr = mlx4_multi_func_init(dev);\n\t\t\tif (err) {\n\t\t\t\tmlx4_err(dev, "Failed to init slave mfunc interface, aborting\\n");\n\t\t\t\tgoto err_cmd;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = mlx4_init_fw(dev);\n\tif (err) {\n\t\tmlx4_err(dev, "Failed to init fw, aborting.\\n");\n\t\tgoto err_mfunc;\n\t}\n\n\tif (mlx4_is_master(dev)) {\n\t\t/* when we hit the goto slave_start below, dev_cap already initialized */\n\t\tif (!dev_cap) {\n\t\t\tdev_cap = kzalloc(sizeof(*dev_cap), GFP_KERNEL);\n\n\t\t\tif (!dev_cap) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_fw;\n\t\t\t}\n\n\t\t\terr = mlx4_QUERY_DEV_CAP(dev, dev_cap);\n\t\t\tif (err) {\n\t\t\t\tmlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\\n");\n\t\t\t\tgoto err_fw;\n\t\t\t}\n\n\t\t\tif (mlx4_check_dev_cap(dev, dev_cap, nvfs))\n\t\t\t\tgoto err_fw;\n\n\t\t\tif (!(dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_SYS_EQS)) {\n\t\t\t\tu64 dev_flags = mlx4_enable_sriov(dev, pdev,\n\t\t\t\t\t\t\t\t  total_vfs,\n\t\t\t\t\t\t\t\t  existing_vfs,\n\t\t\t\t\t\t\t\t  reset_flow);\n\n\t\t\t\tmlx4_close_fw(dev);\n\t\t\t\tmlx4_cmd_cleanup(dev, MLX4_CMD_CLEANUP_ALL);\n\t\t\t\tdev->flags = dev_flags;\n\t\t\t\tif (!SRIOV_VALID_STATE(dev->flags)) {\n\t\t\t\t\tmlx4_err(dev, "Invalid SRIOV state\\n");\n\t\t\t\t\tgoto err_sriov;\n\t\t\t\t}\n\t\t\t\terr = mlx4_reset(dev);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx4_err(dev, "Failed to reset HCA, aborting.\\n");\n\t\t\t\t\tgoto err_sriov;\n\t\t\t\t}\n\t\t\t\tgoto slave_start;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Legacy mode FW requires SRIOV to be enabled before\n\t\t\t * doing QUERY_DEV_CAP, since max_eq's value is different if\n\t\t\t * SRIOV is enabled.\n\t\t\t */\n\t\t\tmemset(dev_cap, 0, sizeof(*dev_cap));\n\t\t\terr = mlx4_QUERY_DEV_CAP(dev, dev_cap);\n\t\t\tif (err) {\n\t\t\t\tmlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\\n");\n\t\t\t\tgoto err_fw;\n\t\t\t}\n\n\t\t\tif (mlx4_check_dev_cap(dev, dev_cap, nvfs))\n\t\t\t\tgoto err_fw;\n\t\t}\n\t}\n\n\terr = mlx4_init_hca(dev);\n\tif (err) {\n\t\tif (err == -EACCES) {\n\t\t\t/* Not primary Physical function\n\t\t\t * Running in slave mode */\n\t\t\tmlx4_cmd_cleanup(dev, MLX4_CMD_CLEANUP_ALL);\n\t\t\t/* We're not a PF */\n\t\t\tif (dev->flags & MLX4_FLAG_SRIOV) {\n\t\t\t\tif (!existing_vfs)\n\t\t\t\t\tpci_disable_sriov(pdev);\n\t\t\t\tif (mlx4_is_master(dev) && !reset_flow)\n\t\t\t\t\tatomic_dec(&pf_loading);\n\t\t\t\tdev->flags &= ~MLX4_FLAG_SRIOV;\n\t\t\t}\n\t\t\tif (!mlx4_is_slave(dev))\n\t\t\t\tmlx4_free_ownership(dev);\n\t\t\tdev->flags |= MLX4_FLAG_SLAVE;\n\t\t\tdev->flags &= ~MLX4_FLAG_MASTER;\n\t\t\tgoto slave_start;\n\t\t} else\n\t\t\tgoto err_fw;\n\t}\n\n\tif (mlx4_is_master(dev) && (dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_SYS_EQS)) {\n\t\tu64 dev_flags = mlx4_enable_sriov(dev, pdev, total_vfs,\n\t\t\t\t\t\t  existing_vfs, reset_flow);\n\n\t\tif ((dev->flags ^ dev_flags) & (MLX4_FLAG_MASTER | MLX4_FLAG_SLAVE)) {\n\t\t\tmlx4_cmd_cleanup(dev, MLX4_CMD_CLEANUP_VHCR);\n\t\t\tdev->flags = dev_flags;\n\t\t\terr = mlx4_cmd_init(dev);\n\t\t\tif (err) {\n\t\t\t\t/* Only VHCR is cleaned up, so could still\n\t\t\t\t * send FW commands\n\t\t\t\t */\n\t\t\t\tmlx4_err(dev, "Failed to init VHCR command interface, aborting\\n");\n\t\t\t\tgoto err_close;\n\t\t\t}\n\t\t} else {\n\t\t\tdev->flags = dev_flags;\n\t\t}\n\n\t\tif (!SRIOV_VALID_STATE(dev->flags)) {\n\t\t\tmlx4_err(dev, "Invalid SRIOV state\\n");\n\t\t\tgoto err_close;\n\t\t}\n\t}\n\n\t/* check if the device is functioning at its maximum possible speed.\n\t * No return code for this call, just warn the user in case of PCI\n\t * express device capabilities are under-satisfied by the bus.\n\t */\n\tif (!mlx4_is_slave(dev))\n\t\tmlx4_check_pcie_caps(dev);\n\n\t/* In master functions, the communication channel must be initialized\n\t * after obtaining its address from fw */\n\tif (mlx4_is_master(dev)) {\n\t\tif (dev->caps.num_ports < 2 &&\n\t\t    num_vfs_argc > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tmlx4_err(dev,\n\t\t\t\t "Error: Trying to configure VFs on port 2, but HCA has only %d physical ports\\n",\n\t\t\t\t dev->caps.num_ports);\n\t\t\tgoto err_close;\n\t\t}\n\t\tmemcpy(dev->persist->nvfs, nvfs, sizeof(dev->persist->nvfs));\n\n\t\tfor (i = 0;\n\t\t     i < sizeof(dev->persist->nvfs)/\n\t\t     sizeof(dev->persist->nvfs[0]); i++) {\n\t\t\tunsigned j;\n\n\t\t\tfor (j = 0; j < dev->persist->nvfs[i]; ++sum, ++j) {\n\t\t\t\tdev->dev_vfs[sum].min_port = i < 2 ? i + 1 : 1;\n\t\t\t\tdev->dev_vfs[sum].n_ports = i < 2 ? 1 :\n\t\t\t\t\tdev->caps.num_ports;\n\t\t\t}\n\t\t}\n\n\t\t/* In master functions, the communication channel\n\t\t * must be initialized after obtaining its address from fw\n\t\t */\n\t\terr = mlx4_multi_func_init(dev);\n\t\tif (err) {\n\t\t\tmlx4_err(dev, "Failed to init master mfunc interface, aborting.\\n");\n\t\t\tgoto err_close;\n\t\t}\n\t}\n\n\terr = mlx4_alloc_eq_table(dev);\n	t
57869	149	squashfs_xattr_get	fs/squashfs/xattr.c	prefix	1	11	\N	\N	\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n	t
57335	2516	snd_cs46xx_mixer	sound/pci/cs46xx/cs46xx_lib.c	kctl	1	-11	\N	\N	\tstruct snd_card *card = chip->card;\n\tstruct snd_ctl_elem_id id;\n\tint err;\n\tunsigned int idx;\n\tstatic struct snd_ac97_bus_ops ops = {\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\t.reset = snd_cs46xx_codec_reset,\n#endif\n\t\t.write = snd_cs46xx_ac97_write,\n\t\t.read = snd_cs46xx_ac97_read,\n\t};\n\n\t/* detect primary codec */\n\tchip->nr_ac97_codecs = 0;\n\tdev_dbg(chip->card->dev, "detecting primary codec\\n");\n\tif ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)\n\t\treturn err;\n\tchip->ac97_bus->private_free = snd_cs46xx_mixer_free_ac97_bus;\n\n\tif (cs46xx_detect_codec(chip, CS46XX_PRIMARY_CODEC_INDEX) < 0)\n\t\treturn -ENXIO;\n\tchip->nr_ac97_codecs = 1;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tdev_dbg(chip->card->dev, "detecting secondary codec\\n");\n\t/* try detect a secondary codec */\n\tif (! cs46xx_detect_codec(chip, CS46XX_SECONDARY_CODEC_INDEX))\n\t\tchip->nr_ac97_codecs = 2;\n#endif /* CONFIG_SND_CS46XX_NEW_DSP */\n\n\t/* add cs4630 mixer controls */\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs46xx_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(&snd_cs46xx_controls[idx], chip);\n\t\tif (kctl && kctl->id.iface == SNDRV_CTL_ELEM_IFACE_PCM)\n	t
21032	597	acpi_processor_get_tsd	drivers/acpi/processor_throttling.c	status	1	11	\N	\N	\tint result = 0;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };\n\tstruct acpi_buffer state = { 0, NULL };\n\tunion acpi_object *tsd = NULL;\n\tstruct acpi_tsd_package *pdomain;\n\tstruct acpi_processor_throttling *pthrottling;\n\n\tpthrottling = &pr->throttling;\n\tpthrottling->tsd_valid_flag = 0;\n\n\tstatus = acpi_evaluate_object(pr->handle, "_TSD", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n	t
53094	1071	mtk_jpeg_clk_init	drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c	node	2	-11	\N	\N	\tstruct device_node *node;\n\tstruct platform_device *pdev;\n\n\tnode = of_parse_phandle(jpeg->dev->of_node, "mediatek,larb", 0);\n\tif (!node)\n	t
28820	652	si2165_init	drivers/media/dvb-frontends/si2165.c	patch_version	2	-11	\N	\N	\tint ret = 0;\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tu8 val;\n\tu8 patch_version = 0x00;\n\n\tdprintk("%s: called\\n", __func__);\n\n\t/* powerup */\n\tret = si2165_writereg8(state, 0x0000, state->config.chip_mode);\n\tif (ret < 0)\n\t\tgoto error;\n\t/* dsp_clock_enable */\n\tret = si2165_writereg8(state, 0x0104, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_readreg8(state, 0x0000, &val); /* verify chip_mode */\n\tif (ret < 0)\n\t\tgoto error;\n\tif (val != state->config.chip_mode) {\n\t\tdev_err(&state->client->dev, "%s: could not set chip_mode\\n",\n\t\t\tKBUILD_MODNAME);\n\t\treturn -EINVAL;\n\t}\n\n\t/* agc */\n\tret = si2165_writereg8(state, 0x018b, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, 0x0190, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, 0x0170, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, 0x0171, 0x07);\n\tif (ret < 0)\n\t\tgoto error;\n\t/* rssi pad */\n\tret = si2165_writereg8(state, 0x0646, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, 0x0641, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_init_pll(state);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* enable chip_init */\n\tret = si2165_writereg8(state, 0x0050, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\t/* set start_init */\n\tret = si2165_writereg8(state, 0x0096, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_wait_init_done(state);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* disable chip_init */\n\tret = si2165_writereg8(state, 0x0050, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ber_pkt */\n\tret = si2165_writereg16(state, 0x0470, 0x7530);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_readreg8(state, 0x0344, &patch_version);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_writereg8(state, 0x00cb, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* dsp_addr_jump */\n\tret = si2165_writereg32(state, 0x0348, 0xf4000000);\n\tif (ret < 0)\n\t\tgoto error;\n\t/* boot/wdog status */\n\tret = si2165_readreg8(state, 0x0341, &val);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (patch_version == 0x00) {\n	t
46511	945	prism54_get_rts	drivers/net/wireless/intersil/prism54/isl_ioctl.c	&r	6	12	\N	\N	\tislpci_private *priv = netdev_priv(ndev);\n\tunion oid_res_t r;\n\tint rvalue;\n\n\t/* get the rts threshold */\n\trvalue = mgt_get_request(priv, DOT11_OID_RTSTHRESH, 0, NULL, &r);\n	t
4614	3232	clear_caseopen	drivers/hwmon/nct6775.c	val	1	11	\N	\N	\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(attr)->index - INTRUSION_ALARM_BASE;\n\tunsigned long val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val) || val != 0)\n	t
42280	8552	bnx2x_set_int_mode	drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c	rc	1	13	\N	\N	\tint rc = 0;\n\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR("VF not loaded since interrupt mode not msix\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\t/* attempt to enable msix */\n\t\trc = bnx2x_enable_msix(bp);\n\n\t\t/* msix attained */\n\t\tif (!rc)\n	f
47461	2730	key_notify_policy_flush	net/key/af_key.c	skb_out	1	13	\N	\N	\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb_out, sizeof(struct sadb_msg));\n	f
44112	1643	broadcast_state_change	drivers/block/drbd/drbd_state.c	NOTIFY_CHANGE	0	11	\N	\N	\tstruct drbd_resource_state_change *resource_state_change = &state_change->resource[0];\n\tbool resource_state_has_changed;\n\tunsigned int n_device, n_connection, n_peer_device, n_peer_devices;\n\tvoid (*last_func)(struct sk_buff *, unsigned int, void *,\n\t\t\t  enum drbd_notification_type) = NULL;\n\tvoid *uninitialized_var(last_arg);\n\n#define HAS_CHANGED(state) ((state)[OLD] != (state)[NEW])\n#define FINAL_STATE_CHANGE(type) \\\n\t({ if (last_func) \\\n\t\tlast_func(NULL, 0, last_arg, type); \\\n\t})\n#define REMEMBER_STATE_CHANGE(func, arg, type) \\\n\t({ FINAL_STATE_CHANGE(type | NOTIFY_CONTINUES); \\\n\t   last_func = (typeof(last_func))func; \\\n\t   last_arg = arg; \\\n\t })\n\n\tmutex_lock(&notification_mutex);\n\n\tresource_state_has_changed =\n\t    HAS_CHANGED(resource_state_change->role) ||\n\t    HAS_CHANGED(resource_state_change->susp) ||\n\t    HAS_CHANGED(resource_state_change->susp_nod) ||\n\t    HAS_CHANGED(resource_state_change->susp_fen);\n\n\tif (resource_state_has_changed)\n\t\tREMEMBER_STATE_CHANGE(notify_resource_state_change,\n	f
45152	705	hns_nic_poll_rx_skb	drivers/net/ethernet/hisilicon/hns/hns_enet.c	bnum	0	11	\N	\N	\tstruct hnae_ring *ring = ring_data->ring;\n\tstruct net_device *ndev = ring_data->napi.dev;\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tstruct hnae_desc *desc;\n\tstruct hnae_desc_cb *desc_cb;\n\tunsigned char *va;\n\tint bnum, length, i;\n\tint pull_len;\n\tu32 bnum_flag;\n\n\tdesc = &ring->desc[ring->next_to_clean];\n\tdesc_cb = &ring->desc_cb[ring->next_to_clean];\n\n\tprefetch(desc);\n\n\tva = (unsigned char *)desc_cb->buf + desc_cb->page_offset;\n\n\t/* prefetch first cache line of first page */\n\tprefetch(va);\n#if L1_CACHE_BYTES < 128\n\tprefetch(va + L1_CACHE_BYTES);\n#endif\n\n\tskb = *out_skb = napi_alloc_skb(&ring_data->napi,\n\t\t\t\t\tHNS_RX_HEAD_SIZE);\n\tif (unlikely(!skb)) {\n\t\tnetdev_err(ndev, "alloc rx skb fail\\n");\n\t\tring->stats.sw_err_cnt++;\n\t\treturn -ENOMEM;\n\t}\n\n\tprefetchw(skb->data);\n\tlength = le16_to_cpu(desc->rx.pkt_len);\n\tbnum_flag = le32_to_cpu(desc->rx.ipoff_bnum_pid_flag);\n\tpriv->ops.get_rxd_bnum(bnum_flag, &bnum);\n\t*out_bnum = bnum;\n\n\tif (length <= HNS_RX_HEAD_SIZE) {\n\t\tmemcpy(__skb_put(skb, length), va, ALIGN(length, sizeof(long)));\n\n\t\t/* we can reuse buffer as-is, just make sure it is local */\n\t\tif (likely(page_to_nid(desc_cb->priv) == numa_node_id()))\n\t\t\tdesc_cb->reuse_flag = 1;\n\t\telse /* this page cannot be reused so discard it */\n\t\t\tput_page(desc_cb->priv);\n\n\t\tring_ptr_move_fw(ring, next_to_clean);\n\n\t\tif (unlikely(bnum != 1)) { /* check err*/\n\t\t\t*out_bnum = 1;\n\t\t\tgoto out_bnum_err;\n\t\t}\n\t} else {\n\t\tring->stats.seg_pkt_cnt++;\n\n\t\tpull_len = hns_nic_get_headlen(va, bnum_flag, HNS_RX_HEAD_SIZE);\n\t\tmemcpy(__skb_put(skb, pull_len), va,\n\t\t       ALIGN(pull_len, sizeof(long)));\n\n\t\thns_nic_reuse_page(skb, 0, ring, pull_len, desc_cb);\n\t\tring_ptr_move_fw(ring, next_to_clean);\n\n\t\tif (unlikely(bnum >= (int)MAX_SKB_FRAGS)) { /* check err*/\n	f
58112	5366	nfsd4_delegreturn	fs/nfsd/nfs4state.c	nfsd4_delegreturn_$dp$obj	0	13	\N	\N	\tstruct nfsd4_delegreturn *dr = &u->delegreturn;\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = check_stateid_generation(stateid, &dp->dl_stid.sc_stateid, nfsd4_has_session(cstate));\n	f
4380	938	store_no_turbo	drivers/cpufreq/intel_pstate.c	store_no_turbo_$__UNIQUE_ID_min1_242$obj	0	21	\N	\N	\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, "%u", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tupdate_turbo_state();\n\tif (global.turbo_disabled) {\n\t\tpr_warn("Turbo disabled by BIOS or unavailable on processor\\n");\n\t\tmutex_unlock(&intel_pstate_limits_lock);\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EPERM;\n\t}\n\n\tglobal.no_turbo = clamp_t(int, input, 0, 1);\n	t
36038	1276	get_version	drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c	get_version_$rmsg$obj$6	0	13	\N	\N	\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tVCHI_HELD_MSG_T rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_GET_VERSION;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.version),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t/* got an unexpected message type in reply */\n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\t*major_out = rmsg->u.version.major;\n	f
25330	757	build_map_info	kernel/events/uprobes.c	build_map_info_$info$obj	0	11	\N	\N	\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n	t
54271	1109	ext4_htree_fill_tree	fs/ext4/namei.c	frames	7	12	\N	\N	\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\tstruct fscrypt_str tmp_str;\n\n\tdxtrace(printk(KERN_DEBUG "In htree_fill_tree, start hash: %x:%x\\n",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = htree_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t\t&hinfo, start_hash,\n\t\t\t\t\t\t\tstart_minor_hash,\n\t\t\t\t\t\t\t&has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n	t
23959	1027	gb_lights_light_config	drivers/staging/greybus/light.c	conf.channel_count	1	11	\N	\N	\tstruct gb_light *light = &glights->lights[id];\n\tstruct gb_lights_get_light_config_request req;\n\tstruct gb_lights_get_light_config_response conf;\n\tint ret;\n\tint i;\n\n\tlight->glights = glights;\n\tlight->id = id;\n\n\treq.id = id;\n\n\tret = gb_operation_sync(glights->connection,\n\t\t\t\tGB_LIGHTS_TYPE_GET_LIGHT_CONFIG,\n\t\t\t\t&req, sizeof(req), &conf, sizeof(conf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!conf.channel_count)\n	t
25499	364	sdio_writeN	drivers/staging/rtl8723bs/hal/sdio_ops.c	bMacPwrCtrlOn	1	11	\N	\N	\tstruct adapter *padapter;\n\tu8 bMacPwrCtrlOn;\n\tu8 deviceId;\n\tu16 offset;\n\tu32 ftaddr;\n\tu8 shift;\n\ts32 err;\n\n\tpadapter = pintfhdl->padapter;\n\terr = 0;\n\n\tftaddr = _cvrt2ftaddr(addr, &deviceId, &offset);\n\n\trtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\n\tif (\n\t\t((deviceId == WLAN_IOREG_DEVICE_ID) && (offset < 0x100)) ||\n\t\t(false == bMacPwrCtrlOn) ||\n	t
32861	325	btmrvl_sdio_get_rx_unit	drivers/bluetooth/btmrvl_sdio.c	ret	1	11	\N	\N	\tu8 reg;\n\tint ret;\n\n\treg = sdio_readb(card->func, card->reg->card_rx_unit, &ret);\n\tif (!ret)\n	t
27456	768	max3421_select_and_start_urb	drivers/usb/host/max3421-hcd.c	ep->desc	0	11	\N	\N	\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum, force_toggles = 0;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\t\t\turb = NULL;\n\t\t\tmax3421_ep = container_of(pos, struct max3421_ep,\n\t\t\t\t\t\t  ep_list);\n\t\t\tep = max3421_ep->ep;\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_NON_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (list_empty(&ep->urb_list))\n\t\t\t\tcontinue;\t/* nothing to do */\n\t\t\turb = list_first_entry(&ep->urb_list, struct urb,\n\t\t\t\t\t       urb_list);\n\t\t\tif (urb->unlinked) {\n\t\t\t\tdev_dbg(&spi->dev, "%s: URB %p unlinked=%d",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tmax3421_hcd->curr_urb = urb;\n\t\t\t\tmax3421_hcd->urb_done = 1;\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\t\t/*\n\t\t\t\t * Allow one control transaction per\n\t\t\t\t * frame per endpoint:\n\t\t\t\t */\n\t\t\t\tif (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t       max3421_hcd->frame_number) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_ep->retransmit\n\t\t\t\t    && (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t\t   max3421_hcd->frame_number)\n\t\t\t\t\t== 0))\n\t\t\t\t\t/*\n\t\t\t\t\t * We already tried this EP\n\t\t\t\t\t * during this frame and got a\n\t\t\t\t\t * NAK or error; wait for next frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (frame_diff(max3421_hcd->frame_number,\n\t\t\t\t\t       max3421_ep->last_active)\n\t\t\t\t    < urb->interval)\n\t\t\t\t\t/*\n\t\t\t\t\t * We already processed this\n\t\t\t\t\t * end-point in the current\n\t\t\t\t\t * frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* move current ep to tail: */\n\t\t\tlist_move_tail(pos, &max3421_hcd->ep_list);\n\t\t\tcurr_urb = urb;\n\t\t\tgoto done;\n\t\t}\ndone:\n\tif (!curr_urb) {\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\treturn 0;\n\t}\n\n\turb = max3421_hcd->curr_urb = curr_urb;\n\tepnum = usb_endpoint_num(&urb->ep->desc);\n\tif (max3421_ep->retransmit)\n\t\t/* restart (part of) a USB transaction: */\n\t\tmax3421_ep->retransmit = 0;\n\telse {\n\t\t/* start USB transaction: */\n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n	f
21632	189	configure_kgdboc	drivers/tty/serial/kgdboc.c	idx	0	11	\N	\N	\tstruct tty_driver *p;\n\tint tty_line = 0;\n\tint err;\n\tchar *cptr = config;\n\tstruct console *cons;\n\n\terr = kgdboc_option_setup(config);\n\tif (err || !strlen(config) || isspace(config[0]))\n\t\tgoto noconfig;\n\n\terr = -ENODEV;\n\tkgdboc_io_ops.is_console = 0;\n\tkgdb_tty_driver = NULL;\n\n\tkgdboc_use_kms = 0;\n\tif (strncmp(cptr, "kms,", 4) == 0) {\n\t\tcptr += 4;\n\t\tkgdboc_use_kms = 1;\n\t}\n\n\tif (kgdboc_register_kbd(&cptr))\n\t\tgoto do_register;\n\n\tp = tty_find_polling_driver(cptr, &tty_line);\n\tif (!p)\n\t\tgoto noconfig;\n\n\tcons = console_drivers;\n\twhile (cons) {\n\t\tint idx;\n\t\tif (cons->device && cons->device(cons, &idx) == p &&\n\t\t    idx == tty_line) {\n	f
21254	167	twl4030_clear_set	drivers/power/supply/twl4030_charger.c	ret	1	13	\N	\N	\tu8 val = 0;\n\tint ret;\n\n\tret = twl_i2c_read_u8(mod_no, &val, reg);\n\tif (ret)\n	f
102808	136	fetch_deref_u32	kernel/trace/trace_probe.c	fetch_deref_u32_$addr$obj	0	11	\N	\N	\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_printf(s, " %s=(fault)", name);\n\telse\n\t\ttrace_seq_printf(s, " %s=\\"%s\\"", name,\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}\nNOKPROBE_SYMBOL(PRINT_TYPE_FUNC_NAME(string));\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = "\\\\\\"%s\\\\\\"";\n\n#define CHECK_FETCH_FUNCS(method, fn)\t\t\t\\\n\t(((FETCH_FUNC_NAME(method, u8) == fn) ||\t\\\n\t  (FETCH_FUNC_NAME(method, u16) == fn) ||\t\\\n\t  (FETCH_FUNC_NAME(method, u32) == fn) ||\t\\\n\t  (FETCH_FUNC_NAME(method, u64) == fn) ||\t\\\n\t  (FETCH_FUNC_NAME(method, string) == fn) ||\t\\\n\t  (FETCH_FUNC_NAME(method, string_size) == fn)) \\\n\t && (fn != NULL))\n\n/* Data fetch function templates */\n#define DEFINE_FETCH_reg(type)\t\t\t\t\t\t\\\nvoid FETCH_FUNC_NAME(reg, type)(struct pt_regs *regs, void *offset, void *dest)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t*(type *)dest = (type)regs_get_register(regs,\t\t\t\\\n\t\t\t\t(unsigned int)((unsigned long)offset));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nNOKPROBE_SYMBOL(FETCH_FUNC_NAME(reg, type));\nDEFINE_BASIC_FETCH_FUNCS(reg)\n/* No string on the register */\n#define fetch_reg_string\tNULL\n#define fetch_reg_string_size\tNULL\n\n#define DEFINE_FETCH_retval(type)\t\t\t\t\t\\\nvoid FETCH_FUNC_NAME(retval, type)(struct pt_regs *regs,\t\t\\\n\t\t\t\t   void *dummy, void *dest)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t*(type *)dest = (type)regs_return_value(regs);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nNOKPROBE_SYMBOL(FETCH_FUNC_NAME(retval, type));\nDEFINE_BASIC_FETCH_FUNCS(retval)\n/* No string on the retval */\n#define fetch_retval_string\t\tNULL\n#define fetch_retval_string_size\tNULL\n\n/* Dereference memory access function */\nstruct deref_fetch_param {\n\tstruct fetch_param\torig;\n\tlong\t\t\toffset;\n\tfetch_func_t\t\tfetch;\n\tfetch_func_t\t\tfetch_size;\n};\n\n#define DEFINE_FETCH_deref(type)\t\t\t\t\t\\\nvoid FETCH_FUNC_NAME(deref, type)(struct pt_regs *regs,\t\t\t\\\n\t\t\t\t  void *data, void *dest)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct deref_fetch_param *dprm = data;\t\t\t\t\\\n\tunsigned long addr;\t\t\t\t\t\t\\\n\tcall_fetch(&dprm->orig, regs, &addr);\t\t\t\t\\\n\tif (addr) {\t\t\t\t\t\t\t\\\n\t\taddr += dprm->offset;\t\t\t\t\t\\\n\t\tdprm->fetch(regs, (void *)addr, dest);\t\t\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t*(type *)dest = 0;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nNOKPROBE_SYMBOL(FETCH_FUNC_NAME(deref, type));\nDEFINE_BASIC_FETCH_FUNCS(deref)\n	t
25691	909	blk_mq_debugfs_register_hctxs	block/blk-mq-debugfs.c	hctx)	1	11	\N	\N	\tstruct blk_mq_hw_ctx *hctx;\n\tint i;\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (blk_mq_debugfs_register_hctx(q, hctx))\n	t
497	1172	assoc_array_delete	lib/assoc_array.c	assoc_array_delete_$node$obj$3	0	11	\N	\N	\tstruct assoc_array_delete_collapse_context collapse;\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_node *node, *new_n0;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *ptr;\n\tbool has_meta;\n\tint slot, i;\n\n\tpr_devel("-->%s()\\n", __func__);\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->adjust_count_by = -1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_found_terminal_node:\n\t\t/* We found a node that should contain the leaf we've been\n\t\t * asked to remove - *if* it's in the tree.\n\t\t */\n\t\tpr_devel("terminal_node\\n");\n\t\tnode = result.terminal_node.node;\n\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\t\tptr = node->slots[slot];\n\t\t\tif (ptr &&\n\t\t\t    assoc_array_ptr_is_leaf(ptr) &&\n\t\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\tindex_key))\n\t\t\t\tgoto found_leaf;\n\t\t}\n\tcase assoc_array_walk_tree_empty:\n\tcase assoc_array_walk_found_wrong_shortcut:\n\tdefault:\n\t\tassoc_array_cancel_edit(edit);\n\t\tpr_devel("not found\\n");\n\t\treturn NULL;\n\t}\n\nfound_leaf:\n\tBUG_ON(array->nr_leaves_on_tree <= 0);\n\n\t/* In the simplest form of deletion we just clear the slot and release\n\t * the leaf after a suitable interval.\n\t */\n\tedit->dead_leaf = node->slots[slot];\n\tedit->set[0].ptr = &node->slots[slot];\n\tedit->set[0].to = NULL;\n\tedit->adjust_count_on = node;\n\n\t/* If that concludes erasure of the last leaf, then delete the entire\n\t * internal array.\n\t */\n\tif (array->nr_leaves_on_tree == 1) {\n\t\tedit->set[1].ptr = &array->root;\n\t\tedit->set[1].to = NULL;\n\t\tedit->adjust_count_on = NULL;\n\t\tedit->excised_subtree = array->root;\n\t\tpr_devel("all gone\\n");\n\t\treturn edit;\n\t}\n\n\t/* However, we'd also like to clear up some metadata blocks if we\n\t * possibly can.\n\t *\n\t * We go for a simple algorithm of: if this node has FAN_OUT or fewer\n\t * leaves in it, then attempt to collapse it - and attempt to\n\t * recursively collapse up the tree.\n\t *\n\t * We could also try and collapse in partially filled subtrees to take\n\t * up space in this node.\n\t */\n\tif (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n	t
50555	1233	ucma_set_ib_path	drivers/infiniband/core/ucma.c	&opa	6	12	\N	\N	\tstruct sa_path_rec sa_path;\n\tstruct rdma_cm_event event;\n\tint ret;\n\n\tif (optlen % sizeof(*path_data))\n\t\treturn -EINVAL;\n\n\tfor (; optlen; optlen -= sizeof(*path_data), path_data++) {\n\t\tif (path_data->flags == (IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t IB_PATH_BIDIRECTIONAL))\n\t\t\tbreak;\n\t}\n\n\tif (!optlen)\n\t\treturn -EINVAL;\n\n\tmemset(&sa_path, 0, sizeof(sa_path));\n\n\tsa_path.rec_type = SA_PATH_REC_TYPE_IB;\n\tib_sa_unpack_path(path_data->path_rec, &sa_path);\n\n\tif (rdma_cap_opa_ah(ctx->cm_id->device, ctx->cm_id->port_num)) {\n\t\tstruct sa_path_rec opa;\n\n\t\tsa_convert_path_ib_to_opa(&opa, &sa_path);\n	t
22098	487	nf_ct_expect_iterate_destroy	net/netfilter/nf_conntrack_expect.c	nf_ct_expect_iterate_destroy_$__mptr14$obj	0	13	\N	\N	\tstruct nf_conntrack_expect *exp;\n\tconst struct hlist_node *next;\n\tunsigned int i;\n\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\n\tfor (i = 0; i < nf_ct_expect_hsize; i++) {\n\t\thlist_for_each_entry_safe(exp, next,\n	f
59315	1170	write_file_tpc	drivers/net/wireless/ath/ath9k/debug.c	val	1	13	\N	\N	\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned long val;\n\tchar buf[32];\n\tssize_t len;\n\tbool tpc_enabled;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val < 0 || val > 1)\n	f
45917	544	mt9m111_s_ctrl	drivers/media/usb/gspca/m5602/m5602_mt9m111.c	err	1	11	\N	\N	\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\terr = mt9m111_set_auto_white_balance(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n	t
51082	280	create_default_filesystem	fs/ubifs/sb.c	&key	1	11	\N	\N	\tstruct ubifs_sb_node *sup;\n\tstruct ubifs_mst_node *mst;\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_branch *br;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_cs_node *cs;\n\tunion ubifs_key key;\n\tint err, tmp, jnl_lebs, log_lebs, max_buds, main_lebs, main_first;\n\tint lpt_lebs, lpt_first, orph_lebs, big_lpt, ino_waste, sup_flags = 0;\n\tint min_leb_cnt = UBIFS_MIN_LEB_CNT;\n\tlong long tmp64, main_bytes;\n\t__le64 tmp_le64;\n\t__le32 tmp_le32;\n\tstruct timespec ts;\n\n\t/* Some functions called from here depend on the @c->key_len filed */\n\tc->key_len = UBIFS_SK_LEN;\n\n\t/*\n\t * First of all, we have to calculate default file-system geometry -\n\t * log size, journal size, etc.\n\t */\n\tif (c->leb_cnt < 0x7FFFFFFF / DEFAULT_JNL_PERCENT)\n\t\t/* We can first multiply then divide and have no overflow */\n\t\tjnl_lebs = c->leb_cnt * DEFAULT_JNL_PERCENT / 100;\n\telse\n\t\tjnl_lebs = (c->leb_cnt / 100) * DEFAULT_JNL_PERCENT;\n\n\tif (jnl_lebs < UBIFS_MIN_JNL_LEBS)\n\t\tjnl_lebs = UBIFS_MIN_JNL_LEBS;\n\tif (jnl_lebs * c->leb_size > DEFAULT_MAX_JNL)\n\t\tjnl_lebs = DEFAULT_MAX_JNL / c->leb_size;\n\n\t/*\n\t * The log should be large enough to fit reference nodes for all bud\n\t * LEBs. Because buds do not have to start from the beginning of LEBs\n\t * (half of the LEB may contain committed data), the log should\n\t * generally be larger, make it twice as large.\n\t */\n\ttmp = 2 * (c->ref_node_alsz * jnl_lebs) + c->leb_size - 1;\n\tlog_lebs = tmp / c->leb_size;\n\t/* Plus one LEB reserved for commit */\n\tlog_lebs += 1;\n\tif (c->leb_cnt - min_leb_cnt > 8) {\n\t\t/* And some extra space to allow writes while committing */\n\t\tlog_lebs += 1;\n\t\tmin_leb_cnt += 1;\n\t}\n\n\tmax_buds = jnl_lebs - log_lebs;\n\tif (max_buds < UBIFS_MIN_BUD_LEBS)\n\t\tmax_buds = UBIFS_MIN_BUD_LEBS;\n\n\t/*\n\t * Orphan nodes are stored in a separate area. One node can store a lot\n\t * of orphan inode numbers, but when new orphan comes we just add a new\n\t * orphan node. At some point the nodes are consolidated into one\n\t * orphan node.\n\t */\n\torph_lebs = UBIFS_MIN_ORPH_LEBS;\n\tif (c->leb_cnt - min_leb_cnt > 1)\n\t\t/*\n\t\t * For debugging purposes it is better to have at least 2\n\t\t * orphan LEBs, because the orphan subsystem would need to do\n\t\t * consolidations and would be stressed more.\n\t\t */\n\t\torph_lebs += 1;\n\n\tmain_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS - log_lebs;\n\tmain_lebs -= orph_lebs;\n\n\tlpt_first = UBIFS_LOG_LNUM + log_lebs;\n\tc->lsave_cnt = DEFAULT_LSAVE_CNT;\n\tc->max_leb_cnt = c->leb_cnt;\n\terr = ubifs_create_dflt_lpt(c, &main_lebs, lpt_first, &lpt_lebs,\n\t\t\t\t    &big_lpt);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen("LEB Properties Tree created (LEBs %d-%d)", lpt_first,\n\t\tlpt_first + lpt_lebs - 1);\n\n\tmain_first = c->leb_cnt - main_lebs;\n\n\t/* Create default superblock */\n\ttmp = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\tsup = kzalloc(tmp, GFP_KERNEL);\n\tif (!sup)\n\t\treturn -ENOMEM;\n\n\ttmp64 = (long long)max_buds * c->leb_size;\n\tif (big_lpt)\n\t\tsup_flags |= UBIFS_FLG_BIGLPT;\n\tsup_flags |= UBIFS_FLG_DOUBLE_HASH;\n\n\tsup->ch.node_type  = UBIFS_SB_NODE;\n\tsup->key_hash      = UBIFS_KEY_HASH_R5;\n\tsup->flags         = cpu_to_le32(sup_flags);\n\tsup->min_io_size   = cpu_to_le32(c->min_io_size);\n\tsup->leb_size      = cpu_to_le32(c->leb_size);\n\tsup->leb_cnt       = cpu_to_le32(c->leb_cnt);\n\tsup->max_leb_cnt   = cpu_to_le32(c->max_leb_cnt);\n\tsup->max_bud_bytes = cpu_to_le64(tmp64);\n\tsup->log_lebs      = cpu_to_le32(log_lebs);\n\tsup->lpt_lebs      = cpu_to_le32(lpt_lebs);\n\tsup->orph_lebs     = cpu_to_le32(orph_lebs);\n\tsup->jhead_cnt     = cpu_to_le32(DEFAULT_JHEADS_CNT);\n\tsup->fanout        = cpu_to_le32(DEFAULT_FANOUT);\n\tsup->lsave_cnt     = cpu_to_le32(c->lsave_cnt);\n\tsup->fmt_version   = cpu_to_le32(UBIFS_FORMAT_VERSION);\n\tsup->time_gran     = cpu_to_le32(DEFAULT_TIME_GRAN);\n\tif (c->mount_opts.override_compr)\n\t\tsup->default_compr = cpu_to_le16(c->mount_opts.compr_type);\n\telse\n\t\tsup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);\n\n\tgenerate_random_uuid(sup->uuid);\n\n\tmain_bytes = (long long)main_lebs * c->leb_size;\n\ttmp64 = div_u64(main_bytes * DEFAULT_RP_PERCENT, 100);\n\tif (tmp64 > DEFAULT_MAX_RP_SIZE)\n\t\ttmp64 = DEFAULT_MAX_RP_SIZE;\n\tsup->rp_size = cpu_to_le64(tmp64);\n\tsup->ro_compat_version = cpu_to_le32(UBIFS_RO_COMPAT_VERSION);\n\n\terr = ubifs_write_node(c, sup, UBIFS_SB_NODE_SZ, 0, 0);\n\tkfree(sup);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen("default superblock created at LEB 0:0");\n\n\t/* Create default master node */\n\tmst = kzalloc(c->mst_node_alsz, GFP_KERNEL);\n\tif (!mst)\n\t\treturn -ENOMEM;\n\n\tmst->ch.node_type = UBIFS_MST_NODE;\n\tmst->log_lnum     = cpu_to_le32(UBIFS_LOG_LNUM);\n\tmst->highest_inum = cpu_to_le64(UBIFS_FIRST_INO);\n\tmst->cmt_no       = 0;\n\tmst->root_lnum    = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->root_offs    = 0;\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tmst->root_len     = cpu_to_le32(tmp);\n\tmst->gc_lnum      = cpu_to_le32(main_first + DEFAULT_GC_LEB);\n\tmst->ihead_lnum   = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->ihead_offs   = cpu_to_le32(ALIGN(tmp, c->min_io_size));\n\tmst->index_size   = cpu_to_le64(ALIGN(tmp, 8));\n\tmst->lpt_lnum     = cpu_to_le32(c->lpt_lnum);\n\tmst->lpt_offs     = cpu_to_le32(c->lpt_offs);\n\tmst->nhead_lnum   = cpu_to_le32(c->nhead_lnum);\n\tmst->nhead_offs   = cpu_to_le32(c->nhead_offs);\n\tmst->ltab_lnum    = cpu_to_le32(c->ltab_lnum);\n\tmst->ltab_offs    = cpu_to_le32(c->ltab_offs);\n\tmst->lsave_lnum   = cpu_to_le32(c->lsave_lnum);\n\tmst->lsave_offs   = cpu_to_le32(c->lsave_offs);\n\tmst->lscan_lnum   = cpu_to_le32(main_first);\n\tmst->empty_lebs   = cpu_to_le32(main_lebs - 2);\n\tmst->idx_lebs     = cpu_to_le32(1);\n\tmst->leb_cnt      = cpu_to_le32(c->leb_cnt);\n\n\t/* Calculate lprops statistics */\n\ttmp64 = main_bytes;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\ttmp64 -= ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tmst->total_free = cpu_to_le64(tmp64);\n\n\ttmp64 = ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\tino_waste = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size) -\n\t\t\t  UBIFS_INO_NODE_SZ;\n\ttmp64 += ino_waste;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tmst->total_dirty = cpu_to_le64(tmp64);\n\n\t/*  The indexing LEB does not contribute to dark space */\n\ttmp64 = ((long long)(c->main_lebs - 1) * c->dark_wm);\n\tmst->total_dark = cpu_to_le64(tmp64);\n\n\tmst->total_used = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM, 0);\n\tif (err) {\n\t\tkfree(mst);\n\t\treturn err;\n\t}\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM + 1,\n\t\t\t       0);\n\tkfree(mst);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen("default master node created at LEB %d:0", UBIFS_MST_LNUM);\n\n\t/* Create the root indexing node */\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tidx = kzalloc(ALIGN(tmp, c->min_io_size), GFP_KERNEL);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\tc->key_fmt = UBIFS_SIMPLE_KEY_FMT;\n\tc->key_hash = key_r5_hash;\n\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(1);\n\tino_key_init(c, &key, UBIFS_ROOT_INO);\n	t
61965	2652	ipmr_rtm_route	net/ipv4/ipmr.c	&mfcc	1	13	\N	\N	\tstruct net *net = sock_net(skb->sk);\n\tint ret, mrtsock, parent;\n\tstruct mr_table *tbl;\n\tstruct mfcctl mfcc;\n\n\tmrtsock = 0;\n\ttbl = NULL;\n\tret = rtm_to_ipmr_mfcc(net, nlh, &mfcc, &mrtsock, &tbl, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tparent = ret ? mfcc.mfcc_parent : -1;\n\tif (nlh->nlmsg_type == RTM_NEWROUTE)\n\t\treturn ipmr_mfc_add(net, tbl, &mfcc, mrtsock, parent);\n	f
54840	368	s2mpa01_pmic_probe	drivers/regulator/s2mpa01.c	rdata	1	11	\N	\N	\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct sec_platform_data *pdata = dev_get_platdata(iodev->dev);\n\tstruct device_node *reg_np = NULL;\n\tstruct regulator_config config = { };\n\tstruct of_regulator_match *rdata;\n\tstruct s2mpa01_info *s2mpa01;\n\tint i;\n\n\ts2mpa01 = devm_kzalloc(&pdev->dev, sizeof(*s2mpa01), GFP_KERNEL);\n\tif (!s2mpa01)\n\t\treturn -ENOMEM;\n\n\trdata = s2mpa01->rdata;\n\tfor (i = 0; i < S2MPA01_REGULATOR_CNT; i++)\n\t\trdata[i].name = regulators[i].name;\n\n\tif (iodev->dev->of_node) {\n\t\treg_np = of_get_child_by_name(iodev->dev->of_node,\n\t\t\t\t\t\t\t"regulators");\n\t\tif (!reg_np) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"could not find regulators sub-node\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tof_regulator_match(&pdev->dev, reg_np, rdata,\n	t
63452	1177	ast_cursor_set	drivers/gpu/drm/ast/ast_mode.c	&uobj_map	1	13	\N	\N	\tstruct ast_private *ast = crtc->dev->dev_private;\n\tstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\n\tstruct drm_gem_object *obj;\n\tstruct ast_bo *bo;\n\tuint64_t gpu_addr;\n\tu32 csum;\n\tint ret;\n\tstruct ttm_bo_kmap_obj uobj_map;\n\tu8 *src, *dst;\n\tbool src_isiomem, dst_isiomem;\n\tif (!handle) {\n\t\tast_hide_cursor(crtc);\n\t\treturn 0;\n\t}\n\n\tif (width > AST_MAX_HWC_WIDTH || height > AST_MAX_HWC_HEIGHT)\n\t\treturn -EINVAL;\n\n\tobj = drm_gem_object_lookup(file_priv, handle);\n\tif (!obj) {\n\t\tDRM_ERROR("Cannot find cursor object %x for crtc\\n", handle);\n\t\treturn -ENOENT;\n\t}\n\tbo = gem_to_ast_bo(obj);\n\n\tret = ast_bo_reserve(bo, false);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &uobj_map);\n\n\tsrc = ttm_kmap_obj_virtual(&uobj_map, &src_isiomem);\n	f
36629	316	pcan_usb_get_serial	drivers/net/can/usb/peak_usb/pcan_usb.c	err	2	-11	\N	\N	\tu8 args[PCAN_USB_CMD_ARGS_LEN];\n\tint err;\n\n\terr = pcan_usb_wait_rsp(dev, 6, 1, args);\n\tif (err) {\n	t
881	785	bq2415x_set_mode	drivers/power/supply/bq2415x_charger.c	bq2415x_set_mode_$ret106$obj	0	11	\N	\N	\tint ret = 0;\n\tint charger = 0;\n\tint boost = 0;\n\n\tif (mode == BQ2415X_MODE_BOOST)\n\t\tboost = 1;\n\telse if (mode != BQ2415X_MODE_OFF)\n\t\tcharger = 1;\n\n\tif (!charger)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\n\n\tif (!boost)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mode) {\n\tcase BQ2415X_MODE_OFF:\n\t\tdev_dbg(bq->dev, "changing mode to: Offline\\n");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\tcase BQ2415X_MODE_NONE:\n\t\tdev_dbg(bq->dev, "changing mode to: N/A\\n");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\tcase BQ2415X_MODE_HOST_CHARGER:\n\t\tdev_dbg(bq->dev, "changing mode to: Host/HUB charger\\n");\n\t\tret = bq2415x_set_current_limit(bq, 500);\n\t\tbreak;\n\tcase BQ2415X_MODE_DEDICATED_CHARGER:\n\t\tdev_dbg(bq->dev, "changing mode to: Dedicated charger\\n");\n\t\tret = bq2415x_set_current_limit(bq, 1800);\n\t\tbreak;\n\tcase BQ2415X_MODE_BOOST: /* Boost mode */\n\t\tdev_dbg(bq->dev, "changing mode to: Boost\\n");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (charger)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGER_ENABLE);\n\telse if (boost)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_ENABLE);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbq2415x_set_default_value(bq, weak_battery_voltage);\n	t
3355	172	adp5520_store	drivers/video/backlight/adp5520_bl.c	val	1	13	\N	\N	\tstruct adp5520_bl *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->lock);\n\tadp5520_write(data->master, reg, val);\n	f
45938	785	wusb_dev_bos_add	drivers/usb/wusbcore/devconnect.c	result	1	11	\N	\N	\tssize_t result;\n\tstruct device *dev = &usb_dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tsize_t alloc_size = 32, desc_size = 4;\n\n\tbos = kmalloc(alloc_size, GFP_KERNEL);\n\tif (bos == NULL)\n\t\treturn -ENOMEM;\n\tresult = usb_get_descriptor(usb_dev, USB_DT_BOS, 0, bos, desc_size);\n\tif (result < 4) {\n	t
62429	1635	ovs_dp_cmd_new	net/openvswitch/datapath.c	reply	1	11	\N	\N	\tstruct nlattr **a = info->attrs;\n\tstruct vport_parms parms;\n\tstruct sk_buff *reply;\n\tstruct datapath *dp;\n\tstruct vport *vport;\n\tstruct ovs_net *ovs_net;\n\tint err, i;\n\n\terr = -EINVAL;\n\tif (!a[OVS_DP_ATTR_NAME] || !a[OVS_DP_ATTR_UPCALL_PID])\n\t\tgoto err;\n\n\treply = ovs_dp_cmd_alloc_info();\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\terr = -ENOMEM;\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (dp == NULL)\n\t\tgoto err_free_reply;\n\n\tovs_dp_set_net(dp, sock_net(skb->sk));\n\n\t/* Allocate table. */\n\terr = ovs_flow_tbl_init(&dp->table);\n\tif (err)\n\t\tgoto err_free_dp;\n\n\tdp->stats_percpu = netdev_alloc_pcpu_stats(struct dp_stats_percpu);\n\tif (!dp->stats_percpu) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_table;\n\t}\n\n\tdp->ports = kmalloc(DP_VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\n\t\t\t    GFP_KERNEL);\n\tif (!dp->ports) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_percpu;\n\t}\n\n\tfor (i = 0; i < DP_VPORT_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(&dp->ports[i]);\n\n\t/* Set up our datapath device. */\n\tparms.name = nla_data(a[OVS_DP_ATTR_NAME]);\n\tparms.type = OVS_VPORT_TYPE_INTERNAL;\n\tparms.options = NULL;\n\tparms.dp = dp;\n\tparms.port_no = OVSP_LOCAL;\n\tparms.upcall_portids = a[OVS_DP_ATTR_UPCALL_PID];\n\n\tovs_dp_change(dp, a);\n\n\t/* So far only local changes have been made, now need the lock. */\n\tovs_lock();\n\n\tvport = new_vport(&parms);\n\tif (IS_ERR(vport)) {\n\t\terr = PTR_ERR(vport);\n\t\tif (err == -EBUSY)\n\t\t\terr = -EEXIST;\n\n\t\tif (err == -EEXIST) {\n\t\t\t/* An outdated user space instance that does not understand\n\t\t\t * the concept of user_features has attempted to create a new\n\t\t\t * datapath and is likely to reuse it. Drop all user features.\n\t\t\t */\n\t\t\tif (info->genlhdr->version < OVS_DP_VER_FEATURES)\n\t\t\t\tovs_dp_reset_user_features(skb, info);\n\t\t}\n\n\t\tgoto err_destroy_ports_array;\n\t}\n\n\terr = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\n	t
62447	139	llc_sap_action_send_test_c	net/llc/llc_s_ac.c	skb	1	11	\N	\N	\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tint rc;\n\n\tllc_pdu_header_init(skb, LLC_PDU_TYPE_U, ev->saddr.lsap,\n\t\t\t    ev->daddr.lsap, LLC_PDU_CMD);\n\tllc_pdu_init_as_test_cmd(skb);\n\trc = llc_mac_hdr_init(skb, ev->saddr.mac, ev->daddr.mac);\n\tif (likely(!rc))\n\t\trc = dev_queue_xmit(skb);\n	f
40336	871	gru_set_context_option	drivers/misc/sgi-gru/grufault.c	req.op	1	11	\N	\N	\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, "op %d, gseg 0x%lx, value1 0x%lx\\n", req.op, req.gseg, req.val1);\n	t
5067	157	intel_dp_aux_set_pwm_freq	drivers/gpu/drm/i915/intel_dp_aux_backlight.c	intel_dp_aux_set_pwm_freq_$__d80$obj	0	11	\N	\N	\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(&connector->encoder->base);\n\tint freq, fxp, fxp_min, fxp_max, fxp_actual, f = 1;\n\tu8 pn, pn_min, pn_max;\n\n\t/* Find desired value of (F x P)\n\t * Note that, if F x P is out of supported range, the maximum value or\n\t * minimum value will applied automatically. So no need to check that.\n\t */\n\tfreq = dev_priv->vbt.backlight.pwm_freq_hz;\n\tDRM_DEBUG_KMS("VBT defined backlight frequency %u Hz\\n", freq);\n\tif (!freq) {\n\t\tDRM_DEBUG_KMS("Use panel default backlight frequency\\n");\n\t\treturn false;\n\t}\n\n\tfxp = DIV_ROUND_CLOSEST(KHz(DP_EDP_BACKLIGHT_FREQ_BASE_KHZ), freq);\n\n\t/* Use highest possible value of Pn for more granularity of brightness\n\t * adjustment while satifying the conditions below.\n\t * - Pn is in the range of Pn_min and Pn_max\n\t * - F is in the range of 1 and 255\n\t * - FxP is within 25% of desired value.\n\t *   Note: 25% is arbitrary value and may need some tweak.\n\t */\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t       DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min) != 1) {\n\t\tDRM_DEBUG_KMS("Failed to read pwmgen bit count cap min\\n");\n\t\treturn false;\n\t}\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t       DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max) != 1) {\n\t\tDRM_DEBUG_KMS("Failed to read pwmgen bit count cap max\\n");\n\t\treturn false;\n\t}\n\tpn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\tpn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\n\tfxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);\n\tfxp_max = DIV_ROUND_CLOSEST(fxp * 5, 4);\n\tif (fxp_min < (1 << pn_min) || (255 << pn_max) < fxp_max) {\n\t\tDRM_DEBUG_KMS("VBT defined backlight frequency out of range\\n");\n\t\treturn false;\n\t}\n\n\tfor (pn = pn_max; pn >= pn_min; pn--) {\n\t\tf = clamp(DIV_ROUND_CLOSEST(fxp, 1 << pn), 1, 255);\n	t
61277	2294	mwifiex_check_fw_status	drivers/net/wireless/marvell/mwifiex/pcie.c	ret	1	11	\N	\N	\tint ret = 0;\n\tu32 firmware_stat;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 tries;\n\n\t/* Mask spurios interrupts */\n\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS_MASK,\n\t\t\t      HOST_INTR_MASK)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    "Write register failed\\n");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    "Setting driver ready signature\\n");\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy,\n\t\t\t      FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    "Failed to write driver ready signature\\n");\n\t\treturn -1;\n\t}\n\n\t/* Wait for firmware initialization event */\n\tfor (tries = 0; tries < poll_num; tries++) {\n\t\tif (mwifiex_read_reg(adapter, reg->fw_status,\n\t\t\t\t     &firmware_stat))\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = 0;\n\n\t\tmwifiex_dbg(adapter, INFO, "Try %d if FW is ready <%d,%#x>",\n	t
62595	309	nfnl_acct_get	net/netfilter/nfnetlink_acct.c	skb2	1	11	\N	\N	\tint ret = -ENOENT;\n\tstruct nf_acct *cur;\n\tchar *acct_name;\n\n\tif (nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nfnl_acct_dump,\n\t\t\t.done = nfnl_acct_done,\n\t\t};\n\n\t\tif (tb[NFACCT_FILTER]) {\n\t\t\tstruct nfacct_filter *filter;\n\n\t\t\tfilter = nfacct_filter_alloc(tb[NFACCT_FILTER]);\n\t\t\tif (IS_ERR(filter))\n\t\t\t\treturn PTR_ERR(filter);\n\n\t\t\tc.data = filter;\n\t\t}\n\t\treturn netlink_dump_start(nfnl, skb, nlh, &c);\n\t}\n\n\tif (!tb[NFACCT_NAME])\n\t\treturn -EINVAL;\n\tacct_name = nla_data(tb[NFACCT_NAME]);\n\n\tlist_for_each_entry(cur, &net->nfnl_acct_list, head) {\n\t\tstruct sk_buff *skb2;\n\n\t\tif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\n\t\t\tcontinue;\n\n\t\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (skb2 == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnl_acct_fill_info(skb2, NETLINK_CB(skb).portid,\n	f
44821	174	csio_dfs_init	drivers/scsi/csiostor/csio_init.c	csio_dfs_init_@csio_debugfs_root $obj	0	11	\N	\N	\tcsio_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\tif (!csio_debugfs_root)\n	t
36746	3597	do_file_open_root	fs/namei.c	filename	1	11	\N	\N	\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n	t
45526	4480	stmmac_init	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	stmmac_init_@stmmac_fs_dir $obj	0	13	\N	\N	#ifdef CONFIG_DEBUG_FS\n\t/* Create debugfs main directory if it doesn't exist yet */\n\tif (!stmmac_fs_dir) {\n\t\tstmmac_fs_dir = debugfs_create_dir(STMMAC_RESOURCE_NAME, NULL);\n\n\t\tif (!stmmac_fs_dir || IS_ERR(stmmac_fs_dir)) {\n	f
63202	283	lowpan_xmit	net/ieee802154/6lowpan/tx.c	&wpan_hdr	1	11	\N	\N	\tstruct ieee802154_hdr wpan_hdr;\n\tint max_single, ret;\n\tu16 dgram_size, dgram_offset;\n\n\tpr_debug("package xmit\\n");\n\n\tWARN_ON_ONCE(skb->len > IPV6_MIN_MTU);\n\n\t/* We must take a copy of the skb before we modify/replace the ipv6\n\t * header as the header could be used elsewhere\n\t */\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_XMIT_DROP;\n\n\tret = lowpan_header(skb, ldev, &dgram_size, &dgram_offset);\n\tif (ret < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tif (ieee802154_hdr_peek(skb, &wpan_hdr) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tmax_single = ieee802154_max_payload(&wpan_hdr);\n	t
49441	433	gfs2_page_mkwrite	fs/gfs2/file.c	ip	1	11	\N	\N	\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned long last_index;\n\tu64 pos = page->index << PAGE_SHIFT;\n\tunsigned int data_blocks, ind_blocks, rblocks;\n\tstruct gfs2_holder gh;\n\tloff_t size;\n\tint ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tret = gfs2_rsqa_alloc(ip);\n\tif (ret)\n\t\tgoto out;\n\n\tgfs2_size_hint(vmf->vma->vm_file, pos, PAGE_SIZE);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\t/* Update file times before taking page lock */\n\tfile_update_time(vmf->vma->vm_file);\n\n\tset_bit(GLF_DIRTY, &ip->i_gl->gl_flags);\n\tset_bit(GIF_SW_PAGED, &ip->i_flags);\n\n\tif (!gfs2_write_alloc_required(ip, pos, PAGE_SIZE)) {\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page) || page->mapping != inode->i_mapping) {\n\t\t\tret = -EAGAIN;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgfs2_write_calc_reserv(ip, PAGE_SIZE, &data_blocks, &ind_blocks);\n\tap.target = data_blocks + ind_blocks;\n\tret = gfs2_quota_lock_check(ip, &ap);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = gfs2_inplace_reserve(ip, &ap);\n	t
63337	2259	ath10k_wmi_tlv_op_gen_set_sta_ps	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_set_sta_ps_$cmd$obj	0	11	\N	\N	\tstruct wmi_sta_powersave_param_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_POWERSAVE_PARAM_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	t
9727	-1	rsvp_replace	net/sched/cls_rsvp.c	rsvp_replace_$size.addr.i100	0	-11	\N	\N	\N	t
51967	135	megadev_ioctl	drivers/scsi/megaraid.c	megadev_ioctl_$bytes.addr.i.i367$obj	0	11	\N	\N	\N	t
40401	1297	igt_gtt_reserve	drivers/gpu/drm/i915/i915_gem_gtt.c	igt_gtt_reserve_$offset$obj	0	13	\N	\N	\tstruct i915_address_space *vm = &ppgtt->base;\n\tstruct i915_page_directory_pointer *pdp = &ppgtt->pdp;\n\tstruct i915_page_directory *pd;\n\tu64 start = 0, length = ppgtt->base.total;\n\tu64 from = start;\n\tunsigned int pdpe;\n\n\tgen8_for_each_pdpe(pd, pdp, start, length, pdpe) {\n\t\tpd = alloc_pd(vm);\n	f
3508	3433	__mem_cgroup_usage_register_event	mm/memcontrol.c	__mem_cgroup_usage_register_event_$thresholds$obj$0$obj$0	0	11	\N	\N	\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tunsigned long threshold;\n\tunsigned long usage;\n\tint i, size, ret;\n\n\tret = page_counter_memparse(args, "-1", &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM) {\n\t\tthresholds = &memcg->thresholds;\n\t\tusage = mem_cgroup_usage(memcg, false);\n\t} else if (type == _MEMSWAP) {\n\t\tthresholds = &memcg->memsw_thresholds;\n\t\tusage = mem_cgroup_usage(memcg, true);\n\t} else\n\t\tBUG();\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n	t
9476	635	ep0_handle_setup	drivers/usb/mtu3/mtu3_gadget_ep0.c	&setup	1	11	\N	\N	\tstruct usb_ctrlrequest setup;\n\tstruct mtu3_request *mreq;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint handled = 0;\n\n\tep0_read_setup(mtu, &setup);\n	t
59678	1769	ovs_dp_cmd_get	net/openvswitch/datapath.c	reply	1	13	\N	\N	\tstruct sk_buff *reply;\n\tstruct datapath *dp;\n\tint err;\n\n\treply = ovs_dp_cmd_alloc_info();\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\tovs_lock();\n\tdp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\n\tif (IS_ERR(dp)) {\n\t\terr = PTR_ERR(dp);\n\t\tgoto err_unlock_free;\n\t}\n\terr = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\n	f
62770	206	gp8psk_power_ctrl	drivers/media/usb/dvb-usb/gp8psk.c	status	1	11	\N	\N	\tu8 status, buf;\n\tint gp_product_id = le16_to_cpu(d->udev->descriptor.idProduct);\n\n\tif (onoff) {\n\t\tgp8psk_usb_in_op(d, GET_8PSK_CONFIG,0,0,&status,1);\n\t\tif (! (status & bm8pskStarted)) {  /* started */\n\t\t\tif(gp_product_id == USB_PID_GENPIX_SKYWALKER_CW3K)\n\t\t\t\tgp8psk_usb_out_op(d, CW3K_INIT, 1, 0, NULL, 0);\n\t\t\tif (gp8psk_usb_in_op(d, BOOT_8PSK, 1, 0, &buf, 1))\n\t\t\t\treturn -EINVAL;\n\t\t\tgp8psk_info(d);\n\t\t}\n\n\t\tif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\n\t\t\tif (! (status & bm8pskFW_Loaded)) /* BCM4500 firmware loaded */\n\t\t\t\tif(gp8psk_load_bcm4500fw(d))\n\t\t\t\t\treturn -EINVAL;\n\n\t\tif (! (status & bmIntersilOn)) /* LNB Power */\n	f
62894	824	cached_dev_cache_miss	drivers/md/bcache/request.c	cache_bio	1	11	\N	\N	\tint ret = MAP_CONTINUE;\n\tunsigned reada = 0;\n\tstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\n\tstruct bio *miss, *cache_bio;\n\n\tif (s->cache_miss || s->iop.bypass) {\n\t\tmiss = bio_next_split(bio, sectors, GFP_NOIO, s->d->bio_split);\n\t\tret = miss == bio ? MAP_DONE : MAP_CONTINUE;\n\t\tgoto out_submit;\n\t}\n\n\tif (!(bio->bi_opf & REQ_RAHEAD) &&\n\t    !(bio->bi_opf & REQ_META) &&\n\t    s->iop.c->gc_stats.in_use < CUTOFF_CACHE_READA)\n\t\treada = min_t(sector_t, dc->readahead >> 9,\n\t\t\t      get_capacity(bio->bi_disk) - bio_end_sector(bio));\n\n\ts->insert_bio_sectors = min(sectors, bio_sectors(bio) + reada);\n\n\ts->iop.replace_key = KEY(s->iop.inode,\n\t\t\t\t bio->bi_iter.bi_sector + s->insert_bio_sectors,\n\t\t\t\t s->insert_bio_sectors);\n\n\tret = bch_btree_insert_check_key(b, &s->op, &s->iop.replace_key);\n\tif (ret)\n\t\treturn ret;\n\n\ts->iop.replace = true;\n\n\tmiss = bio_next_split(bio, sectors, GFP_NOIO, s->d->bio_split);\n\n\t/* btree_search_recurse()'s btree iterator is no good anymore */\n\tret = miss == bio ? MAP_DONE : -EINTR;\n\n\tcache_bio = bio_alloc_bioset(GFP_NOWAIT,\n\t\t\tDIV_ROUND_UP(s->insert_bio_sectors, PAGE_SECTORS),\n\t\t\tdc->disk.bio_split);\n\tif (!cache_bio)\n\t\tgoto out_submit;\n\n\tcache_bio->bi_iter.bi_sector\t= miss->bi_iter.bi_sector;\n\tbio_copy_dev(cache_bio, miss);\n\tcache_bio->bi_iter.bi_size\t= s->insert_bio_sectors << 9;\n\n\tcache_bio->bi_end_io\t= request_endio;\n\tcache_bio->bi_private\t= &s->cl;\n\n\tbch_bio_map(cache_bio, NULL);\n	f
48780	794	cyapa_update_suspend_scanrate	drivers/input/mouse/cyapa.c	cyapa_update_suspend_scanrate_$__UNIQUE_ID_min1_129$obj	0	11	\N	\N	\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu16 sleep_time;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tif (sysfs_streq(buf, BTN_ONLY_MODE_NAME)) {\n\t\tcyapa->suspend_power_mode = PWR_MODE_BTN_ONLY;\n\t} else if (sysfs_streq(buf, OFF_MODE_NAME)) {\n\t\tcyapa->suspend_power_mode = PWR_MODE_OFF;\n\t} else if (!kstrtou16(buf, 10, &sleep_time)) {\n\t\tcyapa->suspend_sleep_time = min_t(u16, sleep_time, 1000);\n	t
50629	179	ip_call_ra_chain	net/ipv4/ip_input.c	skb2	1	11	\N	\N	\tstruct ip_ra_chain *ra;\n\tu8 protocol = ip_hdr(skb)->protocol;\n\tstruct sock *last = NULL;\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\n\tfor (ra = rcu_dereference(ip_ra_chain); ra; ra = rcu_dereference(ra->next)) {\n\t\tstruct sock *sk = ra->sk;\n\n\t\t/* If socket is bound to an interface, only report\n\t\t * the packet if it came  from that interface.\n\t\t */\n\t\tif (sk && inet_sk(sk)->inet_num == protocol &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == dev->ifindex) &&\n\t\t    net_eq(sock_net(sk), net)) {\n\t\t\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\t\t\tif (ip_defrag(net, skb, IP_DEFRAG_CALL_RA_CHAIN))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\traw_rcv(last, skb2);\n	t
45428	679	gs_can_open	drivers/net/can/usb/gs_usb.c	rc	1	11	\N	\N	\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   "No memory left for USB buffer\\n");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   "usb_submit failed (err=%d)\\n",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n	t
53524	1104	audit_rule_change	kernel/auditfilter.c	err	1	11	\N	\N	\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change("add_rule", &entry->rule, !err);\n	t
46103	6247	l2cap_rx_state_recv	net/bluetooth/l2cap_core.c	chan	0	11	\N	\N	\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG("chan %p, control %p, skb %p, event %d", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG("Busy, discarding expected seq %d",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (control->final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tcontrol->final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG("Busy, discarding unexpected seq %d",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG("Queued %p (queue len %d)", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n	f
40675	4154	handle_backoff	net/ceph/osd_client.c	&m	1	11	\N	\N	\tstruct ceph_osd_client *osdc = osd->o_osdc;\n\tstruct MOSDBackoff m;\n\tint ret;\n\n\tdown_read(&osdc->lock);\n\tif (!osd_registered(osd)) {\n\t\tdout("%s osd%d unknown\\n", __func__, osd->o_osd);\n\t\tup_read(&osdc->lock);\n\t\treturn;\n\t}\n\tWARN_ON(osd->o_osd != le64_to_cpu(msg->hdr.src.num));\n\n\tmutex_lock(&osd->lock);\n\tret = decode_MOSDBackoff(msg, &m);\n\tif (ret) {\n\t\tpr_err("failed to decode MOSDBackoff: %d\\n", ret);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (m.op) {\n\tcase CEPH_OSD_BACKOFF_OP_BLOCK:\n\t\thandle_backoff_block(osd, &m);\n\t\tbreak;\n\tcase CEPH_OSD_BACKOFF_OP_UNBLOCK:\n\t\thandle_backoff_unblock(osd, &m);\n	t
47449	629	alua_rtpg	drivers/scsi/device_handler/scsi_dh_alua.c	k	0	11	\N	\N	\tstruct scsi_sense_hdr sense_hdr;\n\tstruct alua_port_group *tmp_pg;\n\tint len, k, off, valid_states = 0, bufflen = ALUA_RTPG_SIZE;\n\tunsigned char *desc, *buff;\n\tunsigned err, retval;\n\tunsigned int tpg_desc_tbl_off;\n\tunsigned char orig_transition_tmo;\n\tunsigned long flags;\n\n\tif (!pg->expiry) {\n\t\tunsigned long transition_tmo = ALUA_FAILOVER_TIMEOUT * HZ;\n\n\t\tif (pg->transition_tmo)\n\t\t\ttransition_tmo = pg->transition_tmo * HZ;\n\n\t\tpg->expiry = round_jiffies_up(jiffies + transition_tmo);\n\t}\n\n\tbuff = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buff)\n\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\n retry:\n\terr = 0;\n\tretval = submit_rtpg(sdev, buff, bufflen, &sense_hdr, pg->flags);\n\n\tif (retval) {\n\t\tif (!scsi_sense_valid(&sense_hdr)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    "%s: rtpg failed, result %d\\n",\n\t\t\t\t    ALUA_DH_NAME, retval);\n\t\t\tkfree(buff);\n\t\t\tif (driver_byte(retval) == DRIVER_ERROR)\n\t\t\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\t\t\treturn SCSI_DH_IO;\n\t\t}\n\n\t\t/*\n\t\t * submit_rtpg() has failed on existing arrays\n\t\t * when requesting extended header info, and\n\t\t * the array doesn't support extended headers,\n\t\t * even though it shouldn't according to T10.\n\t\t * The retry without rtpg_ext_hdr_req set\n\t\t * handles this.\n\t\t */\n\t\tif (!(pg->flags & ALUA_RTPG_EXT_HDR_UNSUPP) &&\n\t\t    sense_hdr.sense_key == ILLEGAL_REQUEST &&\n\t\t    sense_hdr.asc == 0x24 && sense_hdr.ascq == 0) {\n\t\t\tpg->flags |= ALUA_RTPG_EXT_HDR_UNSUPP;\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * Retry on ALUA state transition or if any\n\t\t * UNIT ATTENTION occurred.\n\t\t */\n\t\tif (sense_hdr.sense_key == NOT_READY &&\n\t\t    sense_hdr.asc == 0x04 && sense_hdr.ascq == 0x0a)\n\t\t\terr = SCSI_DH_RETRY;\n\t\telse if (sense_hdr.sense_key == UNIT_ATTENTION)\n\t\t\terr = SCSI_DH_RETRY;\n\t\tif (err == SCSI_DH_RETRY &&\n\t\t    pg->expiry != 0 && time_before(jiffies, pg->expiry)) {\n\t\t\tsdev_printk(KERN_ERR, sdev, "%s: rtpg retry\\n",\n\t\t\t\t    ALUA_DH_NAME);\n\t\t\tscsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);\n\t\t\tkfree(buff);\n\t\t\treturn err;\n\t\t}\n\t\tsdev_printk(KERN_ERR, sdev, "%s: rtpg failed\\n",\n\t\t\t    ALUA_DH_NAME);\n\t\tscsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);\n\t\tkfree(buff);\n\t\tpg->expiry = 0;\n\t\treturn SCSI_DH_IO;\n\t}\n\n\tlen = get_unaligned_be32(&buff[0]) + 4;\n\n\tif (len > bufflen) {\n\t\t/* Resubmit with the correct length */\n\t\tkfree(buff);\n\t\tbufflen = len;\n\t\tbuff = kmalloc(bufflen, GFP_KERNEL);\n\t\tif (!buff) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    "%s: kmalloc buffer failed\\n",__func__);\n\t\t\t/* Temporary failure, bypass */\n\t\t\tpg->expiry = 0;\n\t\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\t\t}\n\t\tgoto retry;\n\t}\n\n\torig_transition_tmo = pg->transition_tmo;\n\tif ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && buff[5] != 0)\n\t\tpg->transition_tmo = buff[5];\n\telse\n\t\tpg->transition_tmo = ALUA_FAILOVER_TIMEOUT;\n\n\tif (orig_transition_tmo != pg->transition_tmo) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    "%s: transition timeout set to %d seconds\\n",\n\t\t\t    ALUA_DH_NAME, pg->transition_tmo);\n\t\tpg->expiry = jiffies + pg->transition_tmo * HZ;\n\t}\n\n\tif ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)\n\t\ttpg_desc_tbl_off = 8;\n\telse\n\t\ttpg_desc_tbl_off = 4;\n\n\tfor (k = tpg_desc_tbl_off, desc = buff + tpg_desc_tbl_off;\n\t     k < len;\n	f
755	103	cfg80211_dev_check_name	net/wireless/core.c	wiphy_idx	38	2	\N	TP	\tstruct cfg80211_registered_device *rdev2;\n\tint wiphy_idx, taken = -1, digits;\n\n\tASSERT_RTNL();\n\n\t/* prohibit calling the thing phy%d when %d is not its number */\n\tsscanf(newname, PHY_NAME "%d%n", &wiphy_idx, &taken);\n\tif (taken == strlen(newname) && wiphy_idx != rdev->wiphy_idx) {\n\t\t/* count number of places needed to print wiphy_idx */\n\t\tdigits = 1;\n\t\twhile (wiphy_idx /= 10)\n	f
9627	563	ieee80211_if_parse_tsf	net/mac80211/debugfs_netdev.c	tsf_is_delta	1	11	\N	\N	\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long long tsf;\n\tint ret;\n\tint tsf_is_delta = 0;\n\n\tif (strncmp(buf, "reset", 5) == 0) {\n\t\tif (local->ops->reset_tsf) {\n\t\t\tdrv_reset_tsf(local, sdata);\n\t\t\twiphy_info(local->hw.wiphy, "debugfs reset TSF\\n");\n\t\t}\n\t} else {\n\t\tif (buflen > 10 && buf[1] == '=') {\n\t\t\tif (buf[0] == '+')\n\t\t\t\ttsf_is_delta = 1;\n\t\t\telse if (buf[0] == '-')\n\t\t\t\ttsf_is_delta = -1;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbuf += 2;\n\t\t}\n\t\tret = kstrtoull(buf, 10, &tsf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (tsf_is_delta && local->ops->offset_tsf) {\n\t\t\tdrv_offset_tsf(local, sdata, tsf_is_delta * tsf);\n\t\t\twiphy_info(local->hw.wiphy,\n	t
50683	182	perf_trace_f2fs__inode_exit	fs/f2fs/super.c	args	1	11	\N	\N	\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n	t
50697	933	trace_event_raw_event_rxrpc_timer	net/rxrpc/af_rxrpc.c	"krxrpcd"	1	11	\N	\N	\tint ret = -1;\n\tunsigned int tmp;\n\n\tBUILD_BUG_ON(sizeof(struct rxrpc_skb_priv) > FIELD_SIZEOF(struct sk_buff, cb));\n\n\tget_random_bytes(&tmp, sizeof(tmp));\n\ttmp &= 0x3fffffff;\n\tif (tmp == 0)\n\t\ttmp = 1;\n\tidr_set_cursor(&rxrpc_client_conn_ids, tmp);\n\n\tret = -ENOMEM;\n\trxrpc_call_jar = kmem_cache_create(\n\t\t"rxrpc_call_jar", sizeof(struct rxrpc_call), 0,\n\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!rxrpc_call_jar) {\n\t\tpr_notice("Failed to allocate call jar\\n");\n\t\tgoto error_call_jar;\n\t}\n\n\trxrpc_workqueue = alloc_workqueue("krxrpcd", 0, 1);\n	t
55662	152	icmpv6_error_message	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c	origtuple.dst.protonum	6	12	\N	\N	\tstruct nf_conntrack_tuple intuple, origtuple;\n\tconst struct nf_conntrack_tuple_hash *h;\n\tconst struct nf_conntrack_l4proto *inproto;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conntrack_zone tmp;\n\n\tWARN_ON(skb_nfct(skb));\n\n\t/* Are they talking about one of our connections? */\n\tif (!nf_ct_get_tuplepr(skb,\n\t\t\t       skb_network_offset(skb)\n\t\t\t\t+ sizeof(struct ipv6hdr)\n\t\t\t\t+ sizeof(struct icmp6hdr),\n\t\t\t       PF_INET6, net, &origtuple)) {\n\t\tpr_debug("icmpv6_error: Can't get tuple\\n");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\t/* rcu_read_lock()ed by nf_hook_thresh */\n\tinproto = __nf_ct_l4proto_find(PF_INET6, origtuple.dst.protonum);\n	t
32549	1198	nfs4_opendata_alloc	fs/nfs/nfs4proc.c	verf	0	11	\N	\N	\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = d_inode(parent);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\n\tp->f_label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->f_label))\n\t\tgoto err_free_p;\n\n\tp->a_label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->a_label))\n\t\tgoto err_free_f;\n\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->o_arg.seqid = alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (IS_ERR(p->o_arg.seqid))\n\t\tgoto err_free_label;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\tp->o_arg.umask = current_umask();\n\tp->o_arg.claim = nfs4_map_atomic_open_claim(server, claim);\n\tp->o_arg.share_access = nfs4_map_atomic_open_share(server,\n\t\t\tfmode, flags);\n\t/* don't put an ACCESS op in OPEN compound if O_EXCL, because ACCESS\n\t * will return permission denied for all bits until close */\n\tif (!(flags & O_EXCL)) {\n\t\t/* ask server to check for all possible rights as results\n\t\t * are cached */\n\t\tswitch (p->o_arg.claim) {\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\tp->o_arg.access = NFS4_ACCESS_READ |\n\t\t\t\tNFS4_ACCESS_MODIFY |\n\t\t\t\tNFS4_ACCESS_EXTEND |\n\t\t\t\tNFS4_ACCESS_EXECUTE;\n\t\t}\n\t}\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = nfs4_bitmask(server, label);\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tp->o_arg.label = nfs4_label_copy(p->a_label, label);\n\tswitch (p->o_arg.claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tp->o_arg.fh = NFS_FH(dir);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tp->o_arg.fh = NFS_FH(d_inode(dentry));\n\t}\n\tif (attrs != NULL && attrs->ia_valid != 0) {\n\t\t__u32 verf[2];\n\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\n\t\tverf[0] = jiffies;\n\t\tverf[1] = current->pid;\n\t\tmemcpy(p->o_arg.u.verifier.data, verf,\n	f
34132	536	macvlan_queue_xmit	drivers/net/macvlan.c	skb	0	11	\N	\N	\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct macvlan_port *port = vlan->port;\n\tconst struct macvlan_dev *dest;\n\n\tif (vlan->mode == MACVLAN_MODE_BRIDGE) {\n\t\tconst struct ethhdr *eth = (void *)skb->data;\n\n\t\t/* send to other bridge ports directly */\n\t\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\t\tmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\n\t\t\tgoto xmit_world;\n\t\t}\n\n\t\tdest = macvlan_hash_lookup(port, eth->h_dest);\n\t\tif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\n\t\t\t/* send to lowerdev first for its network taps */\n\t\t\tdev_forward_skb(vlan->lowerdev, skb);\n\n\t\t\treturn NET_XMIT_SUCCESS;\n\t\t}\n\t}\n\nxmit_world:\n\tskb->dev = vlan->lowerdev;\n\treturn dev_queue_xmit(skb);\n	f
21909	325	acpi_gpiochip_request_interrupts	drivers/gpio/gpiolib-acpi.c	acpi_gpio	0	11	\N	\N	\tstruct acpi_gpio_chip *acpi_gpio;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (!chip->parent || !chip->to_irq)\n\t\treturn;\n\n\thandle = ACPI_HANDLE(chip->parent);\n\tif (!handle)\n\t\treturn;\n\n\tstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tacpi_walk_resources(handle, "_AEI",\n	f
2628	204	bmp280_compensate_temp	drivers/iio/pressure/bmp280-core.c	ret	1	13	\N	\N	\tint ret;\n\ts32 var1, var2;\n\t__le16 buf[BMP280_COMP_TEMP_REG_COUNT / 2];\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_TEMP_START,\n\t\t\t       buf, BMP280_COMP_TEMP_REG_COUNT);\n\tif (ret < 0) {\n	f
27317	872	qca_set_baudrate	drivers/bluetooth/hci_qca.c	skb	1	13	\N	\N	\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\tu8 cmd[] = { 0x01, 0x48, 0xFC, 0x01, 0x00 };\n\n\tif (baudrate > QCA_BAUDRATE_3000000)\n\t\treturn -EINVAL;\n\n\tcmd[4] = baudrate;\n\n\tskb = bt_skb_alloc(sizeof(cmd), GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR("Failed to allocate memory for baudrate packet");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign commands to change baudrate and packet type. */\n\tskb_put_data(skb, cmd, sizeof(cmd));\n	f
51405	1774	ocfs2_write_begin_nolock	fs/ocfs2/aops.c	ocfs2_write_begin_nolock_$wc$obj$4$0	0	11	\N	\N	\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, type, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Direct io change i_size late, should not zero tail here. */\n\tif (type != OCFS2_WRITE_DIRECT) {\n\t\tif (ocfs2_sparse_alloc(osb))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   len, wc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, type, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t/*\n\t * We set w_target_from, w_target_to here so that\n\t * ocfs2_write_end() knows which range in the target page to\n\t * write out. An allocation requires that we write the entire\n\t * cluster range.\n\t */\n\tif (clusters_to_alloc || extents_to_split) {\n\t\t/*\n\t\t * XXX: We are stretching the limits of\n\t\t * ocfs2_lock_allocators(). It greatly over-estimates\n\t\t * the work to be done.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\t} else if (type == OCFS2_WRITE_DIRECT)\n\t\t/* direct write needs not to start trans if no extents alloc. */\n\t\tgoto success;\n\n\t/*\n\t * We have to zero sparse allocated clusters, unwritten extent clusters,\n\t * and non-sparse clusters we just extended.  For non-sparse writes,\n\t * we know zeros will only be needed in the first and/or last cluster.\n\t */\n\tif (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n	t
35534	1559	ieee80211_build_probe_req	net/mac80211/util.c	mgmt->bssid	2	-11	\N	\N	\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_chan_def chandef;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tint ies_len;\n\tu32 rate_masks[NUM_NL80211_BANDS] = {};\n\tstruct ieee80211_scan_ies dummy_ie_desc;\n\n\t/*\n\t * Do not send DS Channel parameter for directed probe requests\n\t * in order to maximize the chance that we get a response.  Some\n\t * badly-behaved APs don't respond when this parameter is included.\n\t */\n\tchandef.width = sdata->vif.bss_conf.chandef.width;\n\tif (directed)\n\t\tchandef.chan = NULL;\n\telse\n\t\tchandef.chan = chan;\n\n\tskb = ieee80211_probereq_get(&local->hw, src, ssid, ssid_len,\n\t\t\t\t     100 + ie_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\trate_masks[chan->band] = ratemask;\n\ties_len = ieee80211_build_preq_ies(local, skb_tail_pointer(skb),\n\t\t\t\t\t   skb_tailroom(skb), &dummy_ie_desc,\n\t\t\t\t\t   ie, ie_len, BIT(chan->band),\n\t\t\t\t\t   rate_masks, &chandef);\n\tskb_put(skb, ies_len);\n\n\tif (dst) {\n\t\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t\tmemcpy(mgmt->da, dst, ETH_ALEN);\n\t\tmemcpy(mgmt->bssid, dst, ETH_ALEN);\n	t
8589	155	ixgbe_get_vfs	drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c	pos	1	11	\N	\N	\tstruct pci_dev *pdev = adapter->pdev;\n\tu16 vendor = pdev->vendor;\n\tstruct pci_dev *vfdev;\n\tint vf = 0;\n\tu16 vf_id;\n\tint pos;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\tif (!pos)\n	t
30211	340	exofs_sbi_write_stats	fs/exofs/super.c	ios->done	1	11	\N	\N	\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR("%s: ore_get_io_state failed.\\n", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n	t
48139	660	radio_led_get	drivers/platform/x86/fujitsu-laptop.c	radio_led_get_$and$32	0	13	\N	\N	\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tenum led_brightness brightness = LED_OFF;\n\n\tif (call_fext_func(device, FUNC_FLAGS, 0x4, 0x0, 0x0) & RADIO_LED_ON)\n	f
45916	496	mt9m111_set_green_balance	drivers/media/usb/gspca/m5602/m5602_mt9m111.c	err	1	11	\N	\N	\tint err;\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[1] = (val & 0xff);\n\tdata[0] = (val & 0xff00) >> 8;\n\n\tPDEBUG(D_CONF, "Set green balance %d", val);\n\terr = m5602_write_sensor(sd, MT9M111_SC_GREEN_1_GAIN,\n\t\t\t\t data, 2);\n\tif (err < 0)\n	t
62462	629	arizona_hpdet_irq	drivers/extcon/extcon-arizona.c	ret	1	11	\N	\N	\tstruct arizona_extcon_info *info = data;\n\tstruct arizona *arizona = info->arizona;\n\tint id_gpio = arizona->pdata.hpdet_id_gpio;\n\tunsigned int report = EXTCON_JACK_HEADPHONE;\n\tint ret, reading;\n\tbool mic = false;\n\n\tmutex_lock(&info->lock);\n\n\t/* If we got a spurious IRQ for some reason then ignore it */\n\tif (!info->hpdet_active) {\n\t\tdev_warn(arizona->dev, "Spurious HPDET IRQ\\n");\n\t\tmutex_unlock(&info->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t/* If the cable was removed while measuring ignore the result */\n\tret = extcon_get_state(info->edev, EXTCON_MECHANICAL);\n\tif (ret < 0) {\n\t\tdev_err(arizona->dev, "Failed to check cable state: %d\\n",\n\t\t\tret);\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tdev_dbg(arizona->dev, "Ignoring HPDET for removed cable\\n");\n\t\tgoto done;\n\t}\n\n\tret = arizona_hpdet_read(info);\n\tif (ret == -EAGAIN)\n	t
39369	2230	add_hwgenerator_randomness	drivers/char/random.c	poolp	0	11	\N	\N	\tstruct entropy_store *poolp = &input_pool;\n\n\tif (!crng_ready()) {\n\t\tcrng_fast_load(buffer, count);\n\t\treturn;\n\t}\n\n\t/* Suspend writing if we're above the trickle threshold.\n\t * We'll be woken up again once below random_write_wakeup_thresh,\n\t * or when the calling thread is about to terminate.\n\t */\n\twait_event_interruptible(random_write_wait, kthread_should_stop() ||\n\t\t\tENTROPY_BITS(&input_pool) <= random_write_wakeup_bits);\n\tmix_pool_bytes(poolp, buffer, count);\n\tcredit_entropy_bits(poolp, entropy);\n	f
48360	705	capi_write	drivers/isdn/capi/capi.c	mlen	0	11	\N	\N	\tstruct capidev *cdev = file->private_data;\n\tstruct sk_buff *skb;\n\tu16 mlen;\n\n\tif (!cdev->ap.applid)\n\t\treturn -ENODEV;\n\n\tskb = alloc_skb(count, GFP_USER);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(skb_put(skb, count), buf, count)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\tmlen = CAPIMSG_LEN(skb->data);\n\tif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_REQ) {\n\t\tif ((size_t)(mlen + CAPIMSG_DATALEN(skb->data)) != count) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (mlen != count) {\n	f
52847	192	acpi_hw_extended_wake_prep	drivers/acpi/acpica/hwesleep.c	status	0	11	\N	\N	\tacpi_status status;\n\tu8 sleep_type_value;\n\n\tACPI_FUNCTION_TRACE(hw_extended_wake_prep);\n\n\tstatus = acpi_get_sleep_type_data(ACPI_STATE_S0,\n\t\t\t\t\t  &acpi_gbl_sleep_type_a,\n\t\t\t\t\t  &acpi_gbl_sleep_type_b);\n\tif (ACPI_SUCCESS(status)) {\n	f
4787	398	atbm8830_read_signal_strength	drivers/media/dvb-frontends/atbm8830.c	pwm	1	11	\N	\N	\tstruct atbm_state *priv = fe->demodulator_priv;\n\tu32 pwm;\n\tu8 t;\n\n\tdprintk("%s\\n", __func__);\n\tatbm8830_reglatch_lock(priv, 1);\n\n\tatbm8830_read_reg(priv, REG_AGC_PWM_VAL + 1, &t);\n\tpwm = t & 0x03;\n\tpwm <<= 8;\n\tatbm8830_read_reg(priv, REG_AGC_PWM_VAL, &t);\n\tpwm |= t;\n\n\tatbm8830_reglatch_lock(priv, 0);\n\n\tdprintk("AGC PWM = 0x%02X\\n", pwm);\n	t
62886	537	rx8025_probe	drivers/rtc/rtc-rx8025.c	err	1	11	\N	\N	\tstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\n\tstruct rx8025_data *rx8025;\n\tint err = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&adapter->dev,\n\t\t\t"doesn't support required functionality\\n");\n\t\treturn -EIO;\n\t}\n\n\trx8025 = devm_kzalloc(&client->dev, sizeof(*rx8025), GFP_KERNEL);\n\tif (!rx8025)\n\t\treturn -ENOMEM;\n\n\trx8025->client = client;\n\ti2c_set_clientdata(client, rx8025);\n\n\terr = rx8025_init_client(client);\n\tif (err)\n	t
21394	206	ni903x_acpi_add	drivers/watchdog/ni903x_wdt.c	status	1	11	\N	\N	\tstruct device *dev = &device->dev;\n\tstruct watchdog_device *wdd;\n\tstruct ni903x_wdt *wdt;\n\tacpi_status status;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tdevice->driver_data = wdt;\n\twdt->dev = dev;\n\n\tstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\n\t\t\t\t     ni903x_resources, wdt);\n\tif (ACPI_FAILURE(status) || wdt->io_base == 0) {\n	t
43118	670	bnx2fc_percpu_io_thread	drivers/scsi/bnx2fc/bnx2fc_fcoe.c	tmp	1	11	\N	\N	\tstruct bnx2fc_percpu_s *p = arg;\n\tstruct bnx2fc_work *work, *tmp;\n\tLIST_HEAD(work_list);\n\n\tset_user_nice(current, MIN_NICE);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tspin_lock_bh(&p->fp_work_lock);\n\t\twhile (!list_empty(&p->work_list)) {\n\t\t\tlist_splice_init(&p->work_list, &work_list);\n\t\t\tspin_unlock_bh(&p->fp_work_lock);\n\n\t\t\tlist_for_each_entry_safe(work, tmp, &work_list, list) {\n	t
60831	3074	ecc_enabled	drivers/edac/amd64_edac.c	value	1	11	\N	\N	\tbool nb_mce_en = false;\n\tu8 ecc_en = 0, i;\n\tu32 value;\n\n\tif (boot_cpu_data.x86 >= 0x17) {\n\t\tu8 umc_en_mask = 0, ecc_en_mask = 0;\n\n\t\tfor (i = 0; i < NUM_UMCS; i++) {\n\t\t\tu32 base = get_umc_base(i);\n\n\t\t\t/* Only check enabled UMCs. */\n\t\t\tif (amd_smn_read(nid, base + UMCCH_SDP_CTRL, &value))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(value & UMC_SDP_INIT))\n\t\t\t\tcontinue;\n\n\t\t\tumc_en_mask |= BIT(i);\n\n\t\t\tif (amd_smn_read(nid, base + UMCCH_UMC_CAP_HI, &value))\n\t\t\t\tcontinue;\n\n\t\t\tif (value & UMC_ECC_ENABLED)\n\t\t\t\tecc_en_mask |= BIT(i);\n\t\t}\n\n\t\t/* Check whether at least one UMC is enabled: */\n\t\tif (umc_en_mask)\n\t\t\tecc_en = umc_en_mask == ecc_en_mask;\n\t\telse\n\t\t\tedac_dbg(0, "Node %d: No enabled UMCs.\\n", nid);\n\n\t\t/* Assume UMC MCA banks are enabled. */\n\t\tnb_mce_en = true;\n\t} else {\n\t\tamd64_read_pci_cfg(F3, NBCFG, &value);\n\n\t\tecc_en = !!(value & NBCFG_ECC_ENABLE);\n	t
22006	6655	brcmf_setup_wiphy	drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c	bandlist	1	11	\N	\N	\tstruct brcmf_pub *drvr = ifp->drvr;\n\tconst struct ieee80211_iface_combination *combo;\n\tstruct ieee80211_supported_band *band;\n\tu16 max_interfaces = 0;\n\tbool gscan;\n\t__le32 bandlist[3];\n\tu32 n_bands;\n\tint err, i;\n\n\twiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\n\twiphy->max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\n\twiphy->max_num_pmkids = BRCMF_MAXPMKID;\n\n\terr = brcmf_setup_ifmodes(wiphy, ifp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0, combo = wiphy->iface_combinations;\n\t     i < wiphy->n_iface_combinations; i++, combo++) {\n\t\tmax_interfaces = max(max_interfaces, combo->max_interfaces);\n\t}\n\n\tfor (i = 0; i < max_interfaces && i < ARRAY_SIZE(drvr->addresses);\n\t     i++) {\n\t\tu8 *addr = drvr->addresses[i].addr;\n\n\t\tmemcpy(addr, drvr->mac, ETH_ALEN);\n\t\tif (i) {\n\t\t\taddr[0] |= BIT(1);\n\t\t\taddr[ETH_ALEN - 1] ^= i;\n\t\t}\n\t}\n\twiphy->addresses = drvr->addresses;\n\twiphy->n_addresses = i;\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->cipher_suites = brcmf_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(brcmf_cipher_suites);\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\twiphy->n_cipher_suites--;\n\twiphy->bss_select_support = BIT(NL80211_BSS_SELECT_ATTR_RSSI) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_BAND_PREF) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_RSSI_ADJUST);\n\n\twiphy->flags |= WIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT |\n\t\t\tWIPHY_FLAG_OFFCHAN_TX |\n\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS))\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\tif (!ifp->drvr->settings->roamoff)\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWSUP)) {\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK);\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X);\n\t}\n\twiphy->mgmt_stypes = brcmf_txrx_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tgscan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_GSCAN);\n\t\tbrcmf_pno_wiphy_params(wiphy, gscan);\n\t}\n\t/* vendor commands/events support */\n\twiphy->vendor_commands = brcmf_vendor_cmds;\n\twiphy->n_vendor_commands = BRCMF_VNDR_CMDS_LAST - 1;\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))\n\t\tbrcmf_wiphy_wowl_params(wiphy, ifp);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,\n\t\t\t\t     sizeof(bandlist));\n\tif (err) {\n\t\tbrcmf_err("could not obtain band info: err=%d\\n", err);\n\t\treturn err;\n\t}\n\t/* first entry in bandlist is number of bands */\n\tn_bands = le32_to_cpu(bandlist[0]);\n\tfor (i = 1; i <= n_bands && i < ARRAY_SIZE(bandlist); i++) {\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_2G)) {\n	t
41046	288	ti_vsend_sync	drivers/usb/serial/io_ti.c	status	1	11	\N	\N	\tint status;\n\n\tstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT),\n\t\t\tvalue, index, data, size, timeout);\n\tif (status < 0)\n	t
47463	2201	key_notify_policy	net/key/af_key.c	key_notify_policy_$out_hdr$obj	0	13	\N	\N	\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n	f
35924	7610	ixgbe_reset_subtask	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	adapter	1	13	\N	\N	\tif (!test_and_clear_bit(__IXGBE_RESET_REQUESTED, &adapter->state))\n\t\treturn;\n\n\t/* If we're already down, removing or resetting, just bail */\n\tif (test_bit(__IXGBE_DOWN, &adapter->state) ||\n\t    test_bit(__IXGBE_REMOVING, &adapter->state) ||\n\t    test_bit(__IXGBE_RESETTING, &adapter->state))\n\t\treturn;\n\n\tixgbe_dump(adapter);\n\tnetdev_err(adapter->netdev, "Reset adapter\\n");\n\tadapter->tx_timeout_count++;\n\n\trtnl_lock();\n\tixgbe_reinit_locked(adapter);\n	f
51259	1079	ubifs_mknod	fs/ubifs/dir.c	dev	1	11	\N	\N	\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tunion ubifs_dev_desc *dev = NULL;\n\tint sz_change;\n\tint err, devlen = 0;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct fscrypt_name nm;\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen("dent '%pd' in dir ino %lu", dentry, dir->i_ino);\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\tdev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\tdevlen = ubifs_encode_dev(dev, rdev);\n	t
50145	324	process_page_range	fs/btrfs/tests/extent-io-tests.c	process_page_range_1$shl$$nr.addr.i.i42$obj$and$63$and$%addr.addr.i.i43$obj$0$obj	0	11	\N	\N	\tunsigned long i, j;\n\tu32 x;\n\tint ret;\n\n\tmemset(bitmap, 0, len);\n\tmemzero_extent_buffer(eb, 0, len);\n\tif (memcmp_extent_buffer(eb, bitmap, 0, len) != 0) {\n\t\ttest_msg("Bitmap was not zeroed\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_set(bitmap, 0, len * BITS_PER_BYTE);\n\textent_buffer_bitmap_set(eb, 0, 0, len * BITS_PER_BYTE);\n\tret = check_eb_bitmap(bitmap, eb, len);\n\tif (ret) {\n\t\ttest_msg("Setting all bits failed\\n");\n\t\treturn ret;\n\t}\n\n\tbitmap_clear(bitmap, 0, len * BITS_PER_BYTE);\n\textent_buffer_bitmap_clear(eb, 0, 0, len * BITS_PER_BYTE);\n	t
28863	99	cxd2820r_set_frontend_t	drivers/media/dvb-frontends/cxd2820r_t.c	if_frequency	1	13	\N	\N	\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, bw_i;\n\tunsigned int utmp;\n\tu32 if_frequency;\n\tu8 buf[3], bw_param;\n\tu8 bw_params1[][5] = {\n\t\t{ 0x17, 0xea, 0xaa, 0xaa, 0xaa }, /* 6 MHz */\n\t\t{ 0x14, 0x80, 0x00, 0x00, 0x00 }, /* 7 MHz */\n\t\t{ 0x11, 0xf0, 0x00, 0x00, 0x00 }, /* 8 MHz */\n\t};\n\tu8 bw_params2[][2] = {\n\t\t{ 0x1f, 0xdc }, /* 6 MHz */\n\t\t{ 0x12, 0xf8 }, /* 7 MHz */\n\t\t{ 0x01, 0xe0 }, /* 8 MHz */\n\t};\n\tstruct reg_val_mask tab[] = {\n\t\t{ 0x00080, 0x00, 0xff },\n\t\t{ 0x00081, 0x03, 0xff },\n\t\t{ 0x00085, 0x07, 0xff },\n\t\t{ 0x00088, 0x01, 0xff },\n\n\t\t{ 0x00070, priv->ts_mode, 0xff },\n\t\t{ 0x00071, !priv->ts_clk_inv << 4, 0x10 },\n\t\t{ 0x000cb, priv->if_agc_polarity << 6, 0x40 },\n\t\t{ 0x000a5, 0x00, 0x01 },\n\t\t{ 0x00082, 0x20, 0x60 },\n\t\t{ 0x000c2, 0xc3, 0xff },\n\t\t{ 0x0016a, 0x50, 0xff },\n\t\t{ 0x00427, 0x41, 0xff },\n\t};\n\n\tdev_dbg(&client->dev,\n\t\t"delivery_system=%d modulation=%d frequency=%u bandwidth_hz=%u inversion=%d\\n",\n\t\tc->delivery_system, c->modulation, c->frequency,\n\t\tc->bandwidth_hz, c->inversion);\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tbw_i = 0;\n\t\tbw_param = 2;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw_i = 1;\n\t\tbw_param = 1;\n\t\tbreak;\n\tcase 8000000:\n\t\tbw_i = 2;\n\t\tbw_param = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* program tuner */\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\tif (priv->delivery_system != SYS_DVBT) {\n\t\tret = cxd2820r_wr_reg_val_mask_tab(priv, tab, ARRAY_SIZE(tab));\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tpriv->delivery_system = SYS_DVBT;\n\tpriv->ber_running = false; /* tune stops BER counter */\n\n\t/* program IF frequency */\n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tdev_dbg(&client->dev, "if_frequency=%u\\n", if_frequency);\n	f
29028	245	rtl2832_set_if	drivers/media/dvb-frontends/rtl2832.c	ret	1	13	\N	\N	\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu64 pset_iffreq;\n\tu8 en_bbin = (if_freq == 0 ? 0x1 : 0x0);\n\n\t/*\n\t* PSET_IFFREQ = - floor((IfFreqHz % CrystalFreqHz) * pow(2, 22)\n\t*\t\t/ CrystalFreqHz)\n\t*/\n\tpset_iffreq = if_freq % dev->pdata->clk;\n\tpset_iffreq *= 0x400000;\n\tpset_iffreq = div_u64(pset_iffreq, dev->pdata->clk);\n\tpset_iffreq = -pset_iffreq;\n\tpset_iffreq = pset_iffreq & 0x3fffff;\n\tdev_dbg(&client->dev, "if_frequency=%d pset_iffreq=%08x\\n",\n\t\tif_freq, (unsigned)pset_iffreq);\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_EN_BBIN, en_bbin);\n\tif (ret)\n	f
3757	2268	psb_intel_sdvo_tv_create_property	drivers/gpu/drm/gma500/psb_intel_sdvo.c	format_map	1	11	\N	\N	\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tstruct psb_intel_sdvo_tv_format format;\n\tuint32_t format_map, i;\n\n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, type))\n\t\treturn false;\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPPORTED_TV_FORMATS,\n\t\t\t\t  &format, sizeof(format)))\n\t\treturn false;\n\n\tmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\n\n\tif (format_map == 0)\n	t
39311	246	btrfs_del_inode_ref	fs/btrfs/inode-item.c	ptr + sub_item_len	1	11	\N	\N	\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\tunsigned long item_start;\n\tu32 item_size;\n\tu32 sub_item_len;\n\tint ret;\n\tint search_ext_refs = 0;\n\tint del_len = name_len + sizeof(*ref);\n\n\tkey.objectid = inode_objectid;\n\tkey.offset = ref_objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t} else if (ret < 0) {\n\t\tgoto out;\n\t}\n\tif (!find_name_in_backref(path, name, name_len, &ref)) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(leaf, ref);\n\n\tif (del_len == item_size) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tgoto out;\n\t}\n\tptr = (unsigned long)ref;\n\tsub_item_len = name_len + sizeof(*ref);\n\titem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n	t
40678	4154	handle_backoff	net/ceph/osd_client.c	&m	1	11	\N	\N	\tstruct ceph_osd_client *osdc = osd->o_osdc;\n\tstruct MOSDBackoff m;\n\tint ret;\n\n\tdown_read(&osdc->lock);\n\tif (!osd_registered(osd)) {\n\t\tdout("%s osd%d unknown\\n", __func__, osd->o_osd);\n\t\tup_read(&osdc->lock);\n\t\treturn;\n\t}\n\tWARN_ON(osd->o_osd != le64_to_cpu(msg->hdr.src.num));\n\n\tmutex_lock(&osd->lock);\n\tret = decode_MOSDBackoff(msg, &m);\n\tif (ret) {\n\t\tpr_err("failed to decode MOSDBackoff: %d\\n", ret);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (m.op) {\n\tcase CEPH_OSD_BACKOFF_OP_BLOCK:\n\t\thandle_backoff_block(osd, &m);\n\t\tbreak;\n\tcase CEPH_OSD_BACKOFF_OP_UNBLOCK:\n\t\thandle_backoff_unblock(osd, &m);\n	t
47011	2944	drbd_adm_resource_opts	drivers/block/drbd/drbd_nl.c	adm_ctx.resource->adm_mutex	6	12	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tenum drbd_ret_code retcode;\n\tstruct res_opts res_opts;\n\tint err;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\n\tif (!adm_ctx.reply_skb)\n\t\treturn retcode;\n\tif (retcode != NO_ERROR)\n\t\tgoto fail;\n\n\tres_opts = adm_ctx.resource->res_opts;\n\tif (should_set_defaults(info))\n\t\tset_res_opts_defaults(&res_opts);\n\n\terr = res_opts_from_attrs(&res_opts, info);\n\tif (err && err != -ENOMSG) {\n\t\tretcode = ERR_MANDATORY_TAG;\n\t\tdrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\n\t\tgoto fail;\n\t}\n\n\tmutex_lock(&adm_ctx.resource->adm_mutex);\n	t
29064	519	anysee_read_config	drivers/media/usb/dvb-usb-v2/anysee.c	hw_info	1	13	\N	\N	\tstruct anysee_state *state = d_to_priv(d);\n\tint ret;\n\tu8 hw_info[3];\n\n\t/*\n\t * Check which hardware we have.\n\t * We must do this call two times to get reliable values (hw/fw bug).\n\t */\n\tret = anysee_get_hw_info(d, hw_info);\n\tif (ret)\n\t\tgoto error;\n\n\tret = anysee_get_hw_info(d, hw_info);\n\tif (ret)\n\t\tgoto error;\n\n\t/*\n\t * Meaning of these info bytes are guessed.\n\t */\n\tdev_info(&d->udev->dev, "%s: firmware version %d.%d hardware id %d\\n",\n	f
21783	1660	mlx5_ib_alloc_mr	drivers/infiniband/hw/mlx5/mr.c	mlx5_ib_alloc_mr_$mr$obj$29$obj$7$0$obj	0	11	\N	\N	\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tint ndescs = ALIGN(max_num_sg, 4);\n\tstruct mlx5_ib_mr *mr;\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tin = kzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, free, 1);\n\tMLX5_SET(mkc, mkc, translations_octword_size, ndescs);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\tMLX5_SET(mkc, mkc, pd, to_mpd(pd)->pdn);\n\n\tif (mr_type == IB_MR_TYPE_MEM_REG) {\n\t\tmr->access_mode = MLX5_MKC_ACCESS_MODE_MTT;\n\t\tMLX5_SET(mkc, mkc, log_page_size, PAGE_SHIFT);\n\t\terr = mlx5_alloc_priv_descs(pd->device, mr,\n\t\t\t\t\t    ndescs, sizeof(struct mlx5_mtt));\n\t\tif (err)\n\t\t\tgoto err_free_in;\n\n\t\tmr->desc_size = sizeof(struct mlx5_mtt);\n\t\tmr->max_descs = ndescs;\n\t} else if (mr_type == IB_MR_TYPE_SG_GAPS) {\n\t\tmr->access_mode = MLX5_MKC_ACCESS_MODE_KLMS;\n\n\t\terr = mlx5_alloc_priv_descs(pd->device, mr,\n\t\t\t\t\t    ndescs, sizeof(struct mlx5_klm));\n\t\tif (err)\n\t\t\tgoto err_free_in;\n\t\tmr->desc_size = sizeof(struct mlx5_klm);\n\t\tmr->max_descs = ndescs;\n\t} else if (mr_type == IB_MR_TYPE_SIGNATURE) {\n\t\tu32 psv_index[2];\n\n\t\tMLX5_SET(mkc, mkc, bsf_en, 1);\n\t\tMLX5_SET(mkc, mkc, bsf_octword_size, MLX5_MKEY_BSF_OCTO_SIZE);\n\t\tmr->sig = kzalloc(sizeof(*mr->sig), GFP_KERNEL);\n\t\tif (!mr->sig) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_in;\n\t\t}\n\n\t\t/* create mem & wire PSVs */\n\t\terr = mlx5_core_create_psv(dev->mdev, to_mpd(pd)->pdn,\n\t\t\t\t\t   2, psv_index);\n\t\tif (err)\n\t\t\tgoto err_free_sig;\n\n\t\tmr->access_mode = MLX5_MKC_ACCESS_MODE_KLMS;\n\t\tmr->sig->psv_memory.psv_idx = psv_index[0];\n\t\tmr->sig->psv_wire.psv_idx = psv_index[1];\n\n\t\tmr->sig->sig_status_checked = true;\n\t\tmr->sig->sig_err_exists = false;\n\t\t/* Next UMR, Arm SIGERR */\n\t\t++mr->sig->sigerr_count;\n\t} else {\n\t\tmlx5_ib_warn(dev, "Invalid mr type %d\\n", mr_type);\n\t\terr = -EINVAL;\n\t\tgoto err_free_in;\n\t}\n\n\tMLX5_SET(mkc, mkc, access_mode, mr->access_mode);\n\tMLX5_SET(mkc, mkc, umr_en, 1);\n\n\terr = mlx5_core_create_mkey(dev->mdev, &mr->mmkey, in, inlen);\n\tif (err)\n\t\tgoto err_destroy_psv;\n\n\tmr->mmkey.type = MLX5_MKEY_MR;\n\tmr->ibmr.lkey = mr->mmkey.key;\n\tmr->ibmr.rkey = mr->mmkey.key;\n\tmr->umem = NULL;\n\tkfree(in);\n\n\treturn &mr->ibmr;\n\nerr_destroy_psv:\n\tif (mr->sig) {\n\t\tif (mlx5_core_destroy_psv(dev->mdev,\n\t\t\t\t\t  mr->sig->psv_memory.psv_idx))\n\t\t\tmlx5_ib_warn(dev, "failed to destroy mem psv %d\\n",\n\t\t\t\t     mr->sig->psv_memory.psv_idx);\n\t\tif (mlx5_core_destroy_psv(dev->mdev,\n\t\t\t\t\t  mr->sig->psv_wire.psv_idx))\n\t\t\tmlx5_ib_warn(dev, "failed to destroy wire psv %d\\n",\n	t
47218	2106	t4_uld_rx_handler	drivers/scsi/cxgbi/cxgb4i/cxgb4i.c	t4_uld_rx_handler_$rpl$obj$0	0	11	\N	\N	\tconst struct cpl_act_establish *rpl;\n\tstruct sk_buff *skb;\n\tunsigned int opc;\n\tstruct cxgbi_device *cdev = handle;\n\n\tif (pgl == NULL) {\n\t\tunsigned int len = 64 - sizeof(struct rsp_ctrl) - 8;\n\n\t\tskb = alloc_wr(len, 0, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto nomem;\n\t\tskb_copy_to_linear_data(skb, &rsp[1], len);\n\t} else {\n\t\tif (unlikely(*(u8 *)rsp != *(u8 *)pgl->va)) {\n\t\t\tpr_info("? FL 0x%p,RSS%#llx,FL %#llx,len %u.\\n",\n\t\t\t\tpgl->va, be64_to_cpu(*rsp),\n\t\t\t\tbe64_to_cpu(*(u64 *)pgl->va),\n\t\t\t\tpgl->tot_len);\n\t\t\treturn 0;\n\t\t}\n\t\tskb = cxgb4_pktgl_to_skb(pgl, RX_PULL_LEN, RX_PULL_LEN);\n\t\tif (unlikely(!skb))\n\t\t\tgoto nomem;\n\t}\n\n\trpl = (struct cpl_act_establish *)skb->data;\n\topc = rpl->ot.opcode;\n	t
9247	571	__llc_lookup_listener	net/llc/llc_conn.c	__llc_lookup_listener_	1	11	\N	\N	\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_listener_match(sap, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_TYPESAFE_BY_RCU */\n\t\t\tif (unlikely(!refcount_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n	t
48119	4466	drbd_adm_down	drivers/block/drbd/drbd_nl.c	connection	6	12	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tstruct drbd_resource *resource;\n\tstruct drbd_connection *connection;\n\tstruct drbd_device *device;\n\tint retcode; /* enum drbd_ret_code rsp. enum drbd_state_rv */\n\tunsigned i;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\n\tif (!adm_ctx.reply_skb)\n\t\treturn retcode;\n\tif (retcode != NO_ERROR)\n\t\tgoto finish;\n\n\tresource = adm_ctx.resource;\n\tmutex_lock(&resource->adm_mutex);\n\t/* demote */\n\tfor_each_connection(connection, resource) {\n	t
50179	2059	d_add_ci	fs/dcache.c	d_add_ci_	1	11	\N	\N	\tstruct dentry *found, *res;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (found) {\n\t\tiput(inode);\n\t\treturn found;\n\t}\n\tif (d_in_lookup(dentry)) {\n\t\tfound = d_alloc_parallel(dentry->d_parent, name,\n\t\t\t\t\tdentry->d_wait);\n\t\tif (IS_ERR(found) || !d_in_lookup(found)) {\n	t
22039	774	__ath10k_pci_rx_post_buf	drivers/net/wireless/ath/ath10k/pci.c	__ath10k_pci_rx_post_buf_$__ret_warn_once$obj	0	11	\N	\N	\tstruct ath10k *ar = pipe->hif_ce_state;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_pipe = pipe->ce_hdl;\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tskb = dev_alloc_skb(pipe->buf_sz);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tWARN_ONCE((unsigned long)skb->data & 3, "unaligned skb");\n	t
47075	63	qedi_dbg_init	drivers/scsi/qedi/qedi_debugfs.c	qedi_dbg_init_@qedi_dbg_root $obj	0	11	\N	\N	\tqedi_dbg_root = debugfs_create_dir(drv_name, NULL);\n\tif (!qedi_dbg_root)\n	t
9446	777	agp_device_command	drivers/char/agp/generic.c	agp	1	11	\N	\N	\tstruct pci_dev *device = NULL;\n\tint mode;\n\n\tmode = bridge_agpstat & 0x7;\n\tif (agp_v3)\n\t\tmode *= 4;\n\n\tfor_each_pci_dev(device) {\n\t\tu8 agp = pci_find_capability(device, PCI_CAP_ID_AGP);\n\t\tif (!agp)\n	t
29585	475	af9035_i2c_master_xfer	drivers/media/usb/dvb-usb-v2/af9035.c	ret	1	11	\N	\N	\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct state *state = d_to_priv(d);\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * AF9035 I2C sub header is 5 bytes long. Meaning of those bytes are:\n\t * 0: data len\n\t * 1: I2C addr << 1\n\t * 2: reg addr len\n\t *    byte 3 and 4 can be used as reg addr\n\t * 3: reg addr MSB\n\t *    used when reg addr len is set to 2\n\t * 4: reg addr LSB\n\t *    used when reg addr len is set to 1 or 2\n\t *\n\t * For the simplify we do not use register addr at all.\n\t * NOTE: As a firmware knows tuner type there is very small possibility\n\t * there could be some tuner I2C hacks done by firmware and this may\n\t * lead problems if firmware expects those bytes are used.\n\t *\n\t * TODO: Here is few hacks. AF9035 chip integrates AF9033 demodulator.\n\t * IT9135 chip integrates AF9033 demodulator and RF tuner. For dual\n\t * tuner devices, there is also external AF9033 demodulator connected\n\t * via external I2C bus. All AF9033 demod I2C traffic, both single and\n\t * dual tuner configuration, is covered by firmware - actual USB IO\n\t * looks just like a memory access.\n\t * In case of IT913x chip, there is own tuner driver. It is implemented\n\t * currently as a I2C driver, even tuner IP block is likely build\n\t * directly into the demodulator memory space and there is no own I2C\n\t * bus. I2C subsystem does not allow register multiple devices to same\n\t * bus, having same slave address. Due to that we reuse demod address,\n\t * shifted by one bit, on that case.\n\t *\n\t * For IT930x we use a different command and the sub header is\n\t * different as well:\n\t * 0: data len\n\t * 1: I2C bus (0x03 seems to be only value used)\n\t * 2: I2C addr << 1\n\t */\n#define AF9035_IS_I2C_XFER_WRITE_READ(_msg, _num) \\\n\t(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_WRITE(_msg, _num) \\\n\t(_num == 1 && !(_msg[0].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_READ(_msg, _num) \\\n\t(_num == 1 && (_msg[0].flags & I2C_M_RD))\n\n\tif (AF9035_IS_I2C_XFER_WRITE_READ(msg, num)) {\n\t\tif (msg[0].len > 40 || msg[1].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\t/* demod access via firmware interface */\n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_rd_regs(d, reg, &msg[1].buf[0],\n\t\t\t\t\tmsg[1].len);\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[1].buf, 0, msg[1].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* I2C write + read */\n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, msg[1].len, msg[1].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\n\t\t\tbuf[0] = msg[1].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\n\t\t\t\t/* Keep prev behavior for write req len > 2*/\n\t\t\t\tif (msg[0].len > 2) {\n\t\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\n\t\t\t\t/* Use reg addr fields if write req len <= 2 */\n\t\t\t\t} else {\n\t\t\t\t\treq.wlen = 5;\n\t\t\t\t\tbuf[2] = msg[0].len;\n\t\t\t\t\tif (msg[0].len == 2) {\n\t\t\t\t\t\tbuf[3] = msg[0].buf[0];\n\t\t\t\t\t\tbuf[4] = msg[0].buf[1];\n\t\t\t\t\t} else if (msg[0].len == 1) {\n\t\t\t\t\t\tbuf[4] = msg[0].buf[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_WRITE(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\t/* demod access via firmware interface */\n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_wr_regs(d, reg, &msg[0].buf[3],\n\t\t\t\t\tmsg[0].len - 3);\n\t\t} else {\n\t\t\t/* I2C write */\n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_WR, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, 0, NULL };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_WR;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_READ(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[0].buf, 0, msg[0].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* I2C read */\n\t\t\tu8 buf[5];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\n\t\t\t\t\t\tbuf, msg[0].len, msg[0].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We support only three kind of I2C transactions:\n\t\t * 1) 1 x write + 1 x read (repeated start)\n\t\t * 2) 1 x write\n\t\t * 3) 1 x read\n\t\t */\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n	t
31220	725	__begin_transaction	drivers/md/dm-thin-metadata.c	sblock	1	11	\N	\N	\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t/*\n\t * We re-read the superblock every time.  Shouldn't need to do this\n\t * really.\n\t */\n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n	t
33350	817	ndev_init_debugfs	drivers/ntb/hw/amd/ntb_hw_amd.c	ndev->debugfs_dir	1	11	\N	\N	\tif (!debugfs_dir) {\n\t\tndev->debugfs_dir = NULL;\n\t\tndev->debugfs_info = NULL;\n\t} else {\n\t\tndev->debugfs_dir =\n\t\t\tdebugfs_create_dir(pci_name(ndev->ntb.pdev),\n\t\t\t\t\t   debugfs_dir);\n\t\tif (!ndev->debugfs_dir)\n	t
45320	1706	sis190_get_mac_addr	drivers/net/ethernet/sis/sis190.c	reg	1	11	\N	\N	\tint rc;\n\n\trc = sis190_get_mac_addr_from_eeprom(pdev, dev);\n\tif (rc < 0) {\n\t\tu8 reg;\n\n\t\tpci_read_config_byte(pdev, 0x73, &reg);\n\n\t\tif (reg & 0x00000001)\n	t
46110	356	ifi_canfd_handle_lost_msg	drivers/net/can/ifi_canfd/ifi_canfd.c	frame->can_id	1	11	\N	\N	\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\n\tnetdev_err(ndev, "RX FIFO overflow, message(s) lost.\\n");\n\n\tstats->rx_errors++;\n\tstats->rx_over_errors++;\n\n\tskb = alloc_can_err_skb(ndev, &frame);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tframe->can_id |= CAN_ERR_CRTL;\n	t
51992	1252	ufx_ops_set_par	drivers/video/fbdev/smscufx.c	result	1	11	\N	\N	\tstruct ufx_data *dev = info->par;\n\tint result;\n\tu16 *pix_framebuffer;\n\tint i;\n\n\tpr_debug("set_par mode %dx%d", info->var.xres, info->var.yres);\n\tresult = ufx_set_vid_mode(dev, &info->var);\n\n\tif ((result == 0) && (dev->fb_count == 0)) {\n	t
51867	576	beiscsi_if_en_dhcp	drivers/scsi/be2iscsi/be_mgmt.c	if_info->dhcp_state	1	13	\N	\N	\tstruct be_cmd_get_def_gateway_resp gw_resp;\n\tstruct be_cmd_get_if_info_resp *if_info;\n\tstruct be_cmd_set_dhcp_req *dhcpreq;\n\tstruct be_dma_mem nonemb_cmd;\n\tu8 *gw;\n\tint rc;\n\n\trc = beiscsi_if_get_info(phba, ip_type, &if_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (if_info->dhcp_state) {\n	f
62906	736	soft_store	net/rfkill/core.c	state	1	11	\N	\N	\tstruct rfkill *rfkill = to_rfkill(dev);\n\tunsigned long state;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\terr = kstrtoul(buf, 0, &state);\n\tif (err)\n\t\treturn err;\n\n\tif (state > 1 )\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rfkill_global_mutex);\n\trfkill_set_block(rfkill, state);\n	t
62902	454	ip6_frag_reasm	net/ipv6/reassembly.c	clone->truesize	1	11	\N	\N	\tstruct net *net = container_of(fq->q.net, struct net, ipv6.frags);\n\tstruct sk_buff *fp, *head = fq->q.fragments;\n\tint    payload_len;\n\tunsigned int nhoff;\n\tint sum_truesize;\n\tu8 ecn;\n\n\tinet_frag_kill(&fq->q, &ip6_frags);\n\n\tecn = ip_frag_ecn_table[fq->ecn];\n\tif (unlikely(ecn == 0xff))\n\t\tgoto out_fail;\n\n\t/* Make the one we just received the head. */\n\tif (prev) {\n\t\thead = prev->next;\n\t\tfp = skb_clone(head, GFP_ATOMIC);\n\n\t\tif (!fp)\n\t\t\tgoto out_oom;\n\n\t\tfp->next = head->next;\n\t\tif (!fp->next)\n\t\t\tfq->q.fragments_tail = fp;\n\t\tprev->next = fp;\n\n\t\tskb_morph(head, fq->q.fragments);\n\t\thead->next = fq->q.fragments->next;\n\n\t\tconsume_skb(fq->q.fragments);\n\t\tfq->q.fragments = head;\n\t}\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\tgoto out_oom;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (!clone)\n\t\t\tgoto out_oom;\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tadd_frag_mem_limit(fq->q.net, clone->truesize);\n	f
31355	1769	kvm_gen_update_masterclock	arch/x86/kvm/x86.c	vcpu	1	11	\N	\N	#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n	t
51638	172	hscx_interrupt	drivers/isdn/hisax/telespci.c	WRITE_DATA_HSCX | data[i]	1	11	\N	\N	\tunsigned int portdata;\n\tregister int i;\n\n\tZORAN_WAIT_NOBUSY;\n\t/* write data to HSCX */\n\tfor (i = 0; i < size; i++) {\n\t\t/* set address for HSCX fifo */\n\t\twritel(WRITE_ADDR_HSCX | (hscx ? 0x5F : 0x1F), adr + 0x200);\n\t\tZORAN_WAIT_NOBUSY;\n\t\twritel(WRITE_DATA_HSCX | data[i], adr + 0x200);\n	t
63093	85	llc_sap_action_send_xid_c	net/llc/llc_s_ac.c	skb	1	11	\N	\N	\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tint rc;\n\n\tllc_pdu_header_init(skb, LLC_PDU_TYPE_U, ev->saddr.lsap,\n\t\t\t    ev->daddr.lsap, LLC_PDU_CMD);\n\tllc_pdu_init_as_xid_cmd(skb, LLC_XID_NULL_CLASS_2, 0);\n\trc = llc_mac_hdr_init(skb, ev->saddr.mac, ev->daddr.mac);\n\tif (likely(!rc))\n\t\trc = dev_queue_xmit(skb);\n	f
63159	269	mag3110_trigger_handler	drivers/iio/magnetometer/mag3110.c	ret	1	11	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mag3110_data *data = iio_priv(indio_dev);\n\tu8 buffer[16]; /* 3 16-bit channels + 1 byte temp + padding + ts */\n\tint ret;\n\n\tret = mag3110_read(data, (__be16 *) buffer);\n\tif (ret < 0)\n	f
29124	429	vidioc_s_hw_freq_seek	drivers/media/radio/radio-tea5777.c	tea	1	13	\N	\N	\tstruct radio_tea5777 *tea = video_drvdata(file);\n\tunsigned long timeout;\n\tu32 rangelow = a->rangelow;\n\tu32 rangehigh = a->rangehigh;\n\tint i, res, spacing;\n\tu32 orig_freq;\n\n\tif (a->tuner || a->wrap_around)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tif (rangelow || rangehigh) {\n\t\tfor (i = 0; i < ARRAY_SIZE(bands); i++) {\n\t\t\tif (i == BAND_AM && !tea->has_am)\n\t\t\t\tcontinue;\n\t\t\tif (bands[i].rangelow  >= rangelow &&\n\t\t\t    bands[i].rangehigh <= rangehigh)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(bands))\n\t\t\treturn -EINVAL; /* No matching band found */\n\n\t\ttea->band = i;\n\t\tif (tea->freq < rangelow || tea->freq > rangehigh) {\n\t\t\ttea->freq = clamp(tea->freq, rangelow,\n\t\t\t\t\t\t     rangehigh);\n\t\t\tres = radio_tea5777_set_freq(tea);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} else {\n\t\trangelow  = bands[tea->band].rangelow;\n\t\trangehigh = bands[tea->band].rangehigh;\n\t}\n\n\tspacing   = (tea->band == BAND_AM) ? (5 * 16) : (200 * 16); /* kHz */\n\torig_freq = tea->freq;\n\n\ttea->write_reg |= TEA5777_W_PROGBLIM_MASK;\n\tif (tea->seek_rangelow != rangelow) {\n\t\ttea->write_reg &= ~TEA5777_W_UPDWN_MASK;\n\t\ttea->freq = rangelow;\n\t\tres = radio_tea5777_set_freq(tea);\n	f
5043	1043	set_pwm_auto_channels	drivers/hwmon/lm85.c	val	1	11	\N	\N	\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].config = (data->autofan[nr].config & (~0xe0))\n\t\t| ZONE_TO_REG(val);\n	t
62717	471	netvsc_start_xmit	drivers/net/hyperv/netvsc_drv.c	skb	0	11	\N	\N	\tstruct net_device_context *net_device_ctx = netdev_priv(net);\n\tstruct hv_netvsc_packet *packet = NULL;\n\tint ret;\n\tunsigned int num_data_pgs;\n\tstruct rndis_message *rndis_msg;\n\tstruct rndis_packet *rndis_pkt;\n\tstruct net_device *vf_netdev;\n\tu32 rndis_msg_size;\n\tstruct rndis_per_packet_info *ppi;\n\tu32 hash;\n\tstruct hv_page_buffer pb[MAX_PAGE_BUFFER_COUNT];\n\n\t/* if VF is present and up then redirect packets\n\t * already called with rcu_read_lock_bh\n\t */\n\tvf_netdev = rcu_dereference_bh(net_device_ctx->vf_netdev);\n\tif (vf_netdev && netif_running(vf_netdev) &&\n\t    !netpoll_tx_running(net))\n\t\treturn netvsc_vf_xmit(net, vf_netdev, skb);\n	f
53350	250	cyapa_gen6_read_sys_info	drivers/input/mouse/cyapa_gen6.c	cyapa_gen6_read_sys_info_$cyapa.addr$obj$30$obj	0	11	\N	\N	\tu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\n\tint resp_len;\n\tu16 product_family;\n\tu8 rotat_align;\n\tint error;\n\n\t/* Get App System Information to determine Gen5 or Gen6. */\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t2000, cyapa_pip_sort_system_info_data, false);\n\tif (error || resp_len < sizeof(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tproduct_family = get_unaligned_le16(&resp_data[7]);\n\tif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\n\t\tPIP_PRODUCT_FAMILY_TRACKPAD)\n\t\treturn -EINVAL;\n\n\tcyapa->platform_ver = (resp_data[67] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\tcyapa->fw_maj_ver = resp_data[9];\n\tcyapa->fw_min_ver = resp_data[10];\n\n\tcyapa->electrodes_x = resp_data[33];\n\tcyapa->electrodes_y = resp_data[34];\n\n\tcyapa->physical_size_x =  get_unaligned_le16(&resp_data[35]) / 100;\n\tcyapa->physical_size_y = get_unaligned_le16(&resp_data[37]) / 100;\n\n\tcyapa->max_abs_x = get_unaligned_le16(&resp_data[39]);\n\tcyapa->max_abs_y = get_unaligned_le16(&resp_data[41]);\n\n\tcyapa->max_z = get_unaligned_le16(&resp_data[43]);\n\n\tcyapa->x_origin = resp_data[45] & 0x01;\n\tcyapa->y_origin = resp_data[46] & 0x01;\n\n\tcyapa->btn_capability = (resp_data[70] << 3) & CAPABILITY_BTN_MASK;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[51], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[56], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[62], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\t/* Get the number of Rx electrodes. */\n\trotat_align = resp_data[68];\n\tcyapa->electrodes_rx =\n\t\trotat_align ? cyapa->electrodes_y : cyapa->electrodes_x;\n\tcyapa->aligned_electrodes_rx = (cyapa->electrodes_rx + 3) & ~3u;\n\n\tif (!cyapa->electrodes_x || !cyapa->electrodes_y ||\n	t
59469	11530	i40e_probe	drivers/net/ethernet/intel/i40e/i40e_main.c	pf->vsi	1	11	\N	\N	\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_pf *pf;\n\tstruct i40e_hw *hw;\n\tstatic u16 pfs_found;\n\tu16 wol_nvm_bits;\n\tu16 link_status;\n\tint err;\n\tu32 val;\n\tu32 i;\n\tu8 set_fc_aq_fail;\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\t/* set up for high or low dma */\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"DMA configuration failed: 0x%x\\n", err);\n\t\t\tgoto err_dma;\n\t\t}\n\t}\n\n\t/* set up pci connections */\n\terr = pci_request_mem_regions(pdev, i40e_driver_name);\n\tif (err) {\n\t\tdev_info(&pdev->dev,\n\t\t\t "pci_request_selected_regions failed %d\\n", err);\n\t\tgoto err_pci_reg;\n\t}\n\n\tpci_enable_pcie_error_reporting(pdev);\n\tpci_set_master(pdev);\n\n\t/* Now that we have a PCI connection, we need to do the\n\t * low level device setup.  This is primarily setting up\n\t * the Admin Queue structures and then querying for the\n\t * device's current profile information.\n\t */\n\tpf = kzalloc(sizeof(*pf), GFP_KERNEL);\n\tif (!pf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pf_alloc;\n\t}\n\tpf->next_vsi = 0;\n\tpf->pdev = pdev;\n\tset_bit(__I40E_DOWN, pf->state);\n\n\thw = &pf->hw;\n\thw->back = pf;\n\n\tpf->ioremap_len = min_t(int, pci_resource_len(pdev, 0),\n\t\t\t\tI40E_MAX_CSR_SPACE);\n\n\thw->hw_addr = ioremap(pci_resource_start(pdev, 0), pf->ioremap_len);\n\tif (!hw->hw_addr) {\n\t\terr = -EIO;\n\t\tdev_info(&pdev->dev, "ioremap(0x%04x, 0x%04x) failed: 0x%x\\n",\n\t\t\t (unsigned int)pci_resource_start(pdev, 0),\n\t\t\t pf->ioremap_len, err);\n\t\tgoto err_ioremap;\n\t}\n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\tpci_read_config_byte(pdev, PCI_REVISION_ID, &hw->revision_id);\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_device_id = pdev->subsystem_device;\n\thw->bus.device = PCI_SLOT(pdev->devfn);\n\thw->bus.func = PCI_FUNC(pdev->devfn);\n\thw->bus.bus_id = pdev->bus->number;\n\tpf->instance = pfs_found;\n\n\tINIT_LIST_HEAD(&pf->l3_flex_pit_list);\n\tINIT_LIST_HEAD(&pf->l4_flex_pit_list);\n\n\t/* set up the locks for the AQ, do this only once in probe\n\t * and destroy them only once in remove\n\t */\n\tmutex_init(&hw->aq.asq_mutex);\n\tmutex_init(&hw->aq.arq_mutex);\n\n\tpf->msg_enable = netif_msg_init(debug,\n\t\t\t\t\tNETIF_MSG_DRV |\n\t\t\t\t\tNETIF_MSG_PROBE |\n\t\t\t\t\tNETIF_MSG_LINK);\n\tif (debug < -1)\n\t\tpf->hw.debug_mask = debug;\n\n\t/* do a special CORER for clearing PXE mode once at init */\n\tif (hw->revision_id == 0 &&\n\t    (rd32(hw, I40E_GLLAN_RCTL_0) & I40E_GLLAN_RCTL_0_PXE_MODE_MASK)) {\n\t\twr32(hw, I40E_GLGEN_RTRIG, I40E_GLGEN_RTRIG_CORER_MASK);\n\t\ti40e_flush(hw);\n\t\tmsleep(200);\n\t\tpf->corer_count++;\n\n\t\ti40e_clear_pxe_mode(hw);\n\t}\n\n\t/* Reset here to make sure all is clean and to define PF 'n' */\n\ti40e_clear_hw(hw);\n\terr = i40e_pf_reset(hw);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "Initial pf_reset failed: %d\\n", err);\n\t\tgoto err_pf_reset;\n\t}\n\tpf->pfr_count++;\n\n\thw->aq.num_arq_entries = I40E_AQ_LEN;\n\thw->aq.num_asq_entries = I40E_AQ_LEN;\n\thw->aq.arq_buf_size = I40E_MAX_AQ_BUF_SIZE;\n\thw->aq.asq_buf_size = I40E_MAX_AQ_BUF_SIZE;\n\tpf->adminq_work_limit = I40E_AQ_WORK_LIMIT;\n\n\tsnprintf(pf->int_name, sizeof(pf->int_name) - 1,\n\t\t "%s-%s:misc",\n\t\t dev_driver_string(&pf->pdev->dev), dev_name(&pdev->dev));\n\n\terr = i40e_init_shared_code(hw);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, "unidentified MAC or BLANK NVM: %d\\n",\n\t\t\t err);\n\t\tgoto err_pf_reset;\n\t}\n\n\t/* set up a default setting for link flow control */\n\tpf->hw.fc.requested_mode = I40E_FC_NONE;\n\n\terr = i40e_init_adminq(hw);\n\tif (err) {\n\t\tif (err == I40E_ERR_FIRMWARE_API_VERSION)\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t "The driver for the device stopped because the NVM image is newer than expected. You must install the most recent version of the network driver.\\n");\n\t\telse\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t "The driver for the device stopped because the device firmware failed to init. Try updating your NVM image.\\n");\n\n\t\tgoto err_pf_reset;\n\t}\n\ti40e_get_oem_version(hw);\n\n\t/* provide nvm, fw, api versions */\n\tdev_info(&pdev->dev, "fw %d.%d.%05d api %d.%d nvm %s\\n",\n\t\t hw->aq.fw_maj_ver, hw->aq.fw_min_ver, hw->aq.fw_build,\n\t\t hw->aq.api_maj_ver, hw->aq.api_min_ver,\n\t\t i40e_nvm_version_str(hw));\n\n\tif (hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&\n\t    hw->aq.api_min_ver > I40E_FW_API_VERSION_MINOR)\n\t\tdev_info(&pdev->dev,\n\t\t\t "The driver for the device detected a newer version of the NVM image than expected. Please install the most recent version of the network driver.\\n");\n\telse if (hw->aq.api_maj_ver < I40E_FW_API_VERSION_MAJOR ||\n\t\t hw->aq.api_min_ver < (I40E_FW_API_VERSION_MINOR - 1))\n\t\tdev_info(&pdev->dev,\n\t\t\t "The driver for the device detected an older version of the NVM image than expected. Please update the NVM image.\\n");\n\n\ti40e_verify_eeprom(pf);\n\n\t/* Rev 0 hardware was never productized */\n\tif (hw->revision_id < 1)\n\t\tdev_warn(&pdev->dev, "This device is a pre-production adapter/LOM. Please be aware there may be issues with your hardware. If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\\n");\n\n\ti40e_clear_pxe_mode(hw);\n\terr = i40e_get_capabilities(pf);\n\tif (err)\n\t\tgoto err_adminq_setup;\n\n\terr = i40e_sw_init(pf);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "sw_init failed: %d\\n", err);\n\t\tgoto err_sw_init;\n\t}\n\n\terr = i40e_init_lan_hmc(hw, hw->func_caps.num_tx_qp,\n\t\t\t\thw->func_caps.num_rx_qp, 0, 0);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "init_lan_hmc failed: %d\\n", err);\n\t\tgoto err_init_lan_hmc;\n\t}\n\n\terr = i40e_configure_lan_hmc(hw, I40E_HMC_MODEL_DIRECT_ONLY);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "configure_lan_hmc failed: %d\\n", err);\n\t\terr = -ENOENT;\n\t\tgoto err_configure_lan_hmc;\n\t}\n\n\t/* Disable LLDP for NICs that have firmware versions lower than v4.3.\n\t * Ignore error return codes because if it was already disabled via\n\t * hardware settings this will fail\n\t */\n\tif (pf->hw_features & I40E_HW_STOP_FW_LLDP) {\n\t\tdev_info(&pdev->dev, "Stopping firmware LLDP agent.\\n");\n\t\ti40e_aq_stop_lldp(hw, true, NULL);\n\t}\n\n\t/* allow a platform config to override the HW addr */\n\ti40e_get_platform_mac_addr(pdev, pf);\n\n\tif (!is_valid_ether_addr(hw->mac.addr)) {\n\t\tdev_info(&pdev->dev, "invalid MAC address %pM\\n", hw->mac.addr);\n\t\terr = -EIO;\n\t\tgoto err_mac_addr;\n\t}\n\tdev_info(&pdev->dev, "MAC address: %pM\\n", hw->mac.addr);\n\tether_addr_copy(hw->mac.perm_addr, hw->mac.addr);\n\ti40e_get_port_mac_addr(hw, hw->mac.port_addr);\n\tif (is_valid_ether_addr(hw->mac.port_addr))\n\t\tpf->hw_features |= I40E_HW_PORT_ID_VALID;\n\n\tpci_set_drvdata(pdev, pf);\n\tpci_save_state(pdev);\n#ifdef CONFIG_I40E_DCB\n\terr = i40e_init_pf_dcb(pf);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "DCB init failed %d, disabled\\n", err);\n\t\tpf->flags &= ~(I40E_FLAG_DCB_CAPABLE | I40E_FLAG_DCB_ENABLED);\n\t\t/* Continue without DCB enabled */\n\t}\n#endif /* CONFIG_I40E_DCB */\n\n\t/* set up periodic task facility */\n\tsetup_timer(&pf->service_timer, i40e_service_timer, (unsigned long)pf);\n\tpf->service_timer_period = HZ;\n\n\tINIT_WORK(&pf->service_task, i40e_service_task);\n\tclear_bit(__I40E_SERVICE_SCHED, pf->state);\n\n\t/* NVM bit on means WoL disabled for the port */\n\ti40e_read_nvm_word(hw, I40E_SR_NVM_WAKE_ON_LAN, &wol_nvm_bits);\n\tif (BIT (hw->port) & wol_nvm_bits || hw->partition_id != 1)\n\t\tpf->wol_en = false;\n\telse\n\t\tpf->wol_en = true;\n\tdevice_set_wakeup_enable(&pf->pdev->dev, pf->wol_en);\n\n\t/* set up the main switch operations */\n\ti40e_determine_queue_usage(pf);\n\terr = i40e_init_interrupt_scheme(pf);\n\tif (err)\n\t\tgoto err_switch_setup;\n\n\t/* The number of VSIs reported by the FW is the minimum guaranteed\n\t * to us; HW supports far more and we share the remaining pool with\n\t * the other PFs. We allocate space for more than the guarantee with\n\t * the understanding that we might not get them all later.\n\t */\n\tif (pf->hw.func_caps.num_vsis < I40E_MIN_VSI_ALLOC)\n\t\tpf->num_alloc_vsi = I40E_MIN_VSI_ALLOC;\n\telse\n\t\tpf->num_alloc_vsi = pf->hw.func_caps.num_vsis;\n\n\t/* Set up the *vsi struct and our local tracking of the MAIN PF vsi. */\n\tpf->vsi = kcalloc(pf->num_alloc_vsi, sizeof(struct i40e_vsi *),\n\t\t\t  GFP_KERNEL);\n\tif (!pf->vsi) {\n\t\terr = -ENOMEM;\n\t\tgoto err_switch_setup;\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\t/* prep for VF support */\n\tif ((pf->flags & I40E_FLAG_SRIOV_ENABLED) &&\n\t    (pf->flags & I40E_FLAG_MSIX_ENABLED) &&\n\t    !test_bit(__I40E_BAD_EEPROM, pf->state)) {\n\t\tif (pci_num_vf(pdev))\n\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\t}\n#endif\n\terr = i40e_setup_pf_switch(pf, false);\n\tif (err) {\n\t\tdev_info(&pdev->dev, "setup_pf_switch failed: %d\\n", err);\n\t\tgoto err_vsis;\n\t}\n\n\t/* Make sure flow control is set according to current settings */\n\terr = i40e_set_fc(hw, &set_fc_aq_fail, true);\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_GET)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t"Set fc with err %s aq_err %s on get_phy_cap\\n",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_SET)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t"Set fc with err %s aq_err %s on set_phy_config\\n",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_UPDATE)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t"Set fc with err %s aq_err %s on get_link_info\\n",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\n\t/* if FDIR VSI was set up, start it now */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i] && pf->vsi[i]->type == I40E_VSI_FDIR) {\n	t
60651	61	adis16400_show_serial_number	drivers/iio/imu/adis16400_core.c	serial_number	1	11	\N	\N	\tstruct adis16400_state *st = file->private_data;\n\tu16 lot1, lot2, serial_number;\n\tchar buf[16];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID1, &lot1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID2, &lot2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_SERIAL_NUMBER,\n\t\t\t&serial_number);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), "%.4x-%.4x-%.4x\\n", lot1, lot2,\n	t
44722	2104	xfs_dir2_node_lookup	fs/xfs/libxfs/xfs_dir2_node.c	xfs_dir2_node_lookup_$state$obj$17$obj	0	11	\N	\N	\tint\t\terror;\t\t\t/* error return value */\n\tint\t\ti;\t\t\t/* btree level */\n\tint\t\trval;\t\t\t/* operation return value */\n\txfs_da_state_t\t*state;\t\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Fill in the path to the entry in the cursor.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t/* If a CI match, dup the actual name and return -EEXIST */\n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t/*\n\t * Release the btree blocks and leaf block.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t/*\n\t * Release the data block if we have it.\n\t */\n\tif (state->extravalid && state->extrablk.bp) {\n	t
20489	332	amdgpu_sync_free	drivers/gpu/drm/amd/amdgpu/amdgpu_sync.c	amdgpu_sync_free_$____ptr13$obj	0	11	\N	\N	\tstruct amdgpu_sync_entry *e;\n\tstruct hlist_node *tmp;\n\tunsigned i;\n\n\thash_for_each_safe(sync->fences, i, tmp, e, node) {\n	t
34814	3202	relocate_file_extent_cluster	fs/btrfs/relocation.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n	t
36912	2264	panel_power_on_store	drivers/platform/x86/toshiba_acpi.c	state	1	11	\N	\N	\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n	t
56148	598	ceph_sync_read	fs/ceph/file.c	num_pages	1	13	\N	\N	\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages;\n\tu64 off = iocb->ki_pos;\n\tint num_pages;\n\tssize_t ret;\n\tsize_t len = iov_iter_count(to);\n\n\tdout("sync_read on file %p %llu~%u %s\\n", file, off, (unsigned)len,\n\t     (file->f_flags & O_DIRECT) ? "O_DIRECT" : "");\n\n\tif (!len)\n\t\treturn 0;\n\t/*\n\t * flush any page cache pages in this range.  this\n\t * will make concurrent normal and sync io slow,\n\t * but it will at least behave sensibly when they are\n\t * in sequence.\n\t */\n\tret = filemap_write_and_wait_range(inode->i_mapping, off,\n\t\t\t\t\t\toff + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (unlikely(to->type & ITER_PIPE)) {\n\t\tsize_t page_off;\n\t\tret = iov_iter_get_pages_alloc(to, &pages, len,\n\t\t\t\t\t       &page_off);\n\t\tif (ret <= 0)\n\t\t\treturn -ENOMEM;\n\t\tnum_pages = DIV_ROUND_UP(ret + page_off, PAGE_SIZE);\n\n\t\tret = striped_read(inode, off, ret, pages, num_pages,\n\t\t\t\t   page_off, checkeof);\n\t\tif (ret > 0) {\n\t\t\tiov_iter_advance(to, ret);\n\t\t\toff += ret;\n\t\t} else {\n\t\t\tiov_iter_advance(to, 0);\n\t\t}\n\t\tceph_put_page_vector(pages, num_pages, false);\n	f
26663	1788	unuse_pte	mm/swapfile.c	memcg	7	12	\N	\N	\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n	t
62676	913	nau8824_interrupt	sound/soc/codecs/nau8824.c	active_irq	1	11	\N	\N	\tstruct nau8824 *nau8824 = (struct nau8824 *)data;\n\tstruct regmap *regmap = nau8824->regmap;\n\tint active_irq, clear_irq = 0, event = 0, event_mask = 0;\n\n\tif (regmap_read(regmap, NAU8824_REG_IRQ, &active_irq)) {\n\t\tdev_err(nau8824->dev, "failed to read irq status\\n");\n\t\treturn IRQ_NONE;\n\t}\n\tdev_dbg(nau8824->dev, "IRQ %x\\n", active_irq);\n\n\tif (active_irq & NAU8824_JACK_EJECTION_DETECTED) {\n\t\tnau8824_eject_jack(nau8824);\n\t\tevent_mask |= SND_JACK_HEADSET;\n\t\tclear_irq = NAU8824_JACK_EJECTION_DETECTED;\n\t\t/* release semaphore held after resume,\n\t\t * and cancel jack detection\n\t\t */\n\t\tnau8824_sema_release(nau8824);\n\t\tcancel_work_sync(&nau8824->jdet_work);\n\t} else if (active_irq & NAU8824_KEY_SHORT_PRESS_IRQ) {\n	t
28888	1159	stb0899_dvbs2_get_fec_status	drivers/media/dvb-frontends/stb0899_algo.c	Locked	1	13	\N	\N	\tint time = 0, Locked;\n\n\tdo {\n\t\tLocked = stb0899_dvbs2_get_data_lock(state, 1);\n\t\ttime++;\n\t\tmsleep(1);\n\n\t} while ((!Locked) && (time < timeout));\n	f
40458	415	enable_camera	drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c	ret	1	11	\N	\N	\tint ret;\n\n\tif (!dev->camera_use_count) {\n\t\tret = vchiq_mmal_port_parameter_set(\n\t\t\tdev->instance,\n\t\t\t&dev->component[MMAL_COMPONENT_CAMERA]->control,\n\t\t\tMMAL_PARAMETER_CAMERA_NUM, &dev->camera_num,\n\t\t\tsizeof(dev->camera_num));\n\t\tif (ret < 0) {\n	t
20720	183	acpi_db_execute_method	drivers/acpi/acpica/dbexec.c	status	2	-11	\N	\N	\tacpi_status status;\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[ACPI_DEBUGGER_MAX_ARGS + 1];\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(db_execute_method);\n\n\tif (acpi_gbl_db_output_to_file && !acpi_dbg_level) {\n\t\tacpi_os_printf("Warning: debug output is not enabled!\\n");\n\t}\n\n\tparam_objects.count = 0;\n\tparam_objects.pointer = NULL;\n\n\t/* Pass through any command-line arguments */\n\n\tif (info->args && info->args[0]) {\n\n\t\t/* Get arguments passed on the command line */\n\n\t\tfor (i = 0; (info->args[i] && *(info->args[i])); i++) {\n\n\t\t\t/* Convert input string (token) to an actual union acpi_object */\n\n\t\t\tstatus = acpi_db_convert_to_object(info->types[i],\n\t\t\t\t\t\t\t   info->args[i],\n\t\t\t\t\t\t\t   &params[i]);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t"While parsing method arguments"));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tparam_objects.count = i;\n\t\tparam_objects.pointer = params;\n\t}\n\n\t/* Prepare for a return object of arbitrary size */\n\n\treturn_obj->pointer = acpi_gbl_db_buffer;\n\treturn_obj->length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t/* Do the actual method execution */\n\n\tacpi_gbl_method_executing = TRUE;\n\tstatus = acpi_evaluate_object(NULL, info->pathname,\n\t\t\t\t      &param_objects, return_obj);\n\n\tacpi_gbl_cm_single_step = FALSE;\n\tacpi_gbl_method_executing = FALSE;\n\n\tif (ACPI_FAILURE(status)) {\n	t
47028	2901	ath10k_wmi_tlv_op_gen_wow_enable	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_wow_enable_$tlv$obj$0	0	11	\N	\N	\tstruct wmi_tlv_wow_enable_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (struct wmi_tlv *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ENABLE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n	t
37993	668	debugfs_init	arch/x86/kernel/cpu/mcheck/mce-inject.c	debugfs_init_@dfs_inj $obj	0	13	\N	\N	\tunsigned int i;\n\tu64 cap;\n\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\tn_banks = cap & MCG_BANKCNT_MASK;\n\n\tdfs_inj = debugfs_create_dir("mce-inject", NULL);\n\tif (!dfs_inj)\n	f
60704	1509	hfsc_destroy_qdisc	net/sched/sch_hfsc.c	hfsc_destroy_qdisc_$__mptr57$obj	0	13	\N	\N	\tstruct hfsc_sched *q = qdisc_priv(sch);\n\tstruct hlist_node *next;\n\tstruct hfsc_class *cl;\n\tunsigned int i;\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry(cl, &q->clhash.hash[i], cl_common.hnode) {\n\t\t\ttcf_block_put(cl->block);\n\t\t\tcl->block = NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry_safe(cl, next, &q->clhash.hash[i],\n	f
1402	115	xfs_refcount_get_rec	fs/xfs/libxfs/xfs_refcount.c	rec	1	13	\N	\N	\tunion xfs_btree_rec\t\t*rec;\n\tint\t\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\txfs_refcount_btrec_to_irec(rec, irec);\n	f
4565	150	humidity1_input_show	drivers/hwmon/shtc1.c	data->humidity	1	13	\N	\N	\tstruct shtc1_data *data = shtc1_update_client(dev);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, "%d\\n", data->humidity);\n	f
7883	1158	ar5523_get_wlan_mode	drivers/net/wireless/ath/ar5523/ar5523.c	sta_rate_set	1	13	\N	\N	\tstruct ieee80211_supported_band *band;\n\tint bit;\n\tstruct ieee80211_sta *sta;\n\tu32 sta_rate_set;\n\n\tband = ar->hw->wiphy->bands[ar->hw->conf.chandef.chan->band];\n\tsta = ieee80211_find_sta(ar->vif, bss_conf->bssid);\n\tif (!sta) {\n\t\tar5523_info(ar, "STA not found!\\n");\n\t\treturn WLAN_MODE_11b;\n\t}\n\tsta_rate_set = sta->supp_rates[ar->hw->conf.chandef.chan->band];\n	f
21527	473	br_ifinfo_notify	net/bridge/br_netlink.c	skb	1	13	\N	\N	\tstruct net *net;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tu32 filter = RTEXT_FILTER_BRVLAN_COMPRESSED;\n\n\tif (!port)\n\t\treturn;\n\n\tnet = dev_net(port->dev);\n\tbr_debug(port->br, "port %u(%s) event %d\\n",\n\t\t (unsigned int)port->port_no, port->dev->name, event);\n\n\tskb = nlmsg_new(br_nlmsg_size(port->dev, filter), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = br_fill_ifinfo(skb, port, 0, 0, event, 0, filter, port->dev);\n	f
29415	185	tps6586x_rtc_set_alarm	drivers/rtc/rtc-tps6586x.c	ret	1	13	\N	\N	\tstruct tps6586x_rtc *rtc = dev_get_drvdata(dev);\n\tstruct device *tps_dev = to_tps6586x_dev(dev);\n\tunsigned long seconds;\n\tunsigned long ticks;\n\tunsigned long rtc_current_time;\n\tunsigned long long rticks = 0;\n\tu8 buff[3];\n\tu8 rbuff[6];\n\tint ret;\n\tint i;\n\n\trtc_tm_to_time(&alrm->time, &seconds);\n\n\tif (alrm->enabled && (seconds < rtc->epoch_start)) {\n\t\tdev_err(dev, "can't set alarm to requested time\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tret = tps6586x_rtc_alarm_irq_enable(dev, alrm->enabled);\n\tif (ret < 0) {\n\t\tdev_err(dev, "can't set alarm irq, err %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tseconds -= rtc->epoch_start;\n\tret = tps6586x_reads(tps_dev, RTC_COUNT4_DUMMYREAD,\n\t\t\tsizeof(rbuff), rbuff);\n\tif (ret < 0) {\n	f
29474	1131	perf_trace_kvm_hv_stimer_set_config	arch/x86/kvm/x86.c	vcpu	1	13	\N	\N	\tstruct msr_data msr;\n\tint r;\n\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n	f
24544	2179	reorder	drivers/scsi/eata.c	reorder_$vla$0$obj$add$%vla2$0$obj	0	11	\N	\N	\tstruct scsi_cmnd *SCpnt;\n\tstruct mscp *cpp;\n\tunsigned int k, n;\n\tunsigned int rev = 0, s = 1, r = 1;\n\tunsigned int input_only = 1, overlap = 0;\n\tunsigned long sl[n_ready], pl[n_ready], ll[n_ready];\n\tunsigned long maxsec = 0, minsec = ULONG_MAX, seek = 0, iseek = 0;\n\tunsigned long ioseek = 0;\n\n\tstatic unsigned int flushcount = 0, batchcount = 0, sortcount = 0;\n\tstatic unsigned int readycount = 0, ovlcount = 0, inputcount = 0;\n\tstatic unsigned int readysorted = 0, revcount = 0;\n\tstatic unsigned long seeksorted = 0, seeknosort = 0;\n\n\tif (link_statistics && !(++flushcount % link_statistics))\n\t\tprintk("fc %d bc %d ic %d oc %d rc %d rs %d sc %d re %d"\n\t\t       " av %ldK as %ldK.\\n", flushcount, batchcount,\n\t\t       inputcount, ovlcount, readycount, readysorted, sortcount,\n\t\t       revcount, seeknosort / (readycount + 1),\n\t\t       seeksorted / (readycount + 1));\n\n\tif (n_ready <= 1)\n\t\treturn 0;\n\n\tfor (n = 0; n < n_ready; n++) {\n\t\tk = il[n];\n\t\tcpp = &ha->cp[k];\n\t\tSCpnt = cpp->SCpnt;\n\n\t\tif (!cpp->din)\n\t\t\tinput_only = 0;\n\n\t\tif (blk_rq_pos(SCpnt->request) < minsec)\n\t\t\tminsec = blk_rq_pos(SCpnt->request);\n\t\tif (blk_rq_pos(SCpnt->request) > maxsec)\n\t\t\tmaxsec = blk_rq_pos(SCpnt->request);\n\n\t\tsl[n] = blk_rq_pos(SCpnt->request);\n\t\tioseek += blk_rq_sectors(SCpnt->request);\n\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (sl[n] < sl[n - 1])\n\t\t\ts = 0;\n\t\tif (sl[n] > sl[n - 1])\n\t\t\tr = 0;\n\n\t\tif (link_statistics) {\n\t\t\tif (sl[n] > sl[n - 1])\n\t\t\t\tseek += sl[n] - sl[n - 1];\n\t\t\telse\n\t\t\t\tseek += sl[n - 1] - sl[n];\n\t\t}\n\n\t}\n\n\tif (link_statistics) {\n\t\tif (cursec > sl[0])\n\t\t\tseek += cursec - sl[0];\n\t\telse\n\t\t\tseek += sl[0] - cursec;\n\t}\n\n\tif (cursec > ((maxsec + minsec) / 2))\n\t\trev = 1;\n\n\tif (ioseek > ((maxsec - minsec) / 2))\n\t\trev = 0;\n\n\tif (!((rev && r) || (!rev && s)))\n\t\tsort(sl, il, n_ready, rev);\n\n\tif (!input_only)\n\t\tfor (n = 0; n < n_ready; n++) {\n\t\t\tk = il[n];\n\t\t\tcpp = &ha->cp[k];\n\t\t\tSCpnt = cpp->SCpnt;\n\t\t\tll[n] = blk_rq_sectors(SCpnt->request);\n\t\t\tpl[n] = SCpnt->serial_number;\n\n\t\t\tif (!n)\n\t\t\t\tcontinue;\n\n\t\t\tif ((sl[n] == sl[n - 1])\n\t\t\t    || (!rev && ((sl[n - 1] + ll[n - 1]) > sl[n]))\n	t
4389	75	syscon_gpio_get	drivers/gpio/gpio-syscon.c	offs	1	11	\N	\N	\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int val, offs;\n\tint ret;\n\n\toffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\n\n\tret = regmap_read(priv->syscon,\n\t\t\t  (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offs % SYSCON_REG_BITS));\n	t
3326	994	mt9v032_get_pdata	drivers/media/i2c/mt9v032.c	&endpoint) < 0	1	11	\N	\N	\tstruct mt9v032_platform_data *pdata = NULL;\n\tstruct v4l2_fwnode_endpoint endpoint;\n\tstruct device_node *np;\n\tstruct property *prop;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tnp = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!np)\n\t\treturn NULL;\n\n\tif (v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &endpoint) < 0)\n	t
43347	993	alx_request_irq	drivers/net/ethernet/atheros/alx/main.c	err	1	11	\N	\N	\tstruct pci_dev *pdev = alx->hw.pdev;\n\tstruct alx_hw *hw = &alx->hw;\n\tint err;\n\tu32 msi_ctrl;\n\n\tmsi_ctrl = (hw->imt >> 1) << ALX_MSI_RETRANS_TM_SHIFT;\n\n\tif (alx->hw.pdev->msix_enabled) {\n\t\talx_write_mem32(hw, ALX_MSI_RETRANS_TIMER, msi_ctrl);\n\t\terr = alx_request_msix(alx);\n\t\tif (!err)\n\t\t\tgoto out;\n\n\t\t/* msix request failed, realloc resources */\n\t\terr = alx_realloc_resources(alx);\n\t\tif (err)\n	t
47161	46	ras_add_daemon_trace	drivers/ras/debugfs.c	fentry	1	11	\N	\N	\tstruct dentry *fentry;\n\n\tif (!ras_debugfs_dir)\n\t\treturn -ENOENT;\n\n\tfentry = debugfs_create_file("daemon_active", S_IRUSR, ras_debugfs_dir,\n\t\t\t\t     NULL, &trace_fops);\n\tif (!fentry)\n	t
53590	759	da9063_regulator_probe	drivers/regulator/da9063-regulator.c	val	1	11	\N	\N	\tstruct da9063 *da9063 = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9063_pdata *da9063_pdata = dev_get_platdata(da9063->dev);\n\tstruct of_regulator_match *da9063_reg_matches = NULL;\n\tstruct da9063_regulators_pdata *regl_pdata;\n\tconst struct da9063_dev_model *model;\n\tstruct da9063_regulators *regulators;\n\tstruct da9063_regulator *regl;\n\tstruct regulator_config config;\n\tbool bcores_merged, bmem_bio_merged;\n\tint id, irq, n, n_regulators, ret, val;\n\tsize_t size;\n\n\tregl_pdata = da9063_pdata ? da9063_pdata->regulators_pdata : NULL;\n\n\tif (!regl_pdata)\n\t\tregl_pdata = da9063_parse_regulators_dt(pdev,\n\t\t\t\t\t\t\t&da9063_reg_matches);\n\n\tif (IS_ERR(regl_pdata) || regl_pdata->n_regulators == 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t"No regulators defined for the platform\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Find regulators set for particular device model */\n\tfor (model = regulators_models; model->regulator_info; model++) {\n\t\tif (model->dev_model == da9063->model)\n\t\t\tbreak;\n\t}\n\tif (!model->regulator_info) {\n\t\tdev_err(&pdev->dev, "Chip model not recognised (%u)\\n",\n\t\t\tda9063->model);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(da9063->regmap, DA9063_REG_CONFIG_H, &val);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t"Error while reading BUCKs configuration\\n");\n\t\treturn ret;\n\t}\n\tbcores_merged = val & DA9063_BCORE_MERGE;\n	t
58198	512	snd_ak4113_build	sound/i2c/other/ak4113.c	kctl	1	11	\N	\N	\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cap_substream))\n\t\treturn -EINVAL;\n\tak4113->substream = cap_substream;\n\tfor (idx = 0; idx < AK4113_CONTROLS; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_ak4113_iec958_controls[idx], ak4113);\n\t\tif (kctl == NULL)\n	t
48845	285	tproxy_handle_time_wait4	net/netfilter/xt_TPROXY.c	sk2	1	13	\N	\N	\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct tcphdr _hdr, *hp;\n\n\thp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\n\tif (hp == NULL) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn NULL;\n\t}\n\n\tif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\n\t\t/* SYN to a TIME_WAIT socket, we'd rather redirect it\n\t\t * to a listener socket if there's one */\n\t\tstruct sock *sk2;\n\n\t\tsk2 = nf_tproxy_get_sock_v4(net, skb, hp, iph->protocol,\n\t\t\t\t\t    iph->saddr, laddr ? laddr : iph->daddr,\n\t\t\t\t\t    hp->source, lport ? lport : hp->dest,\n\t\t\t\t\t    skb->dev, NFT_LOOKUP_LISTENER);\n\t\tif (sk2) {\n	f
44385	2353	fail_postponed_requests	drivers/block/drbd/drbd_receiver.c	&m	6	12	\N	\N	\tstruct drbd_interval *i;\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tstruct drbd_request *req;\n\t\tstruct bio_and_error m;\n\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (!(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\treq->rq_state &= ~RQ_POSTPONED;\n\t\t__req_mod(req, NEG_ACKED, &m);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tif (m.bio)\n\t\t\tcomplete_master_bio(device, &m);\n	t
-513	679	create_snapshot	fs/btrfs/ioctl.c	ret	1000	3	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_KERNEL);\n\tif (!pending_snapshot)\n\t\treturn -ENOMEM;\n\n\tpending_snapshot->root_item = kzalloc(sizeof(struct btrfs_root_item),\n\t\t\tGFP_KERNEL);\n\tpending_snapshot->path = btrfs_alloc_path();\n\tif (!pending_snapshot->root_item || !pending_snapshot->path) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pending;\n\t}\n\n\tatomic_inc(&root->will_be_snapshotted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshotting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto dec_and_free;\n\n\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, (u64)-1);\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n	f
22243	478	xfs_iget_cache_miss	fs/xfs/xfs_icache.c	xfs_iget_cache_miss_	1	11	\N	\N	\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\ttrace_xfs_iget_miss(ip);\n\n\tif ((VFS_I(ip)->i_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n	t
26055	768	init_controller	drivers/ata/sata_inic162x.c	val	1	11	\N	\N	\tint i;\n\tu16 val;\n\n\thctl &= ~HCTL_KNOWN_BITS;\n\n\t/* Soft reset whole controller.  Spec says reset duration is 3\n\t * PCI clocks, be generous and give it 10ms.\n\t */\n\twritew(hctl | HCTL_SOFTRST, mmio_base + HOST_CTL);\n\treadw(mmio_base + HOST_CTL); /* flush */\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(1);\n\t\tval = readw(mmio_base + HOST_CTL);\n\t\tif (!(val & HCTL_SOFTRST))\n\t\t\tbreak;\n\t}\n\n\tif (val & HCTL_SOFTRST)\n	t
34318	6150	compare_refs	fs/btrfs/send.c	dirid	1	11	\N	\N	\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n	t
41146	901	nfc_llcp_recv_connect	net/nfc/llcp_core.c	sn_len	1	11	\N	\N	\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug("%d %d\\n", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tu8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug("Service name length %zu\\n", sn_len);\n	t
59603	169	adis16480_show_firmware_date	drivers/iio/imu/adis16480.c	year	1	-11	\N	\N	\tstruct adis16480 *adis16480 = file->private_data;\n\tu16 md, year;\n\tchar buf[12];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_Y, &year);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_DM, &md);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), "%.2x-%.2x-%.4x\\n",\n	t
53891	1556	ath6kl_create_qos_write	drivers/net/wireless/ath/ath6kl/debug.c	&pstream	1	13	\N	\N	\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tchar buf[200];\n\tssize_t len;\n\tchar *sptr, *token;\n\tstruct wmi_create_pstream_cmd pstream;\n\tu32 val32;\n\tu16 val16;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\tsptr = buf;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.user_pri))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_direc))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_class))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_type))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.voice_psc_cap))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_service_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.max_service_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.inactivity_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.suspension_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.service_start_time = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.tsid))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &val16))\n\t\treturn -EINVAL;\n\tpstream.nominal_msdu = cpu_to_le16(val16);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &val16))\n\t\treturn -EINVAL;\n\tpstream.max_msdu = cpu_to_le16(val16);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.mean_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.peak_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.max_burst_size = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.delay_bound = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_phy_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.sba = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, " ");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.medium_time = cpu_to_le32(val32);\n\n\tpstream.nominal_phy = le32_to_cpu(pstream.min_phy_rate) / 1000000;\n\n\tath6kl_wmi_create_pstream_cmd(ar->wmi, vif->fw_vif_idx, &pstream);\n	f
48709	1683	ath10k_wmi_tlv_op_gen_vdev_start	drivers/net/wireless/ath/ath10k/wmi-tlv.c	cmd->vdev_id	1	11	\N	\N	\tstruct wmi_tlv_vdev_start_cmd *cmd;\n\tstruct wmi_channel *ch;\n\tstruct wmi_p2p_noa_descriptor *noa;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\tu32 flags = 0;\n\n\tif (WARN_ON(arg->hidden_ssid && !arg->ssid))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (sizeof(*tlv) + sizeof(*ch)) +\n\t      (sizeof(*tlv) + 0);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (arg->hidden_ssid)\n\t\tflags |= WMI_VDEV_START_HIDDEN_SSID;\n\tif (arg->pmf_enabled)\n\t\tflags |= WMI_VDEV_START_PMF_ENABLED;\n\n\tptr = (void *)skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_START_REQUEST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n	t
63485	7471	volume_create_alsa_mixer	drivers/platform/x86/thinkpad_acpi.c	ctl_mute	1	11	\N	\N	\tstruct snd_card *card;\n\tstruct tpacpi_alsa_data *data;\n\tstruct snd_kcontrol *ctl_vol;\n\tstruct snd_kcontrol *ctl_mute;\n\tint rc;\n\n\trc = snd_card_new(&tpacpi_pdev->dev,\n\t\t\t  alsa_index, alsa_id, THIS_MODULE,\n\t\t\t  sizeof(struct tpacpi_alsa_data), &card);\n\tif (rc < 0 || !card) {\n\t\tpr_err("Failed to create ALSA card structures: %d\\n", rc);\n\t\treturn 1;\n\t}\n\n\tBUG_ON(!card->private_data);\n\tdata = card->private_data;\n\tdata->card = card;\n\n\tstrlcpy(card->driver, TPACPI_ALSA_DRVNAME,\n\t\tsizeof(card->driver));\n\tstrlcpy(card->shortname, TPACPI_ALSA_SHRTNAME,\n\t\tsizeof(card->shortname));\n\tsnprintf(card->mixername, sizeof(card->mixername), "ThinkPad EC %s",\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : "(unknown)");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t "%s at EC reg 0x%02x, fw %s", card->shortname, TP_EC_AUDIO,\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : "unknown");\n\n\tif (volume_control_allowed) {\n\t\tvolume_alsa_control_vol.put = volume_alsa_vol_put;\n\t\tvolume_alsa_control_vol.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\n\t\tvolume_alsa_control_mute.put = volume_alsa_mute_put;\n\t\tvolume_alsa_control_mute.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t}\n\n\tif (!tp_features.mixer_no_level_control) {\n\t\tctl_vol = snd_ctl_new1(&volume_alsa_control_vol, NULL);\n\t\trc = snd_ctl_add(card, ctl_vol);\n\t\tif (rc < 0) {\n\t\t\tpr_err("Failed to create ALSA volume control: %d\\n",\n\t\t\t       rc);\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdata->ctl_vol_id = &ctl_vol->id;\n\t}\n\n\tctl_mute = snd_ctl_new1(&volume_alsa_control_mute, NULL);\n\trc = snd_ctl_add(card, ctl_mute);\n	t
28598	471	handle_netdev_upper	drivers/infiniband/core/roce_gid_mgmt.c	handle_netdev_upper_$__mptr2$obj	0	11	\N	\N	\tstruct net_device *ndev = cookie;\n\tstruct upper_list *upper_iter;\n\tstruct upper_list *upper_temp;\n\tLIST_HEAD(upper_list);\n\n\trcu_read_lock();\n\tnetdev_walk_all_upper_dev_rcu(ndev, netdev_upper_walk, &upper_list);\n\trcu_read_unlock();\n\n\thandle_netdev(ib_dev, port, ndev);\n\tlist_for_each_entry_safe(upper_iter, upper_temp, &upper_list,\n	t
34084	531	ath10k_htt_h2t_stats_req	drivers/net/wireless/ath/ath10k/htt_tx.c	ath10k_htt_h2t_stats_req_$req$obj$0	0	11	\N	\N	\tstruct ath10k *ar = htt->ar;\n\tstruct htt_stats_req *req;\n\tstruct sk_buff *skb;\n\tstruct htt_cmd *cmd;\n\tint len = 0, ret;\n\n\tlen += sizeof(cmd->hdr);\n\tlen += sizeof(cmd->stats_req);\n\n\tskb = ath10k_htc_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_cmd *)skb->data;\n\tcmd->hdr.msg_type = HTT_H2T_MSG_TYPE_STATS_REQ;\n\n\treq = &cmd->stats_req;\n\n\tmemset(req, 0, sizeof(*req));\n\n\t/* currently we support only max 8 bit masks so no need to worry\n\t * about endian support\n\t */\n\treq->upload_types[0] = mask;\n	t
26871	1347	ips_debugfs_init	drivers/platform/x86/intel_ips.c	ent	1	11	\N	\N	\tint i;\n\n\tips->debug_root = debugfs_create_dir("ips", NULL);\n\tif (!ips->debug_root) {\n\t\tdev_err(&ips->dev->dev,\n\t\t\t"failed to create debugfs entries: %ld\\n",\n\t\t\tPTR_ERR(ips->debug_root));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ips_debug_files); i++) {\n\t\tstruct dentry *ent;\n\t\tstruct ips_debugfs_node *node = &ips_debug_files[i];\n\n\t\tnode->ips = ips;\n\t\tent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,\n\t\t\t\t\t  ips->debug_root, node,\n\t\t\t\t\t  &ips_debugfs_ops);\n\t\tif (!ent) {\n	t
27045	250	debugfs_status_show	drivers/platform/x86/ideapad-laptop.c	value	1	11	\N	\N	\tstruct ideapad_private *priv = s->private;\n\tunsigned long value;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL_MAX, &value))\n\t\tseq_printf(s, "Backlight max:\\t%lu\\n", value);\n	t
46145	352	pfkey_error	net/key/af_key.c	skb	1	11	\N	\N	\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* Woe be to the platform trying to support PFKEY yet\n\t * having normal errnos outside the 1-255 range, inclusive.\n\t */\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n	t
21958	2247	batadv_tt_global_del_orig_node	net/batman-adv/translation-table.c	batadv_tt_global_del_orig_node_$__mptr20$obj	0	13	\N	\N	\tstruct hlist_head *head;\n\tstruct hlist_node *safe;\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\tunsigned short vid;\n\n\tspin_lock_bh(&tt_global_entry->list_lock);\n\thead = &tt_global_entry->orig_list;\n\thlist_for_each_entry_safe(orig_entry, safe, head, list) {\n	f
29495	840	snd_hdac_add_chmap_ctls	sound/hda/hdmi_chmap.c	kctl->count	1	13	\N	\N	\tstruct snd_pcm_chmap *chmap;\n\tstruct snd_kcontrol *kctl;\n\tint err, i;\n\n\terr = snd_pcm_add_chmap_ctls(pcm,\n\t\t\t\t     SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     NULL, 0, pcm_idx, &chmap);\n\tif (err < 0)\n\t\treturn err;\n\t/* override handlers */\n\tchmap->private_data = hchmap;\n\tkctl = chmap->kctl;\n\tfor (i = 0; i < kctl->count; i++)\n	f
7512	10968	intel_modeset_pipe_config	drivers/gpu/drm/i915/intel_display.c	intel_modeset_pipe_config_$__mptr73$obj	0	11	\N	\N	\tstruct drm_atomic_state *state = pipe_config->base.state;\n\tstruct intel_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint base_bpp, ret = -EINVAL;\n\tint i;\n\tbool retry = true;\n\n\tclear_intel_crtc_state(pipe_config);\n\n\tpipe_config->cpu_transcoder =\n\t\t(enum transcoder) to_intel_crtc(crtc)->pipe;\n\n\t/*\n\t * Sanitize sync polarity flags based on requested ones. If neither\n\t * positive or negative polarity is requested, treat this as meaning\n\t * negative polarity.\n\t */\n\tif (!(pipe_config->base.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC)))\n\t\tpipe_config->base.adjusted_mode.flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (!(pipe_config->base.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC)))\n\t\tpipe_config->base.adjusted_mode.flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tbase_bpp = compute_baseline_pipe_bpp(to_intel_crtc(crtc),\n\t\t\t\t\t     pipe_config);\n\tif (base_bpp < 0)\n\t\tgoto fail;\n\n\t/*\n\t * Determine the real pipe dimensions. Note that stereo modes can\n\t * increase the actual pipe size due to the frame doubling and\n\t * insertion of additional space for blanks between the frame. This\n\t * is stored in the crtc timings. We use the requested mode to do this\n\t * computation to clearly distinguish it from the adjusted mode, which\n\t * can be changed by the connectors in the below retry loop.\n\t */\n\tdrm_mode_get_hv_timing(&pipe_config->base.mode,\n\t\t\t       &pipe_config->pipe_src_w,\n\t\t\t       &pipe_config->pipe_src_h);\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n\n\t\tif (!check_single_encoder_cloning(state, to_intel_crtc(crtc), encoder)) {\n\t\t\tDRM_DEBUG_KMS("rejecting invalid cloning configuration\\n");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Determine output_types before calling the .compute_config()\n\t\t * hooks so that the hooks can use this information safely.\n\t\t */\n\t\tpipe_config->output_types |= 1 << encoder->type;\n\t}\n\nencoder_retry:\n\t/* Ensure the port clock defaults are reset when retrying. */\n\tpipe_config->port_clock = 0;\n\tpipe_config->pixel_multiplier = 1;\n\n\t/* Fill in default crtc timings, allow encoders to overwrite them. */\n\tdrm_mode_set_crtcinfo(&pipe_config->base.adjusted_mode,\n\t\t\t      CRTC_STEREO_DOUBLE);\n\n\t/* Pass our mode to the connectors and the CRTC to give them a chance to\n\t * adjust it according to limitations or connector properties, and also\n\t * a chance to reject the mode entirely.\n\t */\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n	t
49493	1556	dir_e_read	fs/gfs2/dir.c	index	1	11	\N	\N	\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = BIT(dip->i_depth);\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n	t
58602	197	batadv_gw_bandwidth_set	net/batman-adv/gateway_common.c	up_new	1	11	\N	\N	\tstruct batadv_priv *bat_priv = netdev_priv(net_dev);\n\tu32 down_curr;\n\tu32 up_curr;\n\tu32 down_new = 0;\n\tu32 up_new = 0;\n\tbool ret;\n\n\tdown_curr = (unsigned int)atomic_read(&bat_priv->gw.bandwidth_down);\n\tup_curr = (unsigned int)atomic_read(&bat_priv->gw.bandwidth_up);\n\n\tret = batadv_parse_gw_bandwidth(net_dev, buff, &down_new, &up_new);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tif (!down_new)\n\t\tdown_new = 1;\n\n\tif (!up_new)\n\t\tup_new = down_new / 5;\n\n\tif (!up_new)\n\t\tup_new = 1;\n\n\tif ((down_curr == down_new) && (up_curr == up_new))\n\t\treturn count;\n\n\tbatadv_gw_reselect(bat_priv);\n\tbatadv_info(net_dev,\n	t
52793	236	virtinput_probe	drivers/virtio/virtio_input.c	virtinput_probe_$__UNIQUE_ID_min1_251$obj	0	11	\N	\N	\tstruct virtio_input *vi;\n\tunsigned long flags;\n\tsize_t size;\n\tint abs, err;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\treturn -ENODEV;\n\n\tvi = kzalloc(sizeof(*vi), GFP_KERNEL);\n\tif (!vi)\n\t\treturn -ENOMEM;\n\n\tvdev->priv = vi;\n\tvi->vdev = vdev;\n\tspin_lock_init(&vi->lock);\n\n\terr = virtinput_init_vqs(vi);\n\tif (err)\n\t\tgoto err_init_vq;\n\n\tvi->idev = input_allocate_device();\n\tif (!vi->idev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_input_alloc;\n\t}\n\tinput_set_drvdata(vi->idev, vi);\n\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_NAME, 0);\n\tvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\n\t\t\t\t\t      u.string),\n\t\t\t   vi->name, min(size, sizeof(vi->name)));\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_SERIAL, 0);\n\tvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\n\t\t\t\t\t      u.string),\n\t\t\t   vi->serial, min(size, sizeof(vi->serial)));\n	t
31271	642	__begin_transaction	drivers/md/dm-cache-metadata.c	sblock	1	11	\N	\N	\tint r;\n\tstruct cache_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t/*\n\t * We re-read the superblock every time.  Shouldn't need to do this\n\t * really.\n\t */\n\tr = superblock_read_lock(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n	t
29605	345	ieee80211_debugfs_key_add	net/mac80211/debugfs_key.c	key->debugfs.dir	1	13	\N	\N	\tstatic int keycount;\n\tchar buf[100];\n\tstruct sta_info *sta;\n\n\tif (!key->local->debugfs.keys)\n\t\treturn;\n\n\tsprintf(buf, "%d", keycount);\n\tkey->debugfs.cnt = keycount;\n\tkeycount++;\n\tkey->debugfs.dir = debugfs_create_dir(buf,\n\t\t\t\t\tkey->local->debugfs.keys);\n\n\tif (!key->debugfs.dir)\n	f
29859	498	dib0700_jumpram	drivers/media/usb/dvb-usb/dib0700_core.c	actlen	1	13	\N	\N	\tint ret = 0, actlen;\n\tu8 *buf;\n\n\tbuf = kmalloc(8, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[0] = REQUEST_JUMPRAM;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tbuf[3] = 0;\n\tbuf[4] = (address >> 24) & 0xff;\n\tbuf[5] = (address >> 16) & 0xff;\n\tbuf[6] = (address >> 8)  & 0xff;\n\tbuf[7] =  address        & 0xff;\n\n\tif ((ret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x01),buf,8,&actlen,1000)) < 0) {\n\t\tdeb_fw("jumpram to 0x%x failed\\n",address);\n\t\tgoto out;\n\t}\n\tif (actlen != 8) {\n	f
46855	426	pb0100_set_autogain_target	drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c	err	1	11	\N	\N	\tint err, totalpixels, brightpixels, darkpixels;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Number of pixels counted by the sensor when subsampling the pixels.\n\t * Slightly larger than the real value to avoid oscillation */\n\ttotalpixels = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\n\ttotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\n\n\tbrightpixels = (totalpixels * val) >> 8;\n\tdarkpixels   = totalpixels - brightpixels;\n\terr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\n\tif (!err)\n	t
41227	883	wl3501_mgmt_join_confirm	drivers/net/wireless/wl3501_cs.c	sig.status	2	-11	\N	\N	\tstruct wl3501_card *this = netdev_priv(dev);\n\tstruct wl3501_join_confirm sig;\n\n\tpr_debug("entry");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\tif (sig.status == WL3501_STATUS_SUCCESS) {\n	t
62205	657	ctnetlink_conntrack_event	net/netfilter/nf_conntrack_netlink.c	skb	1	11	\N	\N	\tconst struct nf_conntrack_zone *zone;\n\tstruct net *net;\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfmsg;\n\tstruct nlattr *nest_parms;\n\tstruct nf_conn *ct = item->ct;\n\tstruct sk_buff *skb;\n\tunsigned int type;\n\tunsigned int flags = 0, group;\n\tint err;\n\n\tif (events & (1 << IPCT_DESTROY)) {\n\t\ttype = IPCTNL_MSG_CT_DELETE;\n\t\tgroup = NFNLGRP_CONNTRACK_DESTROY;\n\t} else if (events & ((1 << IPCT_NEW) | (1 << IPCT_RELATED))) {\n\t\ttype = IPCTNL_MSG_CT_NEW;\n\t\tflags = NLM_F_CREATE|NLM_F_EXCL;\n\t\tgroup = NFNLGRP_CONNTRACK_NEW;\n\t} else if (events) {\n\t\ttype = IPCTNL_MSG_CT_NEW;\n\t\tgroup = NFNLGRP_CONNTRACK_UPDATE;\n\t} else\n\t\treturn 0;\n\n\tnet = nf_ct_net(ct);\n\tif (!item->report && !nfnetlink_has_listeners(net, group))\n\t\treturn 0;\n\n\tskb = nlmsg_new(ctnetlink_nlmsg_size(ct), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\ttype = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK, type);\n\tnlh = nlmsg_put(skb, item->portid, 0, type, sizeof(*nfmsg), flags);\n	t
36591	2739	sony_nc_fanspeed_show	drivers/platform/x86/sony-laptop.c	result	1	11	\N	\N	\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0149, 0x0300, &result))\n\t\treturn -EIO;\n\n\treturn snprintf(buffer, PAGE_SIZE, "%d\\n", result & 0xff);\n	t
56476	502	snd_usX2Y_usbpcm_prepare	sound/usb/usx2y/usx2yhwdeppcm.c	snd_usX2Y_usbpcm_prepare_	1	11	\N	\N	\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usX2Y_substream *subs = runtime->private_data;\n\tstruct usX2Ydev *usX2Y = subs->usX2Y;\n\tstruct snd_usX2Y_substream *capsubs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\tint err = 0;\n\tsnd_printdd("snd_usX2Y_pcm_prepare(%p)\\n", substream);\n\n\tif (NULL == usX2Y->hwdep_pcm_shm) {\n\t\tif (NULL == (usX2Y->hwdep_pcm_shm = snd_malloc_pages(sizeof(struct snd_usX2Y_hwdep_pcm_shm), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tmemset(usX2Y->hwdep_pcm_shm, 0, sizeof(struct snd_usX2Y_hwdep_pcm_shm));\n\t}\n\n\tmutex_lock(&usX2Y->pcm_mutex);\n\tusX2Y_subs_prepare(subs);\n// Start hardware streams\n// SyncStream first....\n\tif (atomic_read(&capsubs->state) < state_PREPARED) {\n\t\tif (usX2Y->format != runtime->format)\n\t\t\tif ((err = usX2Y_format_set(usX2Y, runtime->format)) < 0)\n	t
522	470	show_als_en	drivers/leds/leds-lm3533.c	val	9	12	\N	\N	\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tbool enable;\n\tu8 reg;\n\tu8 val;\n\tint ret;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tenable = val & LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\n	t
29936	835	vsp1_probe	drivers/media/platform/vsp1/vsp1_drv.c	vsp1->info	1	13	\N	\N	\tstruct vsp1_device *vsp1;\n\tstruct device_node *fcp_node;\n\tstruct resource *irq;\n\tstruct resource *io;\n\tunsigned int i;\n\tint ret;\n\n\tvsp1 = devm_kzalloc(&pdev->dev, sizeof(*vsp1), GFP_KERNEL);\n\tif (vsp1 == NULL)\n\t\treturn -ENOMEM;\n\n\tvsp1->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&vsp1->entities);\n\tINIT_LIST_HEAD(&vsp1->videos);\n\n\tplatform_set_drvdata(pdev, vsp1);\n\n\t/* I/O and IRQ resources (clock managed by the clock PM domain) */\n\tio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tvsp1->mmio = devm_ioremap_resource(&pdev->dev, io);\n\tif (IS_ERR(vsp1->mmio))\n\t\treturn PTR_ERR(vsp1->mmio);\n\n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!irq) {\n\t\tdev_err(&pdev->dev, "missing IRQ\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq->start, vsp1_irq_handler,\n\t\t\t      IRQF_SHARED, dev_name(&pdev->dev), vsp1);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "failed to request IRQ\\n");\n\t\treturn ret;\n\t}\n\n\t/* FCP (optional) */\n\tfcp_node = of_parse_phandle(pdev->dev.of_node, "renesas,fcp", 0);\n\tif (fcp_node) {\n\t\tvsp1->fcp = rcar_fcp_get(fcp_node);\n\t\tof_node_put(fcp_node);\n\t\tif (IS_ERR(vsp1->fcp)) {\n\t\t\tdev_dbg(&pdev->dev, "FCP not found (%ld)\\n",\n\t\t\t\tPTR_ERR(vsp1->fcp));\n\t\t\treturn PTR_ERR(vsp1->fcp);\n\t\t}\n\n\t\t/*\n\t\t * When the FCP is present, it handles all bus master accesses\n\t\t * for the VSP and must thus be used in place of the VSP device\n\t\t * to map DMA buffers.\n\t\t */\n\t\tvsp1->bus_master = rcar_fcp_get_device(vsp1->fcp);\n\t} else {\n\t\tvsp1->bus_master = vsp1->dev;\n\t}\n\n\t/* Configure device parameters based on the version register. */\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tvsp1->version = vsp1_read(vsp1, VI6_IP_VERSION);\n\tpm_runtime_put_sync(&pdev->dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(vsp1_device_infos); ++i) {\n\t\tif ((vsp1->version & VI6_IP_VERSION_MODEL_MASK) ==\n\t\t    vsp1_device_infos[i].version) {\n\t\t\tvsp1->info = &vsp1_device_infos[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vsp1->info) {\n	f
29754	824	mxl111sf_i2c_xfer	drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c	ret	1	11	\N	\N	\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct mxl111sf_state *state = d->priv;\n\tint hwi2c = (state->chip_rev > MXL111SF_V6);\n\tint i, ret;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = (hwi2c) ?\n\t\t\tmxl111sf_i2c_hw_xfer_msg(state, &msg[i]) :\n\t\t\tmxl111sf_i2c_sw_xfer_msg(state, &msg[i]);\n\t\tif (mxl_fail(ret)) {\n	t
31214	1990	dm_pool_metadata_set_needs_check	drivers/md/dm-thin-metadata.c	sblock	1	11	\N	\N	\tint r;\n\tstruct dm_block *sblock;\n\tstruct thin_disk_superblock *disk_super;\n\n\tdown_write(&pmd->root_lock);\n\tpmd->flags |= THIN_METADATA_NEEDS_CHECK_FLAG;\n\n\tr = superblock_lock(pmd, &sblock);\n\tif (r) {\n\t\tDMERR("couldn't read superblock");\n\t\tgoto out;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n	t
-618	1843	gf100_gr_ctor_fw_legacy	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c	fuc->size	2	3	\N	\N	\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst struct firmware *fw;\n\tchar f[32];\n\n\t/* see if this firmware has a legacy path */\n\tif (!strcmp(fwname, "fecs_inst"))\n\t\tfwname = "fuc409c";\n\telse if (!strcmp(fwname, "fecs_data"))\n\t\tfwname = "fuc409d";\n\telse if (!strcmp(fwname, "gpccs_inst"))\n\t\tfwname = "fuc41ac";\n\telse if (!strcmp(fwname, "gpccs_data"))\n\t\tfwname = "fuc41ad";\n\telse {\n\t\t/* nope, let's just return the error we got */\n\t\tnvkm_error(subdev, "failed to load %s\\n", fwname);\n\t\treturn ret;\n\t}\n\n\t/* yes, try to load from the legacy path */\n\tnvkm_debug(subdev, "%s: falling back to legacy path\\n", fwname);\n\n\tsnprintf(f, sizeof(f), "nouveau/nv%02x_%s", device->chipset, fwname);\n\tret = request_firmware(&fw, f, device->dev);\n\tif (ret) {\n\t\tsnprintf(f, sizeof(f), "nouveau/%s", fwname);\n\t\tret = request_firmware(&fw, f, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, "failed to load %s\\n", fwname);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfuc->size = fw->size;\n\tfuc->data = kmemdup(fw->data, fuc->size, GFP_KERNEL);\n	f
48961	1306	cdc_ncm_fill_tx_frame	drivers/net/usb/cdc_ncm.c	skb_out->len	1	11	\N	\N	\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tstruct usb_cdc_ncm_nth16 *nth16;\n\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\tstruct sk_buff *skb_out;\n\tu16 n = 0, index, ndplen;\n\tu8 ready2send = 0;\n\tu32 delayed_ndp_size;\n\tsize_t padding_count;\n\n\t/* When our NDP gets written in cdc_ncm_ndp(), then skb_out->len gets updated\n\t * accordingly. Otherwise, we should check here.\n\t */\n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)\n\t\tdelayed_ndp_size = ctx->max_ndp_size;\n\telse\n\t\tdelayed_ndp_size = 0;\n\n\t/* if there is a remaining skb, it gets priority */\n\tif (skb != NULL) {\n\t\tswap(skb, ctx->tx_rem_skb);\n\t\tswap(sign, ctx->tx_rem_sign);\n\t} else {\n\t\tready2send = 1;\n\t}\n\n\t/* check if we are resuming an OUT skb */\n\tskb_out = ctx->tx_curr_skb;\n\n\t/* allocate a new OUT skb */\n\tif (!skb_out) {\n\t\tif (ctx->tx_low_mem_val == 0) {\n\t\t\tctx->tx_curr_size = ctx->tx_max;\n\t\t\tskb_out = alloc_skb(ctx->tx_curr_size, GFP_ATOMIC);\n\t\t\t/* If the memory allocation fails we will wait longer\n\t\t\t * each time before attempting another full size\n\t\t\t * allocation again to not overload the system\n\t\t\t * further.\n\t\t\t */\n\t\t\tif (skb_out == NULL) {\n\t\t\t\tctx->tx_low_mem_max_cnt = min(ctx->tx_low_mem_max_cnt + 1,\n\t\t\t\t\t\t\t      (unsigned)CDC_NCM_LOW_MEM_MAX_CNT);\n\t\t\t\tctx->tx_low_mem_val = ctx->tx_low_mem_max_cnt;\n\t\t\t}\n\t\t}\n\t\tif (skb_out == NULL) {\n\t\t\t/* See if a very small allocation is possible.\n\t\t\t * We will send this packet immediately and hope\n\t\t\t * that there is more memory available later.\n\t\t\t */\n\t\t\tif (skb)\n\t\t\t\tctx->tx_curr_size = max(skb->len,\n\t\t\t\t\t(u32)USB_CDC_NCM_NTB_MIN_OUT_SIZE);\n\t\t\telse\n\t\t\t\tctx->tx_curr_size = USB_CDC_NCM_NTB_MIN_OUT_SIZE;\n\t\t\tskb_out = alloc_skb(ctx->tx_curr_size, GFP_ATOMIC);\n\n\t\t\t/* No allocation possible so we will abort */\n\t\t\tif (skb_out == NULL) {\n\t\t\t\tif (skb != NULL) {\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\t\tdev->net->stats.tx_dropped++;\n\t\t\t\t}\n\t\t\t\tgoto exit_no_skb;\n\t\t\t}\n\t\t\tctx->tx_low_mem_val--;\n\t\t}\n\t\t/* fill out the initial 16-bit NTB header */\n\t\tnth16 = skb_put_zero(skb_out, sizeof(struct usb_cdc_ncm_nth16));\n\t\tnth16->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\n\t\tnth16->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\n\t\tnth16->wSequence = cpu_to_le16(ctx->tx_seq++);\n\n\t\t/* count total number of frames in this NTB */\n\t\tctx->tx_curr_frame_num = 0;\n\n\t\t/* recent payload counter for this skb_out */\n\t\tctx->tx_curr_frame_payload = 0;\n\t}\n\n\tfor (n = ctx->tx_curr_frame_num; n < ctx->tx_max_datagrams; n++) {\n\t\t/* send any remaining skb first */\n\t\tif (skb == NULL) {\n\t\t\tskb = ctx->tx_rem_skb;\n\t\t\tsign = ctx->tx_rem_sign;\n\t\t\tctx->tx_rem_skb = NULL;\n\n\t\t\t/* check for end of skb */\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* get the appropriate NDP for this skb */\n\t\tndp16 = cdc_ncm_ndp(ctx, skb_out, sign, skb->len + ctx->tx_modulus + ctx->tx_remainder);\n\n\t\t/* align beginning of next frame */\n\t\tcdc_ncm_align_tail(skb_out,  ctx->tx_modulus, ctx->tx_remainder, ctx->tx_curr_size);\n\n\t\t/* check if we had enough room left for both NDP and frame */\n\t\tif (!ndp16 || skb_out->len + skb->len + delayed_ndp_size > ctx->tx_curr_size) {\n\t\t\tif (n == 0) {\n\t\t\t\t/* won't fit, MTU problem? */\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tskb = NULL;\n\t\t\t\tdev->net->stats.tx_dropped++;\n\t\t\t} else {\n\t\t\t\t/* no room for skb - store for later */\n\t\t\t\tif (ctx->tx_rem_skb != NULL) {\n\t\t\t\t\tdev_kfree_skb_any(ctx->tx_rem_skb);\n\t\t\t\t\tdev->net->stats.tx_dropped++;\n\t\t\t\t}\n\t\t\t\tctx->tx_rem_skb = skb;\n\t\t\t\tctx->tx_rem_sign = sign;\n\t\t\t\tskb = NULL;\n\t\t\t\tready2send = 1;\n\t\t\t\tctx->tx_reason_ntb_full++;\t/* count reason for transmitting */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* calculate frame number withing this NDP */\n\t\tndplen = le16_to_cpu(ndp16->wLength);\n\t\tindex = (ndplen - sizeof(struct usb_cdc_ncm_ndp16)) / sizeof(struct usb_cdc_ncm_dpe16) - 1;\n\n\t\t/* OK, add this skb */\n\t\tndp16->dpe16[index].wDatagramLength = cpu_to_le16(skb->len);\n\t\tndp16->dpe16[index].wDatagramIndex = cpu_to_le16(skb_out->len);\n\t\tndp16->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe16));\n\t\tskb_put_data(skb_out, skb->data, skb->len);\n\t\tctx->tx_curr_frame_payload += skb->len;\t/* count real tx payload data */\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\t/* send now if this NDP is full */\n\t\tif (index >= CDC_NCM_DPT_DATAGRAMS_MAX) {\n\t\t\tready2send = 1;\n\t\t\tctx->tx_reason_ndp_full++;\t/* count reason for transmitting */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* free up any dangling skb */\n\tif (skb != NULL) {\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\t\tdev->net->stats.tx_dropped++;\n\t}\n\n\tctx->tx_curr_frame_num = n;\n\n\tif (n == 0) {\n\t\t/* wait for more frames */\n\t\t/* push variables */\n\t\tctx->tx_curr_skb = skb_out;\n\t\tgoto exit_no_skb;\n\n\t} else if ((n < ctx->tx_max_datagrams) && (ready2send == 0) && (ctx->timer_interval > 0)) {\n\t\t/* wait for more frames */\n\t\t/* push variables */\n\t\tctx->tx_curr_skb = skb_out;\n\t\t/* set the pending count */\n\t\tif (n < CDC_NCM_RESTART_TIMER_DATAGRAM_CNT)\n\t\t\tctx->tx_timer_pending = CDC_NCM_TIMER_PENDING_CNT;\n\t\tgoto exit_no_skb;\n\n\t} else {\n\t\tif (n == ctx->tx_max_datagrams)\n\t\t\tctx->tx_reason_max_datagram++;\t/* count reason for transmitting */\n\t\t/* frame goes out */\n\t\t/* variables will be reset at next call */\n\t}\n\n\t/* If requested, put NDP at end of frame. */\n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\n\t\tnth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\n\t\tcdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_curr_size);\n\t\tnth16->wNdpIndex = cpu_to_le16(skb_out->len);\n\t\tskb_put_data(skb_out, ctx->delayed_ndp16, ctx->max_ndp_size);\n\n\t\t/* Zero out delayed NDP - signature checking will naturally fail. */\n\t\tndp16 = memset(ctx->delayed_ndp16, 0, ctx->max_ndp_size);\n\t}\n\n\t/* If collected data size is less or equal ctx->min_tx_pkt\n\t * bytes, we send buffers as it is. If we get more data, it\n\t * would be more efficient for USB HS mobile device with DMA\n\t * engine to receive a full size NTB, than canceling DMA\n\t * transfer and receiving a short packet.\n\t *\n\t * This optimization support is pointless if we end up sending\n\t * a ZLP after full sized NTBs.\n\t */\n\tif (!(dev->driver_info->flags & FLAG_SEND_ZLP) &&\n\t    skb_out->len > ctx->min_tx_pkt) {\n	t
2679	71	dcb_gpio_entry	drivers/gpu/drm/nouveau/nvkm/subdev/bios/gpio.c	cnt	8	12	\N	\N	\tu8  hdr, cnt, xver; /* use gpio version for xpio entry parsing */\n\tu16 gpio;\n\n\tif (!idx--)\n\t\tgpio = dcb_gpio_table(bios, ver, &hdr, &cnt, len);\n\telse\n\t\tgpio = dcb_xpio_table(bios, idx, &xver, &hdr, &cnt, len);\n\n\tif (gpio && ent < cnt)\n	t
3339	100	fq_codel_classify	net/sched/sch_fq_codel.c	&res	7	12	\N	indirect call	\tstruct fq_codel_sched_data *q = qdisc_priv(sch);\n\tstruct tcf_proto *filter;\n\tstruct tcf_result res;\n\tint result;\n\n\tif (TC_H_MAJ(skb->priority) == sch->handle &&\n\t    TC_H_MIN(skb->priority) > 0 &&\n\t    TC_H_MIN(skb->priority) <= q->flows_cnt)\n\t\treturn TC_H_MIN(skb->priority);\n\n\tfilter = rcu_dereference_bh(q->filter_list);\n\tif (!filter)\n\t\treturn fq_codel_hash(q, skb) + 1;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tresult = tcf_classify(skb, filter, &res, false);\n	t
51300	1657	fuse_writepage_locked	fs/fuse/file.c	fuse_writepage_locked_$req$obj$31$obj$0	0	11	\N	\N	\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\t/* writeback always goes to bg_queue */\n\t__set_bit(FR_BACKGROUND, &req->flags);\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n	t
52766	1169	xfs_vm_writepage	fs/xfs/xfs_aops.c	ret	1	11	\N	\N	\tstruct xfs_writepage_ctx wpc = {\n\t\t.io_type = XFS_IO_INVALID,\n\t};\n\tint\t\t\tret;\n\n\tret = xfs_do_writepage(page, wbc, &wpc);\n\tif (wpc.ioend)\n\t\tret = xfs_submit_ioend(wbc, wpc.ioend, ret);\n	t
24585	2468	hfa384x_drvr_start	drivers/staging/wlan-ng/prism2usb.c	hfa384x_drvr_start_$status$obj	0	11	\N	\N	\N	t
58768	98	bdc_pci_probe	drivers/usb/gadget/udc/bdc/bdc_pci.c	ret	1	11	\N	\N	\tstruct resource res[2];\n\tstruct platform_device *bdc;\n\tstruct bdc_pci *glue;\n\tint ret = -ENOMEM;\n\n\tglue = devm_kzalloc(&pci->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev = &pci->dev;\n\tret = pci_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(&pci->dev, "failed to enable pci device\\n");\n\t\treturn -ENODEV;\n\t}\n\tpci_set_master(pci);\n\n\tbdc = platform_device_alloc(BRCM_BDC_NAME, PLATFORM_DEVID_AUTO);\n\tif (!bdc)\n\t\treturn -ENOMEM;\n\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\tbdc_setup_msi(pci);\n\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= BRCM_BDC_NAME;\n\tres[0].flags\t= IORESOURCE_MEM;\n\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= BRCM_BDC_NAME;\n\tres[1].flags\t= IORESOURCE_IRQ;\n\n\tret = platform_device_add_resources(bdc, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(&pci->dev,\n\t\t\t"couldn't add resources to bdc device\\n");\n\t\treturn ret;\n\t}\n\n\tpci_set_drvdata(pci, glue);\n\n\tdma_set_coherent_mask(&bdc->dev, pci->dev.coherent_dma_mask);\n\n\tbdc->dev.dma_mask = pci->dev.dma_mask;\n\tbdc->dev.dma_parms = pci->dev.dma_parms;\n\tbdc->dev.parent = &pci->dev;\n\tglue->bdc = bdc;\n\n\tret = platform_device_add(bdc);\n\tif (ret) {\n	t
59483	1156	cxgb4vf_set_mac_addr	drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c	ret	1	11	\N	\N	\tint ret;\n\tstruct sockaddr *addr = _addr;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = t4vf_change_mac(pi->adapter, pi->viid, pi->xact_addr_filt,\n\t\t\t      addr->sa_data, true);\n\tif (ret < 0)\n	t
8875	845	ethtool_set_settings	net/core/ethtool.c	&cmd)	1	11	\N	\N	\tstruct ethtool_cmd cmd;\n\n\tASSERT_RTNL();\n\n\tif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* first, try new %ethtool_link_ksettings API. */\n\tif (dev->ethtool_ops->set_link_ksettings) {\n\t\tstruct ethtool_link_ksettings link_ksettings;\n\n\t\tif (!convert_legacy_settings_to_link_ksettings(&link_ksettings,\n	t
37033	844	hackrf_start_streaming	drivers/media/usb/hackrf/hackrf.c	ret	1	11	\N	\N	\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\tstruct usb_interface *intf = dev->intf;\n\tint ret;\n\tunsigned int mode;\n\n\tdev_dbg(&intf->dev, "count=%i\\n", count);\n\n\tmutex_lock(&dev->v4l2_lock);\n\n\t/* Allow only RX or TX, not both same time */\n\tif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE) {\n\t\tif (test_bit(TX_ON, &dev->flags)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_hackrf_return_all_buffers;\n\t\t}\n\n\t\tmode = 1;\n\t\tset_bit(RX_ON, &dev->flags);\n\t} else {\n\t\tif (test_bit(RX_ON, &dev->flags)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_hackrf_return_all_buffers;\n\t\t}\n\n\t\tmode = 2;\n\t\tset_bit(TX_ON, &dev->flags);\n\t}\n\n\tdev->sequence = 0;\n\n\tret = hackrf_alloc_stream_bufs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_alloc_urbs(dev, (mode == 1));\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_submit_urbs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_set_params(dev);\n\tif (ret)\n	t
43480	335	i2400mu_bus_bm_wait_for_ack	drivers/net/wimax/i2400m/usb-fw.c	i2400mu_bus_bm_wait_for_ack_$notif_urb$14$obj	0	13	\N	\N	\tssize_t result = -ENOMEM;\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct i2400mu *i2400mu = container_of(i2400m, struct i2400mu, i2400m);\n\tstruct urb notif_urb;\n\tvoid *ack = _ack;\n\tsize_t offset, len;\n\tlong val;\n\tint do_autopm = 1;\n\tDECLARE_COMPLETION_ONSTACK(notif_completion);\n\n\td_fnstart(8, dev, "(i2400m %p ack %p size %zu)\\n",\n\t\t  i2400m, ack, ack_size);\n\tBUG_ON(_ack == i2400m->bm_ack_buf);\n\tresult = usb_autopm_get_interface(i2400mu->usb_iface);\n\tif (result < 0) {\n\t\tdev_err(dev, "BM-ACK: can't get autopm: %d\\n", (int) result);\n\t\tdo_autopm = 0;\n\t}\n\tusb_init_urb(&notif_urb);\t/* ready notifications */\n\tusb_get_urb(&notif_urb);\n\toffset = 0;\n\twhile (offset < ack_size) {\n\t\tinit_completion(&notif_completion);\n\t\tresult = i2400mu_notif_submit(i2400mu, &notif_urb,\n\t\t\t\t\t      &notif_completion);\n\t\tif (result < 0)\n\t\t\tgoto error_notif_urb_submit;\n\t\tval = wait_for_completion_interruptible_timeout(\n\t\t\t&notif_completion, HZ);\n\t\tif (val == 0) {\n\t\t\tresult = -ETIMEDOUT;\n\t\t\tusb_kill_urb(&notif_urb);\t/* Timedout */\n\t\t\tgoto error_notif_wait;\n\t\t}\n\t\tif (val == -ERESTARTSYS) {\n\t\t\tresult = -EINTR;\t\t/* Interrupted */\n\t\t\tusb_kill_urb(&notif_urb);\n\t\t\tgoto error_notif_wait;\n\t\t}\n\t\tresult = notif_urb.status;\t\t/* How was the ack? */\n\t\tswitch (result) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -EINVAL:\t\t\t/* while removing driver */\n\t\tcase -ENODEV:\t\t\t/* dev disconnect ... */\n\t\tcase -ENOENT:\t\t\t/* just ignore it */\n\t\tcase -ESHUTDOWN:\t\t/* and exit */\n\t\tcase -ECONNRESET:\n\t\t\tresult = -ESHUTDOWN;\n\t\t\tgoto error_dev_gone;\n\t\tdefault:\t\t\t\t/* any other? */\n\t\t\tusb_kill_urb(&notif_urb);\t/* Timedout */\n\t\t\tif (edc_inc(&i2400mu->urb_edc,\n\t\t\t\t    EDC_MAX_ERRORS, EDC_ERROR_TIMEFRAME))\n\t\t\t\tgoto error_exceeded;\n\t\t\tdev_err(dev, "BM-ACK: URB error %d, "\n	f
7642	2285	team_nl_fill_one_option_get	drivers/net/team/team.c	ctx.data.bin_val.len	6	12	\N	???	\tstruct nlattr *option_item;\n\tstruct team_option *option = opt_inst->option;\n\tstruct team_option_inst_info *opt_inst_info = &opt_inst->info;\n\tstruct team_gsetter_ctx ctx;\n\tint err;\n\n\tctx.info = opt_inst_info;\n\terr = team_option_get(team, opt_inst, &ctx);\n\tif (err)\n\t\treturn err;\n\n\toption_item = nla_nest_start(skb, TEAM_ATTR_ITEM_OPTION);\n\tif (!option_item)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TEAM_ATTR_OPTION_NAME, option->name))\n\t\tgoto nest_cancel;\n\tif (opt_inst_info->port &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_PORT_IFINDEX,\n\t\t\topt_inst_info->port->dev->ifindex))\n\t\tgoto nest_cancel;\n\tif (opt_inst->option->array_size &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_ARRAY_INDEX,\n\t\t\topt_inst_info->array_index))\n\t\tgoto nest_cancel;\n\n\tswitch (option->type) {\n\tcase TEAM_OPTION_TYPE_U32:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_U32))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_u32(skb, TEAM_ATTR_OPTION_DATA, ctx.data.u32_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_STRING:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_STRING))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_string(skb, TEAM_ATTR_OPTION_DATA,\n\t\t\t\t   ctx.data.str_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_BINARY:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_BINARY))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put(skb, TEAM_ATTR_OPTION_DATA, ctx.data.bin_val.len,\n	t
54385	586	sddr55_get_capacity	drivers/usb/storage/sddr55.c	manufacturerID	1	11	\N	\N	\treturn 0;\n}\n\n\nstatic unsigned long sddr55_get_capacity(struct us_data *us) {\n\n\tunsigned char uninitialized_var(manufacturerID);\n\tunsigned char uninitialized_var(deviceID);\n\tint result;\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\n\tusb_stor_dbg(us, "Reading capacity...\\n");\n\n\tresult = sddr55_read_deviceID(us,\n\t\t&manufacturerID,\n\t\t&deviceID);\n\n\tusb_stor_dbg(us, "Result of read_deviceID is %d\\n", result);\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn 0;\n\n\tusb_stor_dbg(us, "Device ID = %02X\\n", deviceID);\n\tusb_stor_dbg(us, "Manuf  ID = %02X\\n", manufacturerID);\n	t
60743	2524	snd_asihpi_clkrate_get	sound/pci/asihpi/asihpi.c	e	1	11	\N	\N	\tu32 h_control = kcontrol->private_value;\n\tu32 rate;\n\tu16 e;\n\n\te = hpi_sample_clock_get_sample_rate(h_control, &rate);\n\tif (!e)\n	t
21454	552	addr_resolve	drivers/infiniband/core/addr.c	dst->dev	1	11	\N	\N	\tstruct net_device *ndev;\n\tstruct dst_entry *dst;\n\tint ret;\n\n\tif (!addr->net) {\n\t\tpr_warn_ratelimited("%s: missing namespace\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (src_in->sa_family == AF_INET) {\n\t\tstruct rtable *rt = NULL;\n\t\tconst struct sockaddr_in *dst_in4 =\n\t\t\t(const struct sockaddr_in *)dst_in;\n\n\t\tret = addr4_resolve((struct sockaddr_in *)src_in,\n\t\t\t\t    dst_in4, addr, &rt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (resolve_neigh)\n\t\t\tret = addr_resolve_neigh(&rt->dst, dst_in, addr, seq);\n\n\t\tif (addr->bound_dev_if) {\n\t\t\tndev = dev_get_by_index(addr->net, addr->bound_dev_if);\n\t\t} else {\n\t\t\tndev = rt->dst.dev;\n\t\t\tdev_hold(ndev);\n\t\t}\n\n\t\tip_rt_put(rt);\n\t} else {\n\t\tconst struct sockaddr_in6 *dst_in6 =\n\t\t\t(const struct sockaddr_in6 *)dst_in;\n\n\t\tret = addr6_resolve((struct sockaddr_in6 *)src_in,\n\t\t\t\t    dst_in6, addr,\n\t\t\t\t    &dst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (resolve_neigh)\n\t\t\tret = addr_resolve_neigh(dst, dst_in, addr, seq);\n\n\t\tif (addr->bound_dev_if) {\n\t\t\tndev = dev_get_by_index(addr->net, addr->bound_dev_if);\n\t\t} else {\n\t\t\tndev = dst->dev;\n	t
21464	1369	cxgbit_send_tx_flowc_wr	drivers/target/iscsi/cxgbit/cxgbit_cm.c	flowclen	1	11	\N	\N	\tstruct cxgbit_device *cdev = csk->com.cdev;\n\tstruct fw_flowc_wr *flowc;\n\tu32 nparams, flowclen16, flowclen;\n\tstruct sk_buff *skb;\n\tu8 index;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tu16 vlan = ((struct l2t_entry *)csk->l2t)->vlan;\n#endif\n\n\tflowclen16 = cxgbit_tx_flowc_wr_credits(csk, &nparams, &flowclen);\n\n\tskb = __skb_dequeue(&csk->skbq);\n\tflowc = __skb_put_zero(skb, flowclen);\n	t
27025	552	cmpc_accel_handler	drivers/platform/x86/classmate-laptop.c	status	1	11	\N	\N	\tif (event == 0x81) {\n\t\tunsigned char x, y, z;\n\t\tacpi_status status;\n\n\t\tstatus = cmpc_get_accel(dev->handle, &x, &y, &z);\n\t\tif (ACPI_SUCCESS(status)) {\n	t
62009	1078	ncm_wrap_ntb	drivers/usb/gadget/function/f_ncm.c	ncm->skb_tx_data	1	11	\N	\N	\tstruct f_ncm\t*ncm = func_to_ncm(&port->func);\n\tstruct sk_buff\t*skb2 = NULL;\n\tint\t\tncb_len = 0;\n\t__le16\t\t*ntb_data;\n\t__le16\t\t*ntb_ndp;\n\tint\t\tdgram_pad;\n\n\tunsigned\tmax_size = ncm->port.fixed_in_len;\n\tconst struct ndp_parser_opts *opts = ncm->parser_opts;\n\tconst int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);\n\tconst int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);\n\tconst int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);\n\tconst int dgram_idx_len = 2 * 2 * opts->dgram_item_len;\n\n\tif (!skb && !ncm->skb_tx_data)\n\t\treturn NULL;\n\n\tif (skb) {\n\t\t/* Add the CRC if required up front */\n\t\tif (ncm->is_crc) {\n\t\t\tuint32_t\tcrc;\n\t\t\t__le16\t\t*crc_pos;\n\n\t\t\tcrc = ~crc32_le(~0,\n\t\t\t\t\tskb->data,\n\t\t\t\t\tskb->len);\n\t\t\tcrc_pos = skb_put(skb, sizeof(uint32_t));\n\t\t\tput_unaligned_le32(crc, crc_pos);\n\t\t}\n\n\t\t/* If the new skb is too big for the current NCM NTB then\n\t\t * set the current stored skb to be sent now and clear it\n\t\t * ready for new data.\n\t\t * NOTE: Assume maximum align for speed of calculation.\n\t\t */\n\t\tif (ncm->skb_tx_data\n\t\t    && (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE\n\t\t    || (ncm->skb_tx_data->len +\n\t\t    div + rem + skb->len +\n\t\t    ncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))\n\t\t    > max_size)) {\n\t\t\tskb2 = package_for_tx(ncm);\n\t\t\tif (!skb2)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (!ncm->skb_tx_data) {\n\t\t\tncb_len = opts->nth_size;\n\t\t\tdgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;\n\t\t\tncb_len += dgram_pad;\n\n\t\t\t/* Create a new skb for the NTH and datagrams. */\n\t\t\tncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);\n\t\t\tif (!ncm->skb_tx_data)\n\t\t\t\tgoto err;\n\n\t\t\tncm->skb_tx_data->dev = ncm->netdev;\n\t\t\tntb_data = skb_put_zero(ncm->skb_tx_data, ncb_len);\n	t
39462	1288	ssi_w	drivers/media/usb/gspca/spca508.c	ret	2	-11	\N	\N	\tint ret, retry;\n\n\tret = reg_write(gspca_dev, 0x8802, reg >> 8);\n\tif (ret < 0)\n	t
28473	1382	ea_dealloc_indirect	fs/gfs2/xattr.c	ea_dealloc_indirect_$dibh$obj$5	0	13	\N	\N	\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, 0, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);\n\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n	f
52606	246	nitrox_pf_sw_init	drivers/crypto/cavium/nitrox/nitrox_main.c	err	1	13	\N	\N	\tint err;\n\n\terr = nitrox_common_sw_init(ndev);\n\tif (err)\n\t\treturn err;\n\n\terr = nitrox_pf_init_isr(ndev);\n\tif (err)\n	f
57832	401	wake_up_lan_show	drivers/platform/x86/compal-laptop.c	wake_up_lan_show_$and$4	0	11	\N	\N	\tu8 result = ec_read_u8(WIRELESS_ADDR);\n\tbool hw_blocked = !(result & WIRELESS_KILLSWITCH);\n\trfkill_set_hw_state(rfkill, hw_blocked);\n}\n\nstatic const struct rfkill_ops compal_rfkill_ops = {\n\t.poll = compal_rfkill_poll,\n\t.set_block = compal_rfkill_set,\n};\n\n\n/* Wake_up interface */\n#define SIMPLE_MASKED_STORE_SHOW(NAME, ADDR, MASK)\t\t\t\\\nstatic ssize_t NAME##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, "%d\\n", ((ec_read_u8(ADDR) & MASK) != 0));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t NAME##_store(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint state;\t\t\t\t\t\t\t\\\n\tu8 old_val = ec_read_u8(ADDR);\t\t\t\t\t\\\n\tif (sscanf(buf, "%d", &state) != 1 || (state < 0 || state > 1))\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tec_write(ADDR, state ? (old_val | MASK) : (old_val & ~MASK));\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nSIMPLE_MASKED_STORE_SHOW(wake_up_pme,\tWAKE_UP_ADDR, WAKE_UP_PME)\nSIMPLE_MASKED_STORE_SHOW(wake_up_modem,\tWAKE_UP_ADDR, WAKE_UP_MODEM)\nSIMPLE_MASKED_STORE_SHOW(wake_up_lan,\tWAKE_UP_ADDR, WAKE_UP_LAN)\n	t
21437	2334	lpfc_nvme_register_port	drivers/scsi/lpfc/lpfc_nvme.c	lpfc_nvme_register_port_$remote_port$obj	0	11	\N	\N	#if (IS_ENABLED(CONFIG_NVME_FC))\n\tint ret = 0;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct nvme_fc_remote_port *remote_port;\n\tstruct nvme_fc_port_info rpinfo;\n\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t "6006 Register NVME PORT. DID x%06x nlptype x%x\\n",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_type);\n\n\tlocalport = vport->localport;\n\tif (!localport)\n\t\treturn 0;\n\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\n\t/* NVME rports are not preserved across devloss.\n\t * Just register this instance.  Note, rpinfo->dev_loss_tmo\n\t * is left 0 to indicate accept transport defaults.  The\n\t * driver communicates port role capabilities consistent\n\t * with the PRLI response data.\n\t */\n\tmemset(&rpinfo, 0, sizeof(struct nvme_fc_port_info));\n\trpinfo.port_id = ndlp->nlp_DID;\n\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_TARGET;\n\tif (ndlp->nlp_type & NLP_NVME_INITIATOR)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_INITIATOR;\n\n\tif (ndlp->nlp_type & NLP_NVME_DISCOVERY)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\trpinfo.port_name = wwn_to_u64(ndlp->nlp_portname.u.wwn);\n\trpinfo.node_name = wwn_to_u64(ndlp->nlp_nodename.u.wwn);\n\tret = nvme_fc_register_remoteport(localport, &rpinfo, &remote_port);\n\tif (!ret) {\n\t\t/* If the ndlp already has an nrport, this is just\n\t\t * a resume of the existing rport.  Else this is a\n\t\t * new rport.\n\t\t */\n\t\trport = remote_port->private;\n	t
54715	154	expkey_parse	fs/nfsd/export.c	&key.ek_path	1	11	\N	\N	\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk("found domain %s\\n", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk("found fsidtype %d\\n", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk("found fsid length %d\\n", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk("Path seems to be <%s>\\n", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk("Found the path %s\\n", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n	t
363	1925	cnl_ddi_vswing_program	drivers/gpu/drm/i915/intel_ddi.c	n_entries	11	12	\N	\N	\tconst struct cnl_ddi_buf_trans *ddi_translations = NULL;\n\tu32 n_entries, val, voltage;\n\tint ln;\n\n\t/*\n\t * Values for each port type are listed in\n\t * voltage swing programming tables.\n\t * Vccio voltage found in PORT_COMP_DW3.\n\t */\n\tvoltage = I915_READ(CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;\n\n\tif (type == INTEL_OUTPUT_HDMI) {\n\t\tddi_translations = cnl_get_buf_trans_hdmi(dev_priv,\n\t\t\t\t\t\t\t  voltage, &n_entries);\n\t} else if (type == INTEL_OUTPUT_DP) {\n\t\tddi_translations = cnl_get_buf_trans_dp(dev_priv,\n\t\t\t\t\t\t\tvoltage, &n_entries);\n\t} else if (type == INTEL_OUTPUT_EDP) {\n\t\tddi_translations = cnl_get_buf_trans_edp(dev_priv,\n\t\t\t\t\t\t\t voltage, &n_entries);\n\t}\n\n\tif (ddi_translations == NULL) {\n\t\tMISSING_CASE(voltage);\n\t\treturn;\n\t}\n\n\tif (level >= n_entries) {\n\t\tDRM_DEBUG_KMS("DDI translation not found for level %d. Using %d instead.", level, n_entries - 1);\n	t
21051	383	handle_critical_trips	drivers/thermal/thermal_core.c	trip_temp	1	11	\N	\N	\tint trip_temp;\n\n\ttz->ops->get_trip_temp(tz, trip, &trip_temp);\n\n\t/* If we have not crossed the trip_temp, we do not care. */\n\tif (trip_temp <= 0 || tz->temperature < trip_temp)\n	t
25800	343	device_rtc_init	drivers/mfd/88pm800.c	ret	1	11	\N	\N	\tint ret;\n\n\tif (pdata) {\n\t\trtc_devs[0].platform_data = pdata->rtc;\n\t\trtc_devs[0].pdata_size =\n\t\t\t\tpdata->rtc ? sizeof(struct pm80x_rtc_pdata) : 0;\n\t}\n\tret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\n\t\t\t      ARRAY_SIZE(rtc_devs), NULL, 0, NULL);\n\tif (ret) {\n	t
35720	677	mwifiex_pcie_init_evt_ring	drivers/net/wireless/marvell/mwifiex/pcie.c	skb	1	11	\N	\N	\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    "Unable to allocate skb for EVENT buf.\\n");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n	t
2046	240	clk_alpha_pll_enable	drivers/clk/qcom/clk-alpha-pll.c	val	8	12	\N	\N	\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val, mask, off;\n\n\toff = pll->offset;\n\n\tmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\n\tret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If in FSM mode, just vote for it */\n\tif (val & PLL_VOTE_FSM_ENA) {\n	t
52506	9186	btrfs_page_mkwrite	fs/btrfs/inode.c	ret	1	11	\N	\N	\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tchar *kaddr;\n\tunsigned long zero_start;\n\tloff_t size;\n\tint ret;\n\tint reserved = 0;\n\tu64 reserved_space;\n\tu64 page_start;\n\tu64 page_end;\n\tu64 end;\n\n\treserved_space = PAGE_SIZE;\n\n\tsb_start_pagefault(inode->i_sb);\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_SIZE - 1;\n\tend = page_end;\n\n\t/*\n\t * Reserving delalloc space after obtaining the page lock can lead to\n\t * deadlock. For example, if a dirty page is locked by this function\n\t * and the call to btrfs_delalloc_reserve_space() ends up triggering\n\t * dirty page write out, then the btrfs_writepage() function could\n\t * end up waiting indefinitely to get a lock on the page currently\n\t * being processed by btrfs_page_mkwrite() function.\n\t */\n\tret = btrfs_delalloc_reserve_space(inode, &data_reserved, page_start,\n\t\t\t\t\t   reserved_space);\n\tif (!ret) {\n	t
46292	3136	ath10k_wmi_tlv_op_gen_echo	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_echo_$cmd$obj	0	11	\N	\N	\tstruct wmi_echo_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_ECHO_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->value = cpu_to_le32(value);\n	t
21329	300	bcm63xx_parse_cfe_partitions	drivers/mtd/bcm63xxpart.c	nvram	1	11	\N	\N	\tstruct bcm963xx_nvram *nvram = NULL;\n\tint ret;\n\n\tif (bcm63xx_detect_cfe(master))\n\t\treturn -EINVAL;\n\n\tnvram = vzalloc(sizeof(*nvram));\n\tif (!nvram)\n\t\treturn -ENOMEM;\n\n\tret = bcm63xx_read_nvram(master, nvram);\n	t
8717	2074	__emulate_int_real	arch/x86/kvm/emulate.c	cs	0	21	\N	\N	\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\n\t/* TODO: Add limit checks */\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);\n\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tops->get_idt(ctxt, &dt);\n\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n	f
21919	572	kone_sysfs_set_startup_profile	drivers/hid/hid-roccat-kone.c	new_startup_profile	1	11	\N	\N	\tstruct kone_device *kone;\n\tstruct usb_device *usb_dev;\n\tint retval;\n\tunsigned long new_startup_profile;\n\n\tdev = dev->parent->parent;\n\tkone = hid_get_drvdata(dev_get_drvdata(dev));\n\tusb_dev = interface_to_usbdev(to_usb_interface(dev));\n\n\tretval = kstrtoul(buf, 10, &new_startup_profile);\n\tif (retval)\n\t\treturn retval;\n\n\tif (new_startup_profile  < 1 || new_startup_profile > 5)\n	t
31159	892	block_clean_combined_dirty	drivers/md/dm-cache-metadata.c	flags	1	11	\N	\N	\tint r;\n\t__le64 value;\n\tdm_oblock_t ob;\n\tunsigned flags;\n\n\tr = dm_array_get_value(&cmd->info, cmd->root, from_cblock(b), &value);\n\tif (r)\n\t\treturn r;\n\n\tunpack_value(value, &ob, &flags);\n\t*result = !((flags & M_VALID) && (flags & M_DIRTY));\n	t
1435	98	add_system_zone	fs/ext4/block_validity.c	new_node	0	21	\N	\N	\tstruct ext4_system_zone *new_entry = NULL, *entry;\n\tstruct rb_node **n = &sbi->system_blks.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\tif (start_blk + count > (entry->start_blk +\n\t\t\t\t\t\t entry->count))\n\t\t\t\tentry->count = (start_blk + count -\n\t\t\t\t\t\tentry->start_blk);\n\t\t\tnew_node = *n;\n\t\t\tnew_entry = rb_entry(new_node, struct ext4_system_zone,\n\t\t\t\t\t     node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!new_entry) {\n\t\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tnew_entry->start_blk = start_blk;\n\t\tnew_entry->count = count;\n\t\tnew_node = &new_entry->node;\n\n\t\trb_link_node(new_node, parent, n);\n\t\trb_insert_color(new_node, &sbi->system_blks);\n\t}\n\n\t/* Can we merge to the left? */\n\tnode = rb_prev(new_node);\n	f
39409	933	tk_request	net/bluetooth/smp.c	passkey	1	11	\N	\N	\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tu32 passkey = 0;\n\tint ret = 0;\n\n\t/* Initialize key for JUST WORKS */\n\tmemset(smp->tk, 0, sizeof(smp->tk));\n\tclear_bit(SMP_FLAG_TK_VALID, &smp->flags);\n\n\tBT_DBG("tk_request: auth:%d lcl:%d rem:%d", auth, local_io, remote_io);\n\n\t/* If neither side wants MITM, either "just" confirm an incoming\n\t * request or use just-works for outgoing ones. The JUST_CFM\n\t * will be converted to JUST_WORKS if necessary later in this\n\t * function. If either side has MITM look up the method from the\n\t * table.\n\t */\n\tif (!(auth & SMP_AUTH_MITM))\n\t\tsmp->method = JUST_CFM;\n\telse\n\t\tsmp->method = get_auth_method(smp, local_io, remote_io);\n\n\t/* Don't confirm locally initiated pairing attempts */\n\tif (smp->method == JUST_CFM && test_bit(SMP_FLAG_INITIATOR,\n\t\t\t\t\t\t&smp->flags))\n\t\tsmp->method = JUST_WORKS;\n\n\t/* Don't bother user space with no IO capabilities */\n\tif (smp->method == JUST_CFM &&\n\t    hcon->io_capability == HCI_IO_NO_INPUT_OUTPUT)\n\t\tsmp->method = JUST_WORKS;\n\n\t/* If Just Works, Continue with Zero TK */\n\tif (smp->method == JUST_WORKS) {\n\t\tset_bit(SMP_FLAG_TK_VALID, &smp->flags);\n\t\treturn 0;\n\t}\n\n\t/* If this function is used for SC -> legacy fallback we\n\t * can only recover the just-works case.\n\t */\n\tif (test_bit(SMP_FLAG_SC, &smp->flags))\n\t\treturn -EINVAL;\n\n\t/* Not Just Works/Confirm results in MITM Authentication */\n\tif (smp->method != JUST_CFM) {\n\t\tset_bit(SMP_FLAG_MITM_AUTH, &smp->flags);\n\t\tif (hcon->pending_sec_level < BT_SECURITY_HIGH)\n\t\t\thcon->pending_sec_level = BT_SECURITY_HIGH;\n\t}\n\n\t/* If both devices have Keyoard-Display I/O, the master\n\t * Confirms and the slave Enters the passkey.\n\t */\n\tif (smp->method == OVERLAP) {\n\t\tif (hcon->role == HCI_ROLE_MASTER)\n\t\t\tsmp->method = CFM_PASSKEY;\n\t\telse\n\t\t\tsmp->method = REQ_PASSKEY;\n\t}\n\n\t/* Generate random passkey. */\n\tif (smp->method == CFM_PASSKEY) {\n\t\tmemset(smp->tk, 0, sizeof(smp->tk));\n\t\tget_random_bytes(&passkey, sizeof(passkey));\n\t\tpasskey %= 1000000;\n\t\tput_unaligned_le32(passkey, smp->tk);\n\t\tBT_DBG("PassKey: %d", passkey);\n	t
33	350	blk_mq_queue_tag_busy_iter	block/blk-mq-tag.c	&tags->bitmap_tags	0	21	\N	\N	\tstruct blk_mq_hw_ctx *hctx;\n\tint i;\n\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tstruct blk_mq_tags *tags = hctx->tags;\n\n\t\t/*\n\t\t * If not software queues are currently mapped to this\n\t\t * hardware queue, there's nothing to check\n\t\t */\n\t\tif (!blk_mq_hw_queue_mapped(hctx))\n\t\t\tcontinue;\n\n\t\tif (tags->nr_reserved_tags)\n\t\t\tbt_for_each(hctx, &tags->breserved_tags, fn, priv, true);\n\t\tbt_for_each(hctx, &tags->bitmap_tags, fn, priv, false);\n	f
57775	313	hfs_cat_move	fs/hfs/catalog.c	&dst_fd	1	11	\N	\N	\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, "rename_cat: %u - %lu,%s - %lu,%s\\n",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n	t
60264	1209	nvmet_rdma_queue_connect	drivers/nvme/target/rdma.c	ret	1	11	\N	\N	\tstruct nvmet_rdma_device *ndev;\n\tstruct nvmet_rdma_queue *queue;\n\tint ret = -EINVAL;\n\n\tndev = nvmet_rdma_find_get_device(cm_id);\n\tif (!ndev) {\n\t\tnvmet_rdma_cm_reject(cm_id, NVME_RDMA_CM_NO_RSC);\n\t\treturn -ECONNREFUSED;\n\t}\n\n\tqueue = nvmet_rdma_alloc_queue(ndev, cm_id, event);\n\tif (!queue) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\tqueue->port = cm_id->context;\n\n\tif (queue->host_qid == 0) {\n\t\t/* Let inflight controller teardown complete */\n\t\tflush_scheduled_work();\n\t}\n\n\tret = nvmet_rdma_cm_accept(cm_id, queue, &event->param.conn);\n\tif (ret)\n	t
41278	255	__ip6addrlbl_add	net/ipv6/addrlabel.c	__ip6addrlbl_add_$__mptr39$obj	0	11	\N	\N	\tstruct hlist_node *n;\n\tstruct ip6addrlbl_entry *last = NULL, *p = NULL;\n\tint ret = 0;\n\n\tADDRLABEL(KERN_DEBUG "%s(newp=%p, replace=%d)\\n", __func__, newp,\n\t\t  replace);\n\n\thlist_for_each_entry_safe(p, n,\t&ip6addrlbl_table.head, list) {\n	t
52549	500	wm8994_device_init	drivers/mfd/wm8994-core.c	wm8994_device_init_$wm8994.addr$obj$35$obj	0	11	\N	\N	\tstruct wm8994_pdata *pdata;\n\tstruct regmap_config *regmap_config;\n\tconst struct reg_sequence *regmap_patch = NULL;\n\tconst char *devname;\n\tint ret, i, patch_regs = 0;\n\tint pulls = 0;\n\n\tif (dev_get_platdata(wm8994->dev)) {\n\t\tpdata = dev_get_platdata(wm8994->dev);\n\t\twm8994->pdata = *pdata;\n\t}\n\tpdata = &wm8994->pdata;\n\n\tret = wm8994_set_pdata_from_of(wm8994);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tdev_set_drvdata(wm8994->dev, wm8994);\n\n\t/* Add the on-chip regulators first for bootstrapping */\n\tret = mfd_add_devices(wm8994->dev, 0,\n\t\t\t      wm8994_regulator_devs,\n\t\t\t      ARRAY_SIZE(wm8994_regulator_devs),\n\t\t\t      NULL, 0, NULL);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, "Failed to add children: %d\\n", ret);\n\t\tgoto err;\n\t}\n\n\tswitch (wm8994->type) {\n\tcase WM1811:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm1811_main_supplies);\n\t\tbreak;\n\tcase WM8994:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm8994_main_supplies);\n\t\tbreak;\n\tcase WM8958:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm8958_main_supplies);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tgoto err;\n\t}\n\n\twm8994->supplies = devm_kzalloc(wm8994->dev,\n\t\t\t\t\tsizeof(struct regulator_bulk_data) *\n\t\t\t\t\twm8994->num_supplies, GFP_KERNEL);\n\tif (!wm8994->supplies) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tswitch (wm8994->type) {\n\tcase WM1811:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm1811_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm1811_main_supplies[i];\n\t\tbreak;\n\tcase WM8994:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm8994_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm8994_main_supplies[i];\n\t\tbreak;\n\tcase WM8958:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm8958_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm8958_main_supplies[i];\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Can't use devres helper here as some of the supplies are provided by\n\t * wm8994->dev's children (regulators) and those regulators are\n\t * unregistered by the devres core before the supplies are freed.\n\t */\n\tret = regulator_bulk_get(wm8994->dev, wm8994->num_supplies,\n\t\t\t\t wm8994->supplies);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, "Failed to get supplies: %d\\n", ret);\n\t\tgoto err;\n\t}\n\n\tret = regulator_bulk_enable(wm8994->num_supplies, wm8994->supplies);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, "Failed to enable supplies: %d\\n", ret);\n\t\tgoto err_regulator_free;\n\t}\n\n\tret = wm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET);\n\tif (ret < 0) {\n\t\tdev_err(wm8994->dev, "Failed to read ID register\\n");\n\t\tgoto err_enable;\n\t}\n\tswitch (ret) {\n\tcase 0x1811:\n\t\tdevname = "WM1811";\n\t\tif (wm8994->type != WM1811)\n\t\t\tdev_warn(wm8994->dev, "Device registered as type %d\\n",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM1811;\n\t\tbreak;\n\tcase 0x8994:\n\t\tdevname = "WM8994";\n\t\tif (wm8994->type != WM8994)\n\t\t\tdev_warn(wm8994->dev, "Device registered as type %d\\n",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM8994;\n\t\tbreak;\n\tcase 0x8958:\n\t\tdevname = "WM8958";\n\t\tif (wm8994->type != WM8958)\n\t\t\tdev_warn(wm8994->dev, "Device registered as type %d\\n",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM8958;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(wm8994->dev, "Device is not a WM8994, ID is %x\\n",\n\t\t\tret);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = wm8994_reg_read(wm8994, WM8994_CHIP_REVISION);\n\tif (ret < 0) {\n\t\tdev_err(wm8994->dev, "Failed to read revision register: %d\\n",\n\t\t\tret);\n\t\tgoto err_enable;\n\t}\n\twm8994->revision = ret & WM8994_CHIP_REV_MASK;\n\twm8994->cust_id = (ret & WM8994_CUST_ID_MASK) >> WM8994_CUST_ID_SHIFT;\n\n\tswitch (wm8994->type) {\n\tcase WM8994:\n\t\tswitch (wm8994->revision) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tdev_warn(wm8994->dev,\n\t\t\t\t "revision %c not fully supported\\n",\n\t\t\t\t 'A' + wm8994->revision);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\tdefault:\n\t\t\tregmap_patch = wm8994_revc_patch;\n\t\t\tpatch_regs = ARRAY_SIZE(wm8994_revc_patch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM8958:\n\t\tswitch (wm8994->revision) {\n\t\tcase 0:\n\t\t\tregmap_patch = wm8958_reva_patch;\n\t\t\tpatch_regs = ARRAY_SIZE(wm8958_reva_patch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM1811:\n\t\t/* Revision C did not change the relevant layer */\n\t\tif (wm8994->revision > 1)\n\t\t\twm8994->revision++;\n\n\t\tregmap_patch = wm1811_reva_patch;\n\t\tpatch_regs = ARRAY_SIZE(wm1811_reva_patch);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_info(wm8994->dev, "%s revision %c CUST_ID %02x\\n", devname,\n	t
32228	221	amdgpufb_create	drivers/gpu/drm/amd/amdgpu/amdgpu_fb.c	amdgpufb_create_$__mptr$obj	0	11	\N	\N	\tstruct amdgpu_fbdev *rfbdev = (struct amdgpu_fbdev *)helper;\n\tstruct amdgpu_device *adev = rfbdev->adev;\n\tstruct fb_info *info;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_mode_fb_cmd2 mode_cmd;\n\tstruct drm_gem_object *gobj = NULL;\n\tstruct amdgpu_bo *abo = NULL;\n\tint ret;\n\tunsigned long tmp;\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\n\tif (sizes->surface_bpp == 24)\n\t\tsizes->surface_bpp = 32;\n\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\t\t\t  sizes->surface_depth);\n\n\tret = amdgpufb_create_pinned_object(rfbdev, &mode_cmd, &gobj);\n\tif (ret) {\n\t\tDRM_ERROR("failed to create fbcon object %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tabo = gem_to_amdgpu_bo(gobj);\n	t
40446	525	start_streaming	drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c	ret	1	11	\N	\N	\tstruct bm2835_mmal_dev *dev = vb2_get_drv_priv(vq);\n\tint ret;\n\tint parameter_size;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p\\n",\n\t\t __func__, dev);\n\n\t/* ensure a format has actually been set */\n\tif (!dev->capture.port)\n\t\treturn -EINVAL;\n\n\tif (enable_camera(dev) < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, "Failed to enable camera\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/*init_completion(&dev->capture.frame_cmplt); */\n\n\t/* enable frame capture */\n\tdev->capture.frame_count = 1;\n\n\t/* if the preview is not already running, wait for a few frames for AGC\n\t * to settle down.\n\t */\n\tif (!dev->component[MMAL_COMPONENT_PREVIEW]->enabled)\n\t\tmsleep(300);\n\n\t/* enable the connection from camera to encoder (if applicable) */\n\tif (dev->capture.camera_port != dev->capture.port\n\t    && dev->capture.camera_port) {\n\t\tret = vchiq_mmal_port_enable(dev->instance,\n\t\t\t\t\t     dev->capture.camera_port, NULL);\n\t\tif (ret) {\n	t
23108	433	xfs_refcount_merge_left_extent	fs/xfs/libxfs/xfs_refcount.c	xfs_refcount_merge_left_extent_$fs_is_ok$obj$icmp$0$xor$-1$xor$-1$xor$-1	0	13	\N	\N	\tint\t\t\t\terror;\n\tint\t\t\t\tfound_rec;\n\n\ttrace_xfs_refcount_merge_left_extent(cur->bc_mp,\n\t\t\tcur->bc_private.a.agno, left, cleft);\n\n\t/* If the extent at agbno (cleft) wasn't synthesized, remove it. */\n\tif (cleft->rc_refcount > 1) {\n\t\terror = xfs_refcount_lookup_le(cur, cleft->rc_startblock,\n\t\t\t\t&found_rec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\n	f
7772	1161	fimc_pipeline_validate	drivers/media/platform/exynos4-is/fimc-capture.c	sink_fmt.format.code	6	12	\N	\N	\tstruct v4l2_subdev_format sink_fmt, src_fmt;\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct v4l2_subdev *sd = &vc->subdev;\n\tstruct fimc_pipeline *p = to_fimc_pipeline(vc->ve.pipe);\n\tstruct media_pad *sink_pad, *src_pad;\n\tint i, ret;\n\n\twhile (1) {\n\t\t/*\n\t\t * Find current entity sink pad and any remote sink pad linked\n\t\t * to it. We stop if there is no sink pad in current entity or\n\t\t * it is not linked to any other remote entity.\n\t\t */\n\t\tsrc_pad = NULL;\n\n\t\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\t\tstruct media_pad *p = &sd->entity.pads[i];\n\n\t\t\tif (p->flags & MEDIA_PAD_FL_SINK) {\n\t\t\t\tsink_pad = p;\n\t\t\t\tsrc_pad = media_entity_remote_pad(sink_pad);\n\t\t\t\tif (src_pad)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!src_pad || !is_media_entity_v4l2_subdev(src_pad->entity))\n\t\t\tbreak;\n\n\t\t/* Don't call FIMC subdev operation to avoid nested locking */\n\t\tif (sd == &vc->subdev) {\n\t\t\tstruct fimc_frame *ff = &vc->ctx->s_frame;\n\t\t\tsink_fmt.format.width = ff->f_width;\n\t\t\tsink_fmt.format.height = ff->f_height;\n\t\t\tsink_fmt.format.code = ff->fmt ? ff->fmt->mbus_code : 0;\n\t\t} else {\n\t\t\tsink_fmt.pad = sink_pad->index;\n\t\t\tsink_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\t\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sink_fmt);\n\t\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\t\treturn -EPIPE;\n\t\t}\n\n\t\t/* Retrieve format at the source pad */\n\t\tsd = media_entity_to_v4l2_subdev(src_pad->entity);\n\t\tsrc_fmt.pad = src_pad->index;\n\t\tsrc_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn -EPIPE;\n\n\t\tif (src_fmt.format.width != sink_fmt.format.width ||\n\t\t    src_fmt.format.height != sink_fmt.format.height ||\n	t
53919	2643	btrfs_punch_hole	fs/btrfs/file.c	drop_end	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trans_metadata_size(fs_info, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tunsigned int rsv_count;\n\tbool same_block;\n\tbool no_holes = btrfs_fs_incompat(fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_block = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\tino_size = round_up(inode->i_size, fs_info->sectorsize);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, btrfs_inode_sectorsize(inode));\n\tlockend = round_down(offset + len,\n\t\t\t     btrfs_inode_sectorsize(inode)) - 1;\n\tsame_block = (BTRFS_BYTES_TO_BLKS(fs_info, offset))\n\t\t== (BTRFS_BYTES_TO_BLKS(fs_info, offset + len - 1));\n\t/*\n\t * We needn't truncate any block which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same block and we aren't doing the\n\t * entire block.\n\t */\n\tif (same_block && len < fs_info->sectorsize) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_block = true;\n\t\t\tret = btrfs_truncate_block(inode, offset, len, 0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t/* zero back part of the first block */\n\tif (offset < ino_size) {\n\t\ttruncated_block = true;\n\t\tret = btrfs_truncate_block(inode, offset, 0, 0);\n\t\tif (ret) {\n\t\t\tinode_unlock(inode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Check the aligned pages after the first unaligned page,\n\t * if offset != orig_start, which means the first unaligned page\n\t * including several following pages are already in holes,\n\t * the extra check can be skipped */\n\tif (offset == orig_start) {\n\t\t/* after truncate page, check hole again */\n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(inode, &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t/* Check the tail unaligned part is in a hole */\n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(inode, &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t/* zero the front end of the last page */\n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_block = true;\n\t\t\t\tret = btrfs_truncate_block(inode,\n\t\t\t\t\t\t\ttail_start + tail_len,\n\t\t\t\t\t\t\t0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, lockend);\n\n\t\t/*\n\t\t * We need to make sure we have no ordered extents in this range\n\t\t * and nobody raced in and read a page in this range, if we did\n\t\t * we need to try again.\n\t\t */\n\t\tif ((!ordered ||\n\t\t    (ordered->file_offset + ordered->len <= lockstart ||\n\t\t     ordered->file_offset > lockend)) &&\n\t\t     !btrfs_page_exists_in_range(inode, lockstart, lockend)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t     lockend, &cached_state, GFP_NOFS);\n\t\tret = btrfs_wait_ordered_range(inode, lockstart,\n\t\t\t\t\t       lockend - lockstart + 1);\n\t\tif (ret) {\n\t\t\tinode_unlock(inode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(fs_info, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\trsv->size = btrfs_calc_trans_metadata_size(fs_info, 1);\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 - update the inode\n\t * 1 - removing the extents in the range\n\t * 1 - adding the hole extent if no_holes isn't set\n\t */\n\trsv_count = no_holes ? 2 : 3;\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size, 0);\n\tBUG_ON(ret);\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = lockstart;\n\tlen = lockend - cur_offset;\n\twhile (cur_offset < lockend) {\n\t\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t\t   cur_offset, lockend + 1,\n\t\t\t\t\t   &drop_end, 1, 0, 0, NULL);\n\t\tif (ret != -ENOSPC)\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\n\t\tif (cur_offset < drop_end && cur_offset < ino_size) {\n	t
55195	1258	aa_change_profile	security/apparmor/domain.c	aa_change_profile_$__lvec$obj$0$obj$10	0	11	\N	\N	\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t/* retain leading & if stack */\n\tbool stack = flags & AA_CHANGE_STACK;\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tif (!fqname || !*fqname) {\n\t\tAA_DEBUG("no profile name");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tlabel = aa_get_current_label();\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t/* don't have label_parse() do stacking */\n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = "label not found";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t/*\n\t\t * TODO: fixme using labels_profile is not right - do profile\n\t\t * per complain profile\n\t\t */\n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t/* released below */\n\t\ttprofile = aa_new_null_profile(labels_profile(label), false,\n\t\t\t\t\t       fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = "failed null profile create";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t/*\n\t * self directed transitions only apply to current policy ns\n\t * TODO: currently requiring perms for stacking and straight change\n\t *       stacking doesn't strictly need this. Determine how much\n\t *       we want to loosen this restriction for stacking\n\t *\n\t * if (!stack) {\n\t */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t/* auditing done in change_profile_perms_wrapper */\n\t\tgoto out;\n\n\t/* } */\n\ncheck:\n\t/* check if tracing task is allowed to trace target domain */\n\terror = may_change_ptraced_domain(target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t/* TODO: add permission check to allow this\n\t * if ((flags & AA_CHANGE_ONEXEC) && !current_is_single_threaded()) {\n\t *      info = "not a single threaded task";\n\t *      error = -EACCES;\n\t *      goto audit;\n\t * }\n\t */\n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t/* only transition profiles in the current ns */\n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\telse\n\t\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n	t
57369	463	spcp8x5_tiocmget	drivers/usb/serial/spcp8x5.c	status	1	11	\N	\N	\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int mcr;\n\tu8 status;\n\tunsigned int result;\n\n\tresult = spcp8x5_get_msr(port, &status);\n\tif (result)\n\t\treturn result;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmcr = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tresult = ((mcr & MCR_DTR)\t\t\t? TIOCM_DTR : 0)\n\t\t  | ((mcr & MCR_RTS)\t\t\t? TIOCM_RTS : 0)\n\t\t  | ((status & MSR_STATUS_LINE_CTS)\t? TIOCM_CTS : 0)\n	t
59129	6466	bnx2_reset_task	drivers/net/ethernet/broadcom/bnx2.c	pcicmd	1	11	\N	\N	\tstruct bnx2 *bp = container_of(work, struct bnx2, reset_task);\n\tint rc;\n\tu16 pcicmd;\n\n\trtnl_lock();\n\tif (!netif_running(bp->dev)) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tbnx2_netif_stop(bp, true);\n\n\tpci_read_config_word(bp->pdev, PCI_COMMAND, &pcicmd);\n\tif (!(pcicmd & PCI_COMMAND_MEMORY)) {\n	t
42880	355	page_to_skb	drivers/net/virtio_net.c	skb->dev->name	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct virtio_net_hdr_mrg_rxbuf *hdr;\n\tunsigned int copy, hdr_len, hdr_padded_len;\n\tchar *p;\n\n\tp = page_address(page) + offset;\n\n\t/* copy small packet so we can reuse these pages for small data */\n\tskb = napi_alloc_skb(&rq->napi, GOOD_COPY_LEN);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\thdr = skb_vnet_hdr(skb);\n\n\thdr_len = vi->hdr_len;\n\tif (vi->mergeable_rx_bufs)\n\t\thdr_padded_len = sizeof(*hdr);\n\telse\n\t\thdr_padded_len = sizeof(struct padded_vnet_hdr);\n\n\tmemcpy(hdr, p, hdr_len);\n\n\tlen -= hdr_len;\n\toffset += hdr_padded_len;\n\tp += hdr_padded_len;\n\n\tcopy = len;\n\tif (copy > skb_tailroom(skb))\n\t\tcopy = skb_tailroom(skb);\n\tskb_put_data(skb, p, copy);\n\n\tlen -= copy;\n\toffset += copy;\n\n\tif (vi->mergeable_rx_bufs) {\n\t\tif (len)\n\t\t\tskb_add_rx_frag(skb, 0, page, offset, len, truesize);\n\t\telse\n\t\t\tput_page(page);\n\t\treturn skb;\n\t}\n\n\t/*\n\t * Verify that we can indeed put this data into a skb.\n\t * This is here to handle cases when the device erroneously\n\t * tries to receive more than is possible. This is usually\n\t * the case of a broken device.\n\t */\n\tif (unlikely(len > MAX_SKB_FRAGS * PAGE_SIZE)) {\n\t\tnet_dbg_ratelimited("%s: too much data\\n", skb->dev->name);\n	t
33386	455	nfc_genl_se_added	net/nfc/netlink.c	msg	1	11	\N	\N	\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n	t
-6	1710	ov5693_detect	drivers/staging/media/atomisp/i2c/ov5693/ov5693.c	low	21	2	arg_no	\N	\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 high, low;\n\tint ret;\n\tu16 id;\n\tu8 revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t\t\tOV5693_SC_CMMN_CHIP_ID_H, &high);\n\tif (ret) {\n\t\tdev_err(&client->dev, "sensor_id_high = 0x%x\\n", high);\n\t\treturn -ENODEV;\n\t}\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t\t\tOV5693_SC_CMMN_CHIP_ID_L, &low);\n\tid = ((((u16) high) << 8) | (u16) low);\n	f
25907	666	bcm3510_check_firmware_version	drivers/media/dvb-frontends/bcm3510.c	ver.demod_version	6	12	\N	TP	\tstruct bcm3510_hab_cmd_get_version_info ver;\n\tbcm3510_do_hab_cmd(st,CMD_GET_VERSION_INFO,MSGID_GET_VERSION_INFO,NULL,0,(u8*)&ver,sizeof(ver));\n\n\tdeb_info("Version information: 0x%02x 0x%02x 0x%02x 0x%02x\\n",\n	t
-4	1565	mt9m114_detect	drivers/staging/media/atomisp/i2c/mt9m114.c	retvalue	20	2	arg_no	\N	\tstruct i2c_adapter *adapter = client->adapter;\n\tu32 retvalue;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, "%s: i2c error", __func__);\n\t\treturn -ENODEV;\n\t}\n\tmt9m114_read_reg(client, MISENSOR_16BIT, (u32)MT9M114_PID, &retvalue);\n\tdev->real_model_id = retvalue;\n\n\tif (retvalue != MT9M114_MOD_ID) {\n	f
28620	290	__shadow_block	drivers/md/persistent-data/dm-transaction-manager.c	new	6	12	\N	\N	\tint r;\n\tdm_block_t new;\n\tstruct dm_block *orig_block;\n\n\tr = dm_sm_new_block(tm->sm, &new);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_dec_block(tm->sm, orig);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_bm_read_lock(tm->bm, orig, v, &orig_block);\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * It would be tempting to use dm_bm_unlock_move here, but some\n\t * code, such as the space maps, keeps using the old data structures\n\t * secure in the knowledge they won't be changed until the next\n\t * transaction.  Using unlock_move would force a synchronous read\n\t * since the old block would no longer be in the cache.\n\t */\n\tr = dm_bm_write_lock_zero(tm->bm, new, v, result);\n	t
57238	894	ch_ioctl_compat	drivers/scsi/ch.c	ch_ioctl_compat_$ces32$0$obj	0	11	\N	\N	\tscsi_changer *ch = file->private_data;\n\n\tswitch (cmd) {\n\tcase CHIOGPARAMS:\n\tcase CHIOGVPARAMS:\n\tcase CHIOPOSITION:\n\tcase CHIOMOVE:\n\tcase CHIOEXCHANGE:\n\tcase CHIOGELEM:\n\tcase CHIOINITELEM:\n\tcase CHIOSVOLTAG:\n\t\t/* compatible */\n\t\treturn ch_ioctl(file, cmd, arg);\n\tcase CHIOGSTATUS32:\n\t{\n\t\tstruct changer_element_status32 ces32;\n\t\tunsigned char __user *data;\n\n\t\tif (copy_from_user(&ces32, (void __user *)arg, sizeof (ces32)))\n\t\t\treturn -EFAULT;\n\t\tif (ces32.ces_type < 0 || ces32.ces_type >= CH_TYPES)\n	t
28963	501	mn88473_init	drivers/media/dvb-frontends/mn88473.c	mn88473_init_$fw$obj	0	11	\N	\N	\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len, remain;\n\tunsigned int uitmp;\n\tconst struct firmware *fw;\n\tconst char *name = MN88473_FIRMWARE;\n\n\tdev_dbg(&client->dev, "\\n");\n\n\t/* Check if firmware is already running */\n\tret = regmap_read(dev->regmap[0], 0xf5, &uitmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!(uitmp & 0x01))\n\t\tgoto warm;\n\n\t/* Request the firmware, this will block and timeout */\n\tret = request_firmware(&fw, name, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, "firmware file '%s' not found\\n", name);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, "downloading firmware from file '%s'\\n", name);\n\n\tret = regmap_write(dev->regmap[0], 0xf5, 0x03);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\tfor (remain = fw->size; remain > 0; remain -= (dev->i2c_wr_max - 1)) {\n	t
60500	816	rds_ib_conn_path_shutdown	net/rds/ib_cm.c	err	1	11	\N	\N	\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tint err = 0;\n\n\trdsdebug("cm %p pd %p cq %p %p qp %p\\n", ic->i_cm_id,\n\t\t ic->i_pd, ic->i_send_cq, ic->i_recv_cq,\n\t\t ic->i_cm_id ? ic->i_cm_id->qp : NULL);\n\n\tif (ic->i_cm_id) {\n\t\tstruct ib_device *dev = ic->i_cm_id->device;\n\n\t\trdsdebug("disconnecting cm %p\\n", ic->i_cm_id);\n\t\terr = rdma_disconnect(ic->i_cm_id);\n\t\tif (err) {\n	t
3153	274	nf_ct_get_tuplepr	net/netfilter/nf_conntrack_core.c	protonum	1	11	\N	\N	\tconst struct nf_conntrack_l3proto *l3proto;\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tunsigned int protoff;\n\tu_int8_t protonum;\n\tint ret;\n\n\trcu_read_lock();\n\n\tl3proto = __nf_ct_l3proto_find(l3num);\n\tret = l3proto->get_l4proto(skb, nhoff, &protoff, &protonum);\n\tif (ret != NF_ACCEPT) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\tl4proto = __nf_ct_l4proto_find(l3num, protonum);\n	t
3814	2078	altera_execute	drivers/misc/altera-stapl/altera.c	source2	1	11	\N	\N	\tstruct altera_config *aconf = astate->config;\n\tchar *msg_buff = astate->msg_buff;\n\tlong *stack = astate->stack;\n\tint status = 0;\n\tu32 first_word = 0L;\n\tu32 action_table = 0L;\n\tu32 proc_table = 0L;\n\tu32 str_table = 0L;\n\tu32 sym_table = 0L;\n\tu32 data_sect = 0L;\n\tu32 code_sect = 0L;\n\tu32 debug_sect = 0L;\n\tu32 action_count = 0L;\n\tu32 proc_count = 0L;\n\tu32 sym_count = 0L;\n\tlong *vars = NULL;\n\ts32 *var_size = NULL;\n\tchar *attrs = NULL;\n\tu8 *proc_attributes = NULL;\n\tu32 pc;\n\tu32 opcode_address;\n\tu32 args[3];\n\tu32 opcode;\n\tu32 name_id;\n\tu8 charbuf[4];\n\tlong long_tmp;\n\tu32 variable_id;\n\tu8 *charptr_tmp;\n\tu8 *charptr_tmp2;\n\tlong *longptr_tmp;\n\tint version = 0;\n\tint delta = 0;\n\tint stack_ptr = 0;\n\tu32 arg_count;\n\tint done = 0;\n\tint bad_opcode = 0;\n\tu32 count;\n\tu32 index;\n\tu32 index2;\n\ts32 long_count;\n\ts32 long_idx;\n\ts32 long_idx2;\n\tu32 i;\n\tu32 j;\n\tu32 uncomp_size;\n\tu32 offset;\n\tu32 value;\n\tint current_proc = 0;\n\tint reverse;\n\n\tchar *name;\n\n\tdprintk("%s\\n", __func__);\n\n\t/* Read header information */\n\tif (program_size > 52L) {\n\t\tfirst_word    = get_unaligned_be32(&p[0]);\n\t\tversion = (first_word & 1L);\n\t\t*format_version = version + 1;\n\t\tdelta = version * 8;\n\n\t\taction_table  = get_unaligned_be32(&p[4]);\n\t\tproc_table    = get_unaligned_be32(&p[8]);\n\t\tstr_table  = get_unaligned_be32(&p[4 + delta]);\n\t\tsym_table  = get_unaligned_be32(&p[16 + delta]);\n\t\tdata_sect  = get_unaligned_be32(&p[20 + delta]);\n\t\tcode_sect  = get_unaligned_be32(&p[24 + delta]);\n\t\tdebug_sect = get_unaligned_be32(&p[28 + delta]);\n\t\taction_count  = get_unaligned_be32(&p[40 + delta]);\n\t\tproc_count    = get_unaligned_be32(&p[44 + delta]);\n\t\tsym_count  = get_unaligned_be32(&p[48 + (2 * delta)]);\n\t}\n\n\tif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L)) {\n\t\tdone = 1;\n\t\tstatus = -EIO;\n\t\tgoto exit_done;\n\t}\n\n\tif (sym_count <= 0)\n\t\tgoto exit_done;\n\n\tvars = kzalloc(sym_count * sizeof(long), GFP_KERNEL);\n\n\tif (vars == NULL)\n\t\tstatus = -ENOMEM;\n\n\tif (status == 0) {\n\t\tvar_size = kzalloc(sym_count * sizeof(s32), GFP_KERNEL);\n\n\t\tif (var_size == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif (status == 0) {\n\t\tattrs = kzalloc(sym_count, GFP_KERNEL);\n\n\t\tif (attrs == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif ((status == 0) && (version > 0)) {\n\t\tproc_attributes = kzalloc(proc_count, GFP_KERNEL);\n\n\t\tif (proc_attributes == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif (status != 0)\n\t\tgoto exit_done;\n\n\tdelta = version * 2;\n\n\tfor (i = 0; i < sym_count; ++i) {\n\t\toffset = (sym_table + ((11 + delta) * i));\n\n\t\tvalue = get_unaligned_be32(&p[offset + 3 + delta]);\n\n\t\tattrs[i] = p[offset];\n\n\t\t/*\n\t\t * use bit 7 of attribute byte to indicate that\n\t\t * this buffer was dynamically allocated\n\t\t * and should be freed later\n\t\t */\n\t\tattrs[i] &= 0x7f;\n\n\t\tvar_size[i] = get_unaligned_be32(&p[offset + 7 + delta]);\n\n\t\t/*\n\t\t * Attribute bits:\n\t\t * bit 0: 0 = read-only, 1 = read-write\n\t\t * bit 1: 0 = not compressed, 1 = compressed\n\t\t * bit 2: 0 = not initialized, 1 = initialized\n\t\t * bit 3: 0 = scalar, 1 = array\n\t\t * bit 4: 0 = Boolean, 1 = integer\n\t\t * bit 5: 0 = declared variable,\n\t\t *\t1 = compiler created temporary variable\n\t\t */\n\n\t\tif ((attrs[i] & 0x0c) == 0x04)\n\t\t\t/* initialized scalar variable */\n\t\t\tvars[i] = value;\n\t\telse if ((attrs[i] & 0x1e) == 0x0e) {\n\t\t\t/* initialized compressed Boolean array */\n\t\t\tuncomp_size = get_unaligned_le32(&p[data_sect + value]);\n\n\t\t\t/* allocate a buffer for the uncompressed data */\n\t\t\tvars[i] = (long)kzalloc(uncomp_size, GFP_KERNEL);\n\t\t\tif (vars[i] == 0L)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse {\n\t\t\t\t/* set flag so buffer will be freed later */\n\t\t\t\tattrs[i] |= 0x80;\n\n\t\t\t\t/* uncompress the data */\n\t\t\t\tif (altera_shrink(&p[data_sect + value],\n\t\t\t\t\t\tvar_size[i],\n\t\t\t\t\t\t(u8 *)vars[i],\n\t\t\t\t\t\tuncomp_size,\n\t\t\t\t\t\tversion) != uncomp_size)\n\t\t\t\t\t/* decompression failed */\n\t\t\t\t\tstatus = -EIO;\n\t\t\t\telse\n\t\t\t\t\tvar_size[i] = uncomp_size * 8L;\n\n\t\t\t}\n\t\t} else if ((attrs[i] & 0x1e) == 0x0c) {\n\t\t\t/* initialized Boolean array */\n\t\t\tvars[i] = value + data_sect + (long)p;\n\t\t} else if ((attrs[i] & 0x1c) == 0x1c) {\n\t\t\t/* initialized integer array */\n\t\t\tvars[i] = value + data_sect;\n\t\t} else if ((attrs[i] & 0x0c) == 0x08) {\n\t\t\t/* uninitialized array */\n\n\t\t\t/* flag attrs so that memory is freed */\n\t\t\tattrs[i] |= 0x80;\n\n\t\t\tif (var_size[i] > 0) {\n\t\t\t\tu32 size;\n\n\t\t\t\tif (attrs[i] & 0x10)\n\t\t\t\t\t/* integer array */\n\t\t\t\t\tsize = (var_size[i] * sizeof(s32));\n\t\t\t\telse\n\t\t\t\t\t/* Boolean array */\n\t\t\t\t\tsize = ((var_size[i] + 7L) / 8L);\n\n\t\t\t\tvars[i] = (long)kzalloc(size, GFP_KERNEL);\n\n\t\t\t\tif (vars[i] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\t/* zero out memory */\n\t\t\t\t\tfor (j = 0; j < size; ++j)\n\t\t\t\t\t\t((u8 *)(vars[i]))[j] = 0;\n\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tvars[i] = 0;\n\n\t\t} else\n\t\t\tvars[i] = 0;\n\n\t}\n\nexit_done:\n\tif (status != 0)\n\t\tdone = 1;\n\n\taltera_jinit(astate);\n\n\tpc = code_sect;\n\tmsg_buff[0] = '\\0';\n\n\t/*\n\t * For JBC version 2, we will execute the procedures corresponding to\n\t * the selected ACTION\n\t */\n\tif (version > 0) {\n\t\tif (aconf->action == NULL) {\n\t\t\tstatus = -EINVAL;\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tint action_found = 0;\n\t\t\tfor (i = 0; (i < action_count) && !action_found; ++i) {\n\t\t\t\tname_id = get_unaligned_be32(&p[action_table +\n\t\t\t\t\t\t\t\t(12 * i)]);\n\n\t\t\t\tname = &p[str_table + name_id];\n\n\t\t\t\tif (strncasecmp(aconf->action, name, strlen(name)) == 0) {\n\t\t\t\t\taction_found = 1;\n\t\t\t\t\tcurrent_proc =\n\t\t\t\t\t\tget_unaligned_be32(&p[action_table +\n\t\t\t\t\t\t\t\t(12 * i) + 8]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!action_found) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tint first_time = 1;\n\t\t\ti = current_proc;\n\t\t\twhile ((i != 0) || first_time) {\n\t\t\t\tfirst_time = 0;\n\t\t\t\t/* check procedure attribute byte */\n\t\t\t\tproc_attributes[i] =\n\t\t\t\t\t\t(p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 8] &\n\t\t\t\t\t\t\t\t\t0x03);\n\n\t\t\t\t/*\n\t\t\t\t * BIT0 - OPTIONAL\n\t\t\t\t * BIT1 - RECOMMENDED\n\t\t\t\t * BIT6 - FORCED OFF\n\t\t\t\t * BIT7 - FORCED ON\n\t\t\t\t */\n\n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t(13 * i) + 4]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set current_proc to the first procedure\n\t\t\t * to be executed\n\t\t\t */\n\t\t\ti = current_proc;\n\t\t\twhile ((i != 0) &&\n\t\t\t\t((proc_attributes[i] == 1) ||\n\t\t\t\t((proc_attributes[i] & 0xc0) == 0x40))) {\n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t(13 * i) + 4]);\n\t\t\t}\n\n\t\t\tif ((i != 0) || ((i == 0) && (current_proc == 0) &&\n\t\t\t\t((proc_attributes[0] != 1) &&\n\t\t\t\t((proc_attributes[0] & 0xc0) != 0x40)))) {\n\t\t\t\tcurrent_proc = i;\n\t\t\t\tpc = code_sect +\n\t\t\t\t\tget_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 9]);\n\t\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t} else\n\t\t\t\t/* there are no procedures to execute! */\n\t\t\t\tdone = 1;\n\n\t\t}\n\t}\n\n\tmsg_buff[0] = '\\0';\n\n\twhile (!done) {\n\t\topcode = (p[pc] & 0xff);\n\t\topcode_address = pc;\n\t\t++pc;\n\n\t\tif (debug > 1)\n\t\t\tprintk("opcode: %02x\\n", opcode);\n\n\t\targ_count = (opcode >> 6) & 3;\n\t\tfor (i = 0; i < arg_count; ++i) {\n\t\t\targs[i] = get_unaligned_be32(&p[pc]);\n\t\t\tpc += 4;\n\t\t}\n\n\t\tswitch (opcode) {\n\t\tcase OP_NOP:\n\t\t\tbreak;\n\t\tcase OP_DUP:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - 1];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SWP:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - 2];\n\t\t\t\tstack[stack_ptr - 2] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_ADD:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] += stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SUB:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] -= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_MULT:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] *= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DIV:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] /= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_MOD:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] %= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SHL:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] <<= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SHR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] >>= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_NOT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tstack[stack_ptr - 1] ^= (-1L);\n\n\t\t\tbreak;\n\t\tcase OP_AND:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] &= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_OR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] |= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_XOR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] ^= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_INV:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tstack[stack_ptr - 1] = stack[stack_ptr - 1] ? 0L : 1L;\n\t\t\tbreak;\n\t\tcase OP_GT:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] > stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\n\t\t\tbreak;\n\t\tcase OP_LT:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] < stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\n\t\t\tbreak;\n\t\tcase OP_RET:\n\t\t\tif ((version > 0) && (stack_ptr == 0)) {\n\t\t\t\t/*\n\t\t\t\t * We completed one of the main procedures\n\t\t\t\t * of an ACTION.\n\t\t\t\t * Find the next procedure\n\t\t\t\t * to be executed and jump to it.\n\t\t\t\t * If there are no more procedures, then EXIT.\n\t\t\t\t */\n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t(13 * current_proc) + 4]);\n\t\t\t\twhile ((i != 0) &&\n\t\t\t\t\t((proc_attributes[i] == 1) ||\n\t\t\t\t\t((proc_attributes[i] & 0xc0) == 0x40)))\n\t\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 4]);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\t/* no procedures to execute! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t\t*exit_code = 0;\t/* success */\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_proc = i;\n\t\t\t\t\tpc = code_sect + get_unaligned_be32(\n\t\t\t\t\t\t\t\t&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 9]);\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\t\tpc = stack[--stack_ptr] + code_sect;\n\t\t\t\t\tif ((pc <= code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\n\t\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_CMPS:\n\t\t\t/*\n\t\t\t * Array short compare\n\t\t\t * ...stack 0 is source 1 value\n\t\t\t * ...stack 1 is source 2 value\n\t\t\t * ...stack 2 is mask value\n\t\t\t * ...stack 3 is count\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 4, &status)) {\n\t\t\t\ts32 a = stack[--stack_ptr];\n\t\t\t\ts32 b = stack[--stack_ptr];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\tcount = stack[stack_ptr - 1];\n\n\t\t\t\tif ((count < 1) || (count > 32))\n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\telse {\n\t\t\t\t\tlong_tmp &= ((-1L) >> (32 - count));\n\n\t\t\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t\t((a & long_tmp) == (b & long_tmp))\n\t\t\t\t\t\t\t\t? 1L : 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PINT:\n\t\t\t/*\n\t\t\t * PRINT add integer\n\t\t\t * ...stack 0 is integer value\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tsprintf(&msg_buff[strlen(msg_buff)],\n\t\t\t\t\t"%ld", stack[--stack_ptr]);\n\t\t\tbreak;\n\t\tcase OP_PRNT:\n\t\t\t/* PRINT finish */\n\t\t\tif (debug)\n\t\t\t\tprintk(msg_buff, "\\n");\n\n\t\t\tmsg_buff[0] = '\\0';\n\t\t\tbreak;\n\t\tcase OP_DSS:\n\t\t\t/*\n\t\t\t * DRSCAN short\n\t\t\t * ...stack 0 is scan data\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_drscan(astate, count, charbuf, 0);\n\t\t\tbreak;\n\t\tcase OP_DSSC:\n\t\t\t/*\n\t\t\t * DRSCAN short with capture\n\t\t\t * ...stack 0 is scan data\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[stack_ptr - 1];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_swap_dr(astate, count, charbuf,\n\t\t\t\t\t\t\t0, charbuf, 0);\n\t\t\tstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\n\t\t\tbreak;\n\t\tcase OP_ISS:\n\t\t\t/*\n\t\t\t * IRSCAN short\n\t\t\t * ...stack 0 is scan data\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_irscan(astate, count, charbuf, 0);\n\t\t\tbreak;\n\t\tcase OP_ISSC:\n\t\t\t/*\n\t\t\t * IRSCAN short with capture\n\t\t\t * ...stack 0 is scan data\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[stack_ptr - 1];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_swap_ir(astate, count, charbuf,\n\t\t\t\t\t\t\t0, charbuf, 0);\n\t\t\tstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\n\t\t\tbreak;\n\t\tcase OP_DPR:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, 0, NULL);\n\t\t\tbreak;\n\t\tcase OP_DPRL:\n\t\t\t/*\n\t\t\t * DRPRE with literal data\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is literal data\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, 0,\n\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_DPO:\n\t\t\t/*\n\t\t\t * DRPOST\n\t\t\t * ...stack 0 is count\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_dr_post(&astate->js, count,\n\t\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DPOL:\n\t\t\t/*\n\t\t\t * DRPOST with literal data\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is literal data\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_dr_post(&astate->js, count, 0,\n\t\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_IPR:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_ir_pre(&astate->js, count,\n\t\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPRL:\n\t\t\t/*\n\t\t\t * IRPRE with literal data\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is literal data\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\t\tstatus = altera_set_ir_pre(&astate->js, count,\n\t\t\t\t\t\t\t0, charbuf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPO:\n\t\t\t/*\n\t\t\t * IRPOST\n\t\t\t * ...stack 0 is count\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_ir_post(&astate->js, count,\n\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPOL:\n\t\t\t/*\n\t\t\t * IRPOST with literal data\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is literal data\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_ir_post(&astate->js, count, 0,\n\t\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_PCHR:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tu8 ch;\n\t\t\t\tcount = strlen(msg_buff);\n\t\t\t\tch = (char) stack[--stack_ptr];\n\t\t\t\tif ((ch < 1) || (ch > 127)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * character code out of range\n\t\t\t\t\t * instead of flagging an error,\n\t\t\t\t\t * force the value to 127\n\t\t\t\t\t */\n\t\t\t\t\tch = 127;\n\t\t\t\t}\n\t\t\t\tmsg_buff[count] = ch;\n\t\t\t\tmsg_buff[count + 1] = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_EXIT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\t*exit_code = stack[--stack_ptr];\n\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\tcase OP_EQU:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] == stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\t\t\tbreak;\n\t\tcase OP_POPT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\t--stack_ptr;\n\n\t\t\tbreak;\n\t\tcase OP_ABS:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tif (stack[stack_ptr - 1] < 0)\n\t\t\t\tstack[stack_ptr - 1] = 0 - stack[stack_ptr - 1];\n\n\t\t\tbreak;\n\t\tcase OP_BCH0:\n\t\t\t/*\n\t\t\t * Batch operation 0\n\t\t\t * SWP\n\t\t\t * SWPN 7\n\t\t\t * SWP\n\t\t\t * SWPN 6\n\t\t\t * DUPN 8\n\t\t\t * SWPN 2\n\t\t\t * SWP\n\t\t\t * DUPN 6\n\t\t\t * DUPN 6\n\t\t\t */\n\n\t\t\t/* SWP  */\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - 2];\n\t\t\t\tstack[stack_ptr - 2] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* SWPN 7 */\n\t\t\tindex = 7 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - index];\n\t\t\t\tstack[stack_ptr - index] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* SWP  */\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - 2];\n\t\t\t\tstack[stack_ptr - 2] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* SWPN 6 */\n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - index];\n\t\t\t\tstack[stack_ptr - index] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* DUPN 8 */\n\t\t\tindex = 8 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\n\t\t\t/* SWPN 2 */\n\t\t\tindex = 2 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - index];\n\t\t\t\tstack[stack_ptr - index] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* SWP  */\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - 2];\n\t\t\t\tstack[stack_ptr - 2] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\n\t\t\t/* DUPN 6 */\n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\n\t\t\t/* DUPN 6 */\n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSH0:\n\t\t\tstack[stack_ptr++] = 0;\n\t\t\tbreak;\n\t\tcase OP_PSHL:\n\t\t\tstack[stack_ptr++] = (s32) args[0];\n\t\t\tbreak;\n\t\tcase OP_PSHV:\n\t\t\tstack[stack_ptr++] = vars[args[0]];\n\t\t\tbreak;\n\t\tcase OP_JMP:\n\t\t\tpc = args[0] + code_sect;\n\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\tstatus = -ERANGE;\n\t\t\tbreak;\n\t\tcase OP_CALL:\n\t\t\tstack[stack_ptr++] = pc;\n\t\t\tpc = args[0] + code_sect;\n\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\tstatus = -ERANGE;\n\t\t\tbreak;\n\t\tcase OP_NEXT:\n\t\t\t/*\n\t\t\t * Process FOR / NEXT loop\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is step value\n\t\t\t * ...stack 1 is end value\n\t\t\t * ...stack 2 is top address\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 3, &status)) {\n\t\t\t\ts32 step = stack[stack_ptr - 1];\n\t\t\t\ts32 end = stack[stack_ptr - 2];\n\t\t\t\ts32 top = stack[stack_ptr - 3];\n\t\t\t\ts32 iterator = vars[args[0]];\n\t\t\t\tint break_out = 0;\n\n\t\t\t\tif (step < 0) {\n\t\t\t\t\tif (iterator <= end)\n\t\t\t\t\t\tbreak_out = 1;\n\t\t\t\t} else if (iterator >= end)\n\t\t\t\t\tbreak_out = 1;\n\n\t\t\t\tif (break_out) {\n\t\t\t\t\tstack_ptr -= 3;\n\t\t\t\t} else {\n\t\t\t\t\tvars[args[0]] = iterator + step;\n\t\t\t\t\tpc = top + code_sect;\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSTR:\n\t\t\t/*\n\t\t\t * PRINT add string\n\t\t\t * ...argument 0 is string ID\n\t\t\t */\n\t\t\tcount = strlen(msg_buff);\n\t\t\tstrlcpy(&msg_buff[count],\n\t\t\t\t&p[str_table + args[0]],\n\t\t\t\tALTERA_MESSAGE_LENGTH - count);\n\t\t\tbreak;\n\t\tcase OP_SINT:\n\t\t\t/*\n\t\t\t * STATE intermediate state\n\t\t\t * ...argument 0 is state code\n\t\t\t */\n\t\t\tstatus = altera_goto_jstate(astate, args[0]);\n\t\t\tbreak;\n\t\tcase OP_ST:\n\t\t\t/*\n\t\t\t * STATE final state\n\t\t\t * ...argument 0 is state code\n\t\t\t */\n\t\t\tstatus = altera_goto_jstate(astate, args[0]);\n\t\t\tbreak;\n\t\tcase OP_ISTP:\n\t\t\t/*\n\t\t\t * IRSTOP state\n\t\t\t * ...argument 0 is state code\n\t\t\t */\n\t\t\tstatus = altera_set_irstop(&astate->js, args[0]);\n\t\t\tbreak;\n\t\tcase OP_DSTP:\n\t\t\t/*\n\t\t\t * DRSTOP state\n\t\t\t * ...argument 0 is state code\n\t\t\t */\n\t\t\tstatus = altera_set_drstop(&astate->js, args[0]);\n\t\t\tbreak;\n\n\t\tcase OP_SWPN:\n\t\t\t/*\n\t\t\t * Exchange top with Nth stack value\n\t\t\t * ...argument 0 is 0-based stack entry\n\t\t\t * to swap with top element\n\t\t\t */\n\t\t\tindex = (args[0]) + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tlong_tmp = stack[stack_ptr - index];\n\t\t\t\tstack[stack_ptr - index] = stack[stack_ptr - 1];\n\t\t\t\tstack[stack_ptr - 1] = long_tmp;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DUPN:\n\t\t\t/*\n\t\t\t * Duplicate Nth stack value\n\t\t\t * ...argument 0 is 0-based stack entry to duplicate\n\t\t\t */\n\t\t\tindex = (args[0]) + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_POPV:\n\t\t\t/*\n\t\t\t * Pop stack into scalar variable\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is value\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tvars[args[0]] = stack[--stack_ptr];\n\n\t\t\tbreak;\n\t\tcase OP_POPE:\n\t\t\t/*\n\t\t\t * Pop stack into integer array element\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is value\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t/*\n\t\t\t * If variable is read-only,\n\t\t\t * convert to writable array\n\t\t\t */\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x1c)) {\n\t\t\t\t/* Allocate a writable buffer for this array */\n\t\t\t\tcount = var_size[variable_id];\n\t\t\t\tlong_tmp = vars[variable_id];\n\t\t\t\tlongptr_tmp = kzalloc(count * sizeof(long),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)longptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* copy previous contents into buffer */\n\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\tlongptr_tmp[i] =\n\t\t\t\t\t\tget_unaligned_be32(&p[long_tmp]);\n\t\t\t\t\tlong_tmp += sizeof(long);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * set bit 7 - buffer was\n\t\t\t\t * dynamically allocated\n\t\t\t\t */\n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t/* clear bit 2 - variable is writable */\n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\t/* check that variable is a writable integer array */\n\t\t\tif ((attrs[variable_id] & 0x1c) != 0x18)\n\t\t\t\tstatus = -ERANGE;\n\t\t\telse {\n\t\t\t\tlongptr_tmp = (long *)vars[variable_id];\n\n\t\t\t\t/* pop the array index */\n\t\t\t\tindex = stack[--stack_ptr];\n\n\t\t\t\t/* pop the value and store it into the array */\n\t\t\t\tlongptr_tmp[index] = stack[--stack_ptr];\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_POPA:\n\t\t\t/*\n\t\t\t * Pop stack into Boolean array\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is array index\n\t\t\t * ...stack 2 is value\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t/*\n\t\t\t * If variable is read-only,\n\t\t\t * convert to writable array\n\t\t\t */\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t/* Allocate a writable buffer for this array */\n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* zero the buffer */\n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < long_tmp;\n\t\t\t\t\t++long_idx) {\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\t\t\t\t}\n\n\t\t\t\t/* copy previous contents into buffer */\n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7))) {\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * set bit 7 - buffer was\n\t\t\t\t * dynamically allocated\n\t\t\t\t */\n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t/* clear bit 2 - variable is writable */\n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * check that variable is\n\t\t\t * a writable Boolean array\n\t\t\t */\n\t\t\tif ((attrs[variable_id] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\n\t\t\t/* pop the count (number of bits to copy) */\n\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\t/* pop the array index */\n\t\t\tlong_idx = stack[--stack_ptr];\n\n\t\t\treverse = 0;\n\n\t\t\tif (version > 0) {\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\n\t\t\t\tif (long_idx > long_count) {\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tlong_tmp = long_count;\n\t\t\t\t\tlong_count = 1 + long_idx -\n\t\t\t\t\t\t\t\tlong_count;\n\t\t\t\t\tlong_idx = long_tmp;\n\n\t\t\t\t\t/* reverse POPA is not supported */\n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tlong_count = 1 + long_count -\n\t\t\t\t\t\t\t\tlong_idx;\n\n\t\t\t}\n\n\t\t\t/* pop the data */\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_count < 1) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < long_count; ++i) {\n\t\t\t\tif (long_tmp & (1L << (s32) i))\n\t\t\t\t\tcharptr_tmp[long_idx >> 3L] |=\n\t\t\t\t\t\t(1L << (long_idx & 7L));\n\t\t\t\telse\n\t\t\t\t\tcharptr_tmp[long_idx >> 3L] &=\n\t\t\t\t\t\t~(1L << (long_idx & 7L));\n\n\t\t\t\t++long_idx;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_JMPZ:\n\t\t\t/*\n\t\t\t * Pop stack and branch if zero\n\t\t\t * ...argument 0 is address\n\t\t\t * ...stack 0 is condition value\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tif (stack[--stack_ptr] == 0) {\n\t\t\t\t\tpc = args[0] + code_sect;\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DS:\n\t\tcase OP_IS:\n\t\t\t/*\n\t\t\t * DRSCAN\n\t\t\t * IRSCAN\n\t\t\t * ...argument 0 is scan data variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_idx = stack[--stack_ptr];\n\t\t\tlong_count = stack[--stack_ptr];\n\t\t\treverse = 0;\n\t\t\tif (version > 0) {\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t * stack 2 = count\n\t\t\t\t */\n\t\t\t\tlong_tmp = long_count;\n\t\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\t\tif (long_idx > long_tmp) {\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tlong_idx = long_tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\n\t\t\tif (reverse) {\n\t\t\t\t/*\n\t\t\t\t * allocate a buffer\n\t\t\t\t * and reverse the data order\n\t\t\t\t */\n\t\t\t\tcharptr_tmp2 = charptr_tmp;\n\t\t\t\tcharptr_tmp = kzalloc((long_count >> 3) + 1,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (charptr_tmp == NULL) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlong_tmp = long_idx + long_count - 1;\n\t\t\t\tlong_idx2 = 0;\n\t\t\t\twhile (long_idx2 < long_count) {\n\t\t\t\t\tif (charptr_tmp2[long_tmp >> 3] &\n\t\t\t\t\t\t\t(1 << (long_tmp & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx2 >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx2 & 7));\n\t\t\t\t\telse\n\t\t\t\t\t\tcharptr_tmp[long_idx2 >> 3] &=\n\t\t\t\t\t\t\t~(1 << (long_idx2 & 7));\n\n\t\t\t\t\t--long_tmp;\n\t\t\t\t\t++long_idx2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opcode == 0x51) /* DS */\n\t\t\t\tstatus = altera_drscan(astate, long_count,\n\t\t\t\t\t\tcharptr_tmp, long_idx);\n\t\t\telse /* IS */\n\t\t\t\tstatus = altera_irscan(astate, long_count,\n\t\t\t\t\t\tcharptr_tmp, long_idx);\n\n\t\t\tif (reverse)\n\t\t\t\tkfree(charptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_DPRA:\n\t\t\t/*\n\t\t\t * DRPRE with array data\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\t\t\tbreak;\n\t\tcase OP_DPOA:\n\t\t\t/*\n\t\t\t * DRPOST with array data\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_dr_post(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\t\t\tbreak;\n\t\tcase OP_IPRA:\n\t\t\t/*\n\t\t\t * IRPRE with array data\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_ir_pre(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_IPOA:\n\t\t\t/*\n\t\t\t * IRPOST with array data\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t * ...stack 1 is count\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_ir_post(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_EXPT:\n\t\t\t/*\n\t\t\t * EXPORT\n\t\t\t * ...argument 0 is string ID\n\t\t\t * ...stack 0 is integer expression\n\t\t\t */\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tname = &p[str_table + args[0]];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\taltera_export_int(name, long_tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSHE:\n\t\t\t/*\n\t\t\t * Push integer array element\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is array index\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\t\t\tindex = stack[stack_ptr - 1];\n\n\t\t\t/* check variable type */\n\t\t\tif ((attrs[variable_id] & 0x1f) == 0x19) {\n\t\t\t\t/* writable integer array */\n\t\t\t\tlongptr_tmp = (long *)vars[variable_id];\n\t\t\t\tstack[stack_ptr - 1] = longptr_tmp[index];\n\t\t\t} else if ((attrs[variable_id] & 0x1f) == 0x1c) {\n\t\t\t\t/* read-only integer array */\n\t\t\t\tlong_tmp = vars[variable_id] +\n\t\t\t\t\t\t(index * sizeof(long));\n\t\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t\tget_unaligned_be32(&p[long_tmp]);\n\t\t\t} else\n\t\t\t\tstatus = -ERANGE;\n\n\t\t\tbreak;\n\t\tcase OP_PSHA:\n\t\t\t/*\n\t\t\t * Push Boolean array\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is array index\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t/* check that variable is a Boolean array */\n\t\t\tif ((attrs[variable_id] & 0x18) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\n\t\t\t/* pop the count (number of bits to copy) */\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\t/* pop the array index */\n\t\t\tindex = stack[stack_ptr - 1];\n\n\t\t\tif (version > 0)\n\t\t\t\t/*\n\t\t\t\t * stack 0 = array right index\n\t\t\t\t * stack 1 = array left index\n\t\t\t\t */\n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tif ((count < 1) || (count > 32)) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlong_tmp = 0L;\n\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\tif (charptr_tmp[(i + index) >> 3] &\n\t\t\t\t\t\t(1 << ((i + index) & 7)))\n\t\t\t\t\tlong_tmp |= (1L << i);\n\n\t\t\tstack[stack_ptr - 1] = long_tmp;\n\n\t\t\tbreak;\n\t\tcase OP_DYNA:\n\t\t\t/*\n\t\t\t * Dynamically change size of array\n\t\t\t * ...argument 0 is variable ID\n\t\t\t * ...stack 0 is new size\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_tmp > var_size[variable_id]) {\n\t\t\t\tvar_size[variable_id] = long_tmp;\n\n\t\t\t\tif (attrs[variable_id] & 0x10)\n\t\t\t\t\t/* allocate integer array */\n\t\t\t\t\tlong_tmp *= sizeof(long);\n\t\t\t\telse\n\t\t\t\t\t/* allocate Boolean array */\n\t\t\t\t\tlong_tmp = (long_tmp + 7) >> 3;\n\n\t\t\t\t/*\n\t\t\t\t * If the buffer was previously allocated,\n\t\t\t\t * free it\n\t\t\t\t */\n\t\t\t\tif (attrs[variable_id] & 0x80) {\n\t\t\t\t\tkfree((void *)vars[variable_id]);\n\t\t\t\t\tvars[variable_id] = 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Allocate a new buffer\n\t\t\t\t * of the requested size\n\t\t\t\t */\n\t\t\t\tvars[variable_id] = (long)\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the attribute bit to indicate that\n\t\t\t\t * this buffer was dynamically allocated and\n\t\t\t\t * should be freed later\n\t\t\t\t */\n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t/* zero out memory */\n\t\t\t\tcount = ((var_size[variable_id] + 7L) /\n\t\t\t\t\t\t\t\t\t8L);\n\t\t\t\tcharptr_tmp = (u8 *)(vars[variable_id]);\n\t\t\t\tfor (index = 0; index < count; ++index)\n\t\t\t\t\tcharptr_tmp[index] = 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_EXPV:\n\t\t\t/*\n\t\t\t * Export Boolean array\n\t\t\t * ...argument 0 is string ID\n\t\t\t * ...stack 0 is variable ID\n\t\t\t * ...stack 1 is array right index\n\t\t\t * ...stack 2 is array left index\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\t\t\tif (version == 0) {\n\t\t\t\t/* EXPV is not supported in JBC 1.0 */\n\t\t\t\tbad_opcode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tname = &p[str_table + args[0]];\n\t\t\tvariable_id = stack[--stack_ptr];\n\t\t\tlong_idx = stack[--stack_ptr];/* right indx */\n\t\t\tlong_idx2 = stack[--stack_ptr];/* left indx */\n\n\t\t\tif (long_idx > long_idx2) {\n\t\t\t\t/* reverse indices not supported */\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlong_count = 1 + long_idx2 - long_idx;\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\t\t\tcharptr_tmp2 = NULL;\n\n\t\t\tif ((long_idx & 7L) != 0) {\n\t\t\t\ts32 k = long_idx;\n\t\t\t\tcharptr_tmp2 =\n\t\t\t\t\tkzalloc(((long_count + 7L) / 8L),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (charptr_tmp2 == NULL) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < long_count; ++i) {\n\t\t\t\t\tif (charptr_tmp[k >> 3] &\n\t\t\t\t\t\t\t(1 << (k & 7)))\n\t\t\t\t\t\tcharptr_tmp2[i >> 3] |=\n\t\t\t\t\t\t\t\t(1 << (i & 7));\n\t\t\t\t\telse\n\t\t\t\t\t\tcharptr_tmp2[i >> 3] &=\n\t\t\t\t\t\t\t\t~(1 << (i & 7));\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tcharptr_tmp = charptr_tmp2;\n\n\t\t\t} else if (long_idx != 0)\n\t\t\t\tcharptr_tmp = &charptr_tmp[long_idx >> 3];\n\n\t\t\taltera_export_bool_array(name, charptr_tmp,\n\t\t\t\t\t\t\tlong_count);\n\n\t\t\t/* free allocated buffer */\n\t\t\tif ((long_idx & 7L) != 0)\n\t\t\t\tkfree(charptr_tmp2);\n\n\t\t\tbreak;\n\t\tcase OP_COPY: {\n\t\t\t/*\n\t\t\t * Array copy\n\t\t\t * ...argument 0 is dest ID\n\t\t\t * ...argument 1 is source ID\n\t\t\t * ...stack 0 is count\n\t\t\t * ...stack 1 is dest index\n\t\t\t * ...stack 2 is source index\n\t\t\t */\n\t\t\ts32 copy_count;\n\t\t\ts32 copy_index;\n\t\t\ts32 copy_index2;\n\t\t\ts32 destleft;\n\t\t\ts32 src_count;\n\t\t\ts32 dest_count;\n\t\t\tint src_reverse = 0;\n\t\t\tint dest_reverse = 0;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\n\t\t\tcopy_count = stack[--stack_ptr];\n\t\t\tcopy_index = stack[--stack_ptr];\n\t\t\tcopy_index2 = stack[--stack_ptr];\n\t\t\treverse = 0;\n\n\t\t\tif (version > 0) {\n\t\t\t\t/*\n\t\t\t\t * stack 0 = source right index\n\t\t\t\t * stack 1 = source left index\n\t\t\t\t * stack 2 = destination right index\n\t\t\t\t * stack 3 = destination left index\n\t\t\t\t */\n\t\t\t\tdestleft = stack[--stack_ptr];\n\n\t\t\t\tif (copy_count > copy_index) {\n\t\t\t\t\tsrc_reverse = 1;\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tsrc_count = 1 + copy_count - copy_index;\n\t\t\t\t\t/* copy_index = source start index */\n\t\t\t\t} else {\n\t\t\t\t\tsrc_count = 1 + copy_index - copy_count;\n\t\t\t\t\t/* source start index */\n\t\t\t\t\tcopy_index = copy_count;\n\t\t\t\t}\n\n\t\t\t\tif (copy_index2 > destleft) {\n\t\t\t\t\tdest_reverse = 1;\n\t\t\t\t\treverse = !reverse;\n\t\t\t\t\tdest_count = 1 + copy_index2 - destleft;\n\t\t\t\t\t/* destination start index */\n\t\t\t\t\tcopy_index2 = destleft;\n\t\t\t\t} else\n\t\t\t\t\tdest_count = 1 + destleft - copy_index2;\n\n\t\t\t\tcopy_count = (src_count < dest_count) ?\n\t\t\t\t\t\t\tsrc_count : dest_count;\n\n\t\t\t\tif ((src_reverse || dest_reverse) &&\n\t\t\t\t\t(src_count != dest_count))\n\t\t\t\t\t/*\n\t\t\t\t\t * If either the source or destination\n\t\t\t\t\t * is reversed, we can't tolerate\n\t\t\t\t\t * a length mismatch, because we\n\t\t\t\t\t * "left justify" arrays when copying.\n\t\t\t\t\t * This won't work correctly\n\t\t\t\t\t * with reversed arrays.\n\t\t\t\t\t */\n\t\t\t\t\tstatus = -ERANGE;\n\n\t\t\t}\n\n\t\t\tcount = copy_count;\n\t\t\tindex = copy_index;\n\t\t\tindex2 = copy_index2;\n\n\t\t\t/*\n\t\t\t * If destination is a read-only array,\n\t\t\t * allocate a buffer and convert it to a writable array\n\t\t\t */\n\t\t\tvariable_id = args[1];\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t/* Allocate a writable buffer for this array */\n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* zero the buffer */\n\t\t\t\tfor (long_idx = 0L; long_idx < long_tmp;\n\t\t\t\t\t\t\t\t++long_idx)\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\n\t\t\t\t/* copy previous contents into buffer */\n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\tset bit 7 - buffer was dynamically allocated */\n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t/* clear bit 2 - variable is writable */\n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[1]];\n\t\t\tcharptr_tmp2 = (u8 *)vars[args[0]];\n\n\t\t\t/* check if destination is a writable Boolean array */\n\t\t\tif ((attrs[args[1]] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (count < 1) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (reverse)\n\t\t\t\tindex2 += (count - 1);\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tif (charptr_tmp2[index >> 3] &\n\t\t\t\t\t\t\t(1 << (index & 7)))\n\t\t\t\t\tcharptr_tmp[index2 >> 3] |=\n\t\t\t\t\t\t\t(1 << (index2 & 7));\n\t\t\t\telse\n\t\t\t\t\tcharptr_tmp[index2 >> 3] &=\n\t\t\t\t\t\t~(1 << (index2 & 7));\n\n\t\t\t\t++index;\n\t\t\t\tif (reverse)\n\t\t\t\t\t--index2;\n\t\t\t\telse\n\t\t\t\t\t++index2;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_DSC:\n\t\tcase OP_ISC: {\n\t\t\t/*\n\t\t\t * DRSCAN with capture\n\t\t\t * IRSCAN with capture\n\t\t\t * ...argument 0 is scan data variable ID\n\t\t\t * ...argument 1 is capture variable ID\n\t\t\t * ...stack 0 is capture index\n\t\t\t * ...stack 1 is scan data index\n\t\t\t * ...stack 2 is count\n\t\t\t */\n\t\t\ts32 scan_right, scan_left;\n\t\t\ts32 capture_count = 0;\n\t\t\ts32 scan_count = 0;\n\t\t\ts32 capture_index;\n\t\t\ts32 scan_index;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\n\t\t\tcapture_index = stack[--stack_ptr];\n\t\t\tscan_index = stack[--stack_ptr];\n\n\t\t\tif (version > 0) {\n\t\t\t\t/*\n\t\t\t\t * stack 0 = capture right index\n\t\t\t\t * stack 1 = capture left index\n\t\t\t\t * stack 2 = scan right index\n\t\t\t\t * stack 3 = scan left index\n\t\t\t\t * stack 4 = count\n\t\t\t\t */\n\t\t\t\tscan_right = stack[--stack_ptr];\n\t\t\t\tscan_left = stack[--stack_ptr];\n\t\t\t\tcapture_count = 1 + scan_index - capture_index;\n\t\t\t\tscan_count = 1 + scan_left - scan_right;\n\t\t\t\tscan_index = scan_right;\n\t\t\t}\n\n\t\t\tlong_count = stack[--stack_ptr];\n\t\t\t/*\n\t\t\t * If capture array is read-only, allocate a buffer\n\t\t\t * and convert it to a writable array\n\t\t\t */\n\t\t\tvariable_id = args[1];\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t/* Allocate a writable buffer for this array */\n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* zero the buffer */\n\t\t\t\tfor (long_idx = 0L; long_idx < long_tmp;\n\t\t\t\t\t\t\t\t++long_idx)\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\n\t\t\t\t/* copy previous contents into buffer */\n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * set bit 7 - buffer was\n\t\t\t\t * dynamically allocated\n\t\t\t\t */\n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t/* clear bit 2 - variable is writable */\n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tcharptr_tmp2 = (u8 *)vars[args[1]];\n\n\t\t\tif ((version > 0) &&\n\t\t\t\t\t((long_count > capture_count) ||\n\t\t\t\t\t(long_count > scan_count))) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * check that capture array\n\t\t\t * is a writable Boolean array\n\t\t\t */\n\t\t\tif ((attrs[args[1]] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (status == 0) {\n\t\t\t\tif (opcode == 0x82) /* DSC */\n\t\t\t\t\tstatus = altera_swap_dr(astate,\n\t\t\t\t\t\t\tlong_count,\n\t\t\t\t\t\t\tcharptr_tmp,\n\t\t\t\t\t\t\tscan_index,\n\t\t\t\t\t\t\tcharptr_tmp2,\n\t\t\t\t\t\t\tcapture_index);\n\t\t\t\telse /* ISC */\n\t\t\t\t\tstatus = altera_swap_ir(astate,\n\t\t\t\t\t\t\tlong_count,\n\t\t\t\t\t\t\tcharptr_tmp,\n\t\t\t\t\t\t\tscan_index,\n\t\t\t\t\t\t\tcharptr_tmp2,\n\t\t\t\t\t\t\tcapture_index);\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_WAIT:\n\t\t\t/*\n\t\t\t * WAIT\n\t\t\t * ...argument 0 is wait state\n\t\t\t * ...argument 1 is end state\n\t\t\t * ...stack 0 is cycles\n\t\t\t * ...stack 1 is microseconds\n\t\t\t */\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_tmp != 0L)\n\t\t\t\tstatus = altera_wait_cycles(astate, long_tmp,\n\t\t\t\t\t\t\t\targs[0]);\n\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif ((status == 0) && (long_tmp != 0L))\n\t\t\t\tstatus = altera_wait_msecs(astate,\n\t\t\t\t\t\t\t\tlong_tmp,\n\t\t\t\t\t\t\t\targs[0]);\n\n\t\t\tif ((status == 0) && (args[1] != args[0]))\n\t\t\t\tstatus = altera_goto_jstate(astate,\n\t\t\t\t\t\t\t\targs[1]);\n\n\t\t\tif (version > 0) {\n\t\t\t\t--stack_ptr; /* throw away MAX cycles */\n\t\t\t\t--stack_ptr; /* throw away MAX microseconds */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_CMPA: {\n\t\t\t/*\n\t\t\t * Array compare\n\t\t\t * ...argument 0 is source 1 ID\n\t\t\t * ...argument 1 is source 2 ID\n\t\t\t * ...argument 2 is mask ID\n\t\t\t * ...stack 0 is source 1 index\n\t\t\t * ...stack 1 is source 2 index\n\t\t\t * ...stack 2 is mask index\n\t\t\t * ...stack 3 is count\n\t\t\t */\n\t\t\ts32 a, b;\n\t\t\tu8 *source1 = (u8 *)vars[args[0]];\n\t\t\tu8 *source2 = (u8 *)vars[args[1]];\n\t\t\tu8 *mask = (u8 *)vars[args[2]];\n\t\t\tu32 index1;\n\t\t\tu32 index2;\n\t\t\tu32 mask_index;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 4, &status))\n\t\t\t\tbreak;\n\n\t\t\tindex1 = stack[--stack_ptr];\n\t\t\tindex2 = stack[--stack_ptr];\n\t\t\tmask_index = stack[--stack_ptr];\n\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\tif (version > 0) {\n\t\t\t\t/*\n\t\t\t\t * stack 0 = source 1 right index\n\t\t\t\t * stack 1 = source 1 left index\n\t\t\t\t * stack 2 = source 2 right index\n\t\t\t\t * stack 3 = source 2 left index\n\t\t\t\t * stack 4 = mask right index\n\t\t\t\t * stack 5 = mask left index\n\t\t\t\t */\n\t\t\t\ts32 mask_right = stack[--stack_ptr];\n\t\t\t\ts32 mask_left = stack[--stack_ptr];\n\t\t\t\t/* source 1 count */\n\t\t\t\ta = 1 + index2 - index1;\n\t\t\t\t/* source 2 count */\n\t\t\t\tb = 1 + long_count - mask_index;\n\t\t\t\ta = (a < b) ? a : b;\n\t\t\t\t/* mask count */\n\t\t\t\tb = 1 + mask_left - mask_right;\n\t\t\t\ta = (a < b) ? a : b;\n\t\t\t\t/* source 2 start index */\n\t\t\t\tindex2 = mask_index;\n\t\t\t\t/* mask start index */\n\t\t\t\tmask_index = mask_right;\n\t\t\t\tlong_count = a;\n\t\t\t}\n\n\t\t\tlong_tmp = 1L;\n\n\t\t\tif (long_count < 1)\n\t\t\t\tstatus = -ERANGE;\n\t\t\telse {\n\t\t\t\tcount = long_count;\n\n\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\tif (mask[mask_index >> 3] &\n\t\t\t\t\t\t(1 << (mask_index & 7))) {\n\t\t\t\t\t\ta = source1[index1 >> 3] &\n\t\t\t\t\t\t\t(1 << (index1 & 7))\n\t\t\t\t\t\t\t\t? 1 : 0;\n\t\t\t\t\t\tb = source2[index2 >> 3] &\n	t
2698	737	cdv_intel_dp_aux_native_read	drivers/gpu/drm/gma500/cdv_intel_dp.c	ack	1	11	\N	\N	\tuint8_t msg[4];\n\tint msg_bytes;\n\tuint8_t reply[20];\n\tint reply_bytes;\n\tuint8_t ack;\n\tint ret;\n\n\tmsg[0] = DP_AUX_NATIVE_READ << 4;\n\tmsg[1] = address >> 8;\n\tmsg[2] = address & 0xff;\n\tmsg[3] = recv_bytes - 1;\n\n\tmsg_bytes = 4;\n\treply_bytes = recv_bytes + 1;\n\n\tfor (;;) {\n\t\tret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret == 0)\n\t\t\treturn -EPROTO;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tack = reply[0] >> 4;\n\t\tif ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK) {\n	t
28831	571	sr_is_xa	drivers/scsi/sr_ioctl.c	raw_sector	1	11	\N	\N	\tunsigned char *raw_sector;\n\tint is_xa;\n\n\tif (!xa_test)\n\t\treturn 0;\n\n\traw_sector = kmalloc(2048, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!raw_sector)\n\t\treturn -ENOMEM;\n\tif (0 == sr_read_sector(cd, cd->ms_offset + 16,\n\t\t\t\tCD_FRAMESIZE_RAW1, raw_sector)) {\n\t\tis_xa = (raw_sector[3] == 0x02) ? 1 : 0;\n	t
41929	179	afs_iget_autocell	fs/afs/inode.c	inode->i_state	1	11	\N	\N	\tstruct afs_iget_data data;\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tstatic atomic_t afs_autocell_ino;\n\n\t_enter("{%x:%u},%*.*s,",\n\t       AFS_FS_I(dir)->fid.vid, AFS_FS_I(dir)->fid.vnode,\n\t       namesz, namesz, dev_name ?: "");\n\n\tsb = dir->i_sb;\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\tdata.fid.vid = as->volume->vid;\n\tdata.fid.unique = 0;\n\tdata.fid.vnode = 0;\n\n\tinode = iget5_locked(sb, atomic_inc_return(&afs_autocell_ino),\n\t\t\t     afs_iget5_autocell_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(" = -ENOMEM");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug("GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }",\n\t       inode, inode->i_ino, data.fid.vid, data.fid.vnode,\n\t       data.fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* there shouldn't be an existing inode */\n\tBUG_ON(!(inode->i_state & I_NEW));\n	t
7963	1128	ath10k_pci_diag_write_mem	drivers/net/wireless/ath/ath10k/pci.c	completed_nbytes	6	12	\N	\N	\tstruct ath10k_pci *ar_pci = ath10k_pci_priv(ar);\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint ret = 0;\n\tu32 *buf;\n\tunsigned int completed_nbytes, orig_nbytes, remaining_bytes;\n\tstruct ath10k_ce_pipe *ce_diag;\n\tvoid *data_buf = NULL;\n\tu32 ce_data;\t/* Host buffer address in CE space */\n\tdma_addr_t ce_data_base = 0;\n\tint i;\n\n\tspin_lock_bh(&ce->ce_lock);\n\n\tce_diag = ar_pci->ce_diag;\n\n\t/*\n\t * Allocate a temporary bounce buffer to hold caller's data\n\t * to be DMA'ed to Target. This guarantees\n\t *   1) 4-byte alignment\n\t *   2) Buffer in DMA-able space\n\t */\n\torig_nbytes = nbytes;\n\tdata_buf = (unsigned char *)dma_alloc_coherent(ar->dev,\n\t\t\t\t\t\t       orig_nbytes,\n\t\t\t\t\t\t       &ce_data_base,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\tif (!data_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* Copy caller's data to allocated DMA buf */\n\tmemcpy(data_buf, data, orig_nbytes);\n\n\t/*\n\t * The address supplied by the caller is in the\n\t * Target CPU virtual address space.\n\t *\n\t * In order to use this address with the diagnostic CE,\n\t * convert it from\n\t *    Target CPU virtual address space\n\t * to\n\t *    CE address space\n\t */\n\taddress = ath10k_pci_targ_cpu_to_ce_addr(ar, address);\n\n\tremaining_bytes = orig_nbytes;\n\tce_data = ce_data_base;\n\twhile (remaining_bytes) {\n\t\t/* FIXME: check cast */\n\t\tnbytes = min_t(int, remaining_bytes, DIAG_TRANSFER_LIMIT);\n\n\t\t/* Set up to receive directly into Target(!) address */\n\t\tret = __ath10k_ce_rx_post_buf(ce_diag, &address, address);\n\t\tif (ret != 0)\n\t\t\tgoto done;\n\n\t\t/*\n\t\t * Request CE to send caller-supplied data that\n\t\t * was copied to bounce buffer to Target(!) address.\n\t\t */\n\t\tret = ath10k_ce_send_nolock(ce_diag, NULL, (u32)ce_data,\n\t\t\t\t\t    nbytes, 0, 0);\n\t\tif (ret != 0)\n\t\t\tgoto done;\n\n\t\ti = 0;\n\t\twhile (ath10k_ce_completed_send_next_nolock(ce_diag,\n\t\t\t\t\t\t\t    NULL) != 0) {\n\t\t\tmdelay(1);\n\n\t\t\tif (i++ > DIAG_ACCESS_CE_TIMEOUT_MS) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\ti = 0;\n\t\twhile (ath10k_ce_completed_recv_next_nolock(ce_diag,\n\t\t\t\t\t\t\t    (void **)&buf,\n\t\t\t\t\t\t\t    &completed_nbytes)\n\t\t\t\t\t\t\t\t!= 0) {\n\t\t\tmdelay(1);\n\n\t\t\tif (i++ > DIAG_ACCESS_CE_TIMEOUT_MS) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (nbytes != completed_nbytes) {\n	t
6583	165	nvkm_client_notify_new	drivers/gpu/drm/nouveau/nvkm/core/client.c	reply	1	11	\N	\N	\tstruct nvkm_client *client = object->client;\n\tstruct nvkm_client_notify *notify;\n\tunion {\n\t\tstruct nvif_notify_req_v0 v0;\n\t} *req = data;\n\tu8  index, reply;\n\tint ret = -ENOSYS;\n\n\tfor (index = 0; index < ARRAY_SIZE(client->notify); index++) {\n\t\tif (!client->notify[index])\n\t\t\tbreak;\n\t}\n\n\tif (index == ARRAY_SIZE(client->notify))\n\t\treturn -ENOSPC;\n\n\tnotify = kzalloc(sizeof(*notify), GFP_KERNEL);\n\tif (!notify)\n\t\treturn -ENOMEM;\n\n\tnvif_ioctl(object, "notify new size %d\\n", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, true))) {\n\t\tnvif_ioctl(object, "notify new vers %d reply %d route %02x "\n\t\t\t\t   "token %llx\\n", req->v0.version,\n\t\t\t   req->v0.reply, req->v0.route, req->v0.token);\n\t\tnotify->version = req->v0.version;\n\t\tnotify->size = sizeof(notify->rep.v0);\n\t\tnotify->rep.v0.version = req->v0.version;\n\t\tnotify->rep.v0.route = req->v0.route;\n\t\tnotify->rep.v0.token = req->v0.token;\n\t\treply = req->v0.reply;\n\t}\n\n\tif (ret == 0) {\n\t\tret = nvkm_notify_init(object, event, nvkm_client_notify,\n	t
5214	283	drm_dp_dual_mode_max_tmds_clock	drivers/gpu/drm/drm_dp_dual_mode_helper.c	max_tmds_clock	6	12	\N	\N	\tuint8_t max_tmds_clock;\n\tssize_t ret;\n\n\t/* native HDMI so no limit */\n\tif (type == DRM_DP_DUAL_MODE_NONE)\n\t\treturn 0;\n\n\t/*\n\t * Type 1 adaptors are limited to 165MHz\n\t * Type 2 adaptors can tells us their limit\n\t */\n\tif (type < DRM_DP_DUAL_MODE_TYPE2_DVI)\n\t\treturn 165000;\n\n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_MAX_TMDS_CLOCK,\n\t\t\t\t    &max_tmds_clock, sizeof(max_tmds_clock));\n\tif (ret || max_tmds_clock == 0x00 || max_tmds_clock == 0xff) {\n	t
9909	169	mdio_sc_cfg_reg_write	drivers/net/ethernet/hisilicon/hns_mdio.c	reg_value	7	12	\N	\N	\tu32 time_cnt;\n\tu32 reg_value;\n\n\tregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\n\n\tfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\n\t\tregmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\n\t\treg_value &= st_msk;\n\t\tif ((!!check_st) == (!!reg_value))\n\t\t\tbreak;\n\t}\n\n\tif ((!!check_st) != (!!reg_value))\n	t
40502	1814	fib_table_flush_external	net/ipv4/fib_trie.c	fib_table_flush_external_$__mptr49$obj	0	11	\N	\N	\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\n\t/* walk trie in reverse order */\n\tfor (;;) {\n\t\tunsigned char slen = 0;\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\t/* cannot resize the trie vector */\n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\t/* update the suffix to address pulled leaves */\n\t\t\tif (pn->slen > pn->pos)\n\t\t\t\tupdate_suffix(pn);\n\n\t\t\t/* resize completed node */\n\t\t\tpn = resize(t, pn);\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab the next available node */\n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t/* record pn and cindex for leaf walking */\n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n	t
4504	435	da9052_adc_read_temp	drivers/mfd/da9052-core.c	tbat	1	11	\N	\N	\tint tbat;\n\n\ttbat = da9052_reg_read(da9052, DA9052_TBAT_RES_REG);\n\tif (tbat <= 0)\n	t
20605	1025	keyctl_change_reqkey_auth	security/keys/keyctl.c	new->request_key_auth	7	12	\N	\N	\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n	t
27642	835	handle_receive_interrupt_dma_rtail	drivers/infiniband/hw/hfi1/driver.c	&packet	2	-11	\N	\N	\tu32 hdrqtail;\n\tint last = RCV_PKT_OK;\n\tstruct hfi1_packet packet;\n\n\tinit_packet(rcd, &packet);\n	t
31082	980	metadata_commit	drivers/md/dm-era-target.c	md	6	12	\N	exclude	\tint r;\n\tstruct dm_block *sblock;\n\n\tif (md->current_writeset->md.root != SUPERBLOCK_LOCATION) {\n\t\tr = dm_bitset_flush(&md->bitset_info, md->current_writeset->md.root,\n\t\t\t\t    &md->current_writeset->md.root);\n\t\tif (r) {\n\t\t\tDMERR("%s: bitset flush failed", __func__);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = dm_tm_pre_commit(md->tm);\n\tif (r) {\n\t\tDMERR("%s: pre commit failed", __func__);\n\t\treturn r;\n\t}\n\n\tr = save_sm_root(md);\n\tif (r) {\n\t\tDMERR("%s: save_sm_root failed", __func__);\n\t\treturn r;\n\t}\n\n\tr = superblock_lock(md, &sblock);\n\tif (r) {\n\t\tDMERR("%s: superblock lock failed", __func__);\n\t\treturn r;\n\t}\n\n\tprepare_superblock(md, dm_block_data(sblock));\n	t
29270	767	empty_dir	fs/udf/namei.c	&eloc	1	11	\N	\N	\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n	t
62519	1764	ath10k_wmi_tlv_op_gen_vdev_up	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_vdev_up_$cmd$obj$2	0	13	\N	\N	\tstruct wmi_vdev_up_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_UP_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->vdev_assoc_id = __cpu_to_le32(aid);\n\tether_addr_copy(cmd->vdev_bssid.addr, bssid);\n	f
3537	2332	stv090x_chk_signal	drivers/media/dvb-frontends/stv090x.c	agc2	1	13	\N	\N	\ts32 offst_car, agc2, car_max;\n\tint no_signal;\n\n\toffst_car  = STV090x_READ_DEMOD(state, CFR2) << 8;\n\toffst_car |= STV090x_READ_DEMOD(state, CFR1);\n\toffst_car = comp2(offst_car, 16);\n\n\tagc2  = STV090x_READ_DEMOD(state, AGC2I1) << 8;\n\tagc2 |= STV090x_READ_DEMOD(state, AGC2I0);\n\tcar_max = state->search_range / 1000;\n\n\tcar_max += (car_max / 10); /* 10% margin */\n\tcar_max  = (65536 * car_max / 2);\n\tcar_max /= state->internal->mclk / 1000;\n\n\tif (car_max > 0x4000)\n\t\tcar_max = 0x4000;\n\n\tif ((agc2 > 0x2000) || (offst_car > 2 * car_max) || (offst_car < -2 * car_max)) {\n	f
24177	3535	handle_resize	drivers/net/ethernet/mellanox/mlx4/resource_tracker.c	mtt	1	13	\N	\N	\tint err;\n\tstruct res_mtt *orig_mtt;\n\tstruct res_mtt *mtt;\n\tstruct mlx4_cq_context *cqc = inbox->buf;\n\tint mtt_base = cq_get_mtt_addr(cqc) / dev->caps.mtt_entry_sz;\n\n\terr = get_res(dev, slave, cq->mtt->com.res_id, RES_MTT, &orig_mtt);\n\tif (err)\n\t\treturn err;\n\n\tif (orig_mtt != cq->mtt) {\n\t\terr = -EINVAL;\n\t\tgoto ex_put;\n\t}\n\n\terr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\n\tif (err)\n\t\tgoto ex_put;\n\n\terr = check_mtt_range(dev, slave, mtt_base, cq_get_mtt_size(cqc), mtt);\n	f
32133	393	uvd_v4_2_stop	drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c	status	1	11	\N	\N	\tuint32_t i, j;\n\tuint32_t status;\n\n\tWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\t\tif (status & 2)\n	t
59676	2451	nfs3_xdr_dec_getacl3res	fs/nfs/nfs3xdr.c	status	1	11	\N	\N	\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n	t
4317	346	kdb_read	kernel/debug/kdb/kdb_io.c	kdb_read_$count$obj	0	11	\N	\N	\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv("DTABCOUNT", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf("%s", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf("\\b%s \\r", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf("%s", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf("%s", buffer);\n\t\t}\n\t\tkdb_printf("\\n");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf("%s \\r", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf("%s", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf("\\r");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf("%s", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf("\\b");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf("\\r%s\\r", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf("%c", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf("\\r%s\\r", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf("\\n%d symbols are found.", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(" But only first %d symbols will"\n	t
21846	93	zpff_init	drivers/hid/hid-zpff.c	zpff_init_$zpff$obj$0$obj	0	11	\N	\N	\tstruct zpff_device *zpff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint i, error;\n\n\tfor (i = 0; i < 4; i++) {\n\t\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);\n\t\tif (!report)\n\t\t\treturn -ENODEV;\n\t}\n\n\tzpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);\n\tif (!zpff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, zpff, zpff_play);\n\tif (error) {\n\t\tkfree(zpff);\n\t\treturn error;\n\t}\n\n\tzpff->report = report;\n\tzpff->report->field[0]->value[0] = 0x00;\n	t
53948	1145	trace_selftest_startup_wakeup	kernel/trace/trace.c	trace_selftest_startup_wakeup_$count$obj	0	11	\N	\N	\treturn nsecs / 1000;\n}\n\n/*\n * TRACE_FLAGS is defined as a tuple matching bit masks with strings.\n * It uses C(a, b) where 'a' is the eval (enum) name and 'b' is the string that\n * matches it. By defining "C(a, b) b", TRACE_FLAGS becomes a list\n	t
9766	1342	ufshcd_clkscale_enable_store	drivers/scsi/ufs/ufshcd.c	value	1	11	\N	\N	\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tu32 value;\n\tint err;\n\n\tif (kstrtou32(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tvalue = !!value;\n	t
52970	762	fsnotify_mark_destroy_workfn	fs/notify/mark.c	mark	6	12	\N	\N	\tstruct fsnotify_mark *mark, *next;\n\tstruct list_head private_destroy_list;\n\n\tspin_lock(&destroy_lock);\n\t/* exchange the list head */\n\tlist_replace_init(&destroy_list, &private_destroy_list);\n\tspin_unlock(&destroy_lock);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\tlist_for_each_entry_safe(mark, next, &private_destroy_list, g_list) {\n	t
35351	160	zd_switch_radio_off	drivers/net/wireless/zydas/zd1211rw/zd_rf.c	r	1	11	\N	\N	\tint r, t;\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\t/* TODO: move phy regs handling to zd_chip */\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n	t
43774	1049	snd_card_asihpi_playback_open	sound/pci/asihpi/asihpi.c	err	1	11	\N	\N	\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_hardware snd_card_asihpi_playback;\n\tint err;\n\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (dpcm == NULL)\n\t\treturn -ENOMEM;\n\n\terr = hpi_outstream_open(card->hpi->adapter->index,\n\t\t\t      substream->number, &dpcm->h_stream);\n\thpi_handle_error(err);\n	t
45714	868	fuse_readpages_fill	fs/fuse/file.c	fuse_readpages_fill_$req$obj$36$obj	0	13	\N	\N	\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n	f
21013	387	ghes_read_estatus	drivers/acpi/apei/ghes.c	buf_paddr	2	-11	\N	\N	\tstruct acpi_hest_generic *g = ghes->generic;\n\tu64 buf_paddr;\n\tu32 len;\n\tint rc;\n\n\trc = apei_read(&buf_paddr, &g->error_status_address);\n\tif (rc) {\n\t\tif (!silent && printk_ratelimit())\n\t\t\tpr_warning(FW_WARN GHES_PFX\n"Failed to read error status block address for hardware error source: %d.\\n",\n\t\t\t\t   g->header.source_id);\n\t\treturn -EIO;\n\t}\n\tif (!buf_paddr)\n	t
46235	145	rmnet_map_ingress_handler	drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c	skbn	2	-11	\N	\N	\tstruct sk_buff *skbn;\n\tint rc;\n\n\tif (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {\n\t\twhile ((skbn = rmnet_map_deaggregate(skb)) != NULL)\n\t\t\t__rmnet_map_ingress_handler(skbn, port);\n	t
60609	323	igt_vma_pin1	drivers/gpu/drm/i915/i915_vma.c	igt_vma_pin1_$err$obj	0	11	\N	\N	\tstruct i915_vma *vma;\n\tstruct drm_i915_gem_object *obj;\n\n\tvma = fetch_and_zero(p_vma);\n\tif (!vma)\n\t\treturn;\n\n\tobj = vma->obj;\n\n\ti915_vma_unpin(vma);\n\ti915_vma_close(vma);\n\n\t__i915_gem_object_release_unless_active(obj);\n}\n\n	t
59878	672	cros_ec_spi_probe	drivers/mfd/cros_ec_spi.c	err	1	11	\N	\N	\tstruct device *dev = &spi->dev;\n\tstruct cros_ec_device *ec_dev;\n\tstruct cros_ec_spi *ec_spi;\n\tint err;\n\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_0;\n\terr = spi_setup(spi);\n\tif (err < 0)\n\t\treturn err;\n\n\tec_spi = devm_kzalloc(dev, sizeof(*ec_spi), GFP_KERNEL);\n\tif (ec_spi == NULL)\n\t\treturn -ENOMEM;\n\tec_spi->spi = spi;\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\t/* Check for any DT properties */\n\tcros_ec_spi_dt_probe(ec_spi, dev);\n\n\tspi_set_drvdata(spi, ec_dev);\n\tec_dev->dev = dev;\n\tec_dev->priv = ec_spi;\n\tec_dev->irq = spi->irq;\n\tec_dev->cmd_xfer = cros_ec_cmd_xfer_spi;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_spi;\n\tec_dev->phys_name = dev_name(&ec_spi->spi->dev);\n\tec_dev->din_size = EC_MSG_PREAMBLE_COUNT +\n\t\t\t   sizeof(struct ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request);\n\n\n\terr = cros_ec_register(ec_dev);\n\tif (err) {\n	t
36577	7880	ath10k_wmi_10_4_gen_update_fw_tdls_state	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_10_4_gen_update_fw_tdls_state_$cmd$obj	0	11	\N	\N	\tstruct wmi_10_4_tdls_set_state_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 options = 0;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (test_bit(WMI_SERVICE_TDLS_EXPLICIT_MODE_ONLY, ar->wmi.svc_map))\n\t\tstate = WMI_TDLS_ENABLE_PASSIVE;\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA, ar->wmi.svc_map))\n\t\toptions |= WMI_TDLS_BUFFER_STA_EN;\n\n\tcmd = (struct wmi_10_4_tdls_set_state_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	t
22517	1348	xfs_qm_quotacheck	fs/xfs/xfs_qm.c	done	6	12	\N	\N	\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, "Quotacheck needed: Please wait.");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n	t
23286	386	f2fs_move_inline_dirents	fs/f2fs/inline.c	src.filename	9	12	\N	\N	\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\tzero_user_segment(page, MAX_INLINE_DATA(dir), PAGE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n	t
30702	87	acpi_custom_method_init	drivers/acpi/custom_method.c	acpi_custom_method_init_@cm_dentry $obj	0	11	\N	\N	\tif (acpi_debugfs_dir == NULL)\n\t\treturn -ENOENT;\n\n\tcm_dentry = debugfs_create_file("custom_method", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (cm_dentry == NULL)\n	t
28302	1163	ipmr_mfc_delete	net/ipv4/ipmr.c	&c->list	6	12	\N	\N	\tstruct mfc_cache *c;\n\n\t/* The entries are added/deleted only under RTNL */\n\trcu_read_lock();\n\tc = ipmr_cache_find_parent(mrt, mfc->mfcc_origin.s_addr,\n\t\t\t\t   mfc->mfcc_mcastgrp.s_addr, parent);\n\trcu_read_unlock();\n\tif (!c)\n\t\treturn -ENOENT;\n\trhltable_remove(&mrt->mfc_hash, &c->mnode, ipmr_rht_params);\n\tlist_del_rcu(&c->list);\n	t
31566	237	usb6fire_fw_ezusb_upload	sound/usb/6fire/firmware.c	ret	1	11	\N	\N	\tint ret;\n\tu8 data;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tconst struct firmware *fw = NULL;\n\tstruct ihex_record *rec = kmalloc(sizeof(struct ihex_record),\n\t\t\tGFP_KERNEL);\n\n\tif (!rec)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, fwname, &device->dev);\n\tif (ret < 0) {\n\t\tkfree(rec);\n\t\tdev_err(&intf->dev,\n\t\t\t"error requesting ezusb firmware %s.\\n", fwname);\n\t\treturn ret;\n\t}\n\tret = usb6fire_fw_ihex_init(fw, rec);\n\tif (ret < 0) {\n\t\tkfree(rec);\n\t\trelease_firmware(fw);\n\t\tdev_err(&intf->dev,\n\t\t\t"error validating ezusb firmware %s.\\n", fwname);\n\t\treturn ret;\n\t}\n\t/* upload firmware image */\n\tdata = 0x01; /* stop ezusb cpu */\n\tret = usb6fire_fw_ezusb_write(device, 0xa0, 0xe600, &data, 1);\n\tif (ret < 0) {\n	t
41270	675	sco_sock_accept	net/bluetooth/sco.c	ch	1	11	\N	\N	\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG("sk %p timeo %ld", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tch = bt_accept_dequeue(sk, newsock);\n\t\tif (ch)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tlock_sock(sk);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG("new socket %p", ch);\n	t
38700	1253	xfs_create	fs/xfs/xfs_inode.c	xfs_create_$ip$obj$4	0	11	\N	\N	\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool                    unlock_dp_on_error = false;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\trdev = 0;\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t}\n\n\t/*\n\t * Initially assume that the file does not exist and\n\t * reserve the resources for that case.  If that is not\n\t * the case we'll drop the one we have and get a more\n\t * appropriate transaction later.\n\t */\n\terror = xfs_trans_alloc(mp, tres, resblks, 0, 0, &tp);\n\tif (error == -ENOSPC) {\n\t\t/* flush outstanding delalloc blocks and retry */\n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_alloc(mp, tres, resblks, 0, 0, &tp);\n\t}\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a "no-allocation" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_alloc(mp, tres, 0, 0, 0, &tp);\n\t}\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\txfs_defer_init(&dfops, &first_block);\n\n\t/*\n\t * Reserve disk quota and the inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, name);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * A newly created regular or special file just has one directory\n\t * entry pointing to them, but a directory also the "." entry\n\t * pointing to itself.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\n\t\t\t       prid, resblks > 0, &ip, NULL);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t/*\n\t * Now we join the directory inode to the transaction.  We do not do it\n\t * earlier because xfs_dir_ialloc might commit the previous transaction\n\t * (and release all the locks).  An error from here on will result in\n\t * the transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n	t
31116	4702	handle_stripe	drivers/md/raid5.c	handle_stripe_$s$1$obj	0	11	\N	\N	\tstruct stripe_head_state s;\n\tstruct r5conf *conf = sh->raid_conf;\n\tint i;\n\tint prexor;\n\tint disks = sh->disks;\n\tstruct r5dev *pdev, *qdev;\n\n\tclear_bit(STRIPE_HANDLE, &sh->state);\n\tif (test_and_set_bit_lock(STRIPE_ACTIVE, &sh->state)) {\n\t\t/* already being handled, ensure it gets handled\n\t\t * again when current action finishes */\n\t\tset_bit(STRIPE_HANDLE, &sh->state);\n\t\treturn;\n\t}\n\n\tif (clear_batch_ready(sh) ) {\n\t\tclear_bit_unlock(STRIPE_ACTIVE, &sh->state);\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(STRIPE_BATCH_ERR, &sh->state))\n\t\tbreak_stripe_batch_list(sh, 0);\n\n\tif (test_bit(STRIPE_SYNC_REQUESTED, &sh->state) && !sh->batch_head) {\n\t\tspin_lock(&sh->stripe_lock);\n\t\t/*\n\t\t * Cannot process 'sync' concurrently with 'discard'.\n\t\t * Flush data in r5cache before 'sync'.\n\t\t */\n\t\tif (!test_bit(STRIPE_R5C_PARTIAL_STRIPE, &sh->state) &&\n\t\t    !test_bit(STRIPE_R5C_FULL_STRIPE, &sh->state) &&\n\t\t    !test_bit(STRIPE_DISCARD, &sh->state) &&\n\t\t    test_and_clear_bit(STRIPE_SYNC_REQUESTED, &sh->state)) {\n\t\t\tset_bit(STRIPE_SYNCING, &sh->state);\n\t\t\tclear_bit(STRIPE_INSYNC, &sh->state);\n\t\t\tclear_bit(STRIPE_REPLACED, &sh->state);\n\t\t}\n\t\tspin_unlock(&sh->stripe_lock);\n\t}\n\tclear_bit(STRIPE_DELAYED, &sh->state);\n\n\tpr_debug("handling stripe %llu, state=%#lx cnt=%d, "\n\t\t"pd_idx=%d, qd_idx=%d\\n, check:%d, reconstruct:%d\\n",\n\t       (unsigned long long)sh->sector, sh->state,\n\t       atomic_read(&sh->count), sh->pd_idx, sh->qd_idx,\n\t       sh->check_state, sh->reconstruct_state);\n\n\tanalyse_stripe(sh, &s);\n\n\tif (test_bit(STRIPE_LOG_TRAPPED, &sh->state))\n\t\tgoto finish;\n\n\tif (s.handle_bad_blocks ||\n\t    test_bit(MD_SB_CHANGE_PENDING, &conf->mddev->sb_flags)) {\n\t\tset_bit(STRIPE_HANDLE, &sh->state);\n\t\tgoto finish;\n\t}\n\n\tif (unlikely(s.blocked_rdev)) {\n\t\tif (s.syncing || s.expanding || s.expanded ||\n	t
44754	183	appledisplay_bl_get_brightness	drivers/usb/misc/appledisplay.c	retval	1	11	\N	\N	\tstruct appledisplay *pdata = bl_get_data(bd);\n\tint retval, brightness;\n\n\tmutex_lock(&pdata->sysfslock);\n\tretval = usb_control_msg(\n\t\tpdata->udev,\n\t\tusb_rcvctrlpipe(pdata->udev, 0),\n\t\tUSB_REQ_GET_REPORT,\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\tACD_USB_BRIGHTNESS,\n\t\t0,\n\t\tpdata->msgdata, 2,\n\t\tACD_USB_TIMEOUT);\n\tbrightness = pdata->msgdata[1];\n\tmutex_unlock(&pdata->sysfslock);\n\n\tif (retval < 0)\n	t
51313	1914	mxt_initialize_input_device	drivers/input/touchscreen/atmel_mxt_ts.c	data->max_y	1	11	\N	\N	\tconst struct mxt_platform_data *pdata = data->pdata;\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input_dev;\n\tint error;\n\tunsigned int num_mt_slots;\n\tunsigned int mt_flags = 0;\n\n\tswitch (data->multitouch) {\n\tcase MXT_TOUCH_MULTI_T9:\n\t\tnum_mt_slots = data->T9_reportid_max - data->T9_reportid_min + 1;\n\t\terror = mxt_read_t9_resolution(data);\n\t\tif (error)\n\t\t\tdev_warn(dev, "Failed to initialize T9 resolution\\n");\n\t\tbreak;\n\n\tcase MXT_TOUCH_MULTITOUCHSCREEN_T100:\n\t\tnum_mt_slots = data->num_touchids;\n\t\terror = mxt_read_t100_config(data);\n\t\tif (error)\n\t\t\tdev_warn(dev, "Failed to read T100 config\\n");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, "Invalid multitouch object\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle default values and orientation switch */\n\tif (data->max_x == 0)\n\t\tdata->max_x = 1023;\n\n\tif (data->max_y == 0)\n	t
53488	2619	snd_rme9652_probe	sound/pci/rme9652/rme9652.c	rme9652->dev	1	11	\N	\N	\tstatic int dev;\n\tstruct snd_rme9652 *rme9652;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct snd_rme9652), &card);\n\n\tif (err < 0)\n\t\treturn err;\n\n\trme9652 = (struct snd_rme9652 *) card->private_data;\n\tcard->private_free = snd_rme9652_card_free;\n\trme9652->dev = dev;\n	t
25467	531	icmp_route_lookup	net/ipv4/icmp.c	fl4_dec.daddr	7	12	\N	indirect call	\tstruct rtable *rt, *rt2;\n\tstruct flowi4 fl4_dec;\n\tint err;\n\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->daddr = (param->replyopts.opt.opt.srr ?\n\t\t      param->replyopts.opt.opt.faddr : iph->saddr);\n\tfl4->saddr = saddr;\n\tfl4->flowi4_mark = mark;\n\tfl4->flowi4_uid = sock_net_uid(net, NULL);\n\tfl4->flowi4_tos = RT_TOS(tos);\n\tfl4->flowi4_proto = IPPROTO_ICMP;\n\tfl4->fl4_icmp_type = type;\n\tfl4->fl4_icmp_code = code;\n\tfl4->flowi4_oif = l3mdev_master_ifindex(skb_dst(skb_in)->dev);\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(fl4));\n\trt = ip_route_output_key_hash(net, fl4, skb_in);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4_dec), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type_dev_table(net, skb_dst(skb_in)->dev,\n\t\t\t\t     fl4_dec.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4_dec);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4_dec.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\tskb_dst_set(skb_in, NULL);\n\t\terr = ip_route_input(skb_in, fl4_dec.daddr, fl4_dec.saddr,\n	t
61916	1125	reread_config_rom	drivers/firewire/core-device.c	rcode	1	11	\N	\N	\tu32 q;\n\tint i, rcode;\n\n\tfor (i = 0; i < 6; i++) {\n\t\trcode = read_rom(device, generation, i, &q);\n\t\tif (rcode != RCODE_COMPLETE)\n	t
58684	2499	write_enabled_file_bool	kernel/kprobes.c	buf	6	12	\N	\N	\tchar buf[32];\n\tsize_t buf_size;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\tswitch (buf[0]) {\n	t
27330	1843	gf100_gr_ctor_fw_legacy	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c	fuc->size	7	12	\N	\N	\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst struct firmware *fw;\n\tchar f[32];\n\n\t/* see if this firmware has a legacy path */\n\tif (!strcmp(fwname, "fecs_inst"))\n\t\tfwname = "fuc409c";\n\telse if (!strcmp(fwname, "fecs_data"))\n\t\tfwname = "fuc409d";\n\telse if (!strcmp(fwname, "gpccs_inst"))\n\t\tfwname = "fuc41ac";\n\telse if (!strcmp(fwname, "gpccs_data"))\n\t\tfwname = "fuc41ad";\n\telse {\n\t\t/* nope, let's just return the error we got */\n\t\tnvkm_error(subdev, "failed to load %s\\n", fwname);\n\t\treturn ret;\n\t}\n\n\t/* yes, try to load from the legacy path */\n\tnvkm_debug(subdev, "%s: falling back to legacy path\\n", fwname);\n\n\tsnprintf(f, sizeof(f), "nouveau/nv%02x_%s", device->chipset, fwname);\n\tret = request_firmware(&fw, f, device->dev);\n\tif (ret) {\n\t\tsnprintf(f, sizeof(f), "nouveau/%s", fwname);\n\t\tret = request_firmware(&fw, f, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, "failed to load %s\\n", fwname);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfuc->size = fw->size;\n\tfuc->data = kmemdup(fw->data, fuc->size, GFP_KERNEL);\n	t
58467	1440	nvme_fc_fcpio_done	drivers/nvme/host/fc.c	&result	1	11	\N	\N	\tstruct nvme_fc_fcp_op *op = fcp_req_to_fcp_op(req);\n\tstruct request *rq = op->rq;\n\tstruct nvmefc_fcp_req *freq = &op->fcp_req;\n\tstruct nvme_fc_ctrl *ctrl = op->ctrl;\n\tstruct nvme_fc_queue *queue = op->queue;\n\tstruct nvme_completion *cqe = &op->rsp_iu.cqe;\n\tstruct nvme_command *sqe = &op->cmd_iu.sqe;\n\t__le16 status = cpu_to_le16(NVME_SC_SUCCESS << 1);\n\tunion nvme_result result;\n\tbool complete_rq, terminate_assoc = true;\n\n\t/*\n\t * WARNING:\n\t * The current linux implementation of a nvme controller\n\t * allocates a single tag set for all io queues and sizes\n\t * the io queues to fully hold all possible tags. Thus, the\n\t * implementation does not reference or care about the sqhd\n\t * value as it never needs to use the sqhd/sqtail pointers\n\t * for submission pacing.\n\t *\n\t * This affects the FC-NVME implementation in two ways:\n\t * 1) As the value doesn't matter, we don't need to waste\n\t *    cycles extracting it from ERSPs and stamping it in the\n\t *    cases where the transport fabricates CQEs on successful\n\t *    completions.\n\t * 2) The FC-NVME implementation requires that delivery of\n\t *    ERSP completions are to go back to the nvme layer in order\n\t *    relative to the rsn, such that the sqhd value will always\n\t *    be "in order" for the nvme layer. As the nvme layer in\n\t *    linux doesn't care about sqhd, there's no need to return\n\t *    them in order.\n\t *\n\t * Additionally:\n\t * As the core nvme layer in linux currently does not look at\n\t * every field in the cqe - in cases where the FC transport must\n\t * fabricate a CQE, the following fields will not be set as they\n\t * are not referenced:\n\t *      cqe.sqid,  cqe.sqhd,  cqe.command_id\n\t *\n\t * Failure or error of an individual i/o, in a transport\n\t * detected fashion unrelated to the nvme completion status,\n\t * potentially cause the initiator and target sides to get out\n\t * of sync on SQ head/tail (aka outstanding io count allowed).\n\t * Per FC-NVME spec, failure of an individual command requires\n\t * the connection to be terminated, which in turn requires the\n\t * association to be terminated.\n\t */\n\n\tfc_dma_sync_single_for_cpu(ctrl->lport->dev, op->fcp_req.rspdma,\n\t\t\t\tsizeof(op->rsp_iu), DMA_FROM_DEVICE);\n\n\tif (atomic_read(&op->state) == FCPOP_STATE_ABORTED)\n\t\tstatus = cpu_to_le16((NVME_SC_ABORT_REQ | NVME_SC_DNR) << 1);\n\telse if (freq->status)\n\t\tstatus = cpu_to_le16(NVME_SC_INTERNAL << 1);\n\n\t/*\n\t * For the linux implementation, if we have an unsuccesful\n\t * status, they blk-mq layer can typically be called with the\n\t * non-zero status and the content of the cqe isn't important.\n\t */\n\tif (status)\n\t\tgoto done;\n\n\t/*\n\t * command completed successfully relative to the wire\n\t * protocol. However, validate anything received and\n\t * extract the status and result from the cqe (create it\n\t * where necessary).\n\t */\n\n\tswitch (freq->rcv_rsplen) {\n\n\tcase 0:\n\tcase NVME_FC_SIZEOF_ZEROS_RSP:\n\t\t/*\n\t\t * No response payload or 12 bytes of payload (which\n\t\t * should all be zeros) are considered successful and\n\t\t * no payload in the CQE by the transport.\n\t\t */\n\t\tif (freq->transferred_length !=\n\t\t\tbe32_to_cpu(op->cmd_iu.data_len)) {\n\t\t\tstatus = cpu_to_le16(NVME_SC_INTERNAL << 1);\n\t\t\tgoto done;\n\t\t}\n\t\tresult.u64 = 0;\n\t\tbreak;\n\n\tcase sizeof(struct nvme_fc_ersp_iu):\n\t\t/*\n\t\t * The ERSP IU contains a full completion with CQE.\n\t\t * Validate ERSP IU and look at cqe.\n\t\t */\n\t\tif (unlikely(be16_to_cpu(op->rsp_iu.iu_len) !=\n\t\t\t\t\t(freq->rcv_rsplen / 4) ||\n\t\t\t     be32_to_cpu(op->rsp_iu.xfrd_len) !=\n\t\t\t\t\tfreq->transferred_length ||\n\t\t\t     op->rsp_iu.status_code ||\n\t\t\t     sqe->common.command_id != cqe->command_id)) {\n\t\t\tstatus = cpu_to_le16(NVME_SC_INTERNAL << 1);\n\t\t\tgoto done;\n\t\t}\n\t\tresult = cqe->result;\n\t\tstatus = cqe->status;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = cpu_to_le16(NVME_SC_INTERNAL << 1);\n\t\tgoto done;\n\t}\n\n\tterminate_assoc = false;\n\ndone:\n\tif (op->flags & FCOP_FLAGS_AEN) {\n\t\tnvme_complete_async_event(&queue->ctrl->ctrl, status, &result);\n	t
58968	5087	lpfc_bsg_menlo_cmd_cmp	drivers/scsi/lpfc/lpfc_bsg.c	bsg_reply->result	1	11	\N	\N	\tstruct bsg_job_data *dd_data;\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tIOCB_t *rsp;\n\tstruct lpfc_dmabuf *bmp, *cmp, *rmp;\n\tstruct lpfc_bsg_menlo *menlo;\n\tunsigned long flags;\n\tstruct menlo_response *menlo_resp;\n\tunsigned int rsp_size;\n\tint rc = 0;\n\n\tdd_data = cmdiocbq->context1;\n\tcmp = cmdiocbq->context2;\n\tbmp = cmdiocbq->context3;\n\tmenlo = &dd_data->context_un.menlo;\n\trmp = menlo->rmp;\n\trsp = &rspiocbq->iocb;\n\n\t/* Determine if job has been aborted */\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\t/* Prevent timeout handling from trying to abort job  */\n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t/* Copy the job data or set the failing status for the job */\n\n\tif (job) {\n\t\t/* always return the xri, this would be used in the case\n\t\t * of a menlo download to allow the data to be sent as a\n\t\t * continuation of the exchange.\n\t\t */\n\n\t\tmenlo_resp = (struct menlo_response *)\n\t\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\t\tmenlo_resp->xri = rsp->ulpContext;\n\t\tif (rsp->ulpStatus) {\n\t\t\tif (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\n\t\t\t\tswitch (rsp->un.ulpWord[4] & IOERR_PARAM_MASK) {\n\t\t\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IOERR_INVALID_RPI:\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\trc = -EACCES;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = -EACCES;\n\t\t\t}\n\t\t} else {\n\t\t\trsp_size = rsp->un.genreq64.bdl.bdeSize;\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tlpfc_bsg_copy_data(rmp, &job->reply_payload,\n\t\t\t\t\t\t   rsp_size, 0);\n\t\t}\n\n\t}\n\n\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\tlpfc_free_bsg_buffers(phba, cmp);\n\tlpfc_free_bsg_buffers(phba, rmp);\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\tkfree(bmp);\n\tkfree(dd_data);\n\n\t/* Complete the job if active */\n\n\tif (job) {\n\t\tbsg_reply->result = rc;\n\t\tbsg_job_done(job, bsg_reply->result,\n	t
28938	305	hpfs_lookup	fs/hpfs/dir.c	&qbh	8	12	\N	\N	\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tino_t ino;\n\tint err;\n\tstruct inode *result = NULL;\n\tstruct hpfs_inode_info *hpfs_result;\n\n\thpfs_lock(dir->i_sb);\n\tif ((err = hpfs_chk_name(name, &len))) {\n\t\tif (err == -ENAMETOOLONG) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t\tgoto end_add;\n\t}\n\n\t/*\n\t * '.' and '..' will never be passed here.\n\t */\n\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, NULL, &qbh);\n\n\t/*\n\t * This is not really a bailout, just means file not found.\n\t */\n\n\tif (!de) goto end;\n\n\t/*\n\t * Get inode number, what we're after.\n\t */\n\n\tino = le32_to_cpu(de->fnode);\n\n\t/*\n\t * Go find or make an inode.\n\t */\n\n\tresult = iget_locked(dir->i_sb, ino);\n\tif (!result) {\n\t\thpfs_error(dir->i_sb, "hpfs_lookup: can't get inode");\n\t\tgoto bail1;\n\t}\n\tif (result->i_state & I_NEW) {\n\t\thpfs_init_inode(result);\n\t\tif (de->directory)\n\t\t\thpfs_read_inode(result);\n\t\telse if (le32_to_cpu(de->ea_size) && hpfs_sb(dir->i_sb)->sb_eas)\n\t\t\thpfs_read_inode(result);\n\t\telse {\n\t\t\tresult->i_mode |= S_IFREG;\n\t\t\tresult->i_mode &= ~0111;\n\t\t\tresult->i_op = &hpfs_file_iops;\n\t\t\tresult->i_fop = &hpfs_file_ops;\n\t\t\tset_nlink(result, 1);\n\t\t}\n\t\tunlock_new_inode(result);\n\t}\n\thpfs_result = hpfs_i(result);\n\tif (!de->directory) hpfs_result->i_parent_dir = dir->i_ino;\n\n\tif (de->has_acl || de->has_xtd_perm) if (!sb_rdonly(dir->i_sb)) {\n\t\thpfs_error(result->i_sb, "ACLs or XPERM found. This is probably HPFS386. This driver doesn't support it now. Send me some info on these structures");\n\t\tgoto bail1;\n\t}\n\n\t/*\n\t * Fill in the info from the directory if this is a newly created\n\t * inode.\n\t */\n\n\tif (!result->i_ctime.tv_sec) {\n\t\tif (!(result->i_ctime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->creation_date))))\n\t\t\tresult->i_ctime.tv_sec = 1;\n\t\tresult->i_ctime.tv_nsec = 0;\n\t\tresult->i_mtime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->write_date));\n\t\tresult->i_mtime.tv_nsec = 0;\n\t\tresult->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->read_date));\n\t\tresult->i_atime.tv_nsec = 0;\n\t\thpfs_result->i_ea_size = le32_to_cpu(de->ea_size);\n\t\tif (!hpfs_result->i_ea_mode && de->read_only)\n\t\t\tresult->i_mode &= ~0222;\n\t\tif (!de->directory) {\n\t\t\tif (result->i_size == -1) {\n\t\t\t\tresult->i_size = le32_to_cpu(de->file_size);\n\t\t\t\tresult->i_data.a_ops = &hpfs_aops;\n\t\t\t\thpfs_i(result)->mmu_private = result->i_size;\n\t\t\t/*\n\t\t\t * i_blocks should count the fnode and any anodes.\n\t\t\t * We count 1 for the fnode and don't bother about\n\t\t\t * anodes -- the disk heads are on the directory band\n\t\t\t * and we want them to stay there.\n\t\t\t */\n\t\t\t\tresult->i_blocks = 1 + ((result->i_size + 511) >> 9);\n\t\t\t}\n\t\t}\n\t}\n\n\thpfs_brelse4(&qbh);\n	t
24127	1052	dt282x_alloc_dma	drivers/staging/comedi/drivers/dt282x.c	dma_chan	2	-11	\N	\N	\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int irq_num = it->options[1];\n\tunsigned int dma_chan[2];\n\n\tif (it->options[2] < it->options[3]) {\n\t\tdma_chan[0] = it->options[2];\n\t\tdma_chan[1] = it->options[3];\n\t} else {\n\t\tdma_chan[0] = it->options[3];\n\t\tdma_chan[1] = it->options[2];\n\t}\n\n\tif (!irq_num || dma_chan[0] == dma_chan[1] ||\n	t
30819	164	get_subobj_info	drivers/platform/x86/wmi.c	dummy_info	6	12	\N	\N	\tstruct acpi_device_info *dummy_info, **info_ptr;\n\tacpi_handle subobj_handle;\n\tacpi_status status;\n\n\tstatus = acpi_get_handle(handle, (char *)pathname, &subobj_handle);\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENOENT;\n\telse if (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tinfo_ptr = info ? info : &dummy_info;\n\tstatus = acpi_get_object_info(subobj_handle, info_ptr);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tif (!info)\n\t\tkfree(dummy_info);\n	t
25573	1964	rtllib_sta_ps_send_pspoll_frame	drivers/staging/rtl8192e/rtllib_softmac.c	buf	1	11	\N	\N	\tstruct sk_buff *buf = rtllib_pspoll_func(ieee);\n\n\tif (buf)\n\t\tsoftmac_ps_mgmt_xmit(buf, ieee);\n	t
31893	438	bt819_probe	drivers/media/i2c/bt819.c	&decoder->hdl	6	12	\N	heap variable, field sensitivity	\tint i, ver;\n\tstruct bt819 *decoder;\n\tstruct v4l2_subdev *sd;\n\tconst char *name;\n\n\t/* Check if the adapter supports the needed features */\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (decoder == NULL)\n\t\treturn -ENOMEM;\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &bt819_ops);\n\n\tver = bt819_read(decoder, 0x17);\n\tswitch (ver & 0xf0) {\n\tcase 0x70:\n\t\tname = "bt819a";\n\t\tbreak;\n\tcase 0x60:\n\t\tname = "bt817a";\n\t\tbreak;\n\tcase 0x20:\n\t\tname = "bt815a";\n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t"unknown chip version 0x%02x\\n", ver);\n\t\treturn -ENODEV;\n\t}\n\n\tv4l_info(client, "%s found @ 0x%x (%s)\\n", name,\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tdecoder->norm = V4L2_STD_NTSC;\n\tdecoder->input = 0;\n\tdecoder->enable = 1;\n\n\ti = bt819_init(sd);\n\tif (i < 0)\n\t\tv4l2_dbg(1, debug, sd, "init status %d\\n", i);\n\n\tv4l2_ctrl_handler_init(&decoder->hdl, 4);\n	t
34330	1635	get_cur_inode_state	fs/btrfs/send.c	right_gen	1	11	\N	\N	\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n	t
44981	1114	xfs_reflink_remap_extent	fs/xfs/xfs_reflink.c	rlen	1	11	\N	\N	\tstruct xfs_mount\t*mp = ip->i_mount;\n\tbool\t\t\treal_extent = xfs_bmap_is_real_extent(irec);\n\tstruct xfs_trans\t*tp;\n\txfs_fsblock_t\t\tfirstfsb;\n\tunsigned int\t\tresblks;\n\tstruct xfs_defer_ops\tdfops;\n\tstruct xfs_bmbt_irec\tuirec;\n\txfs_filblks_t\t\trlen;\n\txfs_filblks_t\t\tunmap_len;\n\txfs_off_t\t\tnewlen;\n\tint\t\t\terror;\n\n\tunmap_len = irec->br_startoff + irec->br_blockcount - destoff;\n\ttrace_xfs_reflink_punch_range(ip, destoff, unmap_len);\n\n\t/* No reflinking if we're low on space */\n\tif (real_extent) {\n\t\terror = xfs_reflink_ag_has_free_space(mp,\n\t\t\t\tXFS_FSB_TO_AGNO(mp, irec->br_startblock));\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/* Start a rolling transaction to switch the mappings */\n\tresblks = XFS_EXTENTADD_SPACE_RES(ip->i_mount, XFS_DATA_FORK);\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, 0, &tp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/* If we're not just clearing space, then do we have enough quota? */\n\tif (real_extent) {\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip,\n\t\t\t\tirec->br_blockcount, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t}\n\n\ttrace_xfs_reflink_remap(ip, irec->br_startoff,\n\t\t\t\tirec->br_blockcount, irec->br_startblock);\n\n\t/* Unmap the old blocks in the data fork. */\n\trlen = unmap_len;\n\twhile (rlen) {\n	t
31996	458	or51211_init	drivers/media/dvb-frontends/or51211.c	rec_buf	6	12	\N	\N	\tstruct or51211_state* state = fe->demodulator_priv;\n\tconst struct or51211_config* config = state->config;\n\tconst struct firmware* fw;\n\tunsigned char get_ver_buf[] = {0x04,0x00,0x30,0x00,0x00};\n\tunsigned char rec_buf[14];\n\tint ret,i;\n\n\tif (!state->initialized) {\n\t\t/* Request the firmware, this will block until it uploads */\n\t\tpr_info("Waiting for firmware upload (%s)...\\n",\n\t\t\tOR51211_DEFAULT_FIRMWARE);\n\t\tret = config->request_firmware(fe, &fw,\n\t\t\t\t\t       OR51211_DEFAULT_FIRMWARE);\n\t\tpr_info("Got Hotplug firmware\\n");\n\t\tif (ret) {\n\t\t\tpr_warn("No firmware uploaded (timeout or file not found?)\\n");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = or51211_load_firmware(fe, fw);\n\t\trelease_firmware(fw);\n\t\tif (ret) {\n\t\t\tpr_warn("Writing firmware to device failed!\\n");\n\t\t\treturn ret;\n\t\t}\n\t\tpr_info("Firmware upload complete.\\n");\n\n\t\t/* Set operation mode in Receiver 1 register;\n\t\t * type 1:\n\t\t * data 0x50h  Automatic sets receiver channel conditions\n\t\t *             Automatic NTSC rejection filter\n\t\t *             Enable  MPEG serial data output\n\t\t *             MPEG2tr\n\t\t *             High tuner phase noise\n\t\t *             normal +/-150kHz Carrier acquisition range\n\t\t */\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   cmd_buf,3)) {\n\t\t\tpr_warn("Load DVR Error 5\\n");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Read back ucode version to besure we loaded correctly */\n\t\t/* and are really up and running */\n\t\trec_buf[0] = 0x04;\n\t\trec_buf[1] = 0x00;\n\t\trec_buf[2] = 0x03;\n\t\trec_buf[3] = 0x00;\n\t\tmsleep(30);\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   rec_buf,3)) {\n\t\t\tpr_warn("Load DVR Error A\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(3);\n\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t  &rec_buf[10],2)) {\n\t\t\tpr_warn("Load DVR Error B\\n");\n\t\t\treturn -1;\n\t\t}\n\n\t\trec_buf[0] = 0x04;\n\t\trec_buf[1] = 0x00;\n\t\trec_buf[2] = 0x01;\n\t\trec_buf[3] = 0x00;\n\t\tmsleep(20);\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   rec_buf,3)) {\n\t\t\tpr_warn("Load DVR Error C\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(3);\n\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t  &rec_buf[12],2)) {\n\t\t\tpr_warn("Load DVR Error D\\n");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\trec_buf[i]=0xed;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmsleep(30);\n\t\t\tget_ver_buf[4] = i+1;\n\t\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t\t   get_ver_buf,5)) {\n\t\t\t\tpr_warn("Load DVR Error 6 - %d\\n", i);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmsleep(3);\n\n\t\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t\t  &rec_buf[i*2],2)) {\n\t\t\t\tpr_warn("Load DVR Error 7 - %d\\n", i);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* If we didn't receive the right index, try again */\n\t\t\tif ((int)rec_buf[i*2+1]!=i+1){\n	t
33994	560	set_card_type	drivers/net/ethernet/xircom/xirc2ps_cs.c	prodid	6	12	\N	\N	    struct net_device *dev = link->priv;\n    struct local_info *local = netdev_priv(dev);\n    u8 *buf;\n    unsigned int cisrev, mediaid, prodid;\n    size_t len;\n\n    len = pcmcia_get_tuple(link, CISTPL_MANFID, &buf);\n    if (len < 5) {\n\t    dev_err(&link->dev, "invalid CIS -- sorry\\n");\n\t    return 0;\n    }\n\n    cisrev = buf[2];\n    mediaid = buf[3];\n    prodid = buf[4];\n\n    dev_dbg(&link->dev, "cisrev=%02x mediaid=%02x prodid=%02x\\n",\n\t  cisrev, mediaid, prodid);\n\n    local->mohawk = 0;\n    local->dingo = 0;\n    local->modem = 0;\n    local->card_type = XIR_UNKNOWN;\n    if (!(prodid & 0x40)) {\n	t
25884	486	br_ip6_multicast_alloc_query	net/bridge/br_multicast.c	skb	1	11	\N	\N	\tstruct mld2_query *mld2q;\n\tunsigned long interval;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tsize_t mld_hdr_size;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eth;\n\tu8 *hopopt;\n\n\tmld_hdr_size = sizeof(*mldq);\n\tif (br->multicast_mld_version == 2)\n\t\tmld_hdr_size = sizeof(*mld2q);\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\n\t\t\t\t\t\t 8 + mld_hdr_size);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t/* Ethernet header */\n\tskb_reset_mac_header(skb);\n	t
34725	8637	reada_walk_down	fs/btrfs/extent-tree.c	flags	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 bytenr;\n\tu64 generation;\n\tu64 refs;\n\tu64 flags;\n\tu32 nritems;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint ret;\n\tint slot;\n\tint nread = 0;\n\n\tif (path->slots[wc->level] < wc->reada_slot) {\n\t\twc->reada_count = wc->reada_count * 2 / 3;\n\t\twc->reada_count = max(wc->reada_count, 2);\n\t} else {\n\t\twc->reada_count = wc->reada_count * 3 / 2;\n\t\twc->reada_count = min_t(int, wc->reada_count,\n\t\t\t\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info));\n\t}\n\n\teb = path->nodes[wc->level];\n\tnritems = btrfs_header_nritems(eb);\n\n\tfor (slot = path->slots[wc->level]; slot < nritems; slot++) {\n\t\tif (nread >= wc->reada_count)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t\tbytenr = btrfs_node_blockptr(eb, slot);\n\t\tgeneration = btrfs_node_ptr_generation(eb, slot);\n\n\t\tif (slot == path->slots[wc->level])\n\t\t\tgoto reada;\n\n\t\tif (wc->stage == UPDATE_BACKREF &&\n\t\t    generation <= root->root_key.offset)\n\t\t\tcontinue;\n\n\t\t/* We don't lock the tree block, it's OK to be racy here */\n\t\tret = btrfs_lookup_extent_info(trans, fs_info, bytenr,\n\t\t\t\t\t       wc->level - 1, 1, &refs,\n\t\t\t\t\t       &flags);\n\t\t/* We don't care about errors in readahead. */\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tBUG_ON(refs == 0);\n\n\t\tif (wc->stage == DROP_REFERENCE) {\n\t\t\tif (refs == 1)\n\t\t\t\tgoto reada;\n\n\t\t\tif (wc->level == 1 &&\n\t\t\t    (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF))\n	t
39540	107	vt586b_probe	drivers/i2c/busses/i2c-via.c	rev	1	11	\N	\N	\tu16 base;\n\tu8 rev;\n\tint res;\n\n\tif (pm_io_base) {\n\t\tdev_err(&dev->dev, "i2c-via: Will only support one host\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_byte(dev, PM_CFG_REVID, &rev);\n\n\tswitch (rev) {\n	t
41104	283	adv748x_afe_s_stream	drivers/media/i2c/adv748x/adv748x-afe.c	ret	1	11	\N	\N	\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint ret, signal = V4L2_IN_ST_NO_SIGNAL;\n\n\tmutex_lock(&state->mutex);\n\n\tif (enable) {\n\t\tret = adv748x_afe_s_input(afe, afe->input);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tret = adv748x_txb_power(state, enable);\n\tif (ret)\n	t
44673	365	session_unregister_bufs	drivers/media/platform/qcom/venus/helpers.c	&bd	1	11	\N	\N	\tstruct venus_buffer *buf, *n;\n\tstruct hfi_buffer_desc bd;\n\tint ret = 0;\n\n\tif (!is_reg_unreg_needed(inst))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(buf, n, &inst->registeredbufs, reg_list) {\n\t\tfill_buffer_desc(buf, &bd, true);\n\t\tret = hfi_session_unset_buffers(inst, &bd);\n	t
29953	452	vsp1_bru_create	drivers/media/platform/vsp1/vsp1_bru.c	bru->ctrls.error	1	13	\N	\N	\tstruct vsp1_bru *bru;\n\tunsigned int num_pads;\n\tconst char *name;\n\tint ret;\n\n\tbru = devm_kzalloc(vsp1->dev, sizeof(*bru), GFP_KERNEL);\n\tif (bru == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbru->base = type == VSP1_ENTITY_BRU ? VI6_BRU_BASE : VI6_BRS_BASE;\n\tbru->entity.ops = &bru_entity_ops;\n\tbru->entity.type = type;\n\n\tif (type == VSP1_ENTITY_BRU) {\n\t\tnum_pads = vsp1->info->num_bru_inputs + 1;\n\t\tname = "bru";\n\t} else {\n\t\tnum_pads = 3;\n\t\tname = "brs";\n\t}\n\n\tret = vsp1_entity_init(vsp1, &bru->entity, name, num_pads, &bru_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_COMPOSER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t/* Initialize the control handler. */\n\tv4l2_ctrl_handler_init(&bru->ctrls, 1);\n\tv4l2_ctrl_new_std(&bru->ctrls, &bru_ctrl_ops, V4L2_CID_BG_COLOR,\n\t\t\t  0, 0xffffff, 1, 0);\n\n\tbru->bgcolor = 0;\n\n\tbru->entity.subdev.ctrl_handler = &bru->ctrls;\n\n\tif (bru->ctrls.error) {\n	f
30058	1311	vmw_translate_mob_ptr	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c	vmw_bo	1	13	\N	\N	\tstruct vmw_dma_buffer *vmw_bo = NULL;\n\tuint32_t handle = *id;\n\tstruct vmw_relocation *reloc;\n\tint ret;\n\n\tret = vmw_user_dmabuf_lookup(sw_context->fp->tfile, handle, &vmw_bo,\n\t\t\t\t     NULL);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR("Could not find or use MOB buffer.\\n");\n\t\tret = -EINVAL;\n\t\tgoto out_no_reloc;\n\t}\n\n\tif (unlikely(sw_context->cur_reloc >= VMWGFX_MAX_RELOCATIONS)) {\n\t\tDRM_ERROR("Max number relocations per submission"\n\t\t\t  " exceeded\\n");\n\t\tret = -EINVAL;\n\t\tgoto out_no_reloc;\n\t}\n\n\treloc = &sw_context->relocs[sw_context->cur_reloc++];\n\treloc->mob_loc = id;\n\treloc->location = NULL;\n\n\tret = vmw_bo_to_validate_list(sw_context, vmw_bo, true, &reloc->index);\n	f
59308	66	ide_cdrom_drive_status	drivers/ide/ide-cd_ioctl.c	sense.ascq	1	11	\N	\N	\tide_drive_t *drive = cdi->handle;\n\tstruct media_event_desc med;\n\tstruct request_sense sense;\n\tint stat;\n\n\tif (slot_nr != CDSL_CURRENT)\n\t\treturn -EINVAL;\n\n\tstat = cdrom_check_status(drive, &sense);\n\tif (!stat || sense.sense_key == UNIT_ATTENTION)\n\t\treturn CDS_DISC_OK;\n\n\tif (!cdrom_get_media_event(cdi, &med)) {\n\t\tif (med.media_present)\n\t\t\treturn CDS_DISC_OK;\n\t\telse if (med.door_open)\n\t\t\treturn CDS_TRAY_OPEN;\n\t\telse\n\t\t\treturn CDS_NO_DISC;\n\t}\n\n\tif (sense.sense_key == NOT_READY && sense.asc == 0x04\n\t\t\t&& sense.ascq == 0x04)\n	t
35120	1111	prism54_set_encode	drivers/net/wireless/intersil/prism54/isl_ioctl.c	current_index	12	12	\N	\N	\tislpci_private *priv = netdev_priv(ndev);\n\tint rvalue = 0, force = 0;\n\tint authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0;\n\tunion oid_res_t r;\n\n\t/* with the new API, it's impossible to get a NULL pointer.\n\t * New version of iwconfig set the IW_ENCODE_NOKEY flag\n\t * when no key is given, but older versions don't. */\n\n\tif (dwrq->length > 0) {\n\t\t/* we have a key to set */\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tint current_index;\n\t\tstruct obj_key key = { DOT11_PRIV_WEP, 0, "" };\n\n\t\t/* get the current key index */\n\t\trvalue = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);\n\t\tcurrent_index = r.u;\n\t\t/* Verify that the key is not marked as invalid */\n\t\tif (!(dwrq->flags & IW_ENCODE_NOKEY)) {\n\t\t\tif (dwrq->length > KEY_SIZE_TKIP) {\n\t\t\t\t/* User-provided key data too big */\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (dwrq->length > KEY_SIZE_WEP104) {\n\t\t\t\t/* WPA-PSK TKIP */\n\t\t\t\tkey.type = DOT11_PRIV_TKIP;\n\t\t\t\tkey.length = KEY_SIZE_TKIP;\n\t\t\t} else if (dwrq->length > KEY_SIZE_WEP40) {\n\t\t\t\t/* WEP 104/128 */\n\t\t\t\tkey.length = KEY_SIZE_WEP104;\n\t\t\t} else {\n\t\t\t\t/* WEP 40/64 */\n\t\t\t\tkey.length = KEY_SIZE_WEP40;\n\t\t\t}\n\t\t\tmemset(key.key, 0, sizeof (key.key));\n\t\t\tmemcpy(key.key, extra, dwrq->length);\n\n\t\t\tif ((index < 0) || (index > 3))\n\t\t\t\t/* no index provided use the current one */\n\t\t\t\tindex = current_index;\n\n\t\t\t/* now send the key to the card  */\n\t\t\trvalue |=\n\t\t\t    mgt_set_request(priv, DOT11_OID_DEFKEYX, index,\n\t\t\t\t\t    &key);\n\t\t}\n\t\t/*\n\t\t * If a valid key is set, encryption should be enabled\n\t\t * (user may turn it off later).\n\t\t * This is also how "iwconfig ethX key on" works\n\t\t */\n\t\tif ((index == current_index) && (key.length > 0))\n	t
6951	765	generate_sched_domains	kernel/cgroup/cpuset.c	generate_sched_domains_$a106$obj$40	0	11	\N	\N	\tstruct cpuset *cp;\t/* scans q */\n\tstruct cpuset **csa;\t/* array of all cpuset ptrs */\n\tint csn;\t\t/* how many cpuset ptrs in csa so far */\n\tint i, j, k;\t\t/* indices for partition finding loops */\n\tcpumask_var_t *doms;\t/* resulting partition; i.e. sched domains */\n\tcpumask_var_t non_isolated_cpus;  /* load balanced CPUs */\n\tstruct sched_domain_attr *dattr;  /* attributes for custom domains */\n\tint ndoms = 0;\t\t/* number of sched domains in result */\n\tint nslot;\t\t/* next empty doms[] struct cpumask slot */\n\tstruct cgroup_subsys_state *pos_css;\n\n\tdoms = NULL;\n\tdattr = NULL;\n\tcsa = NULL;\n\n\tif (!alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL))\n\t\tgoto done;\n\tcpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);\n\n\t/* Special case for the 99% of systems with one, full, sched domain */\n\tif (is_sched_load_balance(&top_cpuset)) {\n\t\tndoms = 1;\n\t\tdoms = alloc_sched_domains(ndoms);\n\t\tif (!doms)\n\t\t\tgoto done;\n\n\t\tdattr = kmalloc(sizeof(struct sched_domain_attr), GFP_KERNEL);\n\t\tif (dattr) {\n\t\t\t*dattr = SD_ATTR_INIT;\n\t\t\tupdate_domain_attr_tree(dattr, &top_cpuset);\n\t\t}\n\t\tcpumask_and(doms[0], top_cpuset.effective_cpus,\n\t\t\t\t     non_isolated_cpus);\n\n\t\tgoto done;\n\t}\n\n\tcsa = kmalloc(nr_cpusets() * sizeof(cp), GFP_KERNEL);\n\tif (!csa)\n\t\tgoto done;\n\tcsn = 0;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, &top_cpuset) {\n\t\tif (cp == &top_cpuset)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Continue traversing beyond @cp iff @cp has some CPUs and\n\t\t * isn't load balancing.  The former is obvious.  The\n\t\t * latter: All child cpusets contain a subset of the\n\t\t * parent's cpus, so just skip them, and then we call\n\t\t * update_domain_attr_tree() to calc relax_domain_level of\n\t\t * the corresponding sched domain.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    !(is_sched_load_balance(cp) &&\n\t\t      cpumask_intersects(cp->cpus_allowed, non_isolated_cpus)))\n\t\t\tcontinue;\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tcsa[csn++] = cp;\n\n\t\t/* skip @cp's subtree */\n\t\tpos_css = css_rightmost_descendant(pos_css);\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < csn; i++)\n\t\tcsa[i]->pn = i;\n\tndoms = csn;\n\nrestart:\n\t/* Find the best partition (set of sched domains) */\n\tfor (i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->pn;\n\n\t\tfor (j = 0; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->pn;\n\n\t\t\tif (apn != bpn && cpusets_overlap(a, b)) {\n\t\t\t\tfor (k = 0; k < csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->pn == bpn)\n\t\t\t\t\t\tc->pn = apn;\n\t\t\t\t}\n\t\t\t\tndoms--;\t/* one less element */\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now we know how many domains to create.\n\t * Convert <csn, csa> to <ndoms, doms> and populate cpu masks.\n\t */\n\tdoms = alloc_sched_domains(ndoms);\n\tif (!doms)\n\t\tgoto done;\n\n\t/*\n\t * The rest of the code, including the scheduler, can deal with\n\t * dattr==NULL case. No need to abort if alloc fails.\n\t */\n\tdattr = kmalloc(ndoms * sizeof(struct sched_domain_attr), GFP_KERNEL);\n\n\tfor (nslot = 0, i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->pn;\n	t
37079	625	ak4642_of_parse_mcko	sound/soc/codecs/ak4642.c	rate	6	12	\N	\N	\tstruct device_node *np = dev->of_node;\n\tstruct clk *clk;\n\tconst char *clk_name = np->name;\n\tconst char *parent_clk_name = NULL;\n\tu32 rate;\n\n\tif (of_property_read_u32(np, "clock-frequency", &rate))\n\t\treturn NULL;\n\n\tif (of_property_read_bool(np, "clocks"))\n\t\tparent_clk_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, "clock-output-names", &clk_name);\n\n\tclk = clk_register_fixed_rate(dev, clk_name, parent_clk_name, 0, rate);\n	t
35176	343	cmp_connection_update	sound/firewire/cmp.c	err	1	11	\N	\N	\tint err;\n\n\tmutex_lock(&c->mutex);\n\n\tif (!c->connected) {\n\t\tmutex_unlock(&c->mutex);\n\t\treturn 0;\n\t}\n\n\terr = fw_iso_resources_update(&c->resources);\n\tif (err < 0)\n	t
42233	3168	amdgpu_debugfs_regs_write	drivers/gpu/drm/amd/amdgpu/amdgpu_device.c	se_bank	1	11	\N	\N	\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\tbool pm_pg_lock, use_bank;\n\tunsigned instance_bank, sh_bank, se_bank;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\t/* are we reading registers for which a PG lock is necessary? */\n\tpm_pg_lock = (*pos >> 23) & 1;\n\n\tif (*pos & (1ULL << 62)) {\n\t\tse_bank = (*pos >> 24) & 0x3FF;\n\t\tsh_bank = (*pos >> 34) & 0x3FF;\n\t\tinstance_bank = (*pos >> 44) & 0x3FF;\n\n\t\tif (se_bank == 0x3FF)\n\t\t\tse_bank = 0xFFFFFFFF;\n\t\tif (sh_bank == 0x3FF)\n\t\t\tsh_bank = 0xFFFFFFFF;\n\t\tif (instance_bank == 0x3FF)\n\t\t\tinstance_bank = 0xFFFFFFFF;\n\t\tuse_bank = 1;\n\t} else {\n\t\tuse_bank = 0;\n\t}\n\n\t*pos &= (1UL << 22) - 1;\n\n\tif (use_bank) {\n\t\tif ((sh_bank != 0xFFFFFFFF && sh_bank >= adev->gfx.config.max_sh_per_se) ||\n\t\t    (se_bank != 0xFFFFFFFF && se_bank >= adev->gfx.config.max_shader_engines))\n	t
9795	128	show_hyst_common	drivers/hwmon/emc1403.c	limit	2	-11	\N	\N	\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int limit;\n\tunsigned int hyst;\n\tint retval;\n\n\tretval = regmap_read(regmap, sda->index, &limit);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = regmap_read(regmap, 0x21, &hyst);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn sprintf(buf, "%d000\\n", is_min ? limit + hyst : limit - hyst);\n	t
56764	254	sst_cdev_close	sound/soc/intel/atom/sst/sst_drv_interface.c	retval	1	11	\N	\N	\tint retval;\n\tstruct stream_info *stream;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream) {\n\t\tdev_err(dev, "stream info is NULL for str %d!!!\\n", str_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (stream->status == STREAM_RESET) {\n\t\tdev_dbg(dev, "stream in reset state...\\n");\n\t\tstream->status = STREAM_UN_INIT;\n\n\t\tretval = 0;\n\t\tgoto put;\n\t}\n\n\tretval = sst_free_stream(ctx, str_id);\nput:\n\tstream->compr_cb_param = NULL;\n\tstream->compr_cb = NULL;\n\n\tif (retval)\n	t
37504	356	hpfs_add_to_dnode	fs/hpfs/dnode.c	&qbh2	6	12	\N	\N	\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err("out of memory, can't add to dnode\\n");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, "%s(): namelen == %d", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "hpfs_add_to_dnode")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err("out of memory for dnode splitting\\n");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, "unable to alloc dnode - dnode tree will be corrupted");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, "unable to alloc dnode - dnode tree will be corrupted");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n	t
29363	402	nfp_nsp_command_buf	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.c	nfp_nsp_command_buf_$tmp43$obj$mul$1048576	0	11	\N	\N	\tstruct nfp_cpp *cpp = nsp->cpp;\n\tunsigned int max_size;\n\tu64 reg, cpp_buf;\n\tint ret, err;\n\tu32 cpp_id;\n\n\tif (nsp->ver.minor < 13) {\n\t\tnfp_err(cpp, "NSP: Code 0x%04x with buffer not supported (ABI %hu.%hu)\\n",\n\t\t\tcode, nsp->ver.major, nsp->ver.minor);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\n\t\t\t    nfp_resource_address(nsp->res) +\n\t\t\t    NSP_DFLT_BUFFER_CONFIG,\n\t\t\t    &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\tmax_size = max(in_size, out_size);\n\tif (FIELD_GET(NSP_DFLT_BUFFER_SIZE_MB, reg) * SZ_1M < max_size) {\n\t\tnfp_err(cpp, "NSP: default buffer too small for command 0x%04x (%llu < %u)\\n",\n	t
52893	1337	snd_card_asihpi_pcm_new	sound/pci/asihpi/asihpi.c	snd_card_asihpi_pcm_new_$pcm$obj	0	11	\N	\N	\tstruct snd_pcm *pcm;\n\tint err;\n\tu16 num_instreams, num_outstreams, x16;\n\tu32 x32;\n\n\terr = hpi_adapter_get_info(asihpi->hpi->adapter->index,\n\t\t\t&num_outstreams, &num_instreams,\n\t\t\t&x16, &x32, &x16);\n\n\terr = snd_pcm_new(asihpi->card, "Asihpi PCM", device,\n\t\t\tnum_outstreams,\tnum_instreams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* pointer to ops struct is stored, dont change ops afterwards! */\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_card_asihpi_playback_mmap_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_card_asihpi_capture_mmap_ops);\n\n\tpcm->private_data = asihpi;\n	t
31516	2488	e1000_check_for_link	drivers/net/ethernet/intel/e1000/e1000_hw.c	hw	1	11	\N	\N	\tu32 rxcw = 0;\n\tu32 ctrl;\n\tu32 status;\n\tu32 rctl;\n\tu32 icr;\n\tu32 signal = 0;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tctrl = er32(CTRL);\n\tstatus = er32(STATUS);\n\n\t/* On adapters with a MAC newer than 82544, SW Definable pin 1 will be\n\t * set when the optics detect a signal. On older adapters, it will be\n\t * cleared when there is a signal.  This applies to fiber media only.\n\t */\n\tif ((hw->media_type == e1000_media_type_fiber) ||\n\t    (hw->media_type == e1000_media_type_internal_serdes)) {\n\t\trxcw = er32(RXCW);\n\n\t\tif (hw->media_type == e1000_media_type_fiber) {\n\t\t\tsignal =\n\t\t\t    (hw->mac_type >\n\t\t\t     e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;\n\t\t\tif (status & E1000_STATUS_LU)\n\t\t\t\thw->get_link_status = false;\n\t\t}\n\t}\n\n\t/* If we have a copper PHY then we only want to go out to the PHY\n\t * registers to see if Auto-Neg has completed and/or if our link\n\t * status has changed.  The get_link_status flag will be set if we\n\t * receive a Link Status Change interrupt or we have Rx Sequence\n\t * Errors.\n\t */\n\tif ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {\n\t\t/* First we want to see if the MII Status Register reports\n\t\t * link.  If so, then we want to get the current speed/duplex\n\t\t * of the PHY.\n\t\t * Read the register twice since the link bit is sticky.\n\t\t */\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tif (phy_data & MII_SR_LINK_STATUS) {\n\t\t\thw->get_link_status = false;\n\t\t\t/* Check if there was DownShift, must be checked\n\t\t\t * immediately after link-up\n\t\t\t */\n\t\t\te1000_check_downshift(hw);\n\n\t\t\t/* If we are on 82544 or 82543 silicon and speed/duplex\n\t\t\t * are forced to 10H or 10F, then we will implement the\n\t\t\t * polarity reversal workaround.  We disable interrupts\n\t\t\t * first, and upon returning, place the devices\n\t\t\t * interrupt state to its previous value except for the\n\t\t\t * link status change interrupt which will\n\t\t\t * happen due to the execution of this workaround.\n\t\t\t */\n\n\t\t\tif ((hw->mac_type == e1000_82544 ||\n\t\t\t     hw->mac_type == e1000_82543) &&\n\t\t\t    (!hw->autoneg) &&\n\t\t\t    (hw->forced_speed_duplex == e1000_10_full ||\n\t\t\t     hw->forced_speed_duplex == e1000_10_half)) {\n\t\t\t\tew32(IMC, 0xffffffff);\n\t\t\t\tret_val =\n\t\t\t\t    e1000_polarity_reversal_workaround(hw);\n\t\t\t\ticr = er32(ICR);\n\t\t\t\tew32(ICS, (icr & ~E1000_ICS_LSC));\n\t\t\t\tew32(IMS, IMS_ENABLE_MASK);\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* No link detected */\n\t\t\te1000_config_dsp_after_link_change(hw, false);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* If we are forcing speed/duplex, then we simply return since\n\t\t * we have already determined whether we have link or not.\n\t\t */\n\t\tif (!hw->autoneg)\n\t\t\treturn -E1000_ERR_CONFIG;\n\n\t\t/* optimize the dsp settings for the igp phy */\n\t\te1000_config_dsp_after_link_change(hw, true);\n	t
56357	4534	iscsi_transport_init	drivers/scsi/scsi_transport_iscsi.c	iscsi_transport_init_@nls $obj	0	11	\N	\N	\tint err;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= 1,\n\t\t.input\t= iscsi_if_rx,\n\t};\n\tprintk(KERN_INFO "Loading iSCSI transport class v%s.\\n",\n\t\tISCSI_TRANSPORT_VERSION);\n\n\tatomic_set(&iscsi_session_nr, 0);\n\n\terr = class_register(&iscsi_transport_class);\n\tif (err)\n\t\treturn err;\n\n\terr = class_register(&iscsi_endpoint_class);\n\tif (err)\n\t\tgoto unregister_transport_class;\n\n\terr = class_register(&iscsi_iface_class);\n\tif (err)\n\t\tgoto unregister_endpoint_class;\n\n\terr = transport_class_register(&iscsi_host_class);\n\tif (err)\n\t\tgoto unregister_iface_class;\n\n\terr = transport_class_register(&iscsi_connection_class);\n\tif (err)\n\t\tgoto unregister_host_class;\n\n\terr = transport_class_register(&iscsi_session_class);\n\tif (err)\n\t\tgoto unregister_conn_class;\n\n\terr = bus_register(&iscsi_flashnode_bus);\n\tif (err)\n\t\tgoto unregister_session_class;\n\n\tnls = netlink_kernel_create(&init_net, NETLINK_ISCSI, &cfg);\n\tif (!nls) {\n	t
60310	1945	macsec_del_rxsc	drivers/net/macsec.c	tb_rxsc	1	11	\N	\N	\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tsci_t sci;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (!tb_rxsc[MACSEC_RXSC_ATTR_SCI])\n	t
23651	1623	load_and_init_attrdef	fs/ntfs/super.c	ino->i_mapping	1	11	\N	\N	\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\n\tntfs_debug("Entering.");\n\t/* Read attrdef table and setup vol->attrdef and vol->attrdef_size. */\n\tino = ntfs_iget(sb, FILE_AttrDef);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto failed;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(ino));\n\t/* The size of FILE_AttrDef must be above 0 and fit inside 31 bits. */\n\ti_size = i_size_read(ino);\n\tif (i_size <= 0 || i_size > 0x7fffffff)\n\t\tgoto iput_failed;\n\tvol->attrdef = (ATTR_DEF*)ntfs_malloc_nofs(i_size);\n\tif (!vol->attrdef)\n\t\tgoto iput_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_SHIFT;\n\tsize = PAGE_SIZE;\n\twhile (index < max_index) {\n\t\t/* Read the attrdef table and copy it into the linear buffer. */\nread_partial_attrdef_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n	t
25414	215	efivarfs_fill_super	fs/efivarfs/super.c	inode	1	11	\N	\N	\tstruct inode *inode = NULL;\n\tstruct dentry *root;\n\tint err;\n\n\tefivarfs_sb = sb;\n\n\tsb->s_maxbytes          = MAX_LFS_FILESIZE;\n\tsb->s_blocksize         = PAGE_SIZE;\n\tsb->s_blocksize_bits    = PAGE_SHIFT;\n\tsb->s_magic             = EFIVARFS_MAGIC;\n\tsb->s_op                = &efivarfs_ops;\n\tsb->s_d_op\t\t= &efivarfs_d_ops;\n\tsb->s_time_gran         = 1;\n\n\tinode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0, true);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode->i_op = &efivarfs_dir_inode_operations;\n\n\troot = d_make_root(inode);\n	t
32865	500	atombios_dvo_setup	drivers/gpu/drm/radeon/atombios_encoders.c	index	1	11	\N	\N	\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tunion dvo_encoder_control args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);\n\tuint8_t frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n	t
34169	213	pch_tx_timestamp	drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c	val	1	11	\N	\N	\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct pci_dev *pdev;\n\tstruct skb_shared_info *shtx;\n\tu64 ns;\n\tu32 cnt, val;\n\n\tshtx = skb_shinfo(skb);\n\tif (likely(!(shtx->tx_flags & SKBTX_HW_TSTAMP && adapter->hwts_tx_en)))\n\t\treturn;\n\n\tshtx->tx_flags |= SKBTX_IN_PROGRESS;\n\n\t/* Get ieee1588's dev information */\n\tpdev = adapter->ptp_pdev;\n\n\t/*\n\t * This really stinks, but we have to poll for the Tx time stamp.\n\t */\n\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\tval = pch_ch_event_read(pdev);\n\t\tif (val & TX_SNAPSHOT_LOCKED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (!(val & TX_SNAPSHOT_LOCKED)) {\n	t
37214	546	vvp_pgcache_show	drivers/staging/lustre/lustre/llite/vvp_dev.c	&id	1	11	\N	\N	\tloff_t\t\t   pos;\n\tstruct ll_sb_info       *sbi;\n\tstruct cl_object\t*clob;\n\tstruct lu_env\t   *env;\n\tstruct vvp_pgcache_id    id;\n\tu16 refcheck;\n\tint\t\t      result;\n\n\tenv = cl_env_get(&refcheck);\n\tif (!IS_ERR(env)) {\n\t\tpos = *(loff_t *)v;\n\t\tvvp_pgcache_id_unpack(pos, &id);\n\t\tsbi = f->private;\n\t\tclob = vvp_pgcache_obj(env, &sbi->ll_cl->cd_lu_dev, &id);\n	t
38281	365	cisco_ioctl	drivers/net/wan/hdlc_cisco.c	new_settings.timeout	1	11	\N	\N	\tcisco_proto __user *cisco_s = ifr->ifr_settings.ifs_ifsu.cisco;\n\tconst size_t size = sizeof(cisco_proto);\n\tcisco_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint result;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifr->ifr_settings.type = IF_PROTO_CISCO;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(cisco_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_CISCO:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, cisco_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.interval < 1 ||\n\t\t    new_settings.timeout < 2)\n	t
60778	217	btmrvl_debugfs_init	drivers/bluetooth/btmrvl_debugfs.c	dbg->config_dir	1	11	\N	\N	\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\tstruct btmrvl_debugfs_data *dbg;\n\n\tif (!hdev->debugfs)\n\t\treturn;\n\n\tdbg = kzalloc(sizeof(*dbg), GFP_KERNEL);\n\tpriv->debugfs_data = dbg;\n\n\tif (!dbg) {\n\t\tBT_ERR("Can not allocate memory for btmrvl_debugfs_data.");\n\t\treturn;\n\t}\n\n\tdbg->config_dir = debugfs_create_dir("config", hdev->debugfs);\n\n\tdebugfs_create_u8("psmode", 0644, dbg->config_dir,\n	t
39679	3303	finish_port_resume	drivers/usb/core/hub.c	devstatus	6	12	\N	\N	\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, "%s\\n",\n\t\tudev->reset_resume ? "finish reset-resume" : "finish resume");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, "retry with reset-resume\\n");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, "gone after usb resume? status %d\\n",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n	t
30013	731	drunk_hole	drivers/gpu/drm/i915/i915_gem_gtt.c	pt	1	11	\N	\N	\tstruct i915_page_table *pt;\n\tu32 pde;\n\n	t
103402	5352	intel_encoders_post_pll_disable	drivers/gpu/drm/i915/intel_display.c	conn	1	11	\N	\N	\tstruct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(old_state, conn, old_conn_state, i) {\n	t
31012	-1	netlbl_domhsh_remove_af6	net/netlabel/netlabel_domainhash.c	netlbl_domhsh_remove_af6_$iter4	0	11	\N	\N	\N	t
44667	310	nfsd4_preprocess_layout_stateid	fs/nfsd/nfs4layouts.c	nfsd4_preprocess_layout_stateid_$ls$obj$17$obj	0	11	\N	\N	\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n	t
33855	229	ath9k_htc_send_beacon	drivers/net/wireless/ath/ath9k/htc_drv_beacon.c	ath9k_htc_send_beacon_$mgmt$obj$6	0	11	\N	\N	\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_vif *vif;\n\tstruct ath9k_htc_vif *avp;\n\tstruct tx_beacon_header beacon_hdr;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *beacon;\n\tu8 *tx_fhdr;\n\tint ret;\n\n\tmemset(&beacon_hdr, 0, sizeof(struct tx_beacon_header));\n\n\tspin_lock_bh(&priv->beacon_lock);\n\n\tvif = priv->beacon.bslot[slot];\n\tavp = (struct ath9k_htc_vif *)vif->drv_priv;\n\n\tif (unlikely(test_bit(ATH_OP_SCANNING, &common->op_flags))) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t/* Get a new beacon */\n\tbeacon = ieee80211_beacon_get(priv->hw, vif);\n\tif (!beacon) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the TSF adjust value here, the HW will\n\t * add this value for every beacon.\n\t */\n\tmgmt = (struct ieee80211_mgmt *)beacon->data;\n\tmgmt->u.beacon.timestamp = avp->tsfadjust;\n	t
2914	479	rio_mport_obw_free	drivers/rapidio/devices/rio_mport_cdev.c	handle	1	11	\N	\N	\tstruct mport_cdev_priv *priv = filp->private_data;\n\tstruct mport_dev *md = priv->md;\n\tu64 handle;\n\tstruct rio_mport_mapping *map, *_map;\n\n\tif (!md->mport->ops->unmap_outb)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (copy_from_user(&handle, arg, sizeof(handle)))\n\t\treturn -EFAULT;\n\n\trmcd_debug(OBW, "h=0x%llx", handle);\n	t
22536	1222	xfs_rtmount_inodes	fs/xfs/xfs_rtalloc.c	mp->m_rbmip	1	11	\N	\N	\tint\t\terror;\t\t/* error return value */\n\txfs_sb_t\t*sbp;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rbmino == NULLFSINO)\n\t\treturn 0;\n\terror = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\tASSERT(mp->m_rbmip != NULL);\n	t
25550	802	mlx4_alloc_hwq_res	drivers/net/ethernet/mellanox/mlx4/alloc.c	&wqres->mtt	1	11	\N	\N	\tint err;\n\n\terr = mlx4_db_alloc(dev, &wqres->db, 1);\n\tif (err)\n\t\treturn err;\n\n\t*wqres->db.db = 0;\n\n\terr = mlx4_buf_direct_alloc(dev, size, &wqres->buf);\n\tif (err)\n\t\tgoto err_db;\n\n\terr = mlx4_mtt_init(dev, wqres->buf.npages, wqres->buf.page_shift,\n\t\t\t    &wqres->mtt);\n\tif (err)\n\t\tgoto err_buf;\n\n\terr = mlx4_buf_write_mtt(dev, &wqres->mtt, &wqres->buf);\n\tif (err)\n\t\tgoto err_mtt;\n\n\treturn 0;\n\nerr_mtt:\n\tmlx4_mtt_cleanup(dev, &wqres->mtt);\n	t
41336	232	cookie_v6_check	net/ipv6/syncookies.c	&final	6	12	\N	\N	\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\tu32 tsoff = 0;\n\n\tif (!sock_net(sk)->ipv4.sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(sock_net(sk), skb, &tcp_opt, 0, NULL);\n\n\tif (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {\n\t\ttsoff = secure_tcpv6_ts_off(sock_net(sk),\n\t\t\t\t\t    ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32);\n\t\ttcp_opt.rcv_tsecr -= tsoff;\n\t}\n\n\tif (!cookie_timestamp_decode(sock_net(sk), &tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\trefcount_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = inet_request_bound_dev_if(sk, skb);\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\ttreq->ts_off = 0;\n\ttreq->txhash = net_tx_rndhash();\n\n\t/*\n\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n	t
45615	198	mct_u232_set_baud_rate	drivers/usb/serial/mct_u232.c	rc	1	11	\N	\N	\tunsigned int divisor;\n\tint rc;\n\tunsigned char *buf;\n\tunsigned char cts_enable_byte = 0;\n\tspeed_t speed;\n\n\tbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tdivisor = mct_u232_calculate_baud_rate(serial, value, &speed);\n\tput_unaligned_le32(divisor, buf);\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\tMCT_U232_SET_BAUD_RATE_REQUEST,\n\t\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t\t0, 0, buf, MCT_U232_SET_BAUD_RATE_SIZE,\n\t\t\t\tWDR_TIMEOUT);\n\tif (rc < 0)\t/*FIXME: What value speed results */\n	t
42725	1049	fsp_init	drivers/input/mouse/sentelic.c	sn	6	12	\N	\N	\tstruct fsp_data *priv;\n\tint ver, rev, sn = 0;\n\tint error;\n\n\tif (fsp_get_version(psmouse, &ver) ||\n\t    fsp_get_revision(psmouse, &rev)) {\n\t\treturn -ENODEV;\n\t}\n\tif (ver >= FSP_VER_STL3888_C0) {\n\t\t/* firmware information is only available since C0 */\n\t\tfsp_get_sn(psmouse, &sn);\n\t}\n\n\tpsmouse_info(psmouse,\n	t
30132	259	do_drive_get_GTF	drivers/ide/ide-acpi.c	output.length	1	13	\N	\N	\tacpi_status\t\t\tstatus;\n\tstruct acpi_buffer\t\toutput;\n\tunion acpi_object \t\t*out_obj;\n\tint\t\t\t\terr = -ENODEV;\n\n\t*gtf_length = 0;\n\t*gtf_address = 0UL;\n\t*obj_loc = 0UL;\n\n\tif (!drive->acpidata->obj_handle) {\n\t\tDEBPRINT("No ACPI object found for %s\\n", drive->name);\n\t\tgoto out;\n\t}\n\n\t/* Setting up output buffer */\n\toutput.length = ACPI_ALLOCATE_BUFFER;\n\toutput.pointer = NULL;\t/* ACPI-CA sets this; save/free it later */\n\n\t/* _GTF has no input parameters */\n\terr = -EIO;\n\tstatus = acpi_evaluate_object(drive->acpidata->obj_handle, "_GTF",\n\t\t\t\t      NULL, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_DEBUG\n\t\t       "%s: Run _GTF error: status = 0x%x\\n",\n\t\t       __func__, status);\n\t\tgoto out;\n\t}\n\n\tif (!output.length || !output.pointer) {\n	f
21496	389	br_fdb_delete_by_port	net/bridge/br_fdb.c	p	1	11	\N	\N	\tint i;\n\n\tspin_lock_bh(&br->hash_lock);\n\tfor (i = 0; i < BR_HASH_SIZE; i++) {\n\t\tstruct hlist_node *h, *g;\n\n\t\thlist_for_each_safe(h, g, &br->hash[i]) {\n\t\t\tstruct net_bridge_fdb_entry *f\n\t\t\t\t= hlist_entry(h, struct net_bridge_fdb_entry, hlist);\n\t\t\tif (f->dst != p)\n	t
44291	1643	ip_vs_in_icmp	net/netfilter/ipvs/ip_vs_core.c	&ciph)	6	12	\N	\N	\tstruct iphdr *iph;\n\tstruct icmphdr\t_icmph, *ic;\n\tstruct iphdr\t_ciph, *cih;\t/* The ip header contained within the ICMP */\n\tstruct ip_vs_iphdr ciph;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tunsigned int offset, offset2, ihl, verdict;\n\tbool ipip, new_cp = false;\n\n\t*related = 1;\n\n\t/* reassemble IP fragments */\n\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\tif (ip_vs_gather_frags(ipvs, skb, ip_vs_defrag_user(hooknum)))\n\t\t\treturn NF_STOLEN;\n\t}\n\n\tiph = ip_hdr(skb);\n\toffset = ihl = iph->ihl * 4;\n\tic = skb_header_pointer(skb, offset, sizeof(_icmph), &_icmph);\n\tif (ic == NULL)\n\t\treturn NF_DROP;\n\n\tIP_VS_DBG(12, "Incoming ICMP (%d,%d) %pI4->%pI4\\n",\n\t\t  ic->type, ntohs(icmp_id(ic)),\n\t\t  &iph->saddr, &iph->daddr);\n\n\t/*\n\t * Work through seeing if this is for us.\n\t * These checks are supposed to be in an order that means easy\n\t * things are checked first to speed up processing.... however\n\t * this means that some packets will manage to get a long way\n\t * down this stack and then be rejected, but that's life.\n\t */\n\tif ((ic->type != ICMP_DEST_UNREACH) &&\n\t    (ic->type != ICMP_SOURCE_QUENCH) &&\n\t    (ic->type != ICMP_TIME_EXCEEDED)) {\n\t\t*related = 0;\n\t\treturn NF_ACCEPT;\n\t}\n\n\t/* Now find the contained IP header */\n\toffset += sizeof(_icmph);\n\tcih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\n\tif (cih == NULL)\n\t\treturn NF_ACCEPT; /* The packet looks wrong, ignore */\n\n\t/* Special case for errors for IPIP packets */\n\tipip = false;\n\tif (cih->protocol == IPPROTO_IPIP) {\n\t\tif (unlikely(cih->frag_off & htons(IP_OFFSET)))\n\t\t\treturn NF_ACCEPT;\n\t\t/* Error for our IPIP must arrive at LOCAL_IN */\n\t\tif (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL))\n\t\t\treturn NF_ACCEPT;\n\t\toffset += cih->ihl * 4;\n\t\tcih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\n\t\tif (cih == NULL)\n\t\t\treturn NF_ACCEPT; /* The packet looks wrong, ignore */\n\t\tipip = true;\n\t}\n\n\tpd = ip_vs_proto_data_get(ipvs, cih->protocol);\n\tif (!pd)\n\t\treturn NF_ACCEPT;\n\tpp = pd->pp;\n\n\t/* Is the embedded protocol header present? */\n\tif (unlikely(cih->frag_off & htons(IP_OFFSET) &&\n\t\t     pp->dont_defrag))\n\t\treturn NF_ACCEPT;\n\n\tIP_VS_DBG_PKT(11, AF_INET, pp, skb, offset,\n\t\t      "Checking incoming ICMP for");\n\n\toffset2 = offset;\n\tip_vs_fill_iph_skb_icmp(AF_INET, skb, offset, !ipip, &ciph);\n\toffset = ciph.len;\n\n\t/* The embedded headers contain source and dest in reverse order.\n\t * For IPIP this is error for request, not for reply.\n\t */\n\tcp = pp->conn_in_get(ipvs, AF_INET, skb, &ciph);\n\n\tif (!cp) {\n\t\tint v;\n\n\t\tif (!sysctl_schedule_icmp(ipvs))\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (!ip_vs_try_to_schedule(ipvs, AF_INET, skb, pd, &v, &cp, &ciph))\n	t
61790	6295	ath10k_wmi_op_gen_vdev_start	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_vdev_start_$cmd$obj$11	0	11	\N	\N	\tstruct wmi_vdev_start_request_cmd *cmd;\n\tstruct sk_buff *skb;\n\tconst char *cmdname;\n\tu32 flags = 0;\n\n\tif (WARN_ON(arg->hidden_ssid && !arg->ssid))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (restart)\n\t\tcmdname = "restart";\n\telse\n\t\tcmdname = "start";\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (arg->hidden_ssid)\n\t\tflags |= WMI_VDEV_START_HIDDEN_SSID;\n\tif (arg->pmf_enabled)\n\t\tflags |= WMI_VDEV_START_PMF_ENABLED;\n\n\tcmd = (struct wmi_vdev_start_request_cmd *)skb->data;\n\tcmd->vdev_id         = __cpu_to_le32(arg->vdev_id);\n\tcmd->disable_hw_ack  = __cpu_to_le32(arg->disable_hw_ack);\n\tcmd->beacon_interval = __cpu_to_le32(arg->bcn_intval);\n\tcmd->dtim_period     = __cpu_to_le32(arg->dtim_period);\n\tcmd->flags           = __cpu_to_le32(flags);\n\tcmd->bcn_tx_rate     = __cpu_to_le32(arg->bcn_tx_rate);\n\tcmd->bcn_tx_power    = __cpu_to_le32(arg->bcn_tx_power);\n\n\tif (arg->ssid) {\n\t\tcmd->ssid.ssid_len = __cpu_to_le32(arg->ssid_len);\n	t
54089	188	cirrusfb_create	drivers/gpu/drm/cirrus/cirrus_fbdev.c	cirrusfb_create_$__mptr9$obj	0	11	\N	\N	\tstruct cirrus_fbdev *gfbdev =\n\t\tcontainer_of(helper, struct cirrus_fbdev, helper);\n\tstruct cirrus_device *cdev = gfbdev->helper.dev->dev_private;\n\tstruct fb_info *info;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_mode_fb_cmd2 mode_cmd;\n\tvoid *sysram;\n\tstruct drm_gem_object *gobj = NULL;\n\tstruct cirrus_bo *bo = NULL;\n\tint size, ret;\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\tmode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\t\t\t  sizes->surface_depth);\n\tsize = mode_cmd.pitches[0] * mode_cmd.height;\n\n\tret = cirrusfb_create_object(gfbdev, &mode_cmd, &gobj);\n\tif (ret) {\n\t\tDRM_ERROR("failed to create fbcon backing object %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tbo = gem_to_cirrus_bo(gobj);\n	t
57669	1751	da7213_probe	sound/soc/codecs/da7213.c	pdata->dmic_data_sel	1	11	\N	\N	\tstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\n\n\t/* Default to using ALC auto offset calibration mode. */\n\tsnd_soc_update_bits(codec, DA7213_ALC_CTRL1,\n\t\t\t    DA7213_ALC_CALIB_MODE_MAN, 0);\n\tda7213->alc_calib_auto = true;\n\n\t/* Default PC counter to free-running */\n\tsnd_soc_update_bits(codec, DA7213_PC_COUNT, DA7213_PC_FREERUN_MASK,\n\t\t\t    DA7213_PC_FREERUN_MASK);\n\n\t/* Enable all Gain Ramps */\n\tsnd_soc_update_bits(codec, DA7213_AUX_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_AUX_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_MIXIN_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_MIXIN_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_ADC_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_ADC_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_DAC_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_DAC_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_HP_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_HP_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_update_bits(codec, DA7213_LINE_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\n\t/*\n\t * There are two separate control bits for input and output mixers as\n\t * well as headphone and line outs.\n\t * One to enable corresponding amplifier and other to enable its\n\t * output. As amplifier bits are related to power control, they are\n\t * being managed by DAPM while other (non power related) bits are\n\t * enabled here\n\t */\n\tsnd_soc_update_bits(codec, DA7213_MIXIN_L_CTRL,\n\t\t\t    DA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\n\tsnd_soc_update_bits(codec, DA7213_MIXIN_R_CTRL,\n\t\t\t    DA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\n\n\tsnd_soc_update_bits(codec, DA7213_MIXOUT_L_CTRL,\n\t\t\t    DA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\n\tsnd_soc_update_bits(codec, DA7213_MIXOUT_R_CTRL,\n\t\t\t    DA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\n\n\tsnd_soc_update_bits(codec, DA7213_HP_L_CTRL,\n\t\t\t    DA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\n\tsnd_soc_update_bits(codec, DA7213_HP_R_CTRL,\n\t\t\t    DA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\n\n\tsnd_soc_update_bits(codec, DA7213_LINE_CTRL,\n\t\t\t    DA7213_LINE_AMP_OE, DA7213_LINE_AMP_OE);\n\n\t/* Handle DT/Platform data */\n\tda7213->pdata = dev_get_platdata(codec->dev);\n\tif (!da7213->pdata)\n\t\tda7213->pdata = da7213_fw_to_pdata(codec);\n\n\t/* Set platform data values */\n\tif (da7213->pdata) {\n\t\tstruct da7213_platform_data *pdata = da7213->pdata;\n\t\tu8 micbias_lvl = 0, dmic_cfg = 0;\n\n\t\t/* Set Mic Bias voltages */\n\t\tswitch (pdata->micbias1_lvl) {\n\t\tcase DA7213_MICBIAS_1_6V:\n\t\tcase DA7213_MICBIAS_2_2V:\n\t\tcase DA7213_MICBIAS_2_5V:\n\t\tcase DA7213_MICBIAS_3_0V:\n\t\t\tmicbias_lvl |= (pdata->micbias1_lvl <<\n\t\t\t\t\tDA7213_MICBIAS1_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (pdata->micbias2_lvl) {\n\t\tcase DA7213_MICBIAS_1_6V:\n\t\tcase DA7213_MICBIAS_2_2V:\n\t\tcase DA7213_MICBIAS_2_5V:\n\t\tcase DA7213_MICBIAS_3_0V:\n\t\t\tmicbias_lvl |= (pdata->micbias2_lvl <<\n\t\t\t\t\t DA7213_MICBIAS2_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tsnd_soc_update_bits(codec, DA7213_MICBIAS_CTRL,\n\t\t\t\t    DA7213_MICBIAS1_LEVEL_MASK |\n\t\t\t\t    DA7213_MICBIAS2_LEVEL_MASK, micbias_lvl);\n\n\t\t/* Set DMIC configuration */\n\t\tswitch (pdata->dmic_data_sel) {\n	t
62039	159	pixcir_ts_isr	drivers/input/touchscreen/pixcir_i2c_ts.c	&report	1	11	\N	\N	\tstruct pixcir_i2c_ts_data *tsdata = dev_id;\n\tstruct pixcir_report_data report;\n\n\twhile (tsdata->running) {\n\t\t/* parse packet */\n\t\tpixcir_ts_parse(tsdata, &report);\n\n\t\t/* report it */\n\t\tpixcir_ts_report(tsdata, &report);\n	t
25342	532	snd_probe	sound/usb/caiaq/device.c	ret	2	-11	\N	\N	\tint ret;\n\tstruct snd_card *card = NULL;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\n\tret = create_card(usb_dev, intf, &card);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusb_set_intfdata(intf, card);\n\tret = init_card(caiaqdev(card));\n\tif (ret < 0) {\n	t
30135	1155	uvc_query_v4l2_menu	drivers/media/usb/uvc/uvc_ctrl.c	mapping->v4l2_type	1	13	\N	\N	\tstruct uvc_menu_info *menu_info;\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_control *ctrl;\n\tu32 index = query_menu->index;\n\tu32 id = query_menu->id;\n\tint ret;\n\n\tmemset(query_menu, 0, sizeof(*query_menu));\n\tquery_menu->id = id;\n\tquery_menu->index = index;\n\n\tret = mutex_lock_interruptible(&chain->ctrl_mutex);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\n\tctrl = uvc_find_control(chain, query_menu->id, &mapping);\n\tif (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU) {\n	f
33421	108	pegasus_control_msg	drivers/input/tablet/pegasus_notetaker.c	result	1	11	\N	\N	\tconst int sizeof_buf = len + 2;\n\tint result;\n\tint error;\n\tu8 *cmd_buf;\n\n\tcmd_buf = kmalloc(sizeof_buf, GFP_KERNEL);\n\tif (!cmd_buf)\n\t\treturn -ENOMEM;\n\n\tcmd_buf[0] = NOTETAKER_REPORT_ID;\n\tcmd_buf[1] = len;\n\tmemcpy(cmd_buf + 2, data, len);\n\n\tresult = usb_control_msg(pegasus->usbdev,\n\t\t\t\t usb_sndctrlpipe(pegasus->usbdev, 0),\n\t\t\t\t USB_REQ_SET_REPORT,\n\t\t\t\t USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t 0, 0, cmd_buf, sizeof_buf,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\n\tkfree(cmd_buf);\n\n\tif (unlikely(result != sizeof_buf)) {\n	t
34509	2513	send_chown	fs/btrfs/send.c	p	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, "send_chown %llu uid=%llu, gid=%llu",\n\t\t    ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n	t
36059	2375	ath10k_wmi_tlv_op_gen_beacon_dma	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_beacon_dma_$tlv$obj$0	0	11	\N	\N	\tstruct wmi_bcn_tx_ref_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdr = (struct ieee80211_hdr *)bcn;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_SEND_FROM_HOST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n	t
27951	273	dln2_adc_read	drivers/iio/adc/dln2-adc.c	conflict	10	12	\N	\N	\tint ret, i;\n\tstruct iio_dev *indio_dev = platform_get_drvdata(dln2->pdev);\n\tu16 conflict;\n\t__le16 value;\n\tint olen = sizeof(value);\n\tstruct dln2_adc_port_chan port_chan = {\n\t\t.port = dln2->port,\n\t\t.chan = channel,\n\t};\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dln2_adc_set_chan_enabled(dln2, channel, true);\n\tif (ret < 0)\n\t\tgoto release_direct;\n\n\tret = dln2_adc_set_port_enabled(dln2, true, &conflict);\n\tif (ret < 0) {\n\t\tif (conflict) {\n	t
7207	469	rpr0521_trigger_consumer_handler	drivers/iio/light/rpr0521.c	err	1	21	\N	\N	\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint err;\n\n\tu8 buffer[16]; /* 3 16-bit channels + padding + ts */\n\n\t/* Use irq timestamp when reasonable. */\n\tif (iio_trigger_using_own(indio_dev) && data->irq_timestamp) {\n\t\tpf->timestamp = data->irq_timestamp;\n\t\tdata->irq_timestamp = 0;\n\t}\n\t/* Other chained trigger polls get timestamp only here. */\n\tif (!pf->timestamp)\n\t\tpf->timestamp = iio_get_time_ns(indio_dev);\n\n\terr = regmap_bulk_read(data->regmap, RPR0521_REG_PXS_DATA,\n\t\t&buffer,\n\t\t(3 * 2) + 1);\t/* 3 * 16-bit + (discarded) int clear reg. */\n\tif (!err)\n	t
39592	325	btrfs_free_fs_roots	fs/btrfs/disk-io.c	btrfs_free_fs_roots_$addr.addr.i$obj	0	11	\N	\N	\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size, GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n	t
50870	777	aspeed_smc_setup_flash	drivers/mtd/spi-nor/aspeed-smc.c	ret	1	11	\N	\N	\tconst struct spi_nor_hwcaps hwcaps = {\n\t\t.mask = SNOR_HWCAPS_READ |\n\t\t\tSNOR_HWCAPS_READ_FAST |\n\t\t\tSNOR_HWCAPS_PP,\n\t};\n\tconst struct aspeed_smc_info *info = controller->info;\n\tstruct device *dev = controller->dev;\n\tstruct device_node *child;\n\tunsigned int cs;\n\tint ret = -ENODEV;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct aspeed_smc_chip *chip;\n\t\tstruct spi_nor *nor;\n\t\tstruct mtd_info *mtd;\n\n\t\t/* This driver does not support NAND or NOR flash devices. */\n\t\tif (!of_device_is_compatible(child, "jedec,spi-nor"))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(child, "reg", &cs);\n\t\tif (ret) {\n	t
36131	837	myri10ge_change_promisc	drivers/net/ethernet/myricom/myri10ge/myri10ge.c	&cmd	6	12	\N	\N	\tstruct myri10ge_cmd cmd;\n\tint status, ctl;\n\n\tctl = promisc ? MXGEFW_ENABLE_PROMISC : MXGEFW_DISABLE_PROMISC;\n\tstatus = myri10ge_send_cmd(mgp, ctl, &cmd, atomic);\n	t
27030	1548	acer_gsensor_event	drivers/platform/x86/acer-wmi.c	acer_gsensor_event_$out_obj$0$0$obj$0$0	0	11	\N	\N	\tacpi_status status;\n\tstruct acpi_buffer output;\n\tunion acpi_object out_obj[5];\n\n\tif (!has_cap(ACER_CAP_ACCEL))\n\t\treturn -1;\n\n\toutput.length = sizeof(out_obj);\n\toutput.pointer = out_obj;\n\n\tstatus = acpi_evaluate_object(gsensor_handle, "RDVL", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -1;\n\n\tif (out_obj->package.count != 4)\n\t\treturn -1;\n\n\tinput_report_abs(acer_wmi_accel_dev, ABS_X,\n\t\t(s16)out_obj->package.elements[0].integer.value);\n	t
46707	3977	extent_write_cache_pages	fs/btrfs/extent_io.c	page->index	6	12	\N	\N	\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n	t
45695	310	saa7164_api_get_encoder	drivers/media/pci/saa7164/saa7164-api.c	saa7164_api_get_encoder_$a$1$obj	0	11	\N	\N	\tstruct saa7164_dev *dev = port->dev;\n\tstruct tmComResEncVideoBitRate v;\n\tstruct tmComResEncAudioBitRate a;\n\tstruct tmComResEncVideoInputAspectRatio ar;\n\tint ret;\n\n\tdprintk(DBGLVL_ENC, "%s() unitid=0x%x\\n", __func__,\n\t\tport->hwcfg.sourceid);\n\n\tport->encoder_profile = 0;\n\tport->video_format = 0;\n\tport->video_resolution = 0;\n\tport->audio_format = 0;\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_PROFILE_CONTROL, sizeof(u8), &port->encoder_profile);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_VIDEO_RESOLUTION_CONTROL, sizeof(u8),\n\t\t&port->video_resolution);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_VIDEO_FORMAT_CONTROL, sizeof(u8), &port->video_format);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_VIDEO_BIT_RATE_CONTROL, sizeof(v), &v);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_AUDIO_FORMAT_CONTROL, sizeof(u8), &port->audio_format);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_AUDIO_BIT_RATE_CONTROL, sizeof(a), &a);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\t/* Aspect Ratio */\n\tar.width = 0;\n\tar.height = 0;\n\tret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\n\t\tEU_VIDEO_INPUT_ASPECT_CONTROL,\n\t\tsizeof(struct tmComResEncVideoInputAspectRatio), &ar);\n\tif (ret != SAA_OK)\n\t\tprintk(KERN_ERR "%s() error, ret = 0x%x\\n", __func__, ret);\n\n\tdprintk(DBGLVL_ENC, "encoder_profile = %d\\n", port->encoder_profile);\n\tdprintk(DBGLVL_ENC, "video_format    = %d\\n", port->video_format);\n\tdprintk(DBGLVL_ENC, "audio_format    = %d\\n", port->audio_format);\n\tdprintk(DBGLVL_ENC, "video_resolution= %d\\n", port->video_resolution);\n\tdprintk(DBGLVL_ENC, "v.ucVideoBitRateMode = %d\\n",\n\t\tv.ucVideoBitRateMode);\n\tdprintk(DBGLVL_ENC, "v.dwVideoBitRate     = %d\\n",\n\t\tv.dwVideoBitRate);\n\tdprintk(DBGLVL_ENC, "v.dwVideoBitRatePeak = %d\\n",\n\t\tv.dwVideoBitRatePeak);\n\tdprintk(DBGLVL_ENC, "a.ucVideoBitRateMode = %d\\n",\n\t\ta.ucAudioBitRateMode);\n\tdprintk(DBGLVL_ENC, "a.dwVideoBitRate     = %d\\n",\n	t
53022	325	wusb_dev_update_address	drivers/usb/wusbcore/security.c	result	1	11	\N	\N	\tint result = -ENOMEM;\n\tstruct usb_device *usb_dev = wusb_dev->usb_dev;\n\tstruct device *dev = &usb_dev->dev;\n\tu8 new_address = wusb_dev->addr & 0x7F;\n\n\t/* Set address 0 */\n\tresult = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\tUSB_REQ_SET_ADDRESS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\t 0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0) {\n	t
21910	223	da9062_thermal_probe	drivers/thermal/da9062-thermal.c	da9062_thermal_probe_	1	11	\N	\N	\tstruct da9062 *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9062_thermal *thermal;\n\tunsigned int pp_tmp = DA9062_DEFAULT_POLLING_MS_PERIOD;\n\tconst struct of_device_id *match;\n\tint ret = 0;\n\n\tmatch = of_match_node(da9062_compatible_reg_id_table,\n\t\t\t      pdev->dev.of_node);\n\tif (!match)\n\t\treturn -ENXIO;\n\n\tif (pdev->dev.of_node) {\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n	t
42144	2082	igb_set_features	drivers/net/ethernet/intel/igb/igb_main.c	igb_set_features_$____ptr16$obj	0	11	\N	\N	\tnetdev_features_t changed = netdev->features ^ features;\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tigb_vlan_mode(netdev, features);\n\n\tif (!(changed & (NETIF_F_RXALL | NETIF_F_NTUPLE)))\n\t\treturn 0;\n\n\tif (!(features & NETIF_F_NTUPLE)) {\n\t\tstruct hlist_node *node2;\n\t\tstruct igb_nfc_filter *rule;\n\n\t\tspin_lock(&adapter->nfc_lock);\n\t\thlist_for_each_entry_safe(rule, node2,\n	t
3167	388	mlx5_get_roce_udp_sport	drivers/infiniband/hw/mlx5/main.c	attr.gid_type	1	11	\N	\N	\tstruct ib_gid_attr attr;\n\tunion ib_gid gid;\n\n\tif (ib_get_cached_gid(&dev->ib_dev, port_num, index, &gid, &attr))\n\t\treturn 0;\n\n\tif (!attr.ndev)\n\t\treturn 0;\n\n\tdev_put(attr.ndev);\n\n\tif (attr.gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)\n	t
46866	4418	mptsas_hotplug_work	drivers/message/fusion/mptsas.c	sas_device.flags	7	12	\N	\N	\tstruct mptsas_phyinfo *phy_info;\n\tstruct scsi_target * starget;\n\tstruct mptsas_devinfo sas_device;\n\tVirtTarget *vtarget;\n\tint i;\n\tstruct mptsas_portinfo *port_info;\n\n\tswitch (hot_plug_info->event_type) {\n\n\tcase MPTSAS_ADD_PHYSDISK:\n\n\t\tif (!ioc->raid_data.pIocPg2)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\n\t\t\tif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID ==\n\t\t\t    hot_plug_info->id) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT "firmware bug: unable "\n\t\t\t\t    "to add hidden disk - target_id matchs "\n\t\t\t\t    "volume_id\\n", ioc->name);\n\t\t\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmpt_findImVolumes(ioc);\n\n\tcase MPTSAS_ADD_DEVICE:\n\t\tmemset(&sas_device, 0, sizeof(struct mptsas_devinfo));\n\t\tmptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t    MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t    (hot_plug_info->channel << 8) +\n\t\t    hot_plug_info->id);\n\n\t\t/* If there is no FW B_T mapping for this device then break\n\t\t * */\n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tbreak;\n\n\t\tif (!sas_device.handle)\n\t\t\treturn;\n\n\t\tphy_info = mptsas_refreshing_device_handles(ioc, &sas_device);\n\t\t/* Device hot plug */\n\t\tif (!phy_info) {\n\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t"%s %d HOT PLUG: "\n\t\t\t\t"parent handle of device %x\\n", ioc->name,\n\t\t\t\t__func__, __LINE__, sas_device.handle_parent));\n\t\t\tport_info = mptsas_find_portinfo_by_handle(ioc,\n\t\t\t\tsas_device.handle_parent);\n\n\t\t\tif (port_info == ioc->hba_port_info)\n\t\t\t\tmptsas_probe_hba_phys(ioc);\n\t\t\telse if (port_info)\n\t\t\t\tmptsas_expander_refresh(ioc, port_info);\n\t\t\telse {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\t"%s %d port info is NULL\\n",\n\t\t\t\t\tioc->name, __func__, __LINE__));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphy_info = mptsas_refreshing_device_handles\n\t\t\t\t(ioc, &sas_device);\n\t\t}\n\n\t\tif (!phy_info) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t"%s %d phy info is NULL\\n",\n\t\t\t\tioc->name, __func__, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mptsas_get_rphy(phy_info))\n\t\t\tbreak;\n\n\t\tmptsas_add_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_DEVICE:\n\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t    hot_plug_info->sas_address);\n\t\tmptsas_del_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_PHYSDISK:\n\n\t\tmpt_findImVolumes(ioc);\n\n\t\tphy_info = mptsas_find_phyinfo_by_phys_disk_num(\n\t\t\t\tioc, hot_plug_info->phys_disk_num,\n\t\t\t\thot_plug_info->channel,\n\t\t\t\thot_plug_info->id);\n\t\tmptsas_del_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_ADD_PHYSDISK_REPROBE:\n\n\t\tif (mptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t    (hot_plug_info->channel << 8) + hot_plug_info->id)) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t"%s: fw_id=%d exit at line=%d\\n", ioc->name,\n\t\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If there is no FW B_T mapping for this device then break\n\t\t * */\n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n	t
23298	853	truncate_hole	fs/f2fs/file.c	dn.node_page	1	11	\N	\N	\tint err;\n\n\twhile (pg_start < pg_end) {\n\t\tstruct dnode_of_data dn;\n\t\tpgoff_t end_offset, count;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pg_start, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tpg_start++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn err;\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n	t
26426	4545	drbd_bcast_event	drivers/block/drbd/drbd_nl.c	msg	1	11	\N	\N	\tstruct sk_buff *msg;\n\tstruct drbd_genlmsghdr *d_out;\n\tunsigned seq;\n\tint err = -ENOMEM;\n\n\tseq = atomic_inc_return(&drbd_genl_seq);\n\tmsg = genlmsg_new(NLMSG_GOODSIZE, GFP_NOIO);\n\tif (!msg)\n\t\tgoto failed;\n\n\terr = -EMSGSIZE;\n\td_out = genlmsg_put(msg, 0, seq, &drbd_genl_family, 0, DRBD_EVENT);\n	t
47291	282	jffs2_init_acl_pre	fs/jffs2/acl.c	acl	6	12	\N	\N	\tstruct posix_acl *default_acl, *acl;\n\tint rc;\n\n\tcache_no_acl(inode);\n\n\trc = posix_acl_create(dir_i, i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n	t
41255	1043	uvd_v6_0_set_powergating_state	drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c	ret	1	11	\N	\N	\t/* This doesn't actually powergate the UVD block.\n\t * That's done in the dpm code via the SMC.  This\n\t * just re-inits the block as necessary.  The actual\n\t * gating still happens in the dpm code.  We should\n\t * revisit this when there is a cleaner line between\n\t * the smc and the hw blocks\n\t */\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint ret = 0;\n\n\tWREG32(mmUVD_POWER_STATUS, UVD_POWER_STATUS__UVD_PG_EN_MASK);\n\n\tif (state == AMD_PG_STATE_GATE) {\n\t\tuvd_v6_0_stop(adev);\n\t} else {\n\t\tret = uvd_v6_0_start(adev);\n\t\tif (ret)\n	t
30686	2625	dme1737_isa_device_add	drivers/hwmon/dme1737.c	err	2	-11	\N	\N	\tstruct resource res = {\n\t\t.start\t= addr,\n\t\t.end\t= addr + DME1737_EXTENT - 1,\n\t\t.name\t= "dme1737",\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc("dme1737", addr);\n\tif (!pdev) {\n\t\tpr_err("Failed to allocate device\\n");\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err("Failed to add device resource (err = %d)\\n", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n	t
36058	2376	ath10k_wmi_tlv_op_gen_beacon_dma	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ath10k_wmi_tlv_op_gen_beacon_dma_$cmd$obj	0	13	\N	\N	\tstruct wmi_bcn_tx_ref_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdr = (struct ieee80211_hdr *)bcn;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_SEND_FROM_HOST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	f
841	163	is_ext_pwr_online	drivers/power/supply/charger-manager.c	is_ext_pwr_online_$val$obj	0	13	\N	\N	\tunion power_supply_propval val;\n\tstruct power_supply *psy;\n\tbool online = false;\n\tint i, ret;\n\n\t/* If at least one of them has one, it's yes. */\n\tfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\n\t\tpsy = power_supply_get_by_name(cm->desc->psy_charger_stat[i]);\n\t\tif (!psy) {\n\t\t\tdev_err(cm->dev, "Cannot find power supply \\"%s\\"\\n",\n\t\t\t\t\tcm->desc->psy_charger_stat[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t&val);\n\t\tpower_supply_put(psy);\n\t\tif (ret == 0 && val.intval) {\n	f
427	2298	tomoyo_read_stat	security/tomoyo/common.c	tomoyo_read_stat_$stamp$0$obj	0	11	\N	\N	\tu8 i;\n\tunsigned int total = 0;\n\tif (head->r.eof)\n\t\treturn;\n\tfor (i = 0; i < TOMOYO_MAX_POLICY_STAT; i++) {\n\t\ttomoyo_io_printf(head, "Policy %-30s %10u",\n\t\t\t\t tomoyo_policy_headers[i],\n\t\t\t\t tomoyo_stat_updated[i]);\n\t\tif (tomoyo_stat_modified[i]) {\n\t\t\tstruct tomoyo_time stamp;\n\t\t\ttomoyo_convert_time(tomoyo_stat_modified[i], &stamp);\n\t\t\ttomoyo_io_printf(head, " (Last: %04u/%02u/%02u "\n	t
62302	9514	nl80211_tx_mgmt	net/wireless/nl80211.c	&chandef	6	12	\N	\N	\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n	t
54213	184	gb_gpio_get_value_operation	drivers/staging/greybus/gpio.c	value	1	11	\N	\N	\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_get_value_request request;\n\tstruct gb_gpio_get_value_response response;\n\tint ret;\n\tu8 value;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_VALUE,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(dev, "failed to get value of gpio %u\\n", which);\n\t\treturn ret;\n\t}\n\n\tvalue = response.value;\n\tif (value && value != 1) {\n	t
26998	1224	toshiba_wwan_set	drivers/platform/x86/toshiba_acpi.c	status	1	11	\N	\N	\tu32 in[TCI_WORDS] = { HCI_SET, HCI_WIRELESS, state, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tin[3] = HCI_WIRELESS_WWAN_STATUS;\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n	t
27457	4255	i40iw_cm_disconnect_all	drivers/infiniband/hw/i40iw/i40iw_cm.c	&attr	1	11	\N	\N	\tstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\n\tstruct list_head *list_core_temp;\n\tstruct list_head *list_node;\n\tstruct i40iw_cm_node *cm_node;\n\tunsigned long flags;\n\tstruct list_head connected_list;\n\tstruct ib_qp_attr attr;\n\n\tINIT_LIST_HEAD(&connected_list);\n\tspin_lock_irqsave(&cm_core->ht_lock, flags);\n\tlist_for_each_safe(list_node, list_core_temp, &cm_core->connected_nodes) {\n\t\tcm_node = container_of(list_node, struct i40iw_cm_node, list);\n\t\tatomic_inc(&cm_node->ref_count);\n\t\tlist_add(&cm_node->connected_entry, &connected_list);\n\t}\n\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n\n\tlist_for_each_safe(list_node, list_core_temp, &connected_list) {\n\t\tcm_node = container_of(list_node, struct i40iw_cm_node, connected_entry);\n\t\tattr.qp_state = IB_QPS_ERR;\n\t\ti40iw_modify_qp(&cm_node->iwqp->ibqp, &attr, IB_QP_STATE, NULL);\n	t
29794	40	stk1160_ac97_wait_transfer_complete	drivers/media/usb/stk1160/stk1160-ac97.c	value	1	11	\N	\N	\tunsigned long timeout = jiffies + msecs_to_jiffies(STK1160_AC97_TIMEOUT);\n\tu8 value;\n\n\t/* Wait for AC97 transfer to complete */\n\twhile (time_is_after_jiffies(timeout)) {\n\t\tstk1160_read_reg(dev, STK1160_AC97CTL_0, &value);\n\n\t\tif (!(value & (STK1160_AC97CTL_0_CR | STK1160_AC97CTL_0_CW)))\n	t
30206	508	_readpage	fs/exofs/inode.c	&pcol	1	11	\N	\N	\tstruct page_collect pcol;\n\tint ret;\n\n\t_pcol_init(&pcol, 1, page->mapping->host);\n\n\tpcol.read_4_write = read_4_write;\n\tret = readpage_strip(&pcol, page);\n\tif (ret) {\n\t\tEXOFS_ERR("_readpage => %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\treturn read_exec(&pcol);\n	t
46645	305	nilfs_checkpoints_snapshots_number_show	fs/nilfs2/sysfs.c	nsnapshots	1	11	\N	\N	\t__u64 nsnapshots;\n\tstruct nilfs_cpstat cpstat;\n\tint err;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (err < 0) {\n\t\tnilfs_msg(nilfs->ns_sb, KERN_ERR,\n\t\t\t  "unable to get checkpoint stat: err=%d", err);\n\t\treturn err;\n\t}\n\n\tnsnapshots = cpstat.cs_nsss;\n\n\treturn snprintf(buf, PAGE_SIZE, "%llu\\n", nsnapshots);\n	t
46655	390	rtsx_pci_ms_issue_cmd	drivers/memstick/host/rtsx_pci_ms.c	int_reg	1	11	\N	\N	\tstruct memstick_request *req = host->req;\n\tint err = 0;\n\tu8 cfg = 0, int_reg;\n\n\tdev_dbg(ms_dev(host), "%s\\n", __func__);\n\n\tif (req->need_card_int) {\n\t\tif (host->ifmode != MEMSTICK_SERIAL)\n\t\t\tcfg = WAIT_INT;\n\t}\n\n\tif (req->long_data) {\n\t\terr = ms_transfer_data(host, req->data_dir,\n\t\t\t\treq->tpc, cfg, &(req->sg));\n\t} else {\n\t\tif (req->data_dir == READ) {\n\t\t\terr = ms_read_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\t} else {\n\t\t\terr = ms_write_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (req->need_card_int && (host->ifmode == MEMSTICK_SERIAL)) {\n\t\terr = ms_read_bytes(host, MS_TPC_GET_INT,\n\t\t\t\tNO_WAIT_INT, 1, &int_reg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (req->need_card_int) {\n\t\tdev_dbg(ms_dev(host), "int_reg: 0x%02x\\n", int_reg);\n\n\t\tif (int_reg & MS_INT_CMDNK)\n\t\t\treq->int_reg |= MEMSTICK_INT_CMDNAK;\n\t\tif (int_reg & MS_INT_BREQ)\n	t
52782	456	nfp_nsp_wait	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.c	err	2	-11	\N	\N	\tconst unsigned long wait_until = jiffies + 30 * HZ;\n\tint err;\n\n\tnfp_dbg(state->cpp, "Waiting for NSP to respond (30 sec max).\\n");\n\n\tfor (;;) {\n\t\tconst unsigned long start_time = jiffies;\n\n\t\terr = nfp_nsp_command(state, SPCODE_NOOP, 0, 0, 0);\n\t\tif (err != -EAGAIN)\n	t
52841	1138	ican3_handle_cevtind	drivers/net/can/janz-ican3.c	cf->data	2	-11	\N	\N	\tstruct net_device *dev = mod->ndev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tenum can_state state = mod->can.state;\n\tu8 isrc, ecc, status, rxerr, txerr;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t/* we can only handle the SJA1000 part */\n\tif (msg->data[1] != CEVTIND_CHIP_SJA1000) {\n\t\tnetdev_err(mod->ndev, "unable to handle errors on non-SJA1000\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* check the message length for sanity */\n\tif (le16_to_cpu(msg->len) < 6) {\n\t\tnetdev_err(mod->ndev, "error message too short\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tisrc = msg->data[0];\n\tecc = msg->data[2];\n\tstatus = msg->data[3];\n\trxerr = msg->data[4];\n\ttxerr = msg->data[5];\n\n\t/*\n\t * This hardware lacks any support other than bus error messages to\n\t * determine if packet transmission has failed.\n\t *\n\t * When TX errors happen, one echo skb needs to be dropped from the\n\t * front of the queue.\n\t *\n\t * A small bit of code is duplicated here and below, to avoid error\n\t * skb allocation when it will just be freed immediately.\n\t */\n\tif (isrc == CEVTIND_BEI) {\n\t\tint ret;\n\t\tnetdev_dbg(mod->ndev, "bus error interrupt\\n");\n\n\t\t/* TX error */\n\t\tif (!(ecc & ECC_DIR)) {\n\t\t\tkfree_skb(skb_dequeue(&mod->echoq));\n\t\t\tstats->tx_errors++;\n\t\t} else {\n\t\t\tstats->rx_errors++;\n\t\t}\n\n\t\t/*\n\t\t * The controller automatically disables bus-error interrupts\n\t\t * and therefore we must re-enable them.\n\t\t */\n\t\tret = ican3_set_buserror(mod, 1);\n\t\tif (ret) {\n\t\t\tnetdev_err(mod->ndev, "unable to re-enable bus-error\\n");\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* bus error reporting is off, return immediately */\n\t\tif (!(mod->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\n\t\t\treturn 0;\n\t}\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* data overrun interrupt */\n\tif (isrc == CEVTIND_DOI || isrc == CEVTIND_LOST) {\n\t\tnetdev_dbg(mod->ndev, "data overrun interrupt\\n");\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t}\n\n\t/* error warning + passive interrupt */\n\tif (isrc == CEVTIND_EI) {\n\t\tnetdev_dbg(mod->ndev, "error warning + passive interrupt\\n");\n\t\tif (status & SR_BS) {\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\t\tmod->can.can_stats.bus_off++;\n\t\t\tcan_bus_off(dev);\n\t\t} else if (status & SR_ES) {\n\t\t\tif (rxerr >= 128 || txerr >= 128)\n\t\t\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t\t\telse\n\t\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\t} else {\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n\n\t/* bus error interrupt */\n\tif (isrc == CEVTIND_BEI) {\n\t\tmod->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\tswitch (ecc & ECC_MASK) {\n\t\tcase ECC_BIT:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n	t
32141	1907	pspoll_send_buffered	drivers/net/wireless/intersil/hostap/hostap_ap.c	skb	1	11	\N	\N	\tstruct hostap_skb_tx_data *meta;\n\n\tif (!(sta->flags & WLAN_STA_PS)) {\n\t\t/* Station has moved to non-PS mode, so send all buffered\n\t\t * frames using normal device queue. */\n\t\tdev_queue_xmit(skb);\n	t
57232	7111	ath10k_wmi_op_gen_pktlog_enable	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_pktlog_enable_$cmd$obj	0	11	\N	\N	\tstruct wmi_pdev_pktlog_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tev_bitmap &= ATH10K_PKTLOG_ANY;\n\n\tcmd = (struct wmi_pdev_pktlog_enable_cmd *)skb->data;\n\tcmd->ev_bitmap = __cpu_to_le32(ev_bitmap);\n	t
1600	2432	intel_haswell_fixup_enable_dp12	sound/pci/hda/patch_hdmi.c	vendor_param	1	11	\N	\N	\tunsigned int vendor_param;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\n	t
26562	186	ti_syscon_reset_probe	drivers/reset/reset-ti-syscon.c	size	1	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ti_syscon_reset_data *data;\n\tstruct regmap *regmap;\n\tconst __be32 *list;\n\tstruct ti_syscon_reset_control *controls;\n\tint size, nr_controls, i;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tregmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tlist = of_get_property(np, "ti,reset-bits", &size);\n\tif (!list || (size / sizeof(*list)) % 7 != 0) {\n	t
62527	3960	hci_sched_esco	net/bluetooth/hci_core.c	conn->sent	1	11	\N	\N	\tstruct hci_conn *conn;\n\tstruct sk_buff *skb;\n\tint quote;\n\n\tBT_DBG("%s", hdev->name);\n\n\tif (!hci_conn_num(hdev, ESCO_LINK))\n\t\treturn;\n\n\twhile (hdev->sco_cnt && (conn = hci_low_sent(hdev, ESCO_LINK,\n\t\t\t\t\t\t     &quote))) {\n\t\twhile (quote-- && (skb = skb_dequeue(&conn->data_q))) {\n\t\t\tBT_DBG("skb %p len %d", skb, skb->len);\n\t\t\thci_send_frame(hdev, skb);\n\n\t\t\tconn->sent++;\n\t\t\tif (conn->sent == ~0)\n	t
34817	2698	btrfs_ioctl_rm_dev_v2	fs/btrfs/ioctl.c	ret	1	11	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto err_drop;\n\t}\n\n\t/* Check for compatibility reject unknown flags */\n\tif (vol_args->flags & ~BTRFS_VOL_ARG_V2_FLAGS_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\tif (test_and_set_bit(BTRFS_FS_EXCL_OP, &fs_info->flags)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tif (vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID) {\n\t\tret = btrfs_rm_device(fs_info, NULL, vol_args->devid);\n\t} else {\n\t\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\t\tret = btrfs_rm_device(fs_info, vol_args->name, 0);\n\t}\n\tmutex_unlock(&fs_info->volume_mutex);\n\tclear_bit(BTRFS_FS_EXCL_OP, &fs_info->flags);\n\n\tif (!ret) {\n	t
48190	2117	happy_meal_interrupt	drivers/net/ethernet/sun/sunhme.c	hp	1	11	\N	\N	\tstruct net_device *dev = dev_id;\n\tstruct happy_meal *hp  = netdev_priv(dev);\n\tu32 happy_status       = hme_read32(hp, hp->gregs + GREG_STAT);\n\n\tHMD(("happy_meal_interrupt: status=%08x ", happy_status));\n\n\tspin_lock(&hp->happy_lock);\n\n\tif (happy_status & GREG_STAT_ERRORS) {\n\t\tHMD(("ERRORS "));\n\t\tif (happy_meal_is_not_so_happy(hp, /* un- */ happy_status))\n\t\t\tgoto out;\n\t}\n\n\tif (happy_status & GREG_STAT_MIFIRQ) {\n\t\tHMD(("MIFIRQ "));\n\t\thappy_meal_mif_interrupt(hp);\n	t
62306	1167	wmi_pcp_start	drivers/net/wireless/ath/wil6210/wmi.c	reply.evt.status	8	12	\N	\N	\tint rc;\n\n\tstruct wmi_pcp_start_cmd cmd = {\n\t\t.bcon_interval = cpu_to_le16(bi),\n\t\t.network_type = wmi_nettype,\n\t\t.disable_sec_offload = 1,\n\t\t.channel = chan - 1,\n\t\t.pcp_max_assoc_sta = max_assoc_sta,\n\t\t.hidden_ssid = hidden_ssid,\n\t\t.is_go = is_go,\n\t\t.disable_ap_sme = disable_ap_sme,\n\t\t.abft_len = wil->abft_len,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_pcp_started_event evt;\n\t} __packed reply;\n\n\tif (!wil->privacy)\n\t\tcmd.disable_sec = 1;\n\n\tif ((cmd.pcp_max_assoc_sta > WIL6210_MAX_CID) ||\n\t    (cmd.pcp_max_assoc_sta <= 0)) {\n\t\twil_info(wil,\n\t\t\t "Requested connection limit %u, valid values are 1 - %d. Setting to %d\\n",\n\t\t\t max_assoc_sta, WIL6210_MAX_CID, WIL6210_MAX_CID);\n\t\tcmd.pcp_max_assoc_sta = WIL6210_MAX_CID;\n\t}\n\n\tif (disable_ap_sme &&\n\t    !test_bit(WMI_FW_CAPABILITY_DISABLE_AP_SME,\n\t\t      wil->fw_capabilities)) {\n\t\twil_err(wil, "disable_ap_sme not supported by FW\\n");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/*\n\t * Processing time may be huge, in case of secure AP it takes about\n\t * 3500ms for FW to start AP\n\t */\n\trc = wmi_call(wil, WMI_PCP_START_CMDID, &cmd, sizeof(cmd),\n\t\t      WMI_PCP_STARTED_EVENTID, &reply, sizeof(reply), 5000);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS)\n	t
62688	183	lpc18xx_serial_probe	drivers/tty/serial/8250/8250_lpc18xx.c	&uart	6	12	\N	\N	\tstruct lpc18xx_uart_data *data;\n\tstruct uart_8250_port uart;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(&pdev->dev, "irq not found");\n\t\treturn irq;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, "memory resource not found");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&uart, 0, sizeof(uart));\n\n\tuart.port.membase = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res));\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->clk_uart = devm_clk_get(&pdev->dev, "uartclk");\n\tif (IS_ERR(data->clk_uart)) {\n\t\tdev_err(&pdev->dev, "uart clock not found\\n");\n\t\treturn PTR_ERR(data->clk_uart);\n\t}\n\n\tdata->clk_reg = devm_clk_get(&pdev->dev, "reg");\n\tif (IS_ERR(data->clk_reg)) {\n\t\tdev_err(&pdev->dev, "reg clock not found\\n");\n\t\treturn PTR_ERR(data->clk_reg);\n\t}\n\n\tret = clk_prepare_enable(data->clk_reg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "unable to enable reg clock\\n");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(data->clk_uart);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "unable to enable uart clock\\n");\n\t\tgoto dis_clk_reg;\n\t}\n\n\tret = of_alias_get_id(pdev->dev.of_node, "serial");\n\tif (ret >= 0)\n\t\tuart.port.line = ret;\n\n\tdata->dma.rx_param = data;\n\tdata->dma.tx_param = data;\n\n\tspin_lock_init(&uart.port.lock);\n\tuart.port.dev = &pdev->dev;\n\tuart.port.irq = irq;\n\tuart.port.iotype = UPIO_MEM32;\n\tuart.port.mapbase = res->start;\n\tuart.port.regshift = 2;\n\tuart.port.type = PORT_16550A;\n\tuart.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SKIP_TEST;\n\tuart.port.uartclk = clk_get_rate(data->clk_uart);\n\tuart.port.private_data = data;\n\tuart.port.rs485_config = lpc18xx_rs485_config;\n\tuart.port.serial_out = lpc18xx_uart_serial_out;\n\n\tuart.dma = &data->dma;\n\tuart.dma->rxconf.src_maxburst = 1;\n\tuart.dma->txconf.dst_maxburst = 1;\n\n\tret = serial8250_register_8250_port(&uart);\n	t
9477	637	ep0_handle_setup	drivers/usb/mtu3/mtu3_gadget_ep0.c	setup.bRequestType	6	12	\N	\N	\tstruct usb_ctrlrequest setup;\n\tstruct mtu3_request *mreq;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint handled = 0;\n\n\tep0_read_setup(mtu, &setup);\n\n\tif ((setup.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n	t
31925	578	idmap_id_to_name	fs/nfsd/nfs4idmap.c	item->name	8	12	\N	real FP	\tstruct ent *item, key = {\n\t\t.id = id,\n\t\t.type = type,\n\t};\n\t__be32 *p;\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tstrlcpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\n\tret = idmap_lookup(rqstp, idtoname_lookup, &key, nn->idtoname_cache, &item);\n\tif (ret == -ENOENT)\n\t\treturn encode_ascii_id(xdr, id);\n\tif (ret)\n\t\treturn nfserrno(ret);\n\tret = strlen(item->name);\n	t
53541	372	audit_get_nd	kernel/audit_watch.c	audit_get_nd_	1	11	\N	\N	\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n	t
56121	2001	ofdpa_fdb_cleanup	drivers/net/ethernet/rocker/rocker_ofdpa.c	ofdpa_fdb_cleanup_$____ptr67$obj	0	11	\N	\N	\tstruct ofdpa *ofdpa = (struct ofdpa *)data;\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct ofdpa_fdb_tbl_entry *entry;\n\tstruct hlist_node *tmp;\n\tunsigned long next_timer = jiffies + ofdpa->ageing_time;\n\tunsigned long expires;\n\tunsigned long lock_flags;\n\tint flags = OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_REMOVE |\n\t\t    OFDPA_OP_FLAG_LEARNED;\n\tint bkt;\n\n\tspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\thash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, entry, entry) {\n	t
48383	601	gigaset_m10x_send_skb	drivers/isdn/gigaset/asyncdata.c	skb	1	13	\N	\N	\tstruct cardstate *cs = bcs->cs;\n\tunsigned len = skb->len;\n\tunsigned long flags;\n\n\tif (bcs->proto2 == L2_HDLC)\n\t\tskb = HDLC_Encode(skb);\n\telse\n\t\tskb = iraw_encode(skb);\n\tif (!skb) {\n\t\tdev_err(cs->dev,\n\t\t\t"unable to allocate memory for encoding!\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_queue_tail(&bcs->squeue, skb);\n	f
56053	372	ila_nl_cmd_add_mapping	net/ipv6/ila/ila_xlat.c	&p	1	11	\N	\N	\tstruct net *net = genl_info_net(info);\n\tstruct ila_xlat_params p;\n\tint err;\n\n\terr = parse_nl_config(info, &p);\n\tif (err)\n\t\treturn err;\n\n\treturn ila_add_mapping(net, &p);\n	t
56766	5501	inet6_prefix_notify	net/ipv6/addrconf.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(idev->dev);\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet6_prefix_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);\n	t
61302	331	pipe_rcv_created	net/phonet/pep.c	type	1	11	\N	\N	\tstruct pep_sock *pn = pep_sk(sk);\n\tstruct pnpipehdr *hdr = pnp_hdr(skb);\n\tu8 n_sb = hdr->data[0];\n\n\tpn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\t__skb_pull(skb, sizeof(*hdr));\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[2], len = sizeof(buf);\n\t\tu8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\treturn -EINVAL;\n\t\tswitch (type) {\n	t
62593	1146	ubifs_sync_wbufs_by_inode	fs/ubifs/io.c	err	1	11	\N	\N	\tint i, err = 0;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tif (i == GCHD)\n\t\t\t/*\n\t\t\t * GC head is special, do not look at it. Even if the\n\t\t\t * head contains something related to this inode, it is\n\t\t\t * a _copy_ of corresponding on-flash node which sits\n\t\t\t * somewhere else.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (!wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\n\t\tif (err) {\n	t
62727	179	wilc_sdio_suspend	drivers/staging/wilc1000/wilc_sdio.c	ret	1	11	\N	\N	\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct wilc *wilc = sdio_get_drvdata(func);\n\tint ret;\n\n\tdev_info(dev, "sdio suspend\\n");\n\tchip_wakeup(wilc);\n\n\tif (!wilc->suspend_event) {\n\t\twilc_chip_sleep_manually(wilc);\n\t} else {\n\t\thost_sleep_notify(wilc);\n\t\tchip_allow_sleep(wilc);\n\t}\n\n\tret = sdio_reset(wilc);\n\tif (ret) {\n	t
63253	755	pl2303_tiocmset	drivers/usb/serial/pl2303.c	ret	1	11	\N	\N	\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (set & TIOCM_RTS)\n\t\tpriv->line_control |= CONTROL_RTS;\n\tif (set & TIOCM_DTR)\n\t\tpriv->line_control |= CONTROL_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tpriv->line_control &= ~CONTROL_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tpriv->line_control &= ~CONTROL_DTR;\n\tcontrol = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tret = pl2303_set_control_lines(port, control);\n\tif (ret)\n	t
867	333	wm8350_bat_get_charge_type	drivers/power/supply/wm8350_power.c	state	1	13	\N	\N	\tint state;\n\n\tstate = wm8350_reg_read(wm8350, WM8350_BATTERY_CHARGER_CONTROL_2) &\n\t    WM8350_CHG_STS_MASK;\n\tswitch (state) {\n	f
54668	1030	ath6kl_usb_bmi_write	drivers/net/wireless/ath/ath6kl/usb.c	ret	1	11	\N	\N	\tstruct ath6kl_usb *ar_usb = ar->hif_priv;\n\tint ret;\n\n\t/* send command */\n\tret = ath6kl_usb_submit_ctrl_out(ar_usb,\n\t\t\t\t\t ATH6KL_USB_CONTROL_REQ_SEND_BMI_CMD,\n\t\t\t\t\t 0, 0, buf, len);\n\tif (ret) {\n	t
3950	189	nfp_nsp_check	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.c	nfp_nsp_check_$tmp$obj	0	11	\N	\N	\tstruct nfp_cpp *cpp = state->cpp;\n\tu64 nsp_status, reg;\n\tu32 nsp_cpp;\n\tint err;\n\n\tnsp_cpp = nfp_resource_cpp_id(state->res);\n\tnsp_status = nfp_resource_address(state->res) + NSP_STATUS;\n\n\terr = nfp_cpp_readq(cpp, nsp_cpp, nsp_status, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (FIELD_GET(NSP_STATUS_MAGIC, reg) != NSP_MAGIC) {\n	t
42100	4493	alc_determine_headset_type	sound/pci/hda/patch_realtek.c	val	1	11	\N	\N	\tint val;\n\tbool is_ctia = false;\n\tstruct alc_spec *spec = codec->spec;\n\tstatic struct coef_fw coef0255[] = {\n\t\tWRITE_COEF(0x45, 0xd089), /* combo jack auto switch control(Check type)*/\n\t\tWRITE_COEF(0x49, 0x0149), /* combo jack auto switch control(Vref\n conteol) */\n\t\t{}\n\t};\n\tstatic struct coef_fw coef0288[] = {\n\t\tUPDATE_COEF(0x4f, 0xfcc0, 0xd400), /* Check Type */\n\t\t{}\n\t};\n\tstatic struct coef_fw coef0298[] = {\n\t\tUPDATE_COEF(0x50, 0x2000, 0x2000),\n\t\tUPDATE_COEF(0x56, 0x0006, 0x0006),\n\t\tUPDATE_COEF(0x66, 0x0008, 0),\n\t\tUPDATE_COEF(0x67, 0x2000, 0),\n\t\tUPDATE_COEF(0x19, 0x1300, 0x1300),\n\t\t{}\n\t};\n\tstatic struct coef_fw coef0293[] = {\n\t\tUPDATE_COEF(0x4a, 0x000f, 0x0008), /* Combo Jack auto detect */\n\t\tWRITE_COEF(0x45, 0xD429), /* Set to ctia type */\n\t\t{}\n\t};\n\tstatic struct coef_fw coef0688[] = {\n\t\tWRITE_COEF(0x11, 0x0001),\n\t\tWRITE_COEF(0xb7, 0x802b),\n\t\tWRITE_COEF(0x15, 0x0d60),\n\t\tWRITE_COEF(0xc3, 0x0c00),\n\t\t{}\n\t};\n\tstatic struct coef_fw coef0274[] = {\n\t\tUPDATE_COEF(0x4a, 0x0010, 0),\n\t\tUPDATE_COEF(0x4a, 0x8000, 0),\n\t\tWRITE_COEF(0x45, 0xd289),\n\t\tUPDATE_COEF(0x49, 0x0300, 0x0300),\n\t\t{}\n\t};\n\n\tswitch (codec->core.vendor_id) {\n\tcase 0x10ec0236:\n\tcase 0x10ec0255:\n\tcase 0x10ec0256:\n\t\talc_process_coef_fw(codec, coef0255);\n\t\tmsleep(300);\n\t\tval = alc_read_coef_idx(codec, 0x46);\n\t\tis_ctia = (val & 0x0070) == 0x0070;\n\t\tbreak;\n\tcase 0x10ec0234:\n\tcase 0x10ec0274:\n\tcase 0x10ec0294:\n\t\talc_process_coef_fw(codec, coef0274);\n\t\tmsleep(80);\n\t\tval = alc_read_coef_idx(codec, 0x46);\n\t\tis_ctia = (val & 0x00f0) == 0x00f0;\n\t\tbreak;\n\tcase 0x10ec0233:\n\tcase 0x10ec0283:\n\t\talc_write_coef_idx(codec, 0x45, 0xd029);\n\t\tmsleep(300);\n\t\tval = alc_read_coef_idx(codec, 0x46);\n\t\tis_ctia = (val & 0x0070) == 0x0070;\n\t\tbreak;\n\tcase 0x10ec0298:\n\t\tsnd_hda_codec_write(codec, 0x21, 0,\n\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE);\n\t\tmsleep(100);\n\t\tsnd_hda_codec_write(codec, 0x21, 0,\n\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL, 0x0);\n\t\tmsleep(200);\n\n\t\tval = alc_read_coef_idx(codec, 0x50);\n\t\tif (val & (1 << 12)) {\n	t
34478	383	btrfs_ioctl_fitrim	fs/btrfs/ioctl.c	btrfs_ioctl_fitrim_$__UNIQUE_ID_min2_282$obj	0	11	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_device *device;\n\tstruct request_queue *q;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tq = bdev_get_queue(device->bdev);\n\t\tif (blk_queue_discard(q)) {\n\t\t\tnum_devices++;\n\t\t\tminlen = min_t(u64, q->limits.discard_granularity,\n\t\t\t\t     minlen);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (range.start > total_bytes ||\n\t    range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.len = min(range.len, total_bytes - range.start);\n	t
36273	148	ceph_ioctl_set_layout_policy	fs/ceph/ioctl.c	&l	1	11	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t/* copy and validate */\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n	t
40750	372	netup_read_ci_status	drivers/media/pci/cx23885/cimax2.c	buf	13	12	\N	\N	\tstruct netup_ci_state *state =\n\t\t\tcontainer_of(work, struct netup_ci_state, work);\n\tu8 buf[33];\n\tint ret;\n\n\t/* CAM module IRQ processing. fast operation */\n\tdvb_ca_en50221_frda_irq(&state->ca, 0);\n\n\t/* CAM module INSERT/REMOVE processing. slow operation because of i2c\n\t * transfers */\n\tif (time_after(jiffies, state->next_status_checked_time)\n\t\t\t|| !state->status) {\n\t\tret = netup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t0, &buf[0], 33);\n\n\t\tstate->next_status_checked_time = jiffies\n\t\t\t+ msecs_to_jiffies(1000);\n\n\t\tif (ret != 0)\n\t\t\treturn;\n\n\t\tci_dbg_print("%s: Slot Status Addr=[0x%04x], Reg=[0x%02x], data=%02x, TS config = %02x\\n",\n\t\t\t     __func__,\tstate->ci_i2c_addr, 0, buf[0], buf[0]);\n\n\n\t\tif (buf[0] & 1)\n	t
44219	2896	ath6kl_wmi_set_host_sleep_mode_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	cmd->asleep	6	12	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_set_host_sleep_mode_cmd *cmd;\n\tint ret;\n\n\tif ((host_mode != ATH6KL_HOST_MODE_ASLEEP) &&\n\t    (host_mode != ATH6KL_HOST_MODE_AWAKE)) {\n\t\tath6kl_err("invalid host sleep mode: %d\\n", host_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_host_sleep_mode_cmd *) skb->data;\n\n\tif (host_mode == ATH6KL_HOST_MODE_ASLEEP) {\n\t\tath6kl_wmi_relinquish_implicit_pstream_credits(wmi);\n\t\tcmd->asleep = cpu_to_le32(1);\n	t
50483	2030	wm5100_micd_irq	sound/soc/codecs/wm5100.c	val	1	13	\N	\N	\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(wm5100->regmap, WM5100_MIC_DETECT_3, &val);\n\tif (ret != 0) {\n\t\tdev_err(wm5100->dev, "Failed to read microphone status: %d\\n",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tdev_dbg(wm5100->dev, "Microphone event: %x\\n", val);\n\n\tif (!(val & WM5100_ACCDET_VALID)) {\n\t\tdev_warn(wm5100->dev, "Microphone detection state invalid\\n");\n\t\treturn;\n\t}\n\n\t/* No accessory, reset everything and report removal */\n\tif (!(val & WM5100_ACCDET_STS)) {\n	f
45302	152	mext_page_double_lock	fs/ext4/move_extent.c	mapping[0]	1	11	\N	\N	\tstruct address_space *mapping[2];\n\tunsigned fl = AOP_FLAG_NOFS;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tpgoff_t tmp = index1;\n\t\tindex1 = index2;\n\t\tindex2 = tmp;\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tpage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\n	t
1768	1640	lstcon_group_debug	drivers/staging/lustre/lnet/selftest/console.c	lstcon_group_debug_$grp$obj	0	11	\N	\N	\tstruct lstcon_group *grp;\n\tint rc;\n\n\trc = lstcon_group_find(name, &grp);\n\tif (rc)\n\t\treturn -ENOENT;\n\n\trc = lstcon_debug_ndlist(&grp->grp_ndl_list, NULL,\n	t
54087	127	cb710_register_slot	drivers/misc/cb710/core.c	err	1	11	\N	\N	\tint nr = chip->slots;\n\tstruct cb710_slot *slot = &chip->slot[nr];\n\tint err;\n\n\tdev_dbg(cb710_chip_dev(chip),\n\t\t"register: %s.%d; slot %d; mask %d; IO offset: 0x%02X\\n",\n\t\tname, chip->platform_id, nr, slot_mask, io_offset);\n\n\t/* slot->irq_handler == NULL here; this needs to be\n\t * seen before platform_device_register() */\n\t++chip->slots;\n\tsmp_wmb();\n\n\tslot->iobase = chip->iobase + io_offset;\n\tslot->pdev.name = name;\n\tslot->pdev.id = chip->platform_id;\n\tslot->pdev.dev.parent = &chip->pdev->dev;\n\tslot->pdev.dev.release = cb710_release_slot;\n\n\terr = platform_device_register(&slot->pdev);\n\n#ifdef CONFIG_CB710_DEBUG_ASSUMPTIONS\n\tatomic_inc(&chip->slot_refs_count);\n#endif\n\n\tif (err) {\n	t
39034	1814	adm8211_probe	drivers/net/wireless/admtek/adm8211.c	reg	7	12	\N	\N	\tstruct ieee80211_hw *dev;\n\tstruct adm8211_priv *priv;\n\tunsigned long mem_addr, mem_len;\n\tunsigned int io_addr, io_len;\n\tint err;\n\tu32 reg;\n\tu8 perm_addr[ETH_ALEN];\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR "%s (adm8211): Cannot enable new PCI device\\n",\n\t\t       pci_name(pdev));\n\t\treturn err;\n\t}\n\n\tio_addr = pci_resource_start(pdev, 0);\n\tio_len = pci_resource_len(pdev, 0);\n\tmem_addr = pci_resource_start(pdev, 1);\n\tmem_len = pci_resource_len(pdev, 1);\n\tif (io_len < 256 || mem_len < 1024) {\n\t\tprintk(KERN_ERR "%s (adm8211): Too short PCI resources\\n",\n\t\t       pci_name(pdev));\n\t\tgoto err_disable_pdev;\n\t}\n\n\n\t/* check signature */\n\tpci_read_config_dword(pdev, 0x80 /* CR32 */, &reg);\n\tif (reg != ADM8211_SIG1 && reg != ADM8211_SIG2) {\n	t
31219	1337	__get_metadata_snap	drivers/md/dm-thin-metadata.c	sblock	1	11	\N	\N	\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n	t
58220	2294	snd_trident_spdif_pcm	sound/pci/trident/trident_main.c	spdif->name	6	12	\N	\N	\tstruct snd_pcm *spdif;\n\tint err;\n\n\tif ((err = snd_pcm_new(trident->card, "trident_dx_nx IEC958", device, 1, 0, &spdif)) < 0)\n\t\treturn err;\n\n\tspdif->private_data = trident;\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\tsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_ops);\n\t} else {\n\t\tsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_7018_ops);\n\t}\n\tspdif->info_flags = 0;\n\tstrcpy(spdif->name, "Trident 4DWave IEC958");\n	t
39758	302	btrtl_setup_rtl8723a	drivers/bluetooth/btrtl.c	fw->size	1	11	\N	\N	\tconst struct firmware *fw;\n\tint ret;\n\n\tBT_INFO("%s: rtl: loading rtl_bt/rtl8723a_fw.bin", hdev->name);\n\tret = request_firmware(&fw, "rtl_bt/rtl8723a_fw.bin", &hdev->dev);\n\tif (ret < 0) {\n\t\tBT_ERR("%s: Failed to load rtl_bt/rtl8723a_fw.bin", hdev->name);\n\t\treturn ret;\n\t}\n\n\tif (fw->size < 8) {\n	t
54260	279	__reiserfs_set_acl	fs/reiserfs/xattr_acl.c	error	1	11	\N	\N	\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n	t
3427	2426	ov5670_identify_module	drivers/media/i2c/ov5670.c	val	2	-11	\N	\N	\tstruct i2c_client *client = v4l2_get_subdevdata(&ov5670->sd);\n\tint ret;\n\tu32 val;\n\n\tret = ov5670_read_reg(ov5670, OV5670_REG_CHIP_ID,\n\t\t\t      OV5670_REG_VALUE_24BIT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != OV5670_CHIP_ID) {\n	t
35963	3791	b43_nphy_tx_power_fix	drivers/net/wireless/broadcom/b43/phy_n.c	txpi	1	13	\N	\N	\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_n *nphy = dev->phy.n;\n\tstruct ssb_sprom *sprom = dev->dev->bus_sprom;\n\n\tu8 txpi[2], bbmult, i;\n\tu16 tmp, radio_gain, dac_gain;\n\tu16 freq = phy->chandef->chan->center_freq;\n\tu32 txgain;\n\t/* u32 gaintbl; rev3+ */\n\n\tif (nphy->hang_avoid)\n\t\tb43_nphy_stay_in_carrier_search(dev, 1);\n\n\t/* TODO: rev19+ */\n\tif (dev->phy.rev >= 7) {\n\t\ttxpi[0] = txpi[1] = 30;\n\t} else if (dev->phy.rev >= 3) {\n\t\ttxpi[0] = 40;\n\t\ttxpi[1] = 40;\n\t} else if (sprom->revision < 4) {\n\t\ttxpi[0] = 72;\n\t\ttxpi[1] = 72;\n\t} else {\n\t\tif (b43_current_band(dev->wl) == NL80211_BAND_2GHZ) {\n\t\t\ttxpi[0] = sprom->txpid2g[0];\n\t\t\ttxpi[1] = sprom->txpid2g[1];\n\t\t} else if (freq >= 4900 && freq < 5100) {\n\t\t\ttxpi[0] = sprom->txpid5gl[0];\n\t\t\ttxpi[1] = sprom->txpid5gl[1];\n\t\t} else if (freq >= 5100 && freq < 5500) {\n\t\t\ttxpi[0] = sprom->txpid5g[0];\n\t\t\ttxpi[1] = sprom->txpid5g[1];\n\t\t} else if (freq >= 5500) {\n\t\t\ttxpi[0] = sprom->txpid5gh[0];\n\t\t\ttxpi[1] = sprom->txpid5gh[1];\n\t\t} else {\n\t\t\ttxpi[0] = 91;\n\t\t\ttxpi[1] = 91;\n\t\t}\n\t}\n\tif (dev->phy.rev < 7 &&\n\t    (txpi[0] < 40 || txpi[0] > 100 || txpi[1] < 40 || txpi[1] > 100))\n	f
38950	1515	devlink_nl_cmd_eswitch_get_doit	net/core/devlink.c	msg	1	13	\N	\N	\tstruct devlink *devlink = info->user_ptr[0];\n\tconst struct devlink_ops *ops = devlink->ops;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_eswitch_fill(msg, devlink, DEVLINK_CMD_ESWITCH_GET,\n	f
50238	206	dw_probe	sound/soc/intel/common/sst-firmware.c	chip	1	11	\N	\N	\tstruct dw_dma_chip *chip;\n\tint err;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchip->irq = irq;\n\tchip->regs = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(chip->regs))\n\t\treturn ERR_CAST(chip->regs);\n\n\terr = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(31));\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tchip->dev = dev;\n\n\terr = dw_dma_probe(chip);\n	t
32642	391	amdgpu_acpi_vfct_bios	drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c	amdgpu_acpi_vfct_bios_$vhdr$obj$1	0	11	\N	\N	\tstruct acpi_table_header *hdr;\n\tacpi_size tbl_size;\n\tUEFI_ACPI_VFCT *vfct;\n\tunsigned offset;\n\n\tif (!ACPI_SUCCESS(acpi_get_table("VFCT", 1, &hdr)))\n\t\treturn false;\n\ttbl_size = hdr->length;\n\tif (tbl_size < sizeof(UEFI_ACPI_VFCT)) {\n\t\tDRM_ERROR("ACPI VFCT table present but broken (too short #1)\\n");\n\t\treturn false;\n\t}\n\n\tvfct = (UEFI_ACPI_VFCT *)hdr;\n\toffset = vfct->VBIOSImageOffset;\n\n\twhile (offset < tbl_size) {\n\t\tGOP_VBIOS_CONTENT *vbios = (GOP_VBIOS_CONTENT *)((char *)hdr + offset);\n\t\tVFCT_IMAGE_HEADER *vhdr = &vbios->VbiosHeader;\n\n\t\toffset += sizeof(VFCT_IMAGE_HEADER);\n\t\tif (offset > tbl_size) {\n\t\t\tDRM_ERROR("ACPI VFCT image header truncated\\n");\n\t\t\treturn false;\n\t\t}\n\n\t\toffset += vhdr->ImageLength;\n\t\tif (offset > tbl_size) {\n\t\t\tDRM_ERROR("ACPI VFCT image truncated\\n");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (vhdr->ImageLength &&\n\t\t    vhdr->PCIBus == adev->pdev->bus->number &&\n\t\t    vhdr->PCIDevice == PCI_SLOT(adev->pdev->devfn) &&\n	t
40215	236	vmk80xx_reset_device	drivers/staging/comedi/drivers/vmk80xx.c	retval	1	11	\N	\N	\tstruct vmk80xx_private *devpriv = dev->private;\n\tsize_t size;\n\tint retval;\n\n\tsize = usb_endpoint_maxp(devpriv->ep_tx);\n\tmemset(devpriv->usb_tx_buf, 0, size);\n\tretval = vmk80xx_write_packet(dev, VMK8055_CMD_RST);\n\tif (retval)\n	t
43904	1979	cas_rx_process_pkt	drivers/net/ethernet/sun/cassini.c	skb	1	11	\N	\N	\tint dlen, hlen, len, i, alloclen;\n\tint off, swivel = RX_SWIVEL_OFF_VAL;\n\tstruct cas_page *page;\n\tstruct sk_buff *skb;\n\tvoid *addr, *crcaddr;\n\t__sum16 csum;\n\tchar *p;\n\n\thlen = CAS_VAL(RX_COMP2_HDR_SIZE, words[1]);\n\tdlen = CAS_VAL(RX_COMP1_DATA_SIZE, words[0]);\n\tlen  = hlen + dlen;\n\n\tif (RX_COPY_ALWAYS || (words[2] & RX_COMP3_SMALL_PKT))\n\t\talloclen = len;\n\telse\n\t\talloclen = max(hlen, RX_COPY_MIN);\n\n\tskb = netdev_alloc_skb(cp->dev, alloclen + swivel + cp->crc_size);\n\tif (skb == NULL)\n\t\treturn -1;\n\n\t*skbref = skb;\n\tskb_reserve(skb, swivel);\n	t
44213	3529	ca0132_cvoice_switch_set	sound/pci/hda/patch_ca0132.c	oldval	1	11	\N	\N	\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid;\n\tint i, ret = 0;\n\tunsigned int oldval;\n\n\tcodec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\\n",\n\t\t    spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);\n\n\ti = IN_EFFECT_START_NID - EFFECT_START_NID;\n\tnid = IN_EFFECT_START_NID;\n\t/* CrystalVoice affects all in effects */\n\tfor (; nid < IN_EFFECT_END_NID; nid++, i++)\n\t\tret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);\n\n\t/* including VoiceFX */\n\tret |= ca0132_voicefx_set(codec, (spec->voicefx_val ? 1 : 0));\n\n\t/* set correct vipsource */\n\toldval = stop_mic1(codec);\n\tret |= ca0132_set_vipsource(codec, 1);\n\tresume_mic1(codec, oldval);\n	t
52231	1155	perf_trace_btrfs_find_cluster	fs/btrfs/super.c	fs_info->fs_root	1	11	\N	\N	\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_key key;\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\tsb->s_flags |= SB_I_VERSION;\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\terr = super_setup_bdi(sb);\n\tif (err) {\n\t\tbtrfs_err(fs_info, "super_setup_bdi failed");\n\t\treturn err;\n\t}\n\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tbtrfs_err(fs_info, "open_ctree failed");\n\t\treturn err;\n\t}\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n	t
50557	1743	ath6kl_wmi_snr_threshold_event_rx	drivers/net/wireless/ath/ath6kl/wmi.c	&cmd	2	-11	\N	\N	\tstruct wmi_snr_threshold_event *reply;\n\tstruct sq_threshold_params *sq_thresh;\n\tstruct wmi_snr_threshold_params_cmd cmd;\n\tenum wmi_snr_threshold_val new_threshold;\n\tu8 upper_snr_threshold, lower_snr_threshold;\n\ts16 snr;\n\tint ret;\n\n\tif (len < sizeof(struct wmi_snr_threshold_event))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_snr_threshold_event *) datap;\n\n\tnew_threshold = (enum wmi_snr_threshold_val) reply->range;\n\tsnr = reply->snr;\n\n\tsq_thresh = &wmi->sq_threshld[SIGNAL_QUALITY_METRICS_SNR];\n\n\t/*\n\t * Identify the threshold breached and communicate that to the app.\n\t * After that install a new set of thresholds based on the signal\n\t * quality reported by the target.\n\t */\n\tif (new_threshold) {\n\t\t/* Upper threshold breached */\n\t\tif (snr < sq_thresh->upper_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   "spurious upper snr threshold event: %d\\n",\n\t\t\t\t   snr);\n\t\t} else if ((snr < sq_thresh->upper_threshold[1]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[0])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD1_ABOVE;\n\t\t} else if ((snr < sq_thresh->upper_threshold[2]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[1])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD2_ABOVE;\n\t\t} else if ((snr < sq_thresh->upper_threshold[3]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[2])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD3_ABOVE;\n\t\t} else if (snr >= sq_thresh->upper_threshold[3]) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD4_ABOVE;\n\t\t}\n\t} else {\n\t\t/* Lower threshold breached */\n\t\tif (snr > sq_thresh->lower_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   "spurious lower snr threshold event: %d\\n",\n\t\t\t\t   sq_thresh->lower_threshold[0]);\n\t\t} else if ((snr > sq_thresh->lower_threshold[1]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[0])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD4_BELOW;\n\t\t} else if ((snr > sq_thresh->lower_threshold[2]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[1])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD3_BELOW;\n\t\t} else if ((snr > sq_thresh->lower_threshold[3]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[2])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD2_BELOW;\n\t\t} else if (snr <= sq_thresh->lower_threshold[3]) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD1_BELOW;\n\t\t}\n\t}\n\n\t/* Calculate and install the next set of thresholds */\n\tlower_snr_threshold = ath6kl_wmi_get_lower_threshold(snr, sq_thresh,\n\t\t\t\t       sq_thresh->lower_threshold_valid_count);\n\tupper_snr_threshold = ath6kl_wmi_get_upper_threshold(snr, sq_thresh,\n\t\t\t\t       sq_thresh->upper_threshold_valid_count);\n\n\t/* Issue a wmi command to install the thresholds */\n\tcmd.thresh_above1_val = upper_snr_threshold;\n\tcmd.thresh_below1_val = lower_snr_threshold;\n\tcmd.weight = sq_thresh->weight;\n\tcmd.poll_time = cpu_to_le32(sq_thresh->polling_interval);\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "snr: %d, threshold: %d, lower: %d, upper: %d\\n",\n\t\t   snr, new_threshold,\n\t\t   lower_snr_threshold, upper_snr_threshold);\n\n\tret = ath6kl_wmi_send_snr_threshold_params(wmi, &cmd);\n	t
51349	150	discard_swap	mm/swapfile.c	err	1	13	\N	\N	\tstruct swap_extent *se;\n\tsector_t start_block;\n\tsector_t nr_blocks;\n\tint err = 0;\n\n\t/* Do not discard the swap header page! */\n\tse = &si->first_swap_extent;\n\tstart_block = (se->start_block + 1) << (PAGE_SHIFT - 9);\n\tnr_blocks = ((sector_t)se->nr_pages - 1) << (PAGE_SHIFT - 9);\n\tif (nr_blocks) {\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n	f
24212	461	sd_check_csd	drivers/staging/rts5208/sd.c	trans_speed	1	11	\N	\N	\tstruct sd_info *sd_card = &chip->sd_card;\n\tint retval;\n\tint i;\n\tu8 csd_ver, trans_speed;\n\tu8 rsp[16];\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (detect_card_cd(chip, SD_CARD) != STATUS_SUCCESS) {\n\t\t\tsd_set_err_code(chip, SD_NO_CARD);\n\t\t\trtsx_trace(chip);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = sd_send_cmd_get_rsp(chip, SEND_CSD, sd_card->sd_addr,\n\t\t\t\t\t     SD_RSP_TYPE_R2, rsp, 16);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\tif (i == 6) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tmemcpy(sd_card->raw_csd, rsp + 1, 15);\n\n\tdev_dbg(rtsx_dev(chip), "CSD Response:\\n");\n\tdev_dbg(rtsx_dev(chip), "%*ph\\n", 16, sd_card->raw_csd);\n\n\tcsd_ver = (rsp[1] & 0xc0) >> 6;\n\tdev_dbg(rtsx_dev(chip), "csd_ver = %d\\n", csd_ver);\n\n\ttrans_speed = rsp[4];\n\tif ((trans_speed & 0x07) == 0x02) {\n	t
29039	1251	fm_download_firmware	drivers/media/radio/wl128x/fmdrv_common.c	fm_download_firmware_$fw_entry$obj	0	11	\N	\N	\tconst struct firmware *fw_entry;\n\tstruct bts_header *fw_header;\n\tstruct bts_action *action;\n\tstruct bts_action_delay *delay;\n\tu8 *fw_data;\n\tint ret, fw_len, cmd_cnt;\n\n\tcmd_cnt = 0;\n\tset_bit(FM_FW_DW_INPROGRESS, &fmdev->flag);\n\n\tret = request_firmware(&fw_entry, fw_name,\n\t\t\t\t&fmdev->radio_dev->dev);\n\tif (ret < 0) {\n\t\tfmerr("Unable to read firmware(%s) content\\n", fw_name);\n\t\treturn ret;\n\t}\n\tfmdbg("Firmware(%s) length : %zu bytes\\n", fw_name, fw_entry->size);\n\n\tfw_data = (void *)fw_entry->data;\n	t
52868	781	capi_ioctl	drivers/isdn/capi/capi.c	&data.version	1	11	\N	\N	\tstruct capidev *cdev = file->private_data;\n\tcapi_ioctl_struct data;\n\tint retval = -EINVAL;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase CAPI_REGISTER:\n\t\tmutex_lock(&cdev->lock);\n\n\t\tif (cdev->ap.applid) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto register_out;\n\t\t}\n\t\tif (copy_from_user(&cdev->ap.rparam, argp,\n\t\t\t\t   sizeof(struct capi_register_params))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto register_out;\n\t\t}\n\t\tcdev->ap.private = cdev;\n\t\tcdev->ap.recv_message = capi_recv_message;\n\t\tcdev->errcode = capi20_register(&cdev->ap);\n\t\tretval = (int)cdev->ap.applid;\n\t\tif (cdev->errcode) {\n\t\t\tcdev->ap.applid = 0;\n\t\t\tretval = -EIO;\n\t\t}\n\nregister_out:\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn retval;\n\n\tcase CAPI_GET_VERSION:\n\t\tif (copy_from_user(&data.contr, argp,\n\t\t\t\t   sizeof(data.contr)))\n\t\t\treturn -EFAULT;\n\t\tcdev->errcode = capi20_get_version(data.contr, &data.version);\n	t
53262	1611	ocfs2_init	fs/ocfs2/super.c	ocfs2_init_@ocfs2_debugfs_root $obj	0	-11	\N	\N	\tint status;\n\n\tstatus = init_ocfs2_uptodate_cache();\n\tif (status < 0)\n\t\tgoto out1;\n\n\tstatus = ocfs2_initialize_mem_caches();\n\tif (status < 0)\n\t\tgoto out2;\n\n\tocfs2_debugfs_root = debugfs_create_dir("ocfs2", NULL);\n\tif (!ocfs2_debugfs_root) {\n	t
33404	903	patch_sigmatel_stac9700_3d	sound/pci/ac97/ac97_codec.c	patch_sigmatel_stac9700_3d_$kctl$obj$2$4	0	13	\N	\N	\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint mask = (kcontrol->private_value >> 16) & 0x0f;\n\tint lshift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES))\n\t\tuinfo->count = 2;\n\telse\n\t\tuinfo->count = 1;\n	f
27245	177	bfusb_tx_wakeup	drivers/bluetooth/bfusb.c	skb) < 0	1	13	\N	\N	\tstruct sk_buff *skb;\n\n\tBT_DBG("bfusb %p", data);\n\n\tif (test_and_set_bit(BFUSB_TX_PROCESS, &data->state)) {\n\t\tset_bit(BFUSB_TX_WAKEUP, &data->state);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tclear_bit(BFUSB_TX_WAKEUP, &data->state);\n\n\t\twhile ((atomic_read(&data->pending_tx) < BFUSB_MAX_BULK_TX) &&\n\t\t\t\t(skb = skb_dequeue(&data->transmit_q))) {\n\t\t\tif (bfusb_send_bulk(data, skb) < 0) {\n	f
43220	504	pca9685_pwm_probe	drivers/pwm/pwm-pca9685.c	&pca->chip	1	13	\N	\N	\tstruct pca9685 *pca;\n\tint ret;\n\tint mode2;\n\n\tpca = devm_kzalloc(&client->dev, sizeof(*pca), GFP_KERNEL);\n\tif (!pca)\n\t\treturn -ENOMEM;\n\n\tpca->regmap = devm_regmap_init_i2c(client, &pca9685_regmap_i2c_config);\n\tif (IS_ERR(pca->regmap)) {\n\t\tret = PTR_ERR(pca->regmap);\n\t\tdev_err(&client->dev, "Failed to initialize register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tpca->duty_ns = 0;\n\tpca->period_ns = PCA9685_DEFAULT_PERIOD;\n\n\ti2c_set_clientdata(client, pca);\n\n\tregmap_read(pca->regmap, PCA9685_MODE2, &mode2);\n\n\tif (device_property_read_bool(&client->dev, "invert"))\n\t\tmode2 |= MODE2_INVRT;\n\telse\n\t\tmode2 &= ~MODE2_INVRT;\n\n\tif (device_property_read_bool(&client->dev, "open-drain"))\n\t\tmode2 &= ~MODE2_OUTDRV;\n\telse\n\t\tmode2 |= MODE2_OUTDRV;\n\n\tregmap_write(pca->regmap, PCA9685_MODE2, mode2);\n\n\t/* clear all "full off" bits */\n\tregmap_write(pca->regmap, PCA9685_ALL_LED_OFF_L, 0);\n\tregmap_write(pca->regmap, PCA9685_ALL_LED_OFF_H, 0);\n\n\tpca->chip.ops = &pca9685_pwm_ops;\n\t/* add an extra channel for ALL_LED */\n\tpca->chip.npwm = PCA9685_MAXCHAN + 1;\n\n\tpca->chip.dev = &client->dev;\n\tpca->chip.base = -1;\n\n\tret = pwmchip_add(&pca->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pca9685_pwm_gpio_probe(pca);\n\tif (ret < 0) {\n\t\tpwmchip_remove(&pca->chip);\n	f
61963	442	rtl8723b_FirmwareDownload	drivers/staging/rtl8723bs/hal/rtl8723b_hal_init.c	fw->data	1	13	\N	\N	\ts32 rtStatus = _SUCCESS;\n\tu8 write_fw = 0;\n\tunsigned long fwdl_start_time;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct rt_firmware *pFirmware;\n\tstruct rt_firmware *pBTFirmware;\n\tstruct rt_firmware_hdr *pFwHdr = NULL;\n\tu8 *pFirmwareBuf;\n\tu32 FirmwareLen;\n\tconst struct firmware *fw;\n\tstruct device *device = dvobj_to_dev(padapter->dvobj);\n\tu8 *fwfilepath;\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tu8 tmp_ps;\n\n\tRT_TRACE(_module_hal_init_c_, _drv_info_, ("+%s\\n", __func__));\n#ifdef CONFIG_WOWLAN\n\tRT_TRACE(_module_hal_init_c_, _drv_notice_, ("+%s, bUsedWoWLANFw:%d\\n", __func__, bUsedWoWLANFw));\n#endif\n\tpFirmware = kzalloc(sizeof(struct rt_firmware), GFP_KERNEL);\n\tif (!pFirmware)\n\t\treturn _FAIL;\n\tpBTFirmware = kzalloc(sizeof(struct rt_firmware), GFP_KERNEL);\n\tif (!pBTFirmware) {\n\t\tkfree(pFirmware);\n\t\treturn _FAIL;\n\t}\n\ttmp_ps = rtw_read8(padapter, 0xa3);\n\ttmp_ps &= 0xf8;\n\ttmp_ps |= 0x02;\n\t/* 1. write 0xA3[:2:0] = 3b'010 */\n\trtw_write8(padapter, 0xa3, tmp_ps);\n\t/* 2. read power_state = 0xA0[1:0] */\n\ttmp_ps = rtw_read8(padapter, 0xa0);\n\ttmp_ps &= 0x03;\n\tif (tmp_ps != 0x01) {\n\t\tDBG_871X(FUNC_ADPT_FMT" tmp_ps =%x\\n", FUNC_ADPT_ARG(padapter), tmp_ps);\n\t\tpdbgpriv->dbg_downloadfw_pwr_state_cnt++;\n\t}\n\n#ifdef CONFIG_WOWLAN\n\tif (bUsedWoWLANFw)\n\t\tfwfilepath = "rtlwifi/rtl8723bs_wowlan.bin";\n\telse\n#endif /*  CONFIG_WOWLAN */\n\t\tfwfilepath = "rtlwifi/rtl8723bs_nic.bin";\n\n\tpr_info("rtl8723bs: acquire FW from file:%s\\n", fwfilepath);\n\n\trtStatus = request_firmware(&fw, fwfilepath, device);\n\tif (rtStatus) {\n\t\tpr_err("Request firmware failed with error 0x%x\\n", rtStatus);\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (!fw) {\n\t\tpr_err("Firmware %s not available\\n", fwfilepath);\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (fw->size > FW_8723B_SIZE) {\n\t\trtStatus = _FAIL;\n\t\tRT_TRACE(\n\t\t\t_module_hal_init_c_,\n\t\t\t_drv_err_,\n\t\t\t("Firmware size exceed 0x%X. Check it.\\n", FW_8188E_SIZE)\n\t\t);\n\t\tgoto exit;\n\t}\n\n\tpFirmware->szFwBuffer = kzalloc(fw->size, GFP_KERNEL);\n\tif (!pFirmware->szFwBuffer) {\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(pFirmware->szFwBuffer, fw->data, fw->size);\n	f
51337	451	hfsplus_symlink	fs/hfsplus/dir.c	inode	1	11	\N	\N	\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOMEM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, S_IFLNK | S_IRWXUGO);\n\tif (!inode)\n\t\tgoto out;\n\n\tres = page_symlink(inode, symname, strlen(symname) + 1);\n	t
40526	2311	ipw2100_alloc_skb	drivers/net/wireless/intel/ipw2x00/ipw2100.c	packet->skb->data	1	11	\N	\N	\tpacket->skb = dev_alloc_skb(sizeof(struct ipw2100_rx));\n\tif (!packet->skb)\n\t\treturn -ENOMEM;\n\n\tpacket->rxp = (struct ipw2100_rx *)packet->skb->data;\n\tpacket->dma_addr = pci_map_single(priv->pci_dev, packet->skb->data,\n	t
4837	151	pm860x_backlight_get_brightness	drivers/video/backlight/88pm860x_bl.c	pm860x_backlight_get_brightness_$data$obj$2$obj	0	11	\N	\N	\tstruct pm860x_backlight_data *data = bl_get_data(bl);\n\tstruct pm860x_chip *chip = data->chip;\n\tint ret;\n\n\tret = pm860x_reg_read(data->i2c, data->reg_duty_cycle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->current_brightness = ret;\n\tdev_dbg(chip->dev, "get brightness %d\\n", data->current_brightness);\n	t
20671	605	vmbus_close_internal	drivers/hv/channel.c	ret	1	11	\N	\N	\tstruct vmbus_channel_close_channel *msg;\n\tint ret;\n\n\t/*\n\t * vmbus_on_event(), running in the per-channel tasklet, can race\n\t * with vmbus_close_internal() in the case of SMP guest, e.g., when\n\t * the former is accessing channel->inbound.ring_buffer, the latter\n\t * could be freeing the ring_buffer pages, so here we must stop it\n\t * first.\n\t */\n\ttasklet_disable(&channel->callback_event);\n\n\t/*\n\t * In case a device driver's probe() fails (e.g.,\n\t * util_probe() -> vmbus_open() returns -ENOMEM) and the device is\n\t * rescinded later (e.g., we dynamically disable an Integrated Service\n\t * in Hyper-V Manager), the driver's remove() invokes vmbus_close():\n\t * here we should skip most of the below cleanup work.\n\t */\n\tif (channel->state != CHANNEL_OPENED_STATE) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tchannel->state = CHANNEL_OPEN_STATE;\n\tchannel->sc_creation_callback = NULL;\n\t/* Stop callback and cancel the timer asap */\n\tif (channel->target_cpu != get_cpu()) {\n\t\tput_cpu();\n\t\tsmp_call_function_single(channel->target_cpu, reset_channel_cb,\n\t\t\t\t\t channel, true);\n\t} else {\n\t\treset_channel_cb(channel);\n\t\tput_cpu();\n\t}\n\n\t/* Send a closing message */\n\n\tmsg = &channel->close_msg.msg;\n\n\tmsg->header.msgtype = CHANNELMSG_CLOSECHANNEL;\n\tmsg->child_relid = channel->offermsg.child_relid;\n\n\tret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel),\n\t\t\t     true);\n\n\tif (ret) {\n\t\tpr_err("Close failed: close post msg return is %d\\n", ret);\n\t\t/*\n\t\t * If we failed to post the close msg,\n\t\t * it is perhaps better to leak memory.\n\t\t */\n\t\tgoto out;\n\t}\n\n\t/* Tear down the gpadl for the channel's ring buffer */\n\tif (channel->ringbuffer_gpadlhandle) {\n\t\tret = vmbus_teardown_gpadl(channel,\n\t\t\t\t\t   channel->ringbuffer_gpadlhandle);\n\t\tif (ret) {\n	t
34104	303	vl6180_read_raw	drivers/iio/light/vl6180.c	ret	1	11	\N	\N	\tstruct vl6180_data *data = iio_priv(indio_dev);\n\tint ret, i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = vl6180_measure(data, chan->address);\n\t\tif (ret < 0)\n	t
61355	733	amdgpu_vce_ring_parse_cs	drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c	*size / 3	6	12	\N	\N	\tstruct amdgpu_ib *ib = &p->job->ibs[ib_idx];\n\tunsigned fb_idx = 0, bs_idx = 0;\n\tint session_idx = -1;\n\tuint32_t destroyed = 0;\n\tuint32_t created = 0;\n\tuint32_t allocated = 0;\n\tuint32_t tmp, handle = 0;\n\tuint32_t *size = &tmp;\n\tint i, r, idx = 0;\n\n\tp->job->vm = NULL;\n\tib->gpu_addr = amdgpu_sa_bo_gpu_addr(ib->sa_bo);\n\n\tr = amdgpu_cs_sysvm_access_required(p);\n\tif (r)\n\t\treturn r;\n\n\twhile (idx < ib->length_dw) {\n\t\tuint32_t len = amdgpu_get_ib_value(p, ib_idx, idx);\n\t\tuint32_t cmd = amdgpu_get_ib_value(p, ib_idx, idx + 1);\n\n\t\tif ((len < 8) || (len & 3)) {\n\t\t\tDRM_ERROR("invalid VCE command length (%d)!\\n", len);\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase 0x00000001: /* session */\n\t\t\thandle = amdgpu_get_ib_value(p, ib_idx, idx + 2);\n\t\t\tsession_idx = amdgpu_vce_validate_handle(p, handle,\n\t\t\t\t\t\t\t\t &allocated);\n\t\t\tif (session_idx < 0) {\n\t\t\t\tr = session_idx;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize = &p->adev->vce.img_size[session_idx];\n\t\t\tbreak;\n\n\t\tcase 0x00000002: /* task info */\n\t\t\tfb_idx = amdgpu_get_ib_value(p, ib_idx, idx + 6);\n\t\t\tbs_idx = amdgpu_get_ib_value(p, ib_idx, idx + 7);\n\t\t\tbreak;\n\n\t\tcase 0x01000001: /* create */\n\t\t\tcreated |= 1 << session_idx;\n\t\t\tif (destroyed & (1 << session_idx)) {\n\t\t\t\tdestroyed &= ~(1 << session_idx);\n\t\t\t\tallocated |= 1 << session_idx;\n\n\t\t\t} else if (!(allocated & (1 << session_idx))) {\n\t\t\t\tDRM_ERROR("Handle already in use!\\n");\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*size = amdgpu_get_ib_value(p, ib_idx, idx + 8) *\n\t\t\t\tamdgpu_get_ib_value(p, ib_idx, idx + 10) *\n\t\t\t\t8 * 3 / 2;\n\t\t\tbreak;\n\n\t\tcase 0x04000001: /* config extension */\n\t\tcase 0x04000002: /* pic control */\n\t\tcase 0x04000005: /* rate control */\n\t\tcase 0x04000007: /* motion estimation */\n\t\tcase 0x04000008: /* rdo */\n\t\tcase 0x04000009: /* vui */\n\t\tcase 0x05000002: /* auxiliary buffer */\n\t\tcase 0x05000009: /* clock table */\n\t\t\tbreak;\n\n\t\tcase 0x0500000c: /* hw config */\n\t\t\tswitch (p->adev->asic_type) {\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\t\t\tcase CHIP_KAVERI:\n\t\t\tcase CHIP_MULLINS:\n#endif\n\t\t\tcase CHIP_CARRIZO:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x03000001: /* encode */\n\t\t\tr = amdgpu_vce_cs_reloc(p, ib_idx, idx + 10, idx + 9,\n\t\t\t\t\t\t*size, 0);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\n\t\t\tr = amdgpu_vce_cs_reloc(p, ib_idx, idx + 12, idx + 11,\n	t
49324	356	amd8111_access	drivers/i2c/busses/i2c-amd8111.c	temp	1	11	\N	\N	\tstruct amd_smbus *smbus = adap->algo_data;\n\tunsigned char protocol, len, pec, temp[2];\n\tint i, status;\n\n\tprotocol = (read_write == I2C_SMBUS_READ) ? AMD_SMB_PRTCL_READ\n\t\t\t\t\t\t  : AMD_SMB_PRTCL_WRITE;\n\tpec = (flags & I2C_CLIENT_PEC) ? AMD_SMB_PRTCL_PEC : 0;\n\n\tswitch (size) {\n\t\tcase I2C_SMBUS_QUICK:\n\t\t\tprotocol |= AMD_SMB_PRTCL_QUICK;\n\t\t\tread_write = I2C_SMBUS_WRITE;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BYTE:\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD,\n\t\t\t\t\t\t      command);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BYTE;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\t      data->byte);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BYTE_DATA;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\t      data->word & 0xff);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\t\t      data->word >> 8);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_WORD_DATA | pec;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t\t    I2C_SMBUS_BLOCK_MAX);\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t  amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t       data->block[i + 1]);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_BLOCK_DATA | pec;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t    I2C_SMBUS_BLOCK_MAX);\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t  amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t       data->block[i + 1]);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\tprotocol |= AMD_SMB_PRTCL_I2C_BLOCK_DATA;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t      data->word & 0xff);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\t      data->word >> 8);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tprotocol = AMD_SMB_PRTCL_PROC_CALL | pec;\n\t\t\tread_write = I2C_SMBUS_READ;\n\t\t\tbreak;\n\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t    I2C_SMBUS_BLOCK_MAX - 1);\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\t      data->block[i + 1]);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tprotocol = AMD_SMB_PRTCL_BLOCK_PROC_CALL | pec;\n\t\t\tread_write = I2C_SMBUS_READ;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(&adap->dev, "Unsupported transaction %d\\n", size);\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatus = amd_ec_write(smbus, AMD_SMB_ADDR, addr << 1);\n\tif (status)\n\t\treturn status;\n\tstatus = amd_ec_write(smbus, AMD_SMB_PRTCL, protocol);\n\tif (status)\n\t\treturn status;\n\n\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\tif (status)\n\t\treturn status;\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tudelay(500);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tmsleep(1);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif ((~temp[0] & AMD_SMB_STS_DONE) || (temp[0] & AMD_SMB_STS_STATUS))\n	t
51660	1103	dlm_send_regions	fs/ocfs2/dlm/dlmdomain.c	ret	1	13	\N	\N	\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t/* if local hb, the numregions will be zero */\n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, "Region %.*s\\n", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, "Sending regions to node %d\\n", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n	f
8601	475	tun_select_queue	drivers/net/tun.c	txq	1	11	\N	\N	\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_flow_entry *e;\n\tu32 txq = 0;\n\tu32 numqueues = 0;\n\n\trcu_read_lock();\n\tnumqueues = ACCESS_ONCE(tun->numqueues);\n\n\ttxq = __skb_get_hash_symmetric(skb);\n\tif (txq) {\n	t
54496	386	asihpi_adapter_probe	sound/pci/asihpi/hpioctl.c	asihpi_adapter_probe_$pci$0$0$obj	0	11	\N	\N	\tint idx, nm, low_latency_mode = 0, irq_supported = 0;\n\tint adapter_index;\n\tunsigned int memlen;\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tstruct hpi_adapter adapter;\n\tstruct hpi_pci pci;\n\n\tmemset(&adapter, 0, sizeof(adapter));\n\n\tdev_printk(KERN_DEBUG, &pci_dev->dev,\n\t\t"probe %04x:%04x,%04x:%04x,%04x\\n", pci_dev->vendor,\n\t\tpci_dev->device, pci_dev->subsystem_vendor,\n\t\tpci_dev->subsystem_device, pci_dev->devfn);\n\n\tif (pci_enable_device(pci_dev) < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t"pci_enable_device failed, disabling device\\n");\n\t\treturn -EIO;\n\t}\n\n\tpci_set_master(pci_dev);\t/* also sets latency timer if < 16 */\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_CREATE_ADAPTER);\n\thpi_init_response(&hr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CREATE_ADAPTER,\n\t\tHPI_ERROR_PROCESSING_MESSAGE);\n\n\thm.adapter_index = HPI_ADAPTER_INDEX_INVALID;\n\n\tnm = HPI_MAX_ADAPTER_MEM_SPACES;\n\n\tfor (idx = 0; idx < nm; idx++) {\n\t\tHPI_DEBUG_LOG(INFO, "resource %d %pR\\n", idx,\n\t\t\t&pci_dev->resource[idx]);\n\n\t\tif (pci_resource_flags(pci_dev, idx) & IORESOURCE_MEM) {\n\t\t\tmemlen = pci_resource_len(pci_dev, idx);\n\t\t\tpci.ap_mem_base[idx] =\n\t\t\t\tioremap(pci_resource_start(pci_dev, idx),\n\t\t\t\tmemlen);\n\t\t\tif (!pci.ap_mem_base[idx]) {\n	t
62120	654	hash_netnet4_resize	net/netfilter/ipset/ip_set_hash_netnet.c	hash_netnet4_resize_$m$obj$2	0	11	\N	\N	\N	t
2758	1299	spmi_regulator_init_slew_rate	drivers/regulator/qcom_spmi-regulator.c	ret	1	11	\N	\N	\tint ret;\n\tu8 reg = 0;\n\tint step, delay, slew_rate, step_delay;\n\tconst struct spmi_voltage_range *range;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);\n\tif (ret) {\n	t
60611	4947	sgl_map_user_pages	drivers/scsi/st.c	pages[j]	18	12	\N	\N	\tunsigned long end = (uaddr + count + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = uaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint res, i, j;\n\tstruct page **pages;\n\tstruct rq_map_data *mdata = &STbp->map_data;\n\n\t/* User attempted Overflow! */\n\tif ((uaddr + count) < uaddr)\n\t\treturn -EINVAL;\n\n\t/* Too big */\n        if (nr_pages > max_pages)\n\t\treturn -ENOMEM;\n\n\t/* Hmm? */\n\tif (count == 0)\n\t\treturn 0;\n\n\tif ((pages = kmalloc(max_pages * sizeof(*pages), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n        /* Try to fault in all of the necessary pages */\n        /* rw==READ means read from drive, write into memory area */\n\tres = get_user_pages_unlocked(\n\t\tuaddr,\n\t\tnr_pages,\n\t\tpages,\n\t\trw == READ ? FOLL_WRITE : 0); /* don't force */\n\n\t/* Errors and no page mapped should return here */\n\tif (res < nr_pages)\n\t\tgoto out_unmap;\n\n        for (i=0; i < nr_pages; i++) {\n                /* FIXME: flush superflous for rw==READ,\n                 * probably wrong function for rw==WRITE\n                 */\n\t\tflush_dcache_page(pages[i]);\n        }\n\n\tmdata->offset = uaddr & ~PAGE_MASK;\n\tSTbp->mapped_pages = pages;\n\n\treturn nr_pages;\n out_unmap:\n\tif (res > 0) {\n\t\tfor (j=0; j < res; j++)\n\t\t\tput_page(pages[j]);\n	t
26806	2124	cdv_intel_dp_init	drivers/gpu/drm/gma500/cdv_intel_dp.c	ret	1	11	\N	\N	\tstruct gma_encoder *gma_encoder;\n\tstruct gma_connector *gma_connector;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct cdv_intel_dp *intel_dp;\n\tconst char *name = NULL;\n\tint type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\tgma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\n\tif (!gma_encoder)\n\t\treturn;\n        gma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\n        if (!gma_connector)\n                goto err_connector;\n\tintel_dp = kzalloc(sizeof(struct cdv_intel_dp), GFP_KERNEL);\n\tif (!intel_dp)\n\t        goto err_priv;\n\n\tif ((output_reg == DP_C) && cdv_intel_dpc_is_edp(dev))\n\t\ttype = DRM_MODE_CONNECTOR_eDP;\n\n\tconnector = &gma_connector->base;\n\tencoder = &gma_encoder->base;\n\n\tdrm_connector_init(dev, connector, &cdv_intel_dp_connector_funcs, type);\n\tdrm_encoder_init(dev, encoder, &cdv_intel_dp_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_TMDS, NULL);\n\n\tgma_connector_attach_encoder(gma_connector, gma_encoder);\n\n\tif (type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\tgma_encoder->type = INTEL_OUTPUT_DISPLAYPORT;\n        else\n\t\tgma_encoder->type = INTEL_OUTPUT_EDP;\n\n\n\tgma_encoder->dev_priv=intel_dp;\n\tintel_dp->encoder = gma_encoder;\n\tintel_dp->output_reg = output_reg;\n\t\n\tdrm_encoder_helper_add(encoder, &cdv_intel_dp_helper_funcs);\n\tdrm_connector_helper_add(connector, &cdv_intel_dp_connector_helper_funcs);\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\tdrm_connector_register(connector);\n\n\t/* Set up the DDC bus. */\n\tswitch (output_reg) {\n\t\tcase DP_B:\n\t\t\tname = "DPDDC-B";\n\t\t\tgma_encoder->ddi_select = (DP_MASK | DDI0_SELECT);\n\t\t\tbreak;\n\t\tcase DP_C:\n\t\t\tname = "DPDDC-C";\n\t\t\tgma_encoder->ddi_select = (DP_MASK | DDI1_SELECT);\n\t\t\tbreak;\n\t}\n\n\tcdv_disable_intel_clock_gating(dev);\n\n\tcdv_intel_dp_i2c_init(gma_connector, gma_encoder, name);\n        /* FIXME:fail check */\n\tcdv_intel_dp_add_properties(connector);\n\n\tif (is_edp(gma_encoder)) {\n\t\tint ret;\n\t\tstruct edp_power_seq cur;\n                u32 pp_on, pp_off, pp_div;\n\t\tu32 pwm_ctrl;\n\n\t\tpp_on = REG_READ(PP_CONTROL);\n\t\tpp_on &= ~PANEL_UNLOCK_MASK;\n\t        pp_on |= PANEL_UNLOCK_REGS;\n\t\t\n\t\tREG_WRITE(PP_CONTROL, pp_on);\n\n\t\tpwm_ctrl = REG_READ(BLC_PWM_CTL2);\n\t\tpwm_ctrl |= PWM_PIPE_B;\n\t\tREG_WRITE(BLC_PWM_CTL2, pwm_ctrl);\n\n                pp_on = REG_READ(PP_ON_DELAYS);\n                pp_off = REG_READ(PP_OFF_DELAYS);\n                pp_div = REG_READ(PP_DIVISOR);\n\t\n\t\t/* Pull timing values out of registers */\n                cur.t1_t3 = (pp_on & PANEL_POWER_UP_DELAY_MASK) >>\n                        PANEL_POWER_UP_DELAY_SHIFT;\n\n                cur.t8 = (pp_on & PANEL_LIGHT_ON_DELAY_MASK) >>\n                        PANEL_LIGHT_ON_DELAY_SHIFT;\n\n                cur.t9 = (pp_off & PANEL_LIGHT_OFF_DELAY_MASK) >>\n                        PANEL_LIGHT_OFF_DELAY_SHIFT;\n\n                cur.t10 = (pp_off & PANEL_POWER_DOWN_DELAY_MASK) >>\n                        PANEL_POWER_DOWN_DELAY_SHIFT;\n\n                cur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>\n                               PANEL_POWER_CYCLE_DELAY_SHIFT);\n\n                DRM_DEBUG_KMS("cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\\n",\n                              cur.t1_t3, cur.t8, cur.t9, cur.t10, cur.t11_t12);\n\n\n\t\tintel_dp->panel_power_up_delay = cur.t1_t3 / 10;\n                intel_dp->backlight_on_delay = cur.t8 / 10;\n                intel_dp->backlight_off_delay = cur.t9 / 10;\n                intel_dp->panel_power_down_delay = cur.t10 / 10;\n                intel_dp->panel_power_cycle_delay = (cur.t11_t12 - 1) * 100;\n\n                DRM_DEBUG_KMS("panel power up delay %d, power down delay %d, power cycle delay %d\\n",\n                              intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,\n                              intel_dp->panel_power_cycle_delay);\n\n                DRM_DEBUG_KMS("backlight on delay %d, off delay %d\\n",\n                              intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);\n\n\n\t\tcdv_intel_edp_panel_vdd_on(gma_encoder);\n\t\tret = cdv_intel_dp_aux_native_read(gma_encoder, DP_DPCD_REV,\n\t\t\t\t\t       intel_dp->dpcd,\n\t\t\t\t\t       sizeof(intel_dp->dpcd));\n\t\tcdv_intel_edp_panel_vdd_off(gma_encoder);\n\t\tif (ret == 0) {\n	t
38165	1378	eeepc_acpi_init	drivers/platform/x86/eeepc-laptop.c	eeepc->cm_supported	1	11	\N	\N	\tunsigned int init_flags;\n\tint result;\n\n\tresult = acpi_bus_get_status(eeepc->device);\n\tif (result)\n\t\treturn result;\n\tif (!eeepc->device->status.present) {\n\t\tpr_err("Hotkey device not present, aborting\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tinit_flags = DISABLE_ASL_WLAN | DISABLE_ASL_DISPLAYSWITCH;\n\tpr_notice("Hotkey init flags 0x%x\\n", init_flags);\n\n\tif (write_acpi_int(eeepc->handle, "INIT", init_flags)) {\n\t\tpr_err("Hotkey initialization failed\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* get control methods supported */\n\tif (read_acpi_int(eeepc->handle, "CMSG", &eeepc->cm_supported)) {\n\t\tpr_err("Get control methods supported failed\\n");\n\t\treturn -ENODEV;\n\t}\n\tcmsg_quirks(eeepc);\n\tpr_info("Get control methods supported: 0x%x\\n", eeepc->cm_supported);\n	t
55392	896	mlxsw_sx_port_set_link_ksettings	drivers/net/ethernet/mellanox/mlxsw/switchx2.c	eth_proto_admin	1	11	\N	\N	\tstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\n\tstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\n\tchar ptys_pl[MLXSW_REG_PTYS_LEN];\n\tu32 speed;\n\tu32 eth_proto_new;\n\tu32 eth_proto_cap;\n\tu32 eth_proto_admin;\n\tu32 advertising;\n\tbool is_up;\n\tint err;\n\n\tspeed = cmd->base.speed;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\teth_proto_new = cmd->base.autoneg == AUTONEG_ENABLE ?\n\t\tmlxsw_sx_to_ptys_advert_link(advertising) :\n\t\tmlxsw_sx_to_ptys_speed(speed);\n\n\tmlxsw_reg_ptys_eth_pack(ptys_pl, mlxsw_sx_port->local_port, 0);\n\terr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\n\tif (err) {\n\t\tnetdev_err(dev, "Failed to get proto");\n\t\treturn err;\n\t}\n\tmlxsw_reg_ptys_eth_unpack(ptys_pl, &eth_proto_cap, &eth_proto_admin,\n\t\t\t\t  NULL);\n\n\teth_proto_new = eth_proto_new & eth_proto_cap;\n\tif (!eth_proto_new) {\n\t\tnetdev_err(dev, "Not supported proto admin requested");\n\t\treturn -EINVAL;\n\t}\n\tif (eth_proto_new == eth_proto_admin)\n	t
53273	81	fuse_direntplus_link	fs/fuse/dir.c	fuse_direntplus_link_$nr.addr.i$obj	0	11	\N	\N	\tif (sec || nsec) {\n\t\tstruct timespec64 ts = {\n\t\t\tsec,\n\t\t\tmin_t(u32, nsec, NSEC_PER_SEC - 1)\n\t\t};\n\n\t\treturn get_jiffies_64() + timespec64_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}\n\n/*\n * Set dentry and possibly attribute timeouts from the lookup/mk*\n * replies\n	t
61645	301	input_action_end_dx2	net/ipv6/seg6_local.c	skb	6	12	\N	\N	\tstruct net *net = dev_net(skb->dev);\n\tstruct net_device *odev;\n\tstruct ethhdr *eth;\n\n\tif (!decap_and_validate(skb, NEXTHDR_NONE))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, ETH_HLEN))\n\t\tgoto drop;\n\n\tskb_reset_mac_header(skb);\n\teth = (struct ethhdr *)skb->data;\n\n\t/* To determine the frame's protocol, we assume it is 802.3. This avoids\n\t * a call to eth_type_trans(), which is not really relevant for our\n\t * use case.\n\t */\n\tif (!eth_proto_is_802_3(eth->h_proto))\n\t\tgoto drop;\n\n\todev = dev_get_by_index_rcu(net, slwt->oif);\n\tif (!odev)\n\t\tgoto drop;\n\n\t/* As we accept Ethernet frames, make sure the egress device is of\n\t * the correct type.\n\t */\n\tif (odev->type != ARPHRD_ETHER)\n\t\tgoto drop;\n\n\tif (!(odev->flags & IFF_UP) || !netif_carrier_ok(odev))\n\t\tgoto drop;\n\n\tskb_orphan(skb);\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\tif (skb->len - ETH_HLEN > odev->mtu)\n\t\tgoto drop;\n\n\tskb->dev = odev;\n\tskb->protocol = eth->h_proto;\n\n\treturn dev_queue_xmit(skb);\n	t
57111	1187	efx_ef10_alloc_vis	drivers/net/ethernet/sfc/ef10.c	outlen	1	11	\N	\N	\tMCDI_DECLARE_BUF(inbuf, MC_CMD_ALLOC_VIS_IN_LEN);\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_ALLOC_VIS_OUT_LEN);\n\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, ALLOC_VIS_IN_MIN_VI_COUNT, min_vis);\n\tMCDI_SET_DWORD(inbuf, ALLOC_VIS_IN_MAX_VI_COUNT, max_vis);\n\trc = efx_mcdi_rpc(efx, MC_CMD_ALLOC_VIS, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (outlen < MC_CMD_ALLOC_VIS_OUT_LEN)\n	t
22829	4907	xlog_recover_cancel_intents	fs/xfs/xfs_log_recover.c	&cur)	1	11	\N	\N	\tstruct xfs_log_item\t*lip;\n\tint\t\t\terror = 0;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\t/*\n\t\t * We're done when we see something other than an intent.\n\t\t * There should be no intents left in the AIL now.\n\t\t */\n\t\tif (!xlog_item_is_intent(lip)) {\n#ifdef DEBUG\n\t\t\tfor (; lip; lip = xfs_trans_ail_cursor_next(ailp, &cur))\n	t
26576	286	gfs2_find_jhead	fs/gfs2/recovery.c	lh_1.lh_sequence	1	11	\N	\N	\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n	t
37501	270	hpfs_add_to_dnode	fs/hpfs/dnode.c	&qbh	1	11	\N	\N	\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err("out of memory, can't add to dnode\\n");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, "%s(): namelen == %d", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "hpfs_add_to_dnode")) {\n\t\t\thpfs_brelse4(&qbh);\n	t
55459	541	show_hdmi_cable	drivers/platform/x86/alienware-wmi.c	status	1	-11	\N	\N	\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus =\n\t    alienware_wmax_command(&in_args, WMAX_METHOD_HDMI_CABLE,\n\t\t\t\t   (u32 *) &out_data);\n\tif (ACPI_SUCCESS(status)) {\n	t
54774	1380	wm8350_mic_handler	sound/soc/codecs/wm8350.c	reg	1	11	\N	\N	\tstruct wm8350_data *priv = data;\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tu16 reg;\n\tint report = 0;\n\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\n\ttrace_snd_soc_jack_irq("WM8350 mic");\n#endif\n\n\treg = wm8350_reg_read(wm8350, WM8350_JACK_PIN_STATUS);\n\tif (reg & WM8350_JACK_MICSCD_LVL)\n\t\treport |= priv->mic.short_report;\n\tif (reg & WM8350_JACK_MICSD_LVL)\n	t
46495	253	acpi_fan_get_fif	drivers/acpi/fan.c	status	1	11	\N	\N	\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\tstruct acpi_buffer format = { sizeof("NNNN"), "NNNN" };\n\tstruct acpi_buffer fif = { sizeof(fan->fif), &fan->fif };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(device->handle, "_FIF", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n	t
54870	78	hmm_vm_clean	drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_vm.c	node	1	11	\N	\N	\tstruct hmm_vm_node *node, *tmp;\n\tstruct list_head new_head;\n\n\tif (!vm)\n\t\treturn;\n\n\tspin_lock(&vm->lock);\n\tlist_replace_init(&vm->vm_node_list, &new_head);\n\tspin_unlock(&vm->lock);\n\n\tlist_for_each_entry_safe(node, tmp, &new_head, list) {\n	t
22534	1461	xfs_qm_mount_quotas	fs/xfs/xfs_qm.c	mp	1	11	\N	\N	\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, "Cannot turn on quotas for realtime filesystem");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n	t
33430	129	clps711x_keypad_probe	drivers/input/keyboard/clps711x-keypad.c	err	1	11	\N	\N	\tstruct clps711x_keypad_data *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct input_polled_dev *poll_dev;\n\tu32 poll_interval;\n\tint i, err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->syscon =\n\t\tsyscon_regmap_lookup_by_compatible("cirrus,ep7209-syscon1");\n\tif (IS_ERR(priv->syscon))\n\t\treturn PTR_ERR(priv->syscon);\n\n\tpriv->row_count = of_gpio_named_count(np, "row-gpios");\n\tif (priv->row_count < 1)\n\t\treturn -EINVAL;\n\n\tpriv->gpio_data = devm_kzalloc(dev,\n\t\t\t\tsizeof(*priv->gpio_data) * priv->row_count,\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->gpio_data)\n\t\treturn -ENOMEM;\n\n\tpriv->row_shift = get_count_order(CLPS711X_KEYPAD_COL_COUNT);\n\n\tfor (i = 0; i < priv->row_count; i++) {\n\t\tstruct clps711x_gpio_data *data = &priv->gpio_data[i];\n\n\t\tdata->desc = devm_gpiod_get_index(dev, "row", i, GPIOD_IN);\n\t\tif (IS_ERR(data->desc))\n\t\t\treturn PTR_ERR(data->desc);\n\t}\n\n\terr = of_property_read_u32(np, "poll-interval", &poll_interval);\n\tif (err)\n	t
36647	577	pcan_usb_fd_decode_status	drivers/net/can/usb/peak_usb/pcan_usb_fd.c	skb	1	11	\N	\N	\tstruct pucan_status_msg *sm = (struct pucan_status_msg *)rx_msg;\n\tstruct peak_usb_device *dev = usb_if->dev[pucan_stmsg_get_channel(sm)];\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\n\tenum can_state rx_state, tx_state;\n\tstruct net_device *netdev = dev->netdev;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t/* nothing should be sent while in BUS_OFF state */\n\tif (dev->can.state == CAN_STATE_BUS_OFF)\n\t\treturn 0;\n\n\tif (sm->channel_p_w_b & PUCAN_BUS_BUSOFF) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (sm->channel_p_w_b & PUCAN_BUS_PASSIVE) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (sm->channel_p_w_b & PUCAN_BUS_WARNING) {\n\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t} else {\n\t\t/* no error bit (so, no error skb, back to active state) */\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tpdev->bec.txerr = 0;\n\t\tpdev->bec.rxerr = 0;\n\t\treturn 0;\n\t}\n\n\t/* state hasn't changed */\n\tif (new_state == dev->can.state)\n\t\treturn 0;\n\n\t/* handle bus state change */\n\ttx_state = (pdev->bec.txerr >= pdev->bec.rxerr) ? new_state : 0;\n\trx_state = (pdev->bec.txerr <= pdev->bec.rxerr) ? new_state : 0;\n\n\t/* allocate an skb to store the error frame */\n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (skb)\n\t\tcan_change_state(netdev, cf, tx_state, rx_state);\n\n\t/* things must be done even in case of OOM */\n\tif (new_state == CAN_STATE_BUS_OFF)\n\t\tcan_bus_off(netdev);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tpeak_usb_netif_rx(skb, &usb_if->time_ref,\n	t
8263	368	pt_req_sense	drivers/block/paride/pt.c	buf	6	12	\N	\N	\tchar rs_cmd[12] = { ATAPI_REQ_SENSE, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r;\n\n\tr = pt_command(tape, rs_cmd, 16, "Request sense");\n\tmdelay(1);\n\tif (!r)\n\t\tpt_completion(tape, buf, "Request sense");\n\n\ttape->last_sense = -1;\n\tif (!r) {\n\t\tif (!quiet)\n\t\t\tprintk("%s: Sense key: %x, ASC: %x, ASQ: %x\\n",\n	t
28952	401	prepare6	drivers/infiniband/sw/rxe/rxe_net.c	dst	1	13	\N	\N	\tstruct rxe_qp *qp = pkt->qp;\n\tstruct dst_entry *dst;\n\tstruct in6_addr *saddr = &av->sgid_addr._sockaddr_in6.sin6_addr;\n\tstruct in6_addr *daddr = &av->dgid_addr._sockaddr_in6.sin6_addr;\n\n\tdst = rxe_find_route(rxe, qp, av);\n\tif (!dst) {\n	f
30701	2286	atl1c_request_irq	drivers/net/ethernet/atheros/atl1c/atl1c_main.c	err	1	13	\N	\N	\tstruct pci_dev    *pdev   = adapter->pdev;\n\tstruct net_device *netdev = adapter->netdev;\n\tint flags = 0;\n\tint err = 0;\n\n\tadapter->have_msi = true;\n\terr = pci_enable_msi(adapter->pdev);\n\tif (err) {\n	f
62574	1971	batadv_nc_init_debugfs	net/batman-adv/network-coding.c	file	1	13	\N	\N	\tstruct dentry *nc_dir, *file;\n\n\tnc_dir = debugfs_create_dir("nc", bat_priv->debug_dir);\n\tif (!nc_dir)\n\t\tgoto out;\n\n\tfile = debugfs_create_u8("min_tq", 0644, nc_dir, &bat_priv->nc.min_tq);\n\tif (!file)\n	f
101030	470	ieee80211_manage_rx_ba_offl	net/mac80211/agg-rx.c	sta	1	11	\N	\N	\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tsta = sta_info_get_bss(sdata, addr);\n\tif (!sta)\n	t
47575	454	ovl_cache_update_ino	fs/overlayfs/readdir.c	this	1	13	\N	\N	\tstruct dentry *dir = path->dentry;\n\tstruct dentry *this = NULL;\n\tenum ovl_path_type type;\n\tu64 ino = p->real_ino;\n\tint err = 0;\n\n\tif (!ovl_same_sb(dir->d_sb))\n\t\tgoto out;\n\n\tif (p->name[0] == '.') {\n\t\tif (p->len == 1) {\n\t\t\tthis = dget(dir);\n\t\t\tgoto get;\n\t\t}\n\t\tif (p->len == 2 && p->name[1] == '.') {\n\t\t\t/* we shall not be moved */\n\t\t\tthis = dget(dir->d_parent);\n\t\t\tgoto get;\n\t\t}\n\t}\n\tthis = lookup_one_len(p->name, dir, p->len);\n\tif (IS_ERR_OR_NULL(this) || !this->d_inode) {\n	f
29121	1604	amdgpu_fill_buffer	drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c	amdgpu_fill_buffer_$job$obj	0	11	\N	\N	\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\t/* max_bytes applies to SDMA_OP_PTEPDE as well as SDMA_OP_CONST_FILL*/\n\tuint32_t max_bytes = adev->mman.buffer_funcs->fill_max_bytes;\n\tstruct amdgpu_ring *ring = adev->mman.buffer_funcs_ring;\n\n\tstruct drm_mm_node *mm_node;\n\tunsigned long num_pages;\n\tunsigned int num_loops, num_dw;\n\n\tstruct amdgpu_job *job;\n\tint r;\n\n\tif (!ring->ready) {\n\t\tDRM_ERROR("Trying to clear memory with ring turned off.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bo->tbo.mem.mem_type == TTM_PL_TT) {\n\t\tr = amdgpu_ttm_bind(&bo->tbo, &bo->tbo.mem);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tnum_pages = bo->tbo.num_pages;\n\tmm_node = bo->tbo.mem.mm_node;\n\tnum_loops = 0;\n\twhile (num_pages) {\n\t\tuint32_t byte_count = mm_node->size << PAGE_SHIFT;\n\n\t\tnum_loops += DIV_ROUND_UP(byte_count, max_bytes);\n\t\tnum_pages -= mm_node->size;\n\t\t++mm_node;\n\t}\n\n\t/* 10 double words for each SDMA_OP_PTEPDE cmd */\n\tnum_dw = num_loops * 10;\n\n\t/* for IB padding */\n\tnum_dw += 64;\n\n\tr = amdgpu_job_alloc_with_ib(adev, num_dw * 4, &job);\n\tif (r)\n\t\treturn r;\n\n\tif (resv) {\n\t\tr = amdgpu_sync_resv(adev, &job->sync, resv,\n	t
26100	321	pciehp_check_link_status	drivers/pci/hotplug/pciehp_hpc.c	lnk_status	1	11	\N	\N	\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tbool found;\n\tu16 lnk_status;\n\n\t/*\n\t * Data Link Layer Link Active Reporting must be capable for\n\t * hot-plug capable downstream port. But old controller might\n\t * not implement it. In this case, we wait for 1000 ms.\n\t*/\n\tif (ctrl->link_active_reporting)\n\t\tpcie_wait_link_active(ctrl);\n\telse\n\t\tmsleep(1000);\n\n\t/* wait 100ms before read pci conf, and try in 1s */\n\tmsleep(100);\n\tfound = pci_bus_check_dev(ctrl->pcie->port->subordinate,\n\t\t\t\t\tPCI_DEVFN(0, 0));\n\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\n\tctrl_dbg(ctrl, "%s: lnk_status = %x\\n", __func__, lnk_status);\n\tif ((lnk_status & PCI_EXP_LNKSTA_LT) ||\n	t
38508	6580	__e1000_resume	drivers/net/ethernet/intel/e1000e/netdev.c	phy_data	6	12	\N	\N	\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\tpci_set_master(pdev);\n\n\tif (hw->mac.type >= e1000_pch2lan)\n\t\te1000_resume_workarounds_pchlan(&adapter->hw);\n\n\te1000e_power_up_phy(adapter);\n\n\t/* report the system wakeup cause from S3/S4 */\n\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(&adapter->hw, BM_WUS, &phy_data);\n\t\tif (phy_data) {\n	t
47400	119	ufshcd_parse_clock_info	drivers/scsi/ufs/ufshcd-pltfrm.c	clki->name	1	11	\N	\N	\tint ret = 0;\n\tint cnt;\n\tint i;\n\tstruct device *dev = hba->dev;\n\tstruct device_node *np = dev->of_node;\n\tchar *name;\n\tu32 *clkfreq = NULL;\n\tstruct ufs_clk_info *clki;\n\tint len = 0;\n\tsize_t sz = 0;\n\n\tif (!np)\n\t\tgoto out;\n\n\tcnt = of_property_count_strings(np, "clock-names");\n\tif (!cnt || (cnt == -EINVAL)) {\n\t\tdev_info(dev, "%s: Unable to find clocks, assuming enabled\\n",\n\t\t\t\t__func__);\n\t} else if (cnt < 0) {\n\t\tdev_err(dev, "%s: count clock strings failed, err %d\\n",\n\t\t\t\t__func__, cnt);\n\t\tret = cnt;\n\t}\n\n\tif (cnt <= 0)\n\t\tgoto out;\n\n\tif (!of_get_property(np, "freq-table-hz", &len)) {\n\t\tdev_info(dev, "freq-table-hz property not specified\\n");\n\t\tgoto out;\n\t}\n\n\tif (len <= 0)\n\t\tgoto out;\n\n\tsz = len / sizeof(*clkfreq);\n\tif (sz != 2 * cnt) {\n\t\tdev_err(dev, "%s len mismatch\\n", "freq-table-hz");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tclkfreq = devm_kzalloc(dev, sz * sizeof(*clkfreq),\n\t\t\tGFP_KERNEL);\n\tif (!clkfreq) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_u32_array(np, "freq-table-hz",\n\t\t\tclkfreq, sz);\n\tif (ret && (ret != -EINVAL)) {\n\t\tdev_err(dev, "%s: error reading array %d\\n",\n\t\t\t\t"freq-table-hz", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < sz; i += 2) {\n\t\tret = of_property_read_string_index(np,\n\t\t\t\t"clock-names", i/2, (const char **)&name);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tclki = devm_kzalloc(dev, sizeof(*clki), GFP_KERNEL);\n\t\tif (!clki) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tclki->min_freq = clkfreq[i];\n\t\tclki->max_freq = clkfreq[i+1];\n\t\tclki->name = kstrdup(name, GFP_KERNEL);\n\t\tdev_dbg(dev, "%s: min %u max %u name %s\\n", "freq-table-hz",\n	t
48286	1230	fat_add_new_entries	fs/fat/dir.c	bhs	1	11	\N	\N	\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t/*\n\t * The minimum cluster size is 512bytes, and maximum entry\n\t * size is 32*slots (672bytes).  So, iff the cluster size is\n\t * 512bytes, we may need two clusters.\n\t */\n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t/*\n\t * First stage: Fill the directory entry.  NOTE: This cluster\n\t * is not referenced from any inode yet, so updates order is\n\t * not important.\n\t */\n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n	t
35861	665	aa_pivotroot	security/apparmor/mount.c	aa_pivotroot_$__lvec$obj$0$obj$10	0	13	\N	\N	\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\tget_buffers(old_buffer, new_buffer);\n\ttarget = fn_label_build(label, profile, GFP_ATOMIC,\n	f
59579	4161	thin_ctr	drivers/md/dm-thin.c	tc->origin_dev	1	11	\N	\N	\tint r;\n\tstruct thin_c *tc;\n\tstruct dm_dev *pool_dev, *origin_dev;\n\tstruct mapped_device *pool_md;\n\tunsigned long flags;\n\n\tmutex_lock(&dm_thin_pool_table.mutex);\n\n\tif (argc != 2 && argc != 3) {\n\t\tti->error = "Invalid argument count";\n\t\tr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\ttc = ti->private = kzalloc(sizeof(*tc), GFP_KERNEL);\n\tif (!tc) {\n\t\tti->error = "Out of memory";\n\t\tr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ttc->thin_md = dm_table_get_md(ti->table);\n\tspin_lock_init(&tc->lock);\n\tINIT_LIST_HEAD(&tc->deferred_cells);\n\tbio_list_init(&tc->deferred_bio_list);\n\tbio_list_init(&tc->retry_on_resume_list);\n\ttc->sort_bio_list = RB_ROOT;\n\n\tif (argc == 3) {\n\t\tr = dm_get_device(ti, argv[2], FMODE_READ, &origin_dev);\n\t\tif (r) {\n\t\t\tti->error = "Error opening origin device";\n\t\t\tgoto bad_origin_dev;\n\t\t}\n\t\ttc->origin_dev = origin_dev;\n\t}\n\n\tr = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &pool_dev);\n\tif (r) {\n\t\tti->error = "Error opening pool device";\n\t\tgoto bad_pool_dev;\n\t}\n\ttc->pool_dev = pool_dev;\n\n\tif (read_dev_id(argv[1], (unsigned long long *)&tc->dev_id, 0)) {\n\t\tti->error = "Invalid device id";\n\t\tr = -EINVAL;\n\t\tgoto bad_common;\n\t}\n\n\tpool_md = dm_get_md(tc->pool_dev->bdev->bd_dev);\n\tif (!pool_md) {\n\t\tti->error = "Couldn't get pool mapped device";\n\t\tr = -EINVAL;\n\t\tgoto bad_common;\n\t}\n\n\ttc->pool = __pool_table_lookup(pool_md);\n\tif (!tc->pool) {\n\t\tti->error = "Couldn't find pool object";\n\t\tr = -EINVAL;\n\t\tgoto bad_pool_lookup;\n\t}\n\t__pool_inc(tc->pool);\n\n\tif (get_pool_mode(tc->pool) == PM_FAIL) {\n\t\tti->error = "Couldn't open thin device, Pool is in fail mode";\n\t\tr = -EINVAL;\n\t\tgoto bad_pool;\n\t}\n\n\tr = dm_pool_open_thin_device(tc->pool->pmd, tc->dev_id, &tc->td);\n\tif (r) {\n\t\tti->error = "Couldn't open thin internal device";\n\t\tgoto bad_pool;\n\t}\n\n\tr = dm_set_target_max_io_len(ti, tc->pool->sectors_per_block);\n\tif (r)\n\t\tgoto bad;\n\n\tti->num_flush_bios = 1;\n\tti->flush_supported = true;\n\tti->per_io_data_size = sizeof(struct dm_thin_endio_hook);\n\n\t/* In case the pool supports discards, pass them on. */\n\tif (tc->pool->pf.discard_enabled) {\n\t\tti->discards_supported = true;\n\t\tti->num_discard_bios = 1;\n\t\tti->split_discard_bios = false;\n\t}\n\n\tmutex_unlock(&dm_thin_pool_table.mutex);\n\n\tspin_lock_irqsave(&tc->pool->lock, flags);\n\tif (tc->pool->suspended) {\n\t\tspin_unlock_irqrestore(&tc->pool->lock, flags);\n\t\tmutex_lock(&dm_thin_pool_table.mutex); /* reacquire for __pool_dec */\n\t\tti->error = "Unable to activate thin device while pool is suspended";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tatomic_set(&tc->refcount, 1);\n\tinit_completion(&tc->can_destroy);\n\tlist_add_tail_rcu(&tc->list, &tc->pool->active_thins);\n\tspin_unlock_irqrestore(&tc->pool->lock, flags);\n\t/*\n\t * This synchronize_rcu() call is needed here otherwise we risk a\n\t * wake_worker() call finding no bios to process (because the newly\n\t * added tc isn't yet visible).  So this reduces latency since we\n\t * aren't then dependent on the periodic commit to wake_worker().\n\t */\n\tsynchronize_rcu();\n\n\tdm_put(pool_md);\n\n\treturn 0;\n\nbad:\n\tdm_pool_close_thin_device(tc->td);\nbad_pool:\n\t__pool_dec(tc->pool);\nbad_pool_lookup:\n\tdm_put(pool_md);\nbad_common:\n\tdm_put_device(ti, tc->pool_dev);\nbad_pool_dev:\n\tif (tc->origin_dev)\n	t
8340	229	gss_wrap_kerberos_v1	net/sunrpc/auth_gss/gss_krb5_wrap.c	md5cksum.data	1	11	\N	\N	\tchar\t\t\tcksumdata[GSS_KRB5_MAX_CKSUM_LEN];\n\tstruct xdr_netobj\tmd5cksum = {.len = sizeof(cksumdata),\n\t\t\t\t\t    .data = cksumdata};\n\tint\t\t\tblocksize = 0, plainlen;\n\tunsigned char\t\t*ptr, *msg_start;\n\ts32\t\t\tnow;\n\tint\t\t\theadlen;\n\tstruct page\t\t**tmp_pages;\n\tu32\t\t\tseq_send;\n\tu8\t\t\t*cksumkey;\n\tu32\t\t\tconflen = kctx->gk5e->conflen;\n\n\tdprintk("RPC:       %s\\n", __func__);\n\n\tnow = get_seconds();\n\n\tblocksize = crypto_skcipher_blocksize(kctx->enc);\n\tgss_krb5_add_padding(buf, offset, blocksize);\n\tBUG_ON((buf->len - offset) % blocksize);\n\tplainlen = conflen + buf->len - offset;\n\n\theadlen = g_token_size(&kctx->mech_used,\n\t\tGSS_KRB5_TOK_HDR_LEN + kctx->gk5e->cksumlength + plainlen) -\n\t\t(buf->len - offset);\n\n\tptr = buf->head[0].iov_base + offset;\n\t/* shift data to make room for header. */\n\txdr_extend_head(buf, offset, headlen);\n\n\t/* XXX Would be cleverer to encrypt while copying. */\n\tBUG_ON((buf->len - offset - headlen) % blocksize);\n\n\tg_make_token_header(&kctx->mech_used,\n\t\t\t\tGSS_KRB5_TOK_HDR_LEN +\n\t\t\t\tkctx->gk5e->cksumlength + plainlen, &ptr);\n\n\n\t/* ptr now at header described in rfc 1964, section 1.2.1: */\n\tptr[0] = (unsigned char) ((KG_TOK_WRAP_MSG >> 8) & 0xff);\n\tptr[1] = (unsigned char) (KG_TOK_WRAP_MSG & 0xff);\n\n\tmsg_start = ptr + GSS_KRB5_TOK_HDR_LEN + kctx->gk5e->cksumlength;\n\n\t/*\n\t * signalg and sealalg are stored as if they were converted from LE\n\t * to host endian, even though they're opaque pairs of bytes according\n\t * to the RFC.\n\t */\n\t*(__le16 *)(ptr + 2) = cpu_to_le16(kctx->gk5e->signalg);\n\t*(__le16 *)(ptr + 4) = cpu_to_le16(kctx->gk5e->sealalg);\n\tptr[6] = 0xff;\n\tptr[7] = 0xff;\n\n\tgss_krb5_make_confounder(msg_start, conflen);\n\n\tif (kctx->gk5e->keyed_cksum)\n\t\tcksumkey = kctx->cksum;\n\telse\n\t\tcksumkey = NULL;\n\n\t/* XXXJBF: UGH!: */\n\ttmp_pages = buf->pages;\n\tbuf->pages = pages;\n\tif (make_checksum(kctx, ptr, 8, buf, offset + headlen - conflen,\n\t\t\t\t\tcksumkey, KG_USAGE_SEAL, &md5cksum))\n\t\treturn GSS_S_FAILURE;\n\tbuf->pages = tmp_pages;\n\n\tmemcpy(ptr + GSS_KRB5_TOK_HDR_LEN, md5cksum.data, md5cksum.len);\n	t
23548	1935	do_journal_release	fs/reiserfs/journal.c	&myth	2	-11	\N	\N	\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !sb_rdonly(sb)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n	t
31137	1074	ppl_load	drivers/md/raid5-ppl.c	ret	1	11	\N	\N	\tint ret = 0;\n\tu32 signature = 0;\n\tbool signature_set = false;\n\tint i;\n\n\tfor (i = 0; i < ppl_conf->count; i++) {\n\t\tstruct ppl_log *log = &ppl_conf->child_logs[i];\n\n\t\t/* skip missing drive */\n\t\tif (!log->rdev)\n\t\t\tcontinue;\n\n\t\tret = ppl_load_distributed(log);\n\t\tif (ret)\n	t
40923	216	lp8788_backlight_register	drivers/video/backlight/lp8788_bl.c	&props	1	11	\N	\N	\tstruct backlight_device *bl_dev;\n\tstruct backlight_properties props;\n\tstruct lp8788_backlight_platform_data *pdata = bl->pdata;\n\tint init_brt;\n\tchar *name;\n\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\n\t/* Initial brightness */\n\tif (pdata)\n\t\tinit_brt = min_t(int, pdata->initial_brightness,\n\t\t\t\tprops.max_brightness);\n\telse\n\t\tinit_brt = 0;\n\n\tprops.brightness = init_brt;\n\n\t/* Backlight device name */\n\tif (!pdata || !pdata->name)\n\t\tname = DEFAULT_BL_NAME;\n\telse\n\t\tname = pdata->name;\n\n\tbl_dev = backlight_device_register(name, bl->lp->dev, bl,\n	t
42976	1485	atomisp_pci_probe	drivers/staging/media/atomisp/pci/atomisp2/atomisp_v4l2.c	isp->wdt_work_queue	1	11	\N	\N	\tconst struct atomisp_platform_data *pdata;\n\tstruct atomisp_device *isp;\n\tunsigned int start;\n\tvoid __iomem *base;\n\tint err, val;\n\tu32 irq;\n\n\tif (!dev) {\n\t\tdev_err(&dev->dev, "atomisp: error device ptr\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_valid_device(dev, id))\n\t\treturn -ENODEV;\n\t/* Pointer to struct device. */\n\tatomisp_dev = &dev->dev;\n\n\tpdata = atomisp_get_platform_data();\n\tif (pdata == NULL)\n\t\tdev_warn(&dev->dev, "no platform data available\\n");\n\n\terr = pcim_enable_device(dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, "Failed to enable CI ISP device (%d)\\n",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tstart = pci_resource_start(dev, ATOM_ISP_PCI_BAR);\n\tdev_dbg(&dev->dev, "start: 0x%x\\n", start);\n\n\terr = pcim_iomap_regions(dev, 1 << ATOM_ISP_PCI_BAR, pci_name(dev));\n\tif (err) {\n\t\tdev_err(&dev->dev, "Failed to I/O memory remapping (%d)\\n",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tbase = pcim_iomap_table(dev)[ATOM_ISP_PCI_BAR];\n\tdev_dbg(&dev->dev, "base: %p\\n", base);\n\n\tatomisp_io_base = base;\n\n\tdev_dbg(&dev->dev, "atomisp_io_base: %p\\n", atomisp_io_base);\n\n\tisp = devm_kzalloc(&dev->dev, sizeof(struct atomisp_device), GFP_KERNEL);\n\tif (!isp) {\n\t\tdev_err(&dev->dev, "Failed to alloc CI ISP structure\\n");\n\t\treturn -ENOMEM;\n\t}\n\tisp->pdev = dev;\n\tisp->dev = &dev->dev;\n\tisp->sw_contex.power_state = ATOM_ISP_POWER_UP;\n\tisp->pci_root = pci_get_bus_and_slot(0, 0);\n\tif (!isp->pci_root) {\n\t\tdev_err(&dev->dev, "Unable to find PCI host\\n");\n\t\treturn -ENODEV;\n\t}\n\tisp->saved_regs.ispmmadr = start;\n\n\trt_mutex_init(&isp->mutex);\n\tmutex_init(&isp->streamoff_mutex);\n\tspin_lock_init(&isp->lock);\n\n\t/* This is not a true PCI device on SoC, so the delay is not needed. */\n\tisp->pdev->d3_delay = 0;\n\n\tswitch (id->device & ATOMISP_PCI_DEVICE_SOC_MASK) {\n\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD:\n\t\tisp->media_dev.hw_revision =\n\t\t\t(ATOMISP_HW_REVISION_ISP2400\n\t\t\t << ATOMISP_HW_REVISION_SHIFT) |\n\t\t\tATOMISP_HW_STEPPING_B0;\n\n\t\tswitch (id->device) {\n\t\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:\n\t\t\tisp->dfs = &dfs_config_merr_1179;\n\t\t\tbreak;\n\t\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD_117A:\n\t\t\tisp->dfs = &dfs_config_merr_117a;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->dfs = &dfs_config_merr;\n\t\t\tbreak;\n\t\t}\n\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_BYT:\n\t\tisp->media_dev.hw_revision =\n\t\t\t(ATOMISP_HW_REVISION_ISP2400\n\t\t\t << ATOMISP_HW_REVISION_SHIFT) |\n\t\t\tATOMISP_HW_STEPPING_B0;\n#ifdef FIXME\t\t\t\n\t\tif (INTEL_MID_BOARD(3, TABLET, BYT, BLK, PRO, CRV2) ||\n\t\t\tINTEL_MID_BOARD(3, TABLET, BYT, BLK, ENG, CRV2)) {\n\t\t\tisp->dfs = &dfs_config_byt_cr;\n\t\t\tisp->hpll_freq = HPLL_FREQ_2000MHZ;\n\t\t} else\n#endif\t\t\n\t\t{\n\t\t\tisp->dfs = &dfs_config_byt;\n\t\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\t}\n\t\t/* HPLL frequency is known to be device-specific, but we don't\n\t\t * have specs yet for exactly how it varies.  Default to\n\t\t * BYT-CR but let provisioning set it via EFI variable */\n\t\tisp->hpll_freq = gmin_get_var_int(&dev->dev, "HpllFreq",\n\t\t\t\t\tHPLL_FREQ_2000MHZ);\n\n\t\t/*\n\t\t * for BYT/CHT we are put isp into D3cold to avoid pci registers access\n\t\t * in power off. Set d3cold_delay to 0 since default 100ms is not\n\t\t * necessary.\n\t\t */\n\t\tisp->pdev->d3cold_delay = 0;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_ANN:\n\t\tisp->media_dev.hw_revision = (\n#ifdef ISP2401_NEW_INPUT_SYSTEM\n\t\t\t ATOMISP_HW_REVISION_ISP2401\n#else\n\t\t\t ATOMISP_HW_REVISION_ISP2401_LEGACY\n#endif\n\t\t\t << ATOMISP_HW_REVISION_SHIFT);\n\t\tisp->media_dev.hw_revision |= isp->pdev->revision < 2 ?\n\t\t\tATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;\n\t\tisp->dfs = &dfs_config_merr;\n\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_CHT:\n\t\tisp->media_dev.hw_revision = (\n#ifdef ISP2401_NEW_INPUT_SYSTEM\n\t\t\t ATOMISP_HW_REVISION_ISP2401\n#else\n\t\t\t ATOMISP_HW_REVISION_ISP2401_LEGACY\n#endif\n\t\t\t<< ATOMISP_HW_REVISION_SHIFT);\n\t\tisp->media_dev.hw_revision |= isp->pdev->revision < 2 ?\n\t\t\t ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;\n\n\t\tisp->dfs = &dfs_config_cht;\n\t\tisp->pdev->d3cold_delay = 0;\n\n\t\tval = intel_mid_msgbus_read32(CCK_PORT, CCK_FUSE_REG_0);\n\t\tswitch (val & CCK_FUSE_HPLL_FREQ_MASK) {\n\t\tcase 0x00:\n\t\t\tisp->hpll_freq = HPLL_FREQ_800MHZ;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tisp->hpll_freq = HPLL_FREQ_2000MHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\t\tdev_warn(isp->dev,\n\t\t\t\t "read HPLL from cck failed.default 1600MHz.\\n");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, "un-supported IUNIT device\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&dev->dev, "ISP HPLL frequency base = %d MHz\\n",\n\t\t isp->hpll_freq);\n\n\tisp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;\n\n\t/* Load isp firmware from user space */\n\tif (!defer_fw_load) {\n\t\tisp->firmware = atomisp_load_firmware(isp);\n\t\tif (!isp->firmware) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto load_fw_fail;\n\t\t}\n\n\t\terr = atomisp_css_check_firmware_version(isp);\n\t\tif (err) {\n\t\t\tdev_dbg(&dev->dev, "Firmware version check failed\\n");\n\t\t\tgoto fw_validation_fail;\n\t\t}\n\t}\n\n\tpci_set_master(dev);\n\tpci_set_drvdata(dev, isp);\n\n\terr = pci_enable_msi(dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, "Failed to enable msi (%d)\\n", err);\n\t\tgoto enable_msi_fail;\n\t}\n\n\tatomisp_msi_irq_init(isp, dev);\n\n\tpm_qos_add_request(&isp->pm_qos, PM_QOS_CPU_DMA_LATENCY,\n\t\t\t   PM_QOS_DEFAULT_VALUE);\n\n\t/*\n\t * for MRFLD, Software/firmware needs to write a 1 to bit 0 of\n\t * the register at CSI_RECEIVER_SELECTION_REG to enable SH CSI\n\t * backend write 0 will enable Arasan CSI backend, which has\n\t * bugs(like sighting:4567697 and 4567699) and will be removed\n\t * in B0\n\t */\n\tatomisp_store_uint32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);\n\n\tif ((id->device & ATOMISP_PCI_DEVICE_SOC_MASK) ==\n\t\t\tATOMISP_PCI_DEVICE_SOC_MRFLD) {\n\t\tu32 csi_afe_trim;\n\n\t\t/*\n\t\t * Workaround for imbalance data eye issue which is observed\n\t\t * on TNG B0.\n\t\t */\n\t\tpci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,\n\t\t\t\t      &csi_afe_trim);\n\t\tcsi_afe_trim &= ~((MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t\tMRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t\tMRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t\tMRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT));\n\t\tcsi_afe_trim |= (MRFLD_PCI_CSI1_HSRXCLKTRIM <<\n\t\t\t\t\tMRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t(MRFLD_PCI_CSI2_HSRXCLKTRIM <<\n\t\t\t\t\tMRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t(MRFLD_PCI_CSI3_HSRXCLKTRIM <<\n\t\t\t\t\tMRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT);\n\t\tpci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,\n\t\t\t\t      csi_afe_trim);\n\t}\n\n\terr = atomisp_initialize_modules(isp);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, "atomisp_initialize_modules (%d)\\n", err);\n\t\tgoto initialize_modules_fail;\n\t}\n\n\terr = atomisp_register_entities(isp);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, "atomisp_register_entities failed (%d)\\n",\n\t\t\terr);\n\t\tgoto register_entities_fail;\n\t}\n\terr = atomisp_create_pads_links(isp);\n\tif (err < 0)\n\t\tgoto register_entities_fail;\n\t/* init atomisp wdts */\n\tif (init_atomisp_wdts(isp) != 0)\n\t\tgoto wdt_work_queue_fail;\n\n\t/* save the iunit context only once after all the values are init'ed. */\n\tatomisp_save_iunit_reg(isp);\n\n\tpm_runtime_put_noidle(&dev->dev);\n\tpm_runtime_allow(&dev->dev);\n\n\thmm_init_mem_stat(repool_pgnr, dypool_enable, dypool_pgnr);\n\terr = hmm_pool_register(repool_pgnr, HMM_POOL_TYPE_RESERVED);\n\tif (err) {\n\t\tdev_err(&dev->dev, "Failed to register reserved memory pool.\\n");\n\t\tgoto hmm_pool_fail;\n\t}\n\n\t/* Init ISP memory management */\n\thmm_init();\n\n\terr = devm_request_threaded_irq(&dev->dev, dev->irq,\n\t\t\t\t\tatomisp_isr, atomisp_isr_thread,\n\t\t\t\t\tIRQF_SHARED, "isp_irq", isp);\n\tif (err) {\n\t\tdev_err(&dev->dev, "Failed to request irq (%d)\\n", err);\n\t\tgoto request_irq_fail;\n\t}\n\n\t/* Load firmware into ISP memory */\n\tif (!defer_fw_load) {\n\t\terr = atomisp_css_load_firmware(isp);\n\t\tif (err) {\n\t\t\tdev_err(&dev->dev, "Failed to init css.\\n");\n\t\t\tgoto css_init_fail;\n\t\t}\n\t} else {\n\t\tdev_dbg(&dev->dev, "Skip css init.\\n");\n\t}\n\t/* Clear FW image from memory */\n\trelease_firmware(isp->firmware);\n\tisp->firmware = NULL;\n\tisp->css_env.isp_css_fw.data = NULL;\n\n\tatomisp_drvfs_init(&atomisp_pci_driver, isp);\n\n\treturn 0;\n\ncss_init_fail:\n\tdevm_free_irq(&dev->dev, dev->irq, isp);\nrequest_irq_fail:\n\thmm_cleanup();\n\thmm_pool_unregister(HMM_POOL_TYPE_RESERVED);\nhmm_pool_fail:\n\tdestroy_workqueue(isp->wdt_work_queue);\n	t
45852	5140	hdsp_request_fw_loader	sound/pci/rme9652/hdsp.c	fw->size	1	11	\N	\N	\tconst char *fwfile;\n\tconst struct firmware *fw;\n\tint err;\n\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\treturn 0;\n\tif (hdsp->io_type == Undefined) {\n\t\tif ((err = hdsp_get_iobox_version(hdsp)) < 0)\n\t\t\treturn err;\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\t\treturn 0;\n\t}\n\n\t/* caution: max length of firmware filename is 30! */\n\tswitch (hdsp->io_type) {\n\tcase RPM:\n\t\tfwfile = "rpm_firmware.bin";\n\t\tbreak;\n\tcase Multiface:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\tfwfile = "multiface_firmware.bin";\n\t\telse\n\t\t\tfwfile = "multiface_firmware_rev11.bin";\n\t\tbreak;\n\tcase Digiface:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\tfwfile = "digiface_firmware.bin";\n\t\telse\n\t\t\tfwfile = "digiface_firmware_rev11.bin";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdsp->card->dev,\n\t\t\t"invalid io_type %d\\n", hdsp->io_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (request_firmware(&fw, fwfile, &hdsp->pci->dev)) {\n\t\tdev_err(hdsp->card->dev,\n\t\t\t"cannot load firmware %s\\n", fwfile);\n\t\treturn -ENOENT;\n\t}\n\tif (fw->size < HDSP_FIRMWARE_SIZE) {\n	t
61137	702	qt2_attach	drivers/usb/serial/quatech2.c	status	1	13	\N	\N	\tstruct qt2_serial_private *serial_priv;\n\tint status;\n\n\t/* power on unit */\n\tstatus = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t 0xc2, 0x40, 0x8000, 0, NULL, 0,\n\t\t\t\t QT2_USB_TIMEOUT);\n\tif (status < 0) {\n	f
50662	321	hfs_free_fork	fs/hfs/extent.c	&fd	1	11	\N	\N	\tstruct hfs_find_data fd;\n\tu32 total_blocks, blocks, start;\n\tu32 cnid = be32_to_cpu(file->FlNum);\n\tstruct hfs_extent *extent;\n\tint res, i;\n\n\tif (type == HFS_FK_DATA) {\n\t\ttotal_blocks = be32_to_cpu(file->PyLen);\n\t\textent = file->ExtRec;\n\t} else {\n\t\ttotal_blocks = be32_to_cpu(file->RPyLen);\n\t\textent = file->RExtRec;\n\t}\n\ttotal_blocks /= HFS_SB(sb)->alloc_blksz;\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 3; extent++, i++)\n\t\tblocks += be16_to_cpu(extent[i].count);\n\n\tres = hfs_free_extents(sb, extent, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be16_to_cpu(fd.key->ext.FABN);\n\t\thfs_free_extents(sb, extent, total_blocks - start, total_blocks);\n\t\thfs_brec_remove(&fd);\n	t
44421	652	hash_ipportip6_resize	net/netfilter/ipset/ip_set_hash_ipportip.c	hash_ipportip6_resize_$m$obj$0$0	0	11	\N	\N	\N	t
46017	557	autofs_dev_ioctl_ismountpoint	fs/autofs4/dev-ioctl.c	autofs_dev_ioctl_ismountpoint_$path$1$obj	0	11	\N	\N	\tstruct path path;\n\tconst char *name;\n\tunsigned int type;\n\tunsigned int devid, magic;\n\tint err = -ENOENT;\n\n\tif (param->size <= AUTOFS_DEV_IOCTL_SIZE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tname = param->path;\n\ttype = param->ismountpoint.in.type;\n\n\tparam->ismountpoint.out.devid = devid = 0;\n\tparam->ismountpoint.out.magic = magic = 0;\n\n\tif (!fp || param->ioctlfd == -1) {\n\t\tif (autofs_type_any(type))\n\t\t\terr = kern_path_mountpoint(AT_FDCWD,\n\t\t\t\t\t\t   name, &path, LOOKUP_FOLLOW);\n\t\telse\n\t\t\terr = find_autofs_mount(name, &path,\n\t\t\t\t\t\ttest_by_type, &type);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdevid = new_encode_dev(path.dentry->d_sb->s_dev);\n	t
27251	424	ath3k_load_patch	drivers/bluetooth/ath3k.c	ath3k_load_patch_$fw_version$0$obj	0	11	\N	\N	\tunsigned char fw_state;\n\tchar filename[ATH3K_NAME_LEN] = {0};\n\tconst struct firmware *firmware;\n\tstruct ath3k_version fw_version;\n\t__u32 pt_rom_version, pt_build_version;\n\tint ret;\n\n\tret = ath3k_get_state(udev, &fw_state);\n\tif (ret < 0) {\n\t\tBT_ERR("Can't get state to change to load ram patch err");\n\t\treturn ret;\n\t}\n\n\tif (fw_state & ATH3K_PATCH_UPDATE) {\n\t\tBT_DBG("Patch was already downloaded");\n\t\treturn 0;\n\t}\n\n\tret = ath3k_get_version(udev, &fw_version);\n\tif (ret < 0) {\n\t\tBT_ERR("Can't get version to change to load ram patch err");\n\t\treturn ret;\n\t}\n\n\tsnprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",\n	t
21516	36	br_send_bpdu_finish	net/bridge/br_stp_bpdu.c	skb	1	11	\N	\N	\treturn dev_queue_xmit(skb);\n	t
29402	2153	ath6kl_wmi_bssfilter_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_bss_filter_cmd *cmd;\n\tint ret;\n\n\tif (filter >= LAST_BSS_FILTER)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bss_filter_cmd *) skb->data;\n\tcmd->bss_filter = filter;\n\tcmd->ie_mask = cpu_to_le32(ie_mask);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_BSS_FILTER_CMDID,\n	t
31899	495	ds_reset	drivers/w1/masters/ds2490.c	err	1	11	\N	\N	\tint err;\n\n\t/* Other potentionally interesting flags for reset.\n\t *\n\t * COMM_NTF: Return result register feedback.  This could be used to\n\t * detect some conditions such as short, alarming presence, or\n\t * detect if a new device was detected.\n\t *\n\t * COMM_SE which allows SPEED_NORMAL, SPEED_FLEXIBLE, SPEED_OVERDRIVE:\n\t * Select the data transfer rate.\n\t */\n\terr = ds_send_control(dev, COMM_1_WIRE_RESET | COMM_IM, SPEED_NORMAL);\n\tif (err)\n	t
40443	1105	ipv4_sk_update_pmtu	net/ipv4/route.c	&fl4	1	11	\N	\N	\tconst struct iphdr *iph = (const struct iphdr *) skb->data;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tstruct dst_entry *odst = NULL;\n\tbool new = false;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\n\tif (!ip_sk_accept_pmtu(sk))\n\t\tgoto out;\n\n\todst = sk_dst_get(sk);\n\n\tif (sock_owned_by_user(sk) || !odst) {\n\t\t__ipv4_sk_update_pmtu(skb, sk, mtu);\n\t\tgoto out;\n\t}\n\n\t__build_flow_key(net, &fl4, sk, iph, 0, 0, 0, 0, 0);\n\n\trt = (struct rtable *)odst;\n\tif (odst->obsolete && !odst->ops->check(odst, 0)) {\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out;\n\n\t\tnew = true;\n\t}\n\n\t__ip_rt_update_pmtu((struct rtable *) rt->dst.path, &fl4, mtu);\n	t
45097	175	acpi_pci_link_get_possible	drivers/acpi/pci_link.c	status	1	11	\N	\N	\tacpi_status status;\n\n\tstatus = acpi_walk_resources(link->device->handle, METHOD_NAME__PRS,\n\t\t\t\t     acpi_pci_link_check_possible, link);\n\tif (ACPI_FAILURE(status)) {\n	t
45632	143	do_sys_truncate	fs/open.c	&path	1	11	\N	\N	\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n	t
52552	165	perf_trace_writeback_write_inode_template	fs/fs-writeback.c	wb	1	11	\N	\N	\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n	t
60447	763	swap_xy_store	drivers/input/touchscreen/rohm_bu21023.c	val	5	12	\N	\N	\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = mutex_lock_interruptible(&ts->input->mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (val)\n	t
62613	70	raw_ioctl	drivers/net/wan/hdlc_raw.c	new_settings.encoding	1	11	\N	\N	\traw_hdlc_proto __user *raw_s = ifr->ifr_settings.ifs_ifsu.raw_hdlc;\n\tconst size_t size = sizeof(raw_hdlc_proto);\n\traw_hdlc_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint result;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifr->ifr_settings.type = IF_PROTO_HDLC;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(raw_s, hdlc->state, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_HDLC:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, raw_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.encoding == ENCODING_DEFAULT)\n	t
7973	2400	prochot_override_duty_cycle_store	drivers/hwmon/lm93.c	prochot_override_duty_cycle_store_$__UNIQUE_ID_min1_177$obj	0	11	\N	\N	\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->prochot_override = (data->prochot_override & 0xf0) |\n\t\t\t\t\tclamp_val(val, 0, 15);\n	t
59863	75	qBri_cpu_trapped	drivers/isdn/hardware/eicon/s_4bri.c	qBri_cpu_trapped_$regs$0$obj	0	11	\N	\N	\N	t
55332	1414	SYSC_mq_getsetattr	ipc/mqueue.c	new	1	11	\N	\N	\tint ret;\n\tstruct mq_attr mqstat, omqstat;\n\tstruct mq_attr *new = NULL, *old = NULL;\n\n\tif (u_mqstat) {\n\t\tnew = &mqstat;\n\t\tif (copy_from_user(new, u_mqstat, sizeof(struct mq_attr)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (u_omqstat)\n\t\told = &omqstat;\n\n\tret = do_mq_getsetattr(mqdes, new, old);\n	t
35061	962	qtnf_ep_fw_send	drivers/net/wireless/quantenna/qtnfmac/pearl/pcie.c	hdr->boardflg	1	11	\N	\N	\tstruct pci_dev *pdev = priv->pdev;\n\tstruct qtnf_bus *bus = pci_get_drvdata(pdev);\n\n\tstruct qtnf_pcie_fw_hdr *hdr;\n\tu8 *pdata;\n\n\tint hds = sizeof(*hdr);\n\tstruct sk_buff *skb = NULL;\n\tint len = 0;\n\tint ret;\n\n\tskb = __dev_alloc_skb(QTN_PCIE_FW_BUFSZ, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb->len = QTN_PCIE_FW_BUFSZ;\n\tskb->dev = NULL;\n\n\thdr = (struct qtnf_pcie_fw_hdr *)skb->data;\n\tmemcpy(hdr->boardflg, QTN_PCIE_BOARDFLG, strlen(QTN_PCIE_BOARDFLG));\n	t
28720	4028	__gdth_queuecommand	drivers/scsi/gdth.c	ha	6	12	\N	\N	    scp->host_scribble = (unsigned char *)cmndinfo;\n    cmndinfo->wait_for_completion = 1;\n    cmndinfo->phase = -1;\n    cmndinfo->OpCode = -1;\n\n#ifdef GDTH_STATISTICS\n    ++act_ios;\n#endif\n\n    gdth_putq(ha, scp, cmndinfo->priority);\n    gdth_next(ha);\n	t
38389	652	quirk_intel_purley_xeon_ras_cap	arch/x86/kernel/quirks.c	capid0	7	12	\N	\N	\tu32 capid0;\n\n\tpci_read_config_dword(pdev, 0x84, &capid0);\n\n\tif ((capid0 & 0xc0) == 0xc0)\n	t
58244	1974	fuse_write_begin	fs/fuse/file.c	err	5	12	\N	\N	\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_SIZE)\n\t\tgoto success;\n\t/*\n\t * Check if the start this page comes after the end of file, in which\n\t * case the readpage can be optimized away.\n\t */\n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n	t
34946	1428	smc_exit	net/smc/af_smc.c	smc_exit_$lg$obj$0	0	13	\N	\N	\tstruct smc_link_group *lgr, *lg;\n\tLIST_HEAD(lgr_freeing_list);\n\n\tspin_lock_bh(&smc_lgr_list.lock);\n\tif (!list_empty(&smc_lgr_list.list))\n\t\tlist_splice_init(&smc_lgr_list.list, &lgr_freeing_list);\n\tspin_unlock_bh(&smc_lgr_list.lock);\n\tlist_for_each_entry_safe(lgr, lg, &lgr_freeing_list, list) {\n	f
45316	5079	ext4_group_add_blocks	fs/ext4/mballoc.c	&e4b	1	11	\N	\N	\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, blk_free_count;\n\text4_grpblk_t blocks_freed;\n\n\text4_debug("Adding block(s) %llu-%llu\\n", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\text4_warning(sb, "too much blocks added to group %u",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, "Adding blocks in system zones - "\n\t\t\t   "Block = %llu, count = %lu",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, "getting write access");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, blocks_freed = 0; i < count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, "clear bit");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, "bit already cleared for block %llu",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, "bit already cleared");\n\t\t} else {\n\t\t\tblocks_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, count);\n\tmb_free_blocks(NULL, &e4b, bit, count);\n	t
47326	4917	be_ndo_bridge_getlink	drivers/net/ethernet/emulex/benet/be_main.c	hsw_mode	1	11	\N	\N	\tstruct be_adapter *adapter = netdev_priv(dev);\n\tint status = 0;\n\tu8 hsw_mode;\n\n\t/* BE and Lancer chips support VEB mode only */\n\tif (BEx_chip(adapter) || lancer_chip(adapter)) {\n\t\t/* VEB is disabled in non-SR-IOV profiles on BE3/Lancer */\n\t\tif (!pci_sriov_get_totalvfs(adapter->pdev))\n\t\t\treturn 0;\n\t\thsw_mode = PORT_FWD_TYPE_VEB;\n\t} else {\n\t\tstatus = be_cmd_get_hsw_config(adapter, NULL, 0,\n\t\t\t\t\t       adapter->if_handle, &hsw_mode,\n\t\t\t\t\t       NULL);\n\t\tif (status)\n\t\t\treturn 0;\n\n\t\tif (hsw_mode == PORT_FWD_TYPE_PASSTHRU)\n	t
32955	4750	notify_peer_device_state	drivers/block/drbd/drbd_nl.c	skb	1	13	\N	\N	\tstruct peer_device_statistics peer_device_statistics;\n\tstruct drbd_resource *resource = peer_device->device->resource;\n\tstruct drbd_genlmsghdr *dh;\n\tbool multicast = false;\n\tint err;\n\n\tif (!skb) {\n\t\tseq = atomic_inc_return(&notify_genl_seq);\n\t\tskb = genlmsg_new(NLMSG_GOODSIZE, GFP_NOIO);\n\t\terr = -ENOMEM;\n\t\tif (!skb)\n\t\t\tgoto failed;\n\t\tmulticast = true;\n\t}\n\n\terr = -EMSGSIZE;\n\tdh = genlmsg_put(skb, 0, seq, &drbd_genl_family, 0, DRBD_PEER_DEVICE_STATE);\n	f
47638	163	t1_link_changed	drivers/net/ethernet/chelsio/cxgb/subr.c	link_ok	1	13	\N	\N	\tint link_ok, speed, duplex, fc;\n\tstruct cphy *phy = adapter->port[port_id].phy;\n\tstruct link_config *lc = &adapter->port[port_id].link_config;\n\n\tphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\n\n\tlc->speed = speed < 0 ? SPEED_INVALID : speed;\n\tlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\n\tif (!(lc->requested_fc & PAUSE_AUTONEG))\n\t\tfc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\n\tif (link_ok && speed >= 0 && lc->autoneg == AUTONEG_ENABLE) {\n	f
53879	3722	cifs_mount	fs/cifs/connect.c	xid	1	13	\N	\N	\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;\n\n\t\tfree_xid(xid);\n	f
33649	7091	ath10k_wmi_10_4_op_gen_dbglog_cfg	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_10_4_op_gen_dbglog_cfg_$cmd$obj$0	0	11	\N	\N	\tstruct wmi_10_4_dbglog_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 cfg;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_10_4_dbglog_cfg_cmd *)skb->data;\n\n\tif (module_enable) {\n\t\tcfg = SM(log_level,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t} else {\n\t\t/* set back defaults, all modules with WARN level */\n\t\tcfg = SM(ATH10K_DBGLOG_LEVEL_WARN,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t\tmodule_enable = ~0;\n\t}\n\n\tcmd->module_enable = __cpu_to_le64(module_enable);\n\tcmd->module_valid = __cpu_to_le64(~0);\n\tcmd->config_enable = __cpu_to_le32(cfg);\n\tcmd->config_valid = __cpu_to_le32(ATH10K_DBGLOG_CFG_LOG_LVL_MASK);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   "wmi dbglog cfg modules 0x%016llx 0x%016llx config %08x %08x\\n",\n\t\t   __le64_to_cpu(cmd->module_enable),\n	t
35071	1983	ecryptfs_encrypt_and_encode_filename	fs/ecryptfs/crypto.c	ecryptfs_encrypt_and_encode_filename_$encoded_name_size.addr$obj$obj	0	11	\N	\N	\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR "%s: Out of memory whilst attempting "\n\t\t\t       "to kzalloc [%zd] bytes\\n", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR "%s: Error attempting to encrypt "\n\t\t\t       "filename; rc = [%d]\\n", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR "%s: Out of memory whilst attempting "\n	t
29636	96	mxl111sf_get_gpi_state	drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c	mxl111sf_get_gpi_state_$tmp50$obj	0	11	\N	\N	\tint ret;\n\tu8 tmp;\n\n\tmxl_debug("(0x%02x)", pin);\n\n\t*val = 0;\n\n\tswitch (pin) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tret = mxl111sf_read_reg(state, 0x23, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\t*val = (tmp >> (pin + 4)) & 0x01;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t\tret = mxl111sf_read_reg(state, 0x2f, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\t*val = (tmp >> pin) & 0x01;\n\t\tbreak;\n\tcase 8:\n\tcase 9:\n\tcase 10:\n\t\tret = mxl111sf_read_reg(state, 0x22, &tmp);\n\t\tif (mxl_fail(ret))\n	t
59802	620	saa7134_irq	drivers/media/pci/saa7134/saa7134-core.c	report	1	11	\N	\N	\tstruct saa7134_dev *dev = (struct saa7134_dev*) dev_id;\n\tunsigned long report,status;\n\tint loop, handled = 0;\n\n\tif (dev->insuspend)\n\t\tgoto out;\n\n\tfor (loop = 0; loop < 10; loop++) {\n\t\treport = saa_readl(SAA7134_IRQ_REPORT);\n\t\tstatus = saa_readl(SAA7134_IRQ_STATUS);\n\n\t\t/* If dmasound support is active and we get a sound report,\n\t\t * mask out the report and let the saa7134-alsa module deal\n\t\t * with it */\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA3) &&\n\t\t\t(dev->dmasound.priv_data != NULL) )\n\t\t{\n\t\t\tirq_dbg(2, "preserving DMA sound interrupt\\n");\n\t\t\treport &= ~SAA7134_IRQ_REPORT_DONE_RA3;\n\t\t}\n\n\t\tif (0 == report) {\n\t\t\tirq_dbg(2, "no (more) work\\n");\n\t\t\tgoto out;\n\t\t}\n\n\t\thandled = 1;\n\t\tsaa_writel(SAA7134_IRQ_REPORT,report);\n\t\tif (irq_debug)\n\t\t\tprint_irqstatus(dev,loop,report,status);\n\n\n\t\tif ((report & SAA7134_IRQ_REPORT_RDCAP) ||\n\t\t\t(report & SAA7134_IRQ_REPORT_INTL))\n\t\t\t\tsaa7134_irq_video_signalchange(dev);\n\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\n\t\t    (status & 0x60) == 0)\n\t\t\tsaa7134_irq_video_done(dev,status);\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\n\t\t    (status & 0x40) == 0x40)\n\t\t\tsaa7134_irq_vbi_done(dev,status);\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA2) &&\n\t\t    card_has_mpeg(dev)) {\n\t\t\tif (dev->mops->irq_ts_done != NULL)\n\t\t\t\tdev->mops->irq_ts_done(dev, status);\n\t\t\telse\n\t\t\t\tsaa7134_irq_ts_done(dev, status);\n\t\t}\n\n\t\tif (report & SAA7134_IRQ_REPORT_GPIO16) {\n\t\t\tswitch (dev->has_remote) {\n\t\t\t\tcase SAA7134_REMOTE_GPIO:\n\t\t\t\t\tif (!dev->remote)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif  (dev->remote->mask_keydown & 0x10000) {\n\t\t\t\t\t\tsaa7134_input_irq(dev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SAA7134_REMOTE_I2C:\n\t\t\t\t\tbreak;\t\t\t/* FIXME: invoke I2C get_key() */\n\n\t\t\t\tdefault:\t\t\t/* GPIO16 not used by IR remote */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (report & SAA7134_IRQ_REPORT_GPIO18) {\n\t\t\tswitch (dev->has_remote) {\n\t\t\t\tcase SAA7134_REMOTE_GPIO:\n\t\t\t\t\tif (!dev->remote)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ((dev->remote->mask_keydown & 0x40000) ||\n\t\t\t\t\t    (dev->remote->mask_keyup & 0x40000)) {\n\t\t\t\t\t\tsaa7134_input_irq(dev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SAA7134_REMOTE_I2C:\n\t\t\t\t\tbreak;\t\t\t/* FIXME: invoke I2C get_key() */\n\n\t\t\t\tdefault:\t\t\t/* GPIO18 not used by IR remote */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (10 == loop) {\n\t\tprint_irqstatus(dev,loop,report,status);\n\t\tif (report & SAA7134_IRQ_REPORT_PE) {\n\t\t\t/* disable all parity error */\n\t\t\tpr_warn("%s/irq: looping -- clearing PE (parity error!) enable bit\\n",\n\t\t\t\tdev->name);\n\t\t\tsaa_clearl(SAA7134_IRQ2,SAA7134_IRQ2_INTE_PE);\n\t\t} else if (report & SAA7134_IRQ_REPORT_GPIO16) {\n	t
49942	303	xfs_readlink_by_handle	fs/xfs/xfs_ioctl.c	olen	1	13	\N	\N	\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\terror = vfs_readlink(dentry, hreq->ohandle, olen);\n	f
24180	134	mlx4_reset	drivers/net/ethernet/mellanox/mlx4/reset.c	vendor	5	12	\N	\N	\tvoid __iomem *reset;\n\tu32 *hca_header = NULL;\n\tint pcie_cap;\n\tu16 devctl;\n\tu16 linkctl;\n\tu16 vendor;\n\tunsigned long end;\n\tu32 sem;\n\tint i;\n\tint err = 0;\n\n#define MLX4_RESET_BASE\t\t0xf0000\n#define MLX4_RESET_SIZE\t\t  0x400\n#define MLX4_SEM_OFFSET\t\t  0x3fc\n#define MLX4_RESET_OFFSET\t   0x10\n#define MLX4_RESET_VALUE\tswab32(1)\n\n#define MLX4_SEM_TIMEOUT_JIFFIES\t(10 * HZ)\n#define MLX4_RESET_TIMEOUT_JIFFIES\t(2 * HZ)\n\n\t/*\n\t * Reset the chip.  This is somewhat ugly because we have to\n\t * save off the PCI header before reset and then restore it\n\t * after the chip reboots.  We skip config space offsets 22\n\t * and 23 since those have a special meaning.\n\t */\n\n\t/* Do we need to save off the full 4K PCI Express header?? */\n\thca_header = kmalloc(256, GFP_KERNEL);\n\tif (!hca_header) {\n\t\terr = -ENOMEM;\n\t\tmlx4_err(dev, "Couldn't allocate memory to save HCA PCI header, aborting\\n");\n\t\tgoto out;\n\t}\n\n\tpcie_cap = pci_pcie_cap(dev->persist->pdev);\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tif (i == 22 || i == 23)\n\t\t\tcontinue;\n\t\tif (pci_read_config_dword(dev->persist->pdev, i * 4,\n\t\t\t\t\t  hca_header + i)) {\n\t\t\terr = -ENODEV;\n\t\t\tmlx4_err(dev, "Couldn't save HCA PCI header, aborting\\n");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treset = ioremap(pci_resource_start(dev->persist->pdev, 0) +\n\t\t\tMLX4_RESET_BASE,\n\t\t\tMLX4_RESET_SIZE);\n\tif (!reset) {\n\t\terr = -ENOMEM;\n\t\tmlx4_err(dev, "Couldn't map HCA reset register, aborting\\n");\n\t\tgoto out;\n\t}\n\n\t/* grab HW semaphore to lock out flash updates */\n\tend = jiffies + MLX4_SEM_TIMEOUT_JIFFIES;\n\tdo {\n\t\tsem = readl(reset + MLX4_SEM_OFFSET);\n\t\tif (!sem)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (time_before(jiffies, end));\n\n\tif (sem) {\n\t\tmlx4_err(dev, "Failed to obtain HW semaphore, aborting\\n");\n\t\terr = -EAGAIN;\n\t\tiounmap(reset);\n\t\tgoto out;\n\t}\n\n\t/* actually hit reset */\n\twritel(MLX4_RESET_VALUE, reset + MLX4_RESET_OFFSET);\n\tiounmap(reset);\n\n\t/* Docs say to wait one second before accessing device */\n\tmsleep(1000);\n\n\tend = jiffies + MLX4_RESET_TIMEOUT_JIFFIES;\n\tdo {\n\t\tif (!pci_read_config_word(dev->persist->pdev, PCI_VENDOR_ID,\n\t\t\t\t\t  &vendor) && vendor != 0xffff)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (time_before(jiffies, end));\n\n\tif (vendor == 0xffff) {\n	t
26983	1982	touchpad_store	drivers/platform/x86/toshiba_acpi.c	state	1	11	\N	\N	\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\t/* Set the TouchPad on/off, 0 - Disable | 1 - Enable */\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n	t
30968	458	bch_root_usage	drivers/md/bcache/sysfs.c	bch_root_usage_$c.addr$obj$283	0	11	\N	\N	\tunsigned bytes = 0;\n\tstruct bkey *k;\n\tstruct btree *b;\n\tstruct btree_iter iter;\n\n\tgoto lock_root;\n\n\tdo {\n\t\trw_unlock(false, b);\nlock_root:\n\t\tb = c->root;\n	t
2696	658	cdv_intel_dp_aux_ch	drivers/gpu/drm/gma500/cdv_intel_dp.c	recv_bytes	1	11	\N	\N	\tstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\n\tuint32_t output_reg = intel_dp->output_reg;\n\tstruct drm_device *dev = encoder->base.dev;\n\tuint32_t ch_ctl = output_reg + 0x10;\n\tuint32_t ch_data = ch_ctl + 4;\n\tint i;\n\tint recv_bytes;\n\tuint32_t status;\n\tuint32_t aux_clock_divider;\n\tint try, precharge;\n\n\t/* The clock divider is based off the hrawclk,\n\t * and would like to run at 2MHz. So, take the\n\t * hrawclk value and divide by 2 and use that\n\t * On CDV platform it uses 200MHz as hrawclk.\n\t *\n\t */\n\taux_clock_divider = 200 / 2;\n\n\tprecharge = 4;\n\tif (is_edp(encoder))\n\t\tprecharge = 10;\n\n\tif (REG_READ(ch_ctl) & DP_AUX_CH_CTL_SEND_BUSY) {\n\t\tDRM_ERROR("dp_aux_ch not started status 0x%08x\\n",\n\t\t\t  REG_READ(ch_ctl));\n\t\treturn -EBUSY;\n\t}\n\n\t/* Must try at least 3 times according to DP spec */\n\tfor (try = 0; try < 5; try++) {\n\t\t/* Load the send data into the aux channel data registers */\n\t\tfor (i = 0; i < send_bytes; i += 4)\n\t\t\tREG_WRITE(ch_data + i,\n\t\t\t\t   pack_aux(send + i, send_bytes - i));\n\t\n\t\t/* Send the command and wait for it to complete */\n\t\tREG_WRITE(ch_ctl,\n\t\t\t   DP_AUX_CH_CTL_SEND_BUSY |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_400us |\n\t\t\t   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |\n\t\t\t   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |\n\t\t\t   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |\n\t\t\t   DP_AUX_CH_CTL_DONE |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t   DP_AUX_CH_CTL_RECEIVE_ERROR);\n\t\tfor (;;) {\n\t\t\tstatus = REG_READ(ch_ctl);\n\t\t\tif ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\t\n\t\t/* Clear done status and any errors */\n\t\tREG_WRITE(ch_ctl,\n\t\t\t   status |\n\t\t\t   DP_AUX_CH_CTL_DONE |\n\t\t\t   DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t   DP_AUX_CH_CTL_RECEIVE_ERROR);\n\t\tif (status & DP_AUX_CH_CTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif ((status & DP_AUX_CH_CTL_DONE) == 0) {\n\t\tDRM_ERROR("dp_aux_ch not done status 0x%08x\\n", status);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Check for timeout or receive error.\n\t * Timeouts occur when the sink is not connected\n\t */\n\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\tDRM_ERROR("dp_aux_ch receive error status 0x%08x\\n", status);\n\t\treturn -EIO;\n\t}\n\n\t/* Timeouts occur when the device isn't connected, so they're\n\t * "normal" -- don't fill the kernel log with these */\n\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {\n\t\tDRM_DEBUG_KMS("dp_aux_ch timeout status 0x%08x\\n", status);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* Unload any bytes sent back from the other side */\n\trecv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>\n\t\t      DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);\n\tif (recv_bytes > recv_size)\n	t
30357	3782	ath6kl_wmi_probe_report_req_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_probe_report_req_cmd_$p$obj	0	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_probe_req_report_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, "probe_report_req_cmd: enable=%u\\n",\n\t\t   enable);\n\tp = (struct wmi_probe_req_report_cmd *) skb->data;\n\tp->enable = enable ? 1 : 0;\n	t
30248	3257	dw_mci_probe	drivers/mmc/host/dw_mmc.c	host	1	13	\N	\N	\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tint width, i, ret = 0;\n\tu32 fifo_size;\n\n\tif (!host->pdata) {\n\t\thost->pdata = dw_mci_parse_dt(host);\n\t\tif (PTR_ERR(host->pdata) == -EPROBE_DEFER) {\n\t\t\treturn -EPROBE_DEFER;\n\t\t} else if (IS_ERR(host->pdata)) {\n\t\t\tdev_err(host->dev, "platform data not available\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thost->biu_clk = devm_clk_get(host->dev, "biu");\n\tif (IS_ERR(host->biu_clk)) {\n\t\tdev_dbg(host->dev, "biu clock not available\\n");\n\t} else {\n\t\tret = clk_prepare_enable(host->biu_clk);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, "failed to enable biu clock\\n");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thost->ciu_clk = devm_clk_get(host->dev, "ciu");\n\tif (IS_ERR(host->ciu_clk)) {\n\t\tdev_dbg(host->dev, "ciu clock not available\\n");\n\t\thost->bus_hz = host->pdata->bus_hz;\n\t} else {\n\t\tret = clk_prepare_enable(host->ciu_clk);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, "failed to enable ciu clock\\n");\n\t\t\tgoto err_clk_biu;\n\t\t}\n\n\t\tif (host->pdata->bus_hz) {\n\t\t\tret = clk_set_rate(host->ciu_clk, host->pdata->bus_hz);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(host->dev,\n\t\t\t\t\t "Unable to set bus rate to %uHz\\n",\n\t\t\t\t\t host->pdata->bus_hz);\n\t\t}\n\t\thost->bus_hz = clk_get_rate(host->ciu_clk);\n\t}\n\n\tif (!host->bus_hz) {\n\t\tdev_err(host->dev,\n\t\t\t"Platform data must supply bus speed\\n");\n\t\tret = -ENODEV;\n\t\tgoto err_clk_ciu;\n\t}\n\n\tif (!IS_ERR(host->pdata->rstc)) {\n\t\treset_control_assert(host->pdata->rstc);\n\t\tusleep_range(10, 50);\n\t\treset_control_deassert(host->pdata->rstc);\n\t}\n\n\tif (drv_data && drv_data->init) {\n\t\tret = drv_data->init(host);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t"implementation specific init failed\\n");\n\t\t\tgoto err_clk_ciu;\n\t\t}\n\t}\n\n\tsetup_timer(&host->cmd11_timer,\n\t\t    dw_mci_cmd11_timer, (unsigned long)host);\n\n\tsetup_timer(&host->cto_timer,\n\t\t    dw_mci_cto_timer, (unsigned long)host);\n\n\tsetup_timer(&host->dto_timer,\n\t\t    dw_mci_dto_timer, (unsigned long)host);\n\n\tspin_lock_init(&host->lock);\n\tspin_lock_init(&host->irq_lock);\n\tINIT_LIST_HEAD(&host->queue);\n\n\t/*\n\t * Get the host data width - this assumes that HCON has been set with\n\t * the correct values.\n\t */\n\ti = SDMMC_GET_HDATA_WIDTH(mci_readl(host, HCON));\n\tif (!i) {\n\t\thost->push_data = dw_mci_push_data16;\n\t\thost->pull_data = dw_mci_pull_data16;\n\t\twidth = 16;\n\t\thost->data_shift = 1;\n\t} else if (i == 2) {\n\t\thost->push_data = dw_mci_push_data64;\n\t\thost->pull_data = dw_mci_pull_data64;\n\t\twidth = 64;\n\t\thost->data_shift = 3;\n\t} else {\n\t\t/* Check for a reserved value, and warn if it is */\n\t\tWARN((i != 1),\n\t\t     "HCON reports a reserved host data width!\\n"\n\t\t     "Defaulting to 32-bit access.\\n");\n\t\thost->push_data = dw_mci_push_data32;\n\t\thost->pull_data = dw_mci_pull_data32;\n\t\twidth = 32;\n\t\thost->data_shift = 2;\n\t}\n\n\t/* Reset all blocks */\n\tif (!dw_mci_ctrl_reset(host, SDMMC_CTRL_ALL_RESET_FLAGS)) {\n\t\tret = -ENODEV;\n\t\tgoto err_clk_ciu;\n\t}\n\n\thost->dma_ops = host->pdata->dma_ops;\n\tdw_mci_init_dma(host);\n	f
9168	5477	bnx2x_check_fallback_to_cl37	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	bnx2x_check_fallback_to_cl37_$ustat_val$obj	0	11	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu16 rx_status, ustat_val, cl37_fsm_received;\n\tDP(NETIF_MSG_LINK, "bnx2x_check_fallback_to_cl37\\n");\n\t/* Step 1: Make sure signal is detected */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_RX0,\n\t\t\t  MDIO_RX0_RX_STATUS,\n\t\t\t  &rx_status);\n\tif ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=\n\t    (MDIO_RX0_RX_STATUS_SIGDET)) {\n\t\tDP(NETIF_MSG_LINK, "Signal is not detected. Restoring CL73."\n\t\t\t     "rx_status(0x80b0) = 0x%x\\n", rx_status);\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN);\n\t\treturn;\n\t}\n\t/* Step 2: Check CL73 state machine */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_USERB0,\n\t\t\t  MDIO_CL73_USERB0_CL73_USTAT1,\n\t\t\t  &ustat_val);\n\tif ((ustat_val &\n\t     (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) !=\n\t    (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) {\n\t\tDP(NETIF_MSG_LINK, "CL73 state-machine is not stable. "\n	t
50740	327	do_encrypt	crypto/lrw.c	do_encrypt_	1	13	\N	\N	\tstruct rctx *rctx = skcipher_request_ctx(req);\n\tstruct skcipher_request *subreq;\n\n\tsubreq = &rctx->subreq;\n\n\twhile (!err && rctx->left) {\n\t\terr = pre_crypt(req) ?:\n	f
30259	516	goldfish_mmc_probe	drivers/mmc/host/android-goldfish.c	host	1	13	\N	\N	\tstruct mmc_host *mmc;\n\tstruct goldfish_mmc_host *host = NULL;\n\tstruct resource *res;\n\tint ret = 0;\n\tint irq;\n\tdma_addr_t buf_addr;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (res == NULL || irq < 0)\n\t\treturn -ENXIO;\n\n\tmmc = mmc_alloc_host(sizeof(struct goldfish_mmc_host), &pdev->dev);\n\tif (mmc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_host_failed;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\n\tpr_err("mmc: Mapping %lX to %lX\\n", (long)res->start, (long)res->end);\n\thost->reg_base = ioremap(res->start, resource_size(res));\n\tif (host->reg_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto ioremap_failed;\n\t}\n\thost->virt_base = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,\n\t\t\t\t\t     &buf_addr, GFP_KERNEL);\n\n\tif (host->virt_base == 0) {\n\t\tret = -ENOMEM;\n\t\tgoto dma_alloc_failed;\n\t}\n\thost->phys_base = buf_addr;\n\n\thost->id = pdev->id;\n\thost->irq = irq;\n\n\tmmc->ops = &goldfish_mmc_ops;\n\tmmc->f_min = 400000;\n\tmmc->f_max = 24000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA;\n\n\t/* Use scatterlist DMA to reduce per-transfer costs.\n\t * NOTE max_seg_size assumption that small blocks aren't\n\t * normally used (except e.g. for reading SD registers).\n\t */\n\tmmc->max_segs = 32;\n\tmmc->max_blk_size = 2048;\t/* MMC_BLOCK_LENGTH is 11 bits (+1) */\n\tmmc->max_blk_count = 2048;\t/* MMC_BLOCK_COUNT is 11 bits (+1) */\n\tmmc->max_req_size = BUFFER_SIZE;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\tret = request_irq(host->irq, goldfish_mmc_irq, 0, DRIVER_NAME, host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "Failed IRQ Adding goldfish MMC\\n");\n\t\tgoto err_request_irq_failed;\n\t}\n\n\thost->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, host);\n\n\tret = device_create_file(&pdev->dev, &dev_attr_cover_switch);\n\tif (ret)\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t "Unable to create sysfs attributes\\n");\n\n\tGOLDFISH_MMC_WRITE(host, MMC_SET_BUFFER, host->phys_base);\n	f
978	113	mtdchar_readoob	drivers/mtd/mtdchar.c	struct file *file	1	11	\N	\N	\tint minor = iminor(inode);\n\tint devnum = minor >> 1;\n\tint ret = 0;\n\tstruct mtd_info *mtd;\n\tstruct mtd_file_info *mfi;\n\n\tpr_debug("MTD_open\\n");\n\n\t/* You can't open the RO devices RW */\n\tif ((file->f_mode & FMODE_WRITE) && (minor & 1))\n\t\treturn -EACCES;\n\n\tmutex_lock(&mtd_mutex);\n\tmtd = get_mtd_device(NULL, devnum);\n\n\tif (IS_ERR(mtd)) {\n\t\tret = PTR_ERR(mtd);\n\t\tgoto out;\n\t}\n\n\tif (mtd->type == MTD_ABSENT) {\n\t\tret = -ENODEV;\n\t\tgoto out1;\n\t}\n\n\t/* You can't open it RW if it's not a writeable device */\n\tif ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {\n\t\tret = -EACCES;\n\t\tgoto out1;\n\t}\n\n\tmfi = kzalloc(sizeof(*mfi), GFP_KERNEL);\n\tif (!mfi) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\tmfi->mtd = mtd;\n\tfile->private_data = mfi;\n\tmutex_unlock(&mtd_mutex);\n\treturn 0;\n\nout1:\n\tput_mtd_device(mtd);\nout:\n\tmutex_unlock(&mtd_mutex);\n\treturn ret;\n} /* mtdchar_open */\n\n/*====================================================================*/\n\nstatic int mtdchar_close(struct inode *inode, struct file *file)\n	t
33039	3835	cik_ib_test	drivers/gpu/drm/radeon/cik.c	&ib	1	11	\N	\N	\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR("radeon: failed to get scratch reg (%d).\\n", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\n	t
43801	378	vt6420_prereset	drivers/ata/sata_via.c	sstatus	1	13	\N	\N	\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &ap->link.eh_context;\n\tunsigned long timeout = jiffies + (HZ * 5);\n\tu32 sstatus, scontrol;\n\tint online;\n\n\t/* don't do any SCR stuff if we're not loading */\n\tif (!(ap->pflags & ATA_PFLAG_LOADING))\n\t\tgoto skip_scr;\n\n\t/* Resume phy.  This is the old SATA resume sequence */\n\tsvia_scr_write(link, SCR_CONTROL, 0x300);\n\tsvia_scr_read(link, SCR_CONTROL, &scontrol); /* flush */\n\n\t/* wait for phy to become ready, if necessary */\n\tdo {\n\t\tata_msleep(link->ap, 200);\n\t\tsvia_scr_read(link, SCR_STATUS, &sstatus);\n\t\tif ((sstatus & 0xf) != 1)\n\t\t\tbreak;\n\t} while (time_before(jiffies, timeout));\n\n\t/* open code sata_print_link_status() */\n\tsvia_scr_read(link, SCR_STATUS, &sstatus);\n\tsvia_scr_read(link, SCR_CONTROL, &scontrol);\n\n\tonline = (sstatus & 0xf) == 0x3;\n\n\tata_port_info(ap,\n	f
42736	179	r128_cce_load_microcode	drivers/gpu/drm/r128/r128_cce.c	r128_cce_load_microcode_$p.addr.i.i$obj	0	13	\N	\N	\tstruct platform_device *pdev;\n\tconst struct firmware *fw;\n\tconst __be32 *fw_data;\n\tint rc, i;\n\n\tDRM_DEBUG("\\n");\n\n\tpdev = platform_device_register_simple("r128_cce", 0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tpr_err("r128_cce: Failed to register firmware\\n");\n\t\treturn PTR_ERR(pdev);\n\t}\n\trc = request_firmware(&fw, FIRMWARE_NAME, &pdev->dev);\n\tplatform_device_unregister(pdev);\n\tif (rc) {\n\t\tpr_err("r128_cce: Failed to load firmware \\"%s\\"\\n",\n\t\t       FIRMWARE_NAME);\n\t\treturn rc;\n\t}\n\n\tif (fw->size != 256 * 8) {\n\t\tpr_err("r128_cce: Bogus length %zu in firmware \\"%s\\"\\n",\n\t\t       fw->size, FIRMWARE_NAME);\n\t\trc = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\tr128_do_wait_for_idle(dev_priv);\n\n\tfw_data = (const __be32 *)fw->data;\n\tR128_WRITE(R128_PM4_MICROCODE_ADDR, 0);\n\tfor (i = 0; i < 256; i++) {\n\t\tR128_WRITE(R128_PM4_MICROCODE_DATAH,\n\t\t\t   be32_to_cpup(&fw_data[i * 2]));\n\t\tR128_WRITE(R128_PM4_MICROCODE_DATAL,\n\t\t\t   be32_to_cpup(&fw_data[i * 2 + 1]));\n\t}\n	f
20736	620	acpi_ex_store_direct_to_node	drivers/acpi/acpica/exstore.c	new_desc->common.type	1	13	\N	\N	\tacpi_status status;\n\tunion acpi_operand_object *new_desc;\n\n\tACPI_FUNCTION_TRACE(ex_store_direct_to_node);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  "Storing [%s] (%p) directly into node [%s] (%p)"\n\t\t\t  " with no implicit conversion\\n",\n\t\t\t  acpi_ut_get_object_type_name(source_desc),\n\t\t\t  source_desc, acpi_ut_get_type_name(node->type),\n\t\t\t  node));\n\n\t/* Copy the source object to a new object */\n\n\tstatus =\n\t    acpi_ut_copy_iobject_to_iobject(source_desc, &new_desc, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Attach the new object to the node */\n\n\tstatus = acpi_ns_attach_object(node, new_desc, new_desc->common.type);\n	f
53301	3276	clone_finish_inode_update	fs/btrfs/ioctl.c	ret	1	13	\N	\N	\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tif (!no_time_update)\n\t\tinode->i_mtime = inode->i_ctime = current_time(inode);\n\t/*\n\t * We round up to the block size at eof when determining which\n\t * extents to clone above, but shouldn't round up the file size.\n\t */\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(BTRFS_I(inode), endoff);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n	f
59481	991	fsp_detect	drivers/input/mouse/sentelic.c	id	1	13	\N	\N	\tint id;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_DEVICE_ID, &id))\n\t\treturn -EIO;\n\n\tif (id != 0x01)\n	f
5216	533	nouveau_bios_parse_lvds_table	drivers/gpu/drm/nouveau/nouveau_bios.c	lth.lvds_ver	1	11	\N	\N	\t/*\n\t * The LVDS table header is (mostly) described in\n\t * parse_lvds_manufacturer_table_header(): the BIT header additionally\n\t * contains the dual-link transition pxclk (in 10s kHz), at byte 5 - if\n\t * straps are not being used for the panel, this specifies the frequency\n\t * at which modes should be set up in the dual link style.\n\t *\n\t * Following the header, the BMP (ver 0xa) table has several records,\n\t * indexed by a separate xlat table, indexed in turn by the fp strap in\n\t * EXTDEV_BOOT. Each record had a config byte, followed by 6 script\n\t * numbers for use by INIT_SUB which controlled panel init and power,\n\t * and finally a dword of ms to sleep between power off and on\n\t * operations.\n\t *\n\t * In the BIT versions, the table following the header serves as an\n\t * integrated config and xlat table: the records in the table are\n\t * indexed by the FP strap nibble in EXTDEV_BOOT, and each record has\n\t * two bytes - the first as a config byte, the second for indexing the\n\t * fp mode table pointed to by the BIT 'D' table\n\t *\n\t * DDC is not used until after card init, so selecting the correct table\n\t * entry and setting the dual link flag for EDID equipped panels,\n\t * requiring tests against the native-mode pixel clock, cannot be done\n\t * until later, when this function should be called with non-zero pxclk\n\t */\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tint fpstrapping = get_fp_strap(dev, bios), lvdsmanufacturerindex = 0;\n\tstruct lvdstableheader lth;\n\tuint16_t lvdsofs;\n\tint ret, chip_version = bios->chip_version;\n\n\tret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (lth.lvds_ver) {\n	t
5246	235	nv04_update_arb	drivers/gpu/drm/nouveau/dispnv04/arb.c	fifo_data.burst	1	11	\N	\N	\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nv_fifo_info fifo_data;\n\tstruct nv_sim_state sim_data;\n\tint MClk = nouveau_hw_get_clock(dev, PLL_MEMORY);\n\tint NVClk = nouveau_hw_get_clock(dev, PLL_CORE);\n\tuint32_t cfg1 = nvif_rd32(device, NV04_PFB_CFG1);\n\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tsim_data.bpp = bpp;\n\tsim_data.two_heads = nv_two_heads(dev);\n\tif ((dev->pdev->device & 0xffff) == 0x01a0 /*CHIPSET_NFORCE*/ ||\n\t    (dev->pdev->device & 0xffff) == 0x01f0 /*CHIPSET_NFORCE2*/) {\n\t\tuint32_t type;\n\n\t\tpci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);\n\n\t\tsim_data.memory_type = (type >> 12) & 1;\n\t\tsim_data.memory_width = 64;\n\t\tsim_data.mem_latency = 3;\n\t\tsim_data.mem_page_miss = 10;\n\t} else {\n\t\tsim_data.memory_type = nvif_rd32(device, NV04_PFB_CFG0) & 0x1;\n\t\tsim_data.memory_width = (nvif_rd32(device, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;\n\t\tsim_data.mem_latency = cfg1 & 0xf;\n\t\tsim_data.mem_page_miss = ((cfg1 >> 4) & 0xf) + ((cfg1 >> 31) & 0x1);\n\t}\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT)\n\t\tnv04_calc_arb(&fifo_data, &sim_data);\n\telse\n\t\tnv10_calc_arb(&fifo_data, &sim_data);\n\n\t*burst = ilog2(fifo_data.burst >> 4);\n	t
6869	662	g762_of_prop_import_one	drivers/hwmon/g762.c	pval	1	11	\N	\N	\tint ret;\n\tu32 pval;\n\n\tif (of_property_read_u32(client->dev.of_node, pname, &pval))\n\t\treturn 0;\n\n\tdev_dbg(&client->dev, "found %s (%d)\\n", pname, pval);\n	t
6932	1698	ssi_buffer_mgr_map_hash_request_update	drivers/staging/ccree/ssi_buffer_mgr.c	&sg_data	1	11	\N	\N	\tstruct ahash_req_ctx *areq_ctx = (struct ahash_req_ctx *)ctx;\n\tstruct device *dev = &drvdata->plat_dev->dev;\n\tu8 *curr_buff = areq_ctx->buff_index ? areq_ctx->buff1 :\n\t\t\tareq_ctx->buff0;\n\tu32 *curr_buff_cnt = areq_ctx->buff_index ? &areq_ctx->buff1_cnt :\n\t\t\t&areq_ctx->buff0_cnt;\n\tu8 *next_buff = areq_ctx->buff_index ? areq_ctx->buff0 :\n\t\t\tareq_ctx->buff1;\n\tu32 *next_buff_cnt = areq_ctx->buff_index ? &areq_ctx->buff0_cnt :\n\t\t\t&areq_ctx->buff1_cnt;\n\tstruct mlli_params *mlli_params = &areq_ctx->mlli_params;\n\tunsigned int update_data_len;\n\tu32 total_in_len = nbytes + *curr_buff_cnt;\n\tstruct buffer_array sg_data;\n\tstruct buff_mgr_handle *buff_mgr = drvdata->buff_mgr_handle;\n\tunsigned int swap_index = 0;\n\tu32 dummy = 0;\n\tu32 mapped_nents = 0;\n\n\tSSI_LOG_DEBUG(" update params : curr_buff=%pK "\n\t\t     "curr_buff_cnt=0x%X nbytes=0x%X "\n\t\t     "src=%pK curr_index=%u\\n",\n\t\t     curr_buff, *curr_buff_cnt, nbytes,\n\t\t     src, areq_ctx->buff_index);\n\t/* Init the type of the dma buffer */\n\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_NULL;\n\tmlli_params->curr_pool = NULL;\n\tareq_ctx->curr_sg = NULL;\n\tsg_data.num_of_buffers = 0;\n\tareq_ctx->in_nents = 0;\n\n\tif (unlikely(total_in_len < block_size)) {\n\t\tSSI_LOG_DEBUG(" less than one block: curr_buff=%pK "\n\t\t\t     "*curr_buff_cnt=0x%X copy_to=%pK\\n",\n\t\t\tcurr_buff, *curr_buff_cnt,\n\t\t\t&curr_buff[*curr_buff_cnt]);\n\t\tareq_ctx->in_nents =\n\t\t\tssi_buffer_mgr_get_sgl_nents(src,\n\t\t\t\t\t\t     nbytes,\n\t\t\t\t\t\t     &dummy, NULL);\n\t\tsg_copy_to_buffer(src, areq_ctx->in_nents,\n\t\t\t\t  &curr_buff[*curr_buff_cnt], nbytes);\n\t\t*curr_buff_cnt += nbytes;\n\t\treturn 1;\n\t}\n\n\t/* Calculate the residue size*/\n\t*next_buff_cnt = total_in_len & (block_size - 1);\n\t/* update data len */\n\tupdate_data_len = total_in_len - *next_buff_cnt;\n\n\tSSI_LOG_DEBUG(" temp length : *next_buff_cnt=0x%X "\n\t\t     "update_data_len=0x%X\\n",\n\t\t*next_buff_cnt, update_data_len);\n\n\t/* Copy the new residue to next buffer */\n\tif (*next_buff_cnt != 0) {\n\t\tSSI_LOG_DEBUG(" handle residue: next buff %pK skip data %u"\n\t\t\t     " residue %u\\n", next_buff,\n\t\t\t     (update_data_len - *curr_buff_cnt),\n\t\t\t     *next_buff_cnt);\n\t\tssi_buffer_mgr_copy_scatterlist_portion(next_buff, src,\n\t\t\t\t\t\t\t(update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t\tnbytes, SSI_SG_TO_BUF);\n\t\t/* change the buffer index for next operation */\n\t\tswap_index = 1;\n\t}\n\n\tif (*curr_buff_cnt != 0) {\n\t\tif (ssi_ahash_handle_curr_buf(dev, areq_ctx, curr_buff,\n\t\t\t\t\t      *curr_buff_cnt, &sg_data) != 0) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/* change the buffer index for next operation */\n\t\tswap_index = 1;\n\t}\n\n\tif (update_data_len > *curr_buff_cnt) {\n\t\tif (unlikely(ssi_buffer_mgr_map_scatterlist(dev, src,\n\t\t\t\t\t\t\t    (update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t\t    DMA_TO_DEVICE,\n\t\t\t\t\t\t\t    &areq_ctx->in_nents,\n\t\t\t\t\t\t\t    LLI_MAX_NUM_OF_DATA_ENTRIES,\n\t\t\t\t\t\t\t    &dummy,\n\t\t\t\t\t\t\t    &mapped_nents))){\n\t\t\tgoto unmap_curr_buff;\n\t\t}\n\t\tif ((mapped_nents == 1)\n\t\t     && (areq_ctx->data_dma_buf_type == SSI_DMA_BUF_NULL)) {\n\t\t\t/* only one entry in the SG and no previous data */\n\t\t\tmemcpy(areq_ctx->buff_sg, src,\n\t\t\t       sizeof(struct scatterlist));\n\t\t\tareq_ctx->buff_sg->length = update_data_len;\n\t\t\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_DLLI;\n\t\t\tareq_ctx->curr_sg = areq_ctx->buff_sg;\n\t\t} else {\n\t\t\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_MLLI;\n\t\t}\n\t}\n\n\tif (unlikely(areq_ctx->data_dma_buf_type == SSI_DMA_BUF_MLLI)) {\n\t\tmlli_params->curr_pool = buff_mgr->mlli_buffs_pool;\n\t\t/* add the src data to the sg_data */\n\t\tssi_buffer_mgr_add_scatterlist_entry(&sg_data,\n\t\t\t\t\t\t     areq_ctx->in_nents,\n\t\t\t\t\t\t     src,\n\t\t\t\t\t\t     (update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     true,\n\t\t\t\t\t\t     &areq_ctx->mlli_nents);\n\t\tif (unlikely(ssi_buffer_mgr_generate_mlli(dev, &sg_data,\n	t
50722	195	ia_css_frame_map	drivers/staging/media/atomisp/pci/atomisp2/css2400/runtime/frame/src/frame.c	ia_css_frame_map_$me$obj$9	0	13	\N	\N	\tenum ia_css_err err = IA_CSS_SUCCESS;\n\tstruct ia_css_frame *me;\n\tassert(frame != NULL);\n\n\t/* Create the frame structure */\n\terr = ia_css_frame_create_from_info(&me, info);\n\n\tif (err != IA_CSS_SUCCESS)\n\t\treturn err;\n\n\tif (err == IA_CSS_SUCCESS) {\n\t\t/* use mmgr_mmap to map */\n\t\tme->data = (ia_css_ptr) mmgr_mmap(data,\n\t\t\t\t\t\t  me->data_bytes,\n	f
57205	550	gru_intr	drivers/misc/sgi-gru/grufault.c	gru_intr_$imap$0$0$obj	0	13	\N	\N	\tstruct gru_state *gru;\n\tstruct gru_tlb_fault_map imap, dmap;\n\tstruct gru_thread_state *gts;\n\tstruct gru_tlb_fault_handle *tfh = NULL;\n\tstruct completion *cmp;\n\tint cbrnum, ctxnum;\n\n\tSTAT(intr);\n\n\tgru = &gru_base[blade]->bs_grus[chiplet];\n\tif (!gru) {\n\t\tdev_err(grudev, "GRU: invalid interrupt: cpu %d, chiplet %d\\n",\n\t\t\traw_smp_processor_id(), chiplet);\n\t\treturn IRQ_NONE;\n\t}\n\tget_clear_fault_map(gru, &imap, &dmap);\n\tgru_dbg(grudev,\n	f
55067	1904	do_semtimedop	ipc/sem.c	do_semtimedop_$sop$obj$0$obj	0	13	\N	\N	\tint error = -EINVAL;\n\tstruct sem_array *sma;\n\tstruct sembuf fast_sops[SEMOPM_FAST];\n\tstruct sembuf *sops = fast_sops, *sop;\n\tstruct sem_undo *un;\n\tint max, locknum;\n\tbool undos = false, alter = false, dupsop = false;\n\tstruct sem_queue queue;\n\tunsigned long dup = 0, jiffies_left = 0;\n\tstruct ipc_namespace *ns;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (nsops < 1 || semid < 0)\n\t\treturn -EINVAL;\n\tif (nsops > ns->sc_semopm)\n\t\treturn -E2BIG;\n\tif (nsops > SEMOPM_FAST) {\n\t\tsops = kvmalloc(sizeof(*sops)*nsops, GFP_KERNEL);\n\t\tif (sops == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(sops, tsops, nsops * sizeof(*tsops))) {\n\t\terror =  -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (timeout) {\n\t\tif (timeout->tv_sec < 0 || timeout->tv_nsec < 0 ||\n\t\t\ttimeout->tv_nsec >= 1000000000L) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tjiffies_left = timespec64_to_jiffies(timeout);\n\t}\n\n\tmax = 0;\n\tfor (sop = sops; sop < sops + nsops; sop++) {\n\t\tunsigned long mask = 1ULL << ((sop->sem_num) % BITS_PER_LONG);\n\n\t\tif (sop->sem_num >= max)\n	f
7594	397	drm_atomic_normalize_zpos	drivers/gpu/drm/drm_blend.c	new_crtc_state->plane_mask	1	11	\N	\N	\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tint i, ret = 0;\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tcrtc = new_plane_state->crtc;\n\t\tif (!crtc)\n\t\t\tcontinue;\n\t\tif (old_plane_state->zpos != new_plane_state->zpos) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\t\tnew_crtc_state->zpos_changed = true;\n\t\t}\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tif (old_crtc_state->plane_mask != new_crtc_state->plane_mask ||\n	t
7256	130	pn533_i2c_read	drivers/nfc/pn533/i2c.c	skb	1	11	\N	\N	\tstruct i2c_client *client = phy->i2c_dev;\n\tint len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t  PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t  PN533_STD_FRAME_TAIL_LEN + 1;\n\tint r;\n\n\t*skb = alloc_skb(len, GFP_KERNEL);\n\tif (*skb == NULL)\n\t\treturn -ENOMEM;\n\n\tr = i2c_master_recv(client, skb_put(*skb, len), len);\n\tif (r != len) {\n\t\tnfc_err(&client->dev, "cannot read. r=%d len=%d\\n", r, len);\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (!((*skb)->data[0] & 0x01)) {\n	t
7502	6267	ironlake_fdi_compute_config	drivers/gpu/drm/i915/intel_display.c	ret	1	11	\N	\N	\tstruct drm_device *dev = intel_crtc->base.dev;\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\n\tint lane, link_bw, fdi_dotclock, ret;\n\tbool needs_recompute = false;\n\nretry:\n\t/* FDI is a binary signal running at ~2.7GHz, encoding\n\t * each output octet as 10 bits. The actual frequency\n\t * is stored as a divider into a 100MHz clock, and the\n\t * mode pixel clock is stored in units of 1KHz.\n\t * Hence the bw of each lane in terms of the mode signal\n\t * is:\n\t */\n\tlink_bw = intel_fdi_link_freq(to_i915(dev), pipe_config);\n\n\tfdi_dotclock = adjusted_mode->crtc_clock;\n\n\tlane = ironlake_get_lanes_required(fdi_dotclock, link_bw,\n\t\t\t\t\t   pipe_config->pipe_bpp);\n\n\tpipe_config->fdi_lanes = lane;\n\n\tintel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,\n\t\t\t       link_bw, &pipe_config->fdi_m_n, false);\n\n\tret = ironlake_check_fdi_lanes(dev, intel_crtc->pipe, pipe_config);\n\tif (ret == -EINVAL && pipe_config->pipe_bpp > 6*3) {\n	t
7553	113	lp8727_read_bytes	drivers/power/supply/lp8727_charger.c	ret	1	11	\N	\N	\ts32 ret;\n\n\tmutex_lock(&pchg->xfer_lock);\n\tret = i2c_smbus_read_i2c_block_data(pchg->client, reg, len, data);\n\tmutex_unlock(&pchg->xfer_lock);\n\n\treturn (ret != len) ? -EIO : 0;\n	t
7566	235	wep_encrypt	drivers/staging/wlan-ng/p80211wep.c	iv	1	11	\N	\N	\tu32 i, j, k, crc, keylen;\n\tu8 s[256], key[64];\n\n\t/* no point in WEPping an empty frame */\n\tif (len <= 0)\n\t\treturn -1;\n\n\t/* we need to have a real key.. */\n\tif (keynum >= NUM_WEPKEYS)\n\t\treturn -2;\n\tkeylen = wlandev->wep_keylens[keynum];\n\tif (keylen <= 0)\n\t\treturn -3;\n\n\t/* use a random IV.  And skip known weak ones. */\n\tget_random_bytes(iv, 3);\n\twhile ((iv[1] == 0xff) && (iv[0] >= 3) && (iv[0] < keylen))\n	t
59122	690	br_mdb_del	net/bridge/br_mdb.c	entry->ifindex	6	12	\N	\N	\tstruct net *net = sock_net(skb->sk);\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_device *dev, *pdev;\n\tstruct br_mdb_entry *entry;\n\tstruct net_bridge_port *p;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\t/* If vlan filtering is enabled and VLAN is not specified\n\t * delete mdb entry on all vlans configured on the port.\n\t */\n\tpdev = __dev_get_by_index(net, entry->ifindex);\n	t
7765	659	sdp_parse_addr	net/netfilter/nf_conntrack_sip.c	ret	1	11	\N	\N	\tconst char *end;\n\tint ret;\n\n\tmemset(addr, 0, sizeof(*addr));\n\tswitch (nf_ct_l3num(ct)) {\n\tcase AF_INET:\n\t\tret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tret = in6_pton(cp, limit - cp, (u8 *)&addr->ip6, -1, &end);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (ret == 0)\n	t
8347	274	rx8010_read_alarm	drivers/rtc/rtc-rx8010.c	alarmvals	1	11	\N	\N	\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = rx8010->client;\n\tu8 alarmvals[3];\n\tint flagreg;\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(client, RX8010_ALMIN, 3, alarmvals);\n\tif (err != 3)\n\t\treturn err < 0 ? err : -EIO;\n\n\tflagreg = i2c_smbus_read_byte_data(client, RX8010_FLAG);\n\tif (flagreg < 0)\n\t\treturn flagreg;\n\n\tt->time.tm_sec = 0;\n\tt->time.tm_min = bcd2bin(alarmvals[0] & 0x7f);\n\tt->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\n\n\tif (!(alarmvals[2] & RX8010_ALARM_AE))\n	t
60600	3165	ath10k_wmi_tlv_op_gen_vdev_spectral_conf	drivers/net/wireless/ath/ath10k/wmi-tlv.c	cmd->vdev_id	1	13	\N	\N	\tstruct wmi_vdev_spectral_conf_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SPECTRAL_CONFIGURE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n	f
61276	127	snd_trident_probe	sound/pci/trident/trident.c	card->longname	1	13	\N	\N	\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_trident *trident;\n\tconst char *str;\n\tint err, pcm_dev = 0;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((err = snd_trident_create(card, pci,\n\t\t\t\t      pcm_channels[dev],\n\t\t\t\t      ((pci->vendor << 16) | pci->device) == TRIDENT_DEVICE_ID_SI7018 ? 1 : 2,\n\t\t\t\t      wavetable_size[dev],\n\t\t\t\t      &trident)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tcard->private_data = trident;\n\n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_DX:\n\t\tstr = "TRID4DWAVEDX";\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\tstr = "TRID4DWAVENX";\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\tstr = "SI7018";\n\t\tbreak;\n\tdefault:\n\t\tstr = "Unknown";\n\t}\n\tstrcpy(card->driver, str);\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\tstrcpy(card->shortname, "SiS ");\n\t} else {\n\t\tstrcpy(card->shortname, "Trident ");\n\t}\n\tstrcat(card->shortname, card->driver);\n\tsprintf(card->longname, "%s PCI Audio at 0x%lx, irq %d",\n	f
7981	170	ath5k_eeprom_init_header	drivers/net/wireless/ath/ath5k/eeprom.c	val	1	11	\N	\N	\tstruct ath5k_eeprom_info *ee = &ah->ah_capabilities.cap_eeprom;\n\tu16 val;\n\tu32 cksum, offset, eep_max = AR5K_EEPROM_INFO_MAX;\n\n\t/*\n\t * Read values from EEPROM and store them in the capability structure\n\t */\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MAGIC, ee_magic);\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_PROTECT, ee_protect);\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_REG_DOMAIN, ee_regdomain);\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_VERSION, ee_version);\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_HDR, ee_header);\n\n\t/* Return if we have an old EEPROM */\n\tif (ah->ah_ee_version < AR5K_EEPROM_VERSION_3_0)\n\t\treturn 0;\n\n\t/*\n\t * Validate the checksum of the EEPROM date. There are some\n\t * devices with invalid EEPROMs.\n\t */\n\tAR5K_EEPROM_READ(AR5K_EEPROM_SIZE_UPPER, val);\n\tif (val) {\n\t\teep_max = (val & AR5K_EEPROM_SIZE_UPPER_MASK) <<\n\t\t\t   AR5K_EEPROM_SIZE_ENDLOC_SHIFT;\n\t\tAR5K_EEPROM_READ(AR5K_EEPROM_SIZE_LOWER, val);\n\t\teep_max = (eep_max | val) - AR5K_EEPROM_INFO_BASE;\n\n\t\t/*\n\t\t * Fail safe check to prevent stupid loops due\n\t\t * to busted EEPROMs. XXX: This value is likely too\n\t\t * big still, waiting on a better value.\n\t\t */\n\t\tif (eep_max > (3 * AR5K_EEPROM_INFO_MAX)) {\n\t\t\tATH5K_ERR(ah, "Invalid max custom EEPROM size: "\n\t\t\t\t  "%d (0x%04x) max expected: %d (0x%04x)\\n",\n\t\t\t\t  eep_max, eep_max,\n\t\t\t\t  3 * AR5K_EEPROM_INFO_MAX,\n\t\t\t\t  3 * AR5K_EEPROM_INFO_MAX);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfor (cksum = 0, offset = 0; offset < eep_max; offset++) {\n\t\tAR5K_EEPROM_READ(AR5K_EEPROM_INFO(offset), val);\n\t\tcksum ^= val;\n\t}\n\tif (cksum != AR5K_EEPROM_INFO_CKSUM) {\n\t\tATH5K_ERR(ah, "Invalid EEPROM "\n\t\t\t  "checksum: 0x%04x eep_max: 0x%04x (%s)\\n",\n\t\t\t  cksum, eep_max,\n\t\t\t  eep_max == AR5K_EEPROM_INFO_MAX ?\n\t\t\t\t"default size" : "custom size");\n\t\treturn -EIO;\n\t}\n\n\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_ANT_GAIN(ah->ah_ee_version),\n\t    ee_ant_gain);\n\n\tif (ah->ah_ee_version >= AR5K_EEPROM_VERSION_4_0) {\n\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC0, ee_misc0);\n\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC1, ee_misc1);\n\n\t\t/* XXX: Don't know which versions include these two */\n\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC2, ee_misc2);\n\n\t\tif (ee->ee_version >= AR5K_EEPROM_VERSION_4_3)\n\t\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC3, ee_misc3);\n\n\t\tif (ee->ee_version >= AR5K_EEPROM_VERSION_5_0) {\n\t\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC4, ee_misc4);\n\t\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC5, ee_misc5);\n\t\t\tAR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC6, ee_misc6);\n\t\t}\n\t}\n\n\tif (ah->ah_ee_version < AR5K_EEPROM_VERSION_3_3) {\n\t\tAR5K_EEPROM_READ(AR5K_EEPROM_OBDB0_2GHZ, val);\n\t\tee->ee_ob[AR5K_EEPROM_MODE_11B][0] = val & 0x7;\n\t\tee->ee_db[AR5K_EEPROM_MODE_11B][0] = (val >> 3) & 0x7;\n\n\t\tAR5K_EEPROM_READ(AR5K_EEPROM_OBDB1_2GHZ, val);\n\t\tee->ee_ob[AR5K_EEPROM_MODE_11G][0] = val & 0x7;\n\t\tee->ee_db[AR5K_EEPROM_MODE_11G][0] = (val >> 3) & 0x7;\n\t}\n\n\tAR5K_EEPROM_READ(AR5K_EEPROM_IS_HB63, val);\n\n\tif ((ah->ah_mac_version == (AR5K_SREV_AR2425 >> 4)) && val)\n\t\tee->ee_is_hb63 = true;\n\telse\n\t\tee->ee_is_hb63 = false;\n\n\tAR5K_EEPROM_READ(AR5K_EEPROM_RFKILL, val);\n\tee->ee_rfkill_pin = (u8) AR5K_REG_MS(val, AR5K_EEPROM_RFKILL_GPIO_SEL);\n\tee->ee_rfkill_pol = val & AR5K_EEPROM_RFKILL_POLARITY ? true : false;\n	t
30481	638	rxe_qp_from_attr	drivers/infiniband/sw/rxe/rxe_qp.c	&sgid_attr	1	13	\N	\N	\tint err;\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\tunion ib_gid sgid;\n\tstruct ib_gid_attr sgid_attr;\n\n\tif (mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tint max_rd_atomic = __roundup_pow_of_two(attr->max_rd_atomic);\n\n\t\tqp->attr.max_rd_atomic = max_rd_atomic;\n\t\tatomic_set(&qp->req.rd_atomic, max_rd_atomic);\n\t}\n\n\tif (mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tint max_dest_rd_atomic =\n\t\t\t__roundup_pow_of_two(attr->max_dest_rd_atomic);\n\n\t\tqp->attr.max_dest_rd_atomic = max_dest_rd_atomic;\n\n\t\tfree_rd_atomic_resources(qp);\n\n\t\terr = alloc_rd_atomic_resources(qp, max_dest_rd_atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (mask & IB_QP_CUR_STATE)\n\t\tqp->attr.cur_qp_state = attr->qp_state;\n\n\tif (mask & IB_QP_EN_SQD_ASYNC_NOTIFY)\n\t\tqp->attr.en_sqd_async_notify = attr->en_sqd_async_notify;\n\n\tif (mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->attr.qp_access_flags = attr->qp_access_flags;\n\n\tif (mask & IB_QP_PKEY_INDEX)\n\t\tqp->attr.pkey_index = attr->pkey_index;\n\n\tif (mask & IB_QP_PORT)\n\t\tqp->attr.port_num = attr->port_num;\n\n\tif (mask & IB_QP_QKEY)\n\t\tqp->attr.qkey = attr->qkey;\n\n\tif (mask & IB_QP_AV) {\n\t\tib_get_cached_gid(&rxe->ib_dev, 1,\n\t\t\t\t  rdma_ah_read_grh(&attr->ah_attr)->sgid_index,\n\t\t\t\t  &sgid, &sgid_attr);\n\t\trxe_av_from_attr(rxe, attr->port_num, &qp->pri_av,\n\t\t\t\t &attr->ah_attr);\n\t\trxe_av_fill_ip_info(rxe, &qp->pri_av, &attr->ah_attr,\n	f
8366	152	if_usb_setup_firmware	drivers/net/wireless/marvell/libertas/if_usb.c	wake_method.method	1	11	\N	\N	\tstruct if_usb_card *cardp = priv->card;\n\tstruct cmd_ds_set_boot2_ver b2_cmd;\n\tstruct cmd_ds_802_11_fw_wake_method wake_method;\n\n\tb2_cmd.hdr.size = cpu_to_le16(sizeof(b2_cmd));\n\tb2_cmd.action = 0;\n\tb2_cmd.version = cardp->boot2_version;\n\n\tif (lbs_cmd_with_response(priv, CMD_SET_BOOT2_VER, &b2_cmd))\n\t\tlbs_deb_usb("Setting boot2 version failed\\n");\n\n\tpriv->wol_gpio = 2; /* Wake via GPIO2... */\n\tpriv->wol_gap = 20; /* ... after 20ms    */\n\tlbs_host_sleep_cfg(priv, EHS_WAKE_ON_UNICAST_DATA,\n\t\t\t(struct wol_config *) NULL);\n\n\twake_method.hdr.size = cpu_to_le16(sizeof(wake_method));\n\twake_method.action = cpu_to_le16(CMD_ACT_GET);\n\tif (lbs_cmd_with_response(priv, CMD_802_11_FW_WAKE_METHOD, &wake_method)) {\n\t\tnetdev_info(priv->dev, "Firmware does not seem to support PS mode\\n");\n\t\tpriv->fwcapinfo &= ~FW_CAPINFO_PS;\n\t} else {\n\t\tif (le16_to_cpu(wake_method.method) == CMD_WAKE_METHOD_COMMAND_INT) {\n	t
8261	312	cyapa_smbus_read_block	drivers/input/mouse/cyapa_gen3.c	ret	1	11	\N	\N	\tssize_t ret;\n\tu8 index;\n\tu8 smbus_cmd;\n\tu8 *buf;\n\tstruct i2c_client *client = cyapa->client;\n\n\tif (!(SMBUS_BYTE_BLOCK_CMD_MASK & cmd))\n\t\treturn -EINVAL;\n\n\tif (SMBUS_GROUP_BLOCK_CMD_MASK & cmd) {\n\t\t/* read specific block registers command. */\n\t\tsmbus_cmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\n\t\tret = i2c_smbus_read_block_data(client, smbus_cmd, values);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tfor (index = 0; index * I2C_SMBUS_BLOCK_MAX < len; index++) {\n\t\tsmbus_cmd = SMBUS_ENCODE_IDX(cmd, index);\n\t\tsmbus_cmd = SMBUS_ENCODE_RW(smbus_cmd, SMBUS_READ);\n\t\tbuf = values + I2C_SMBUS_BLOCK_MAX * index;\n\t\tret = i2c_smbus_read_block_data(client, smbus_cmd, buf);\n\t\tif (ret < 0)\n	t
1499	1479	i40e_add_mac_filter	drivers/net/ethernet/intel/i40e/i40e_main.c	i40e_add_mac_filter_$__mptr30$obj	0	13	\N	\N	\tstruct i40e_mac_filter *f, *add = NULL;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\tif (vsi->info.pvid)\n\t\treturn i40e_add_filter(vsi, macaddr,\n\t\t\t\t       le16_to_cpu(vsi->info.pvid));\n\n\tif (!i40e_is_vsi_in_vlan(vsi))\n\t\treturn i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);\n\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n	f
7823	845	i40e_get_dcb_config	drivers/net/ethernet/intel/i40e/i40e_dcb.c	&cee_v1_cfg	1	13	\N	\N	\ti40e_status ret = 0;\n\tstruct i40e_aqc_get_cee_dcb_cfg_resp cee_cfg;\n\tstruct i40e_aqc_get_cee_dcb_cfg_v1_resp cee_v1_cfg;\n\n\t/* If Firmware version < v4.33 on X710/XL710, IEEE only */\n\tif ((hw->mac.type == I40E_MAC_XL710) &&\n\t    (((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver < 33)) ||\n\t      (hw->aq.fw_maj_ver < 4)))\n\t\treturn i40e_get_ieee_dcb_config(hw);\n\n\t/* If Firmware version == v4.33 on X710/XL710, use old CEE struct */\n\tif ((hw->mac.type == I40E_MAC_XL710) &&\n\t    ((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver == 33))) {\n\t\tret = i40e_aq_get_cee_dcb_config(hw, &cee_v1_cfg,\n\t\t\t\t\t\t sizeof(cee_v1_cfg), NULL);\n\t\tif (!ret) {\n\t\t\t/* CEE mode */\n\t\t\thw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;\n\t\t\thw->local_dcbx_config.tlv_status =\n\t\t\t\t\tle16_to_cpu(cee_v1_cfg.tlv_status);\n\t\t\ti40e_cee_to_dcb_v1_config(&cee_v1_cfg,\n	f
21283	1159	doc_write_erase_wait_status	drivers/mtd/devices/docg3.c	status	1	13	\N	\N	\tint i, status, ret = 0;\n\n\tfor (i = 0; !doc_is_ready(docg3) && i < 5; i++)\n\t\tmsleep(20);\n\tif (!doc_is_ready(docg3)) {\n\t\tdoc_dbg("Timeout reached and the chip is still not ready\\n");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tstatus = doc_get_op_status(docg3);\n\tif (status & DOC_PLANES_STATUS_FAIL) {\n	f
9065	799	gcmaes_encrypt	arch/x86/crypto/aesni-intel_glue.c	&src_sg_walk	1	11	\N	\N	\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk dst_sg_walk = {};\n\n\tif (sg_is_last(req->src) &&\n\t    (!PageHighMem(sg_page(req->src)) ||\n\t    req->src->offset + req->src->length <= PAGE_SIZE) &&\n\t    sg_is_last(req->dst) &&\n\t    (!PageHighMem(sg_page(req->dst)) ||\n\t    req->dst->offset + req->dst->length <= PAGE_SIZE)) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tassoc = scatterwalk_map(&src_sg_walk);\n\t\tsrc = assoc + req->assoclen;\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk) + req->assoclen;\n\t\t}\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n\t\tassoc = kmalloc(req->cryptlen + auth_tag_len + req->assoclen,\n\t\t\tGFP_ATOMIC);\n\t\tif (unlikely(!assoc))\n\t\t\treturn -ENOMEM;\n\t\tscatterwalk_map_and_copy(assoc, req->src, 0,\n\t\t\t\t\t req->assoclen + req->cryptlen, 0);\n\t\tsrc = assoc + req->assoclen;\n\t\tdst = src;\n\t}\n\n\tkernel_fpu_begin();\n\taesni_gcm_enc_tfm(aes_ctx, dst, src, req->cryptlen, iv,\n\t\t\t  hash_subkey, assoc, assoclen,\n\t\t\t  dst + req->cryptlen, auth_tag_len);\n\tkernel_fpu_end();\n\n\t/* The authTag (aka the Integrity Check Value) needs to be written\n\t * back to the packet. */\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst - req->assoclen);\n\t\t\tscatterwalk_advance(&dst_sg_walk, req->dst->length);\n\t\t\tscatterwalk_done(&dst_sg_walk, 1, 0);\n\t\t}\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_advance(&src_sg_walk, req->src->length);\n\t\tscatterwalk_done(&src_sg_walk, req->src == req->dst, 0);\n	t
9109	346	fix_header	drivers/staging/rtl8712/rtl8712_efuse.c	pkt.data	1	11	\N	\N	\tstruct PGPKT_STRUCT pkt;\n\tu8 offset, word_en, value;\n\tu16 addr;\n\tint i;\n\tu8 ret = true;\n\n\tpkt.offset = GET_EFUSE_OFFSET(header);\n\tpkt.word_en = GET_EFUSE_WORD_EN(header);\n\taddr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;\n\tif (addr > efuse_available_max_size)\n\t\treturn false;\n\t/* retrieve original data */\n\taddr = 0;\n\twhile (addr < header_addr) {\n\t\tif (!efuse_one_byte_read(padapter, addr++, &value)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\toffset = GET_EFUSE_OFFSET(value);\n\t\tword_en = GET_EFUSE_WORD_EN(value);\n\t\tif (pkt.offset != offset) {\n\t\t\taddr += calculate_word_cnts(word_en) * 2;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\n\t\t\tif (BIT(i) & word_en) {\n\t\t\t\tif (BIT(i) & pkt.word_en) {\n\t\t\t\t\tif (efuse_one_byte_read(\n\t\t\t\t\t\t\tpadapter, addr,\n\t\t\t\t\t\t\t&value))\n\t\t\t\t\t\tpkt.data[i * 2] = value;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (efuse_one_byte_read(\n\t\t\t\t\t\t\tpadapter,\n\t\t\t\t\t\t\taddr + 1,\n\t\t\t\t\t\t\t&value))\n\t\t\t\t\t\tpkt.data[i * 2 + 1] =\n\t\t\t\t\t\t\tvalue;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\taddr += 2;\n\t\t\t}\n\t\t}\n\t}\n\tif (addr != header_addr)\n\t\treturn false;\n\taddr++;\n\t/* fill original data */\n\tfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\n\t\tif (BIT(i) & pkt.word_en) {\n\t\t\tefuse_one_byte_write(padapter, addr, pkt.data[i * 2]);\n\t\t\tefuse_one_byte_write(padapter, addr + 1,\n\t\t\t\t\t     pkt.data[i * 2 + 1]);\n\t\t\t/* additional check */\n\t\t\tif (!efuse_one_byte_read(padapter, addr, &value)) {\n\t\t\t\tret = false;\n\t\t\t} else if (pkt.data[i * 2] != value) {\n	t
31796	2825	intel_sdvo_create_enhance_property_tv	drivers/gpu/drm/i915/intel_sdvo.c	intel_sdvo_create_enhance_property_tv_$response$obj	0	13	\N	\N	\tstruct drm_device *dev = intel_sdvo->base.base.dev;\n\tstruct drm_connector *connector = &intel_sdvo_connector->base.base;\n\tstruct drm_connector_state *conn_state = connector->state;\n\tstruct intel_sdvo_connector_state *sdvo_state =\n\t\tto_intel_sdvo_connector_state(conn_state);\n\tuint16_t response, data_value[2];\n\n\t/* when horizontal overscan is supported, Add the left/right  property */\n\tif (enhancements.overscan_h) {\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_MAX_OVERSCAN_H,\n\t\t\t\t\t  &data_value, 4))\n\t\t\treturn false;\n\n\t\tif (!intel_sdvo_get_value(intel_sdvo,\n\t\t\t\t\t  SDVO_CMD_GET_OVERSCAN_H,\n\t\t\t\t\t  &response, 2))\n\t\t\treturn false;\n\n\t\tsdvo_state->tv.overscan_h = response;\n\n\t\tintel_sdvo_connector->max_hscan = data_value[0];\n\t\tintel_sdvo_connector->left =\n\t\t\tdrm_property_create_range(dev, 0, "left_margin", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->left)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   intel_sdvo_connector->left, 0);\n\n\t\tintel_sdvo_connector->right =\n\t\t\tdrm_property_create_range(dev, 0, "right_margin", 0, data_value[0]);\n\t\tif (!intel_sdvo_connector->right)\n\t\t\treturn false;\n\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t      intel_sdvo_connector->right, 0);\n\t\tDRM_DEBUG_KMS("h_overscan: max %d, "\n	f
9295	310	mxc4005_trigger_handler	drivers/iio/accel/mxc4005.c	ret	1	11	\N	\N	\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mxc4005_read_xyz(data);\n\tif (ret < 0)\n	t
9520	584	load_pdptrs	arch/x86/kvm/x86.c	pdpte	1	11	\N	\N	\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif ((pdpte[i] & PT_PRESENT_MASK) &&\n	t
9533	4959	kvm_mmu_page_fault	arch/x86/kvm/mmu.c	er	1	11	\N	\N	\tint r, emulation_type = EMULTYPE_RETRY;\n\tenum emulation_result er;\n\tbool direct = vcpu->arch.mmu.direct_map;\n\n\t/* With shadow page tables, fault_address contains a GVA or nGPA.  */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tvcpu->arch.gpa_available = true;\n\t\tvcpu->arch.gpa_val = cr2;\n\t}\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2, direct);\n\t\tif (r == RET_MMIO_PF_EMULATE) {\n\t\t\temulation_type = 0;\n\t\t\tgoto emulate;\n\t\t}\n\t\tif (r == RET_MMIO_PF_RETRY)\n\t\t\treturn 1;\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\t/* Must be RET_MMIO_PF_INVALID.  */\n\t}\n\n\tr = vcpu->arch.mmu.page_fault(vcpu, cr2, lower_32_bits(error_code),\n\t\t\t\t      false);\n\tif (r < 0)\n\t\treturn r;\n\tif (!r)\n\t\treturn 1;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu.direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2));\n\t\treturn 1;\n\t}\n\n\tif (mmio_info_in_cache(vcpu, cr2, direct))\n\t\temulation_type = 0;\nemulate:\n\ter = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);\n\n\tswitch (er) {\n	t
9538	240	shutdown_handler	drivers/xen/manage.c	xbt	1	11	\N	\N	\tchar *str;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tint idx;\n\n\tif (shutting_down != SHUTDOWN_INVALID)\n\t\treturn;\n\n again:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err)\n\t\treturn;\n\n\tstr = (char *)xenbus_read(xbt, "control", "shutdown", NULL);\n\t/* Ignore read errors and empty reads. */\n\tif (XENBUS_IS_ERR_READ(str)) {\n\t\txenbus_transaction_end(xbt, 1);\n	t
9673	1893	cxd2841er_read_agc_gain_c	drivers/media/dvb-frontends/cxd2841er.c	data	2	-11	\N	\N	\tu8 data[2];\n\n\tcxd2841er_write_reg(\n\t\tpriv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);\n\tdev_dbg(&priv->i2c->dev,\n	t
9841	2219	qed_hw_set_soft_resc_size	drivers/net/ethernet/qlogic/qed/qed_dev.c	mcp_resp	1	11	\N	\N	\tbool b_ah = QED_IS_AH(p_hwfn->cdev);\n\tu32 resc_max_val, mcp_resp;\n\tu8 res_id;\n\tint rc;\n\n\tfor (res_id = 0; res_id < QED_MAX_RESC; res_id++) {\n\t\tswitch (res_id) {\n\t\tcase QED_LL2_QUEUE:\n\t\t\tresc_max_val = MAX_NUM_LL2_RX_QUEUES;\n\t\t\tbreak;\n\t\tcase QED_RDMA_CNQ_RAM:\n\t\t\t/* No need for a case for QED_CMDQS_CQS since\n\t\t\t * CNQ/CMDQS are the same resource.\n\t\t\t */\n\t\t\tresc_max_val = NUM_OF_CMDQS_CQS;\n\t\t\tbreak;\n\t\tcase QED_RDMA_STATS_QUEUE:\n\t\t\tresc_max_val = b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2\n\t\t\t    : RDMA_NUM_STATISTIC_COUNTERS_BB;\n\t\t\tbreak;\n\t\tcase QED_BDQ:\n\t\t\tresc_max_val = BDQ_NUM_RESOURCES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = __qed_hw_set_soft_resc_size(p_hwfn, p_ptt, res_id,\n\t\t\t\t\t\t resc_max_val, &mcp_resp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* There's no point to continue to the next resource if the\n\t\t * command is not supported by the MFW.\n\t\t * We do continue if the command is supported but the resource\n\t\t * is unknown to the MFW. Such a resource will be later\n\t\t * configured with the default allocation values.\n\t\t */\n\t\tif (mcp_resp == FW_MSG_CODE_UNSUPPORTED)\n	t
9955	3344	config_pcie	drivers/net/ethernet/chelsio/cxgb3/t3_hw.c	val	1	11	\N	\N	\tstatic const u16 ack_lat[4][6] = {\n\t\t{237, 416, 559, 1071, 2095, 4143},\n\t\t{128, 217, 289, 545, 1057, 2081},\n\t\t{73, 118, 154, 282, 538, 1050},\n\t\t{67, 107, 86, 150, 278, 534}\n\t};\n\tstatic const u16 rpl_tmr[4][6] = {\n\t\t{711, 1248, 1677, 3213, 6285, 12429},\n\t\t{384, 651, 867, 1635, 3171, 6243},\n\t\t{219, 354, 462, 846, 1614, 3150},\n\t\t{201, 321, 258, 450, 834, 1602}\n\t};\n\n\tu16 val, devid;\n\tunsigned int log2_width, pldsize;\n\tunsigned int fst_trn_rx, fst_trn_tx, acklat, rpllmt;\n\n\tpcie_capability_read_word(adap->pdev, PCI_EXP_DEVCTL, &val);\n\tpldsize = (val & PCI_EXP_DEVCTL_PAYLOAD) >> 5;\n\n\tpci_read_config_word(adap->pdev, 0x2, &devid);\n\tif (devid == 0x37) {\n\t\tpcie_capability_write_word(adap->pdev, PCI_EXP_DEVCTL,\n\t\t\t\t\t   val & ~PCI_EXP_DEVCTL_READRQ &\n\t\t\t\t\t   ~PCI_EXP_DEVCTL_PAYLOAD);\n\t\tpldsize = 0;\n\t}\n\n\tpcie_capability_read_word(adap->pdev, PCI_EXP_LNKCTL, &val);\n\n\tfst_trn_tx = G_NUMFSTTRNSEQ(t3_read_reg(adap, A_PCIE_PEX_CTRL0));\n\tfst_trn_rx = adap->params.rev == 0 ? fst_trn_tx :\n\t    G_NUMFSTTRNSEQRX(t3_read_reg(adap, A_PCIE_MODE));\n\tlog2_width = fls(adap->params.pci.width) - 1;\n\tacklat = ack_lat[log2_width][pldsize];\n\tif (val & PCI_EXP_LNKCTL_ASPM_L0S)\t/* check LOsEnable */\n	t
9985	2709	__nv_msi_ht_cap_quirk	drivers/pci/quirks.c	pos	1	11	\N	\N	\tstruct pci_dev *host_bridge;\n\tint pos;\n\tint found;\n\n\tif (!pci_msi_enabled())\n\t\treturn;\n\n\t/* check if there is HT MSI cap or enabled on this device */\n\tfound = ht_check_msi_mapping(dev);\n\n\t/* no HT MSI CAP */\n\tif (found == 0)\n\t\treturn;\n\n\t/*\n\t * HT MSI mapping should be disabled on devices that are below\n\t * a non-Hypertransport host bridge. Locate the host bridge...\n\t */\n\thost_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\n\tif (host_bridge == NULL) {\n\t\tdev_warn(&dev->dev, "nv_msi_ht_cap_quirk didn't locate host bridge\\n");\n\t\treturn;\n\t}\n\n\tpos = pci_find_ht_capability(host_bridge, HT_CAPTYPE_SLAVE);\n\tif (pos != 0) {\n	t
20189	4182	sch_handle_ingress	net/core/dev.c	skb	1	11	\N	\N	#ifdef CONFIG_NET_CLS_ACT\n\tstruct tcf_proto *cl = rcu_dereference_bh(skb->dev->ingress_cl_list);\n\tstruct tcf_result cl_res;\n\n\t/* If there's at least one ingress present somewhere (so\n\t * we get here via enabled static key), remaining devices\n\t * that are not configured with an ingress qdisc will bail\n\t * out here.\n\t */\n\tif (!cl)\n\t\treturn skb;\n\tif (*pt_prev) {\n\t\t*ret = deliver_skb(skb, *pt_prev, orig_dev);\n\t\t*pt_prev = NULL;\n\t}\n\n\tqdisc_skb_cb(skb)->pkt_len = skb->len;\n\tskb->tc_at_ingress = 1;\n\tqdisc_bstats_cpu_update(cl->q, skb);\n\n\tswitch (tcf_classify(skb, cl, &cl_res, false)) {\n\tcase TC_ACT_OK:\n\tcase TC_ACT_RECLASSIFY:\n\t\tskb->tc_index = TC_H_MIN(cl_res.classid);\n\t\tbreak;\n\tcase TC_ACT_SHOT:\n\t\tqdisc_qstats_cpu_drop(cl->q);\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\tcase TC_ACT_STOLEN:\n\tcase TC_ACT_QUEUED:\n\tcase TC_ACT_TRAP:\n\t\tconsume_skb(skb);\n\t\treturn NULL;\n\tcase TC_ACT_REDIRECT:\n\t\t/* skb_mac_header check was done by cls/act_bpf, so\n\t\t * we can safely push the L2 header back before\n\t\t * redirecting to another netdev\n\t\t */\n\t\t__skb_push(skb, skb->mac_len);\n\t\tskb_do_redirect(skb);\n	t
29435	288	jl2005c_stream_start_cif_small	drivers/media/usb/gspca/jl2005bcd.c	retval	1	13	\N	\N	\tint i;\n\tint retval = -1;\n\tstatic u8 instruction[][2] = {\n\t\t{0x06, 0x00},\n\t\t{0x7c, 0x00},\n\t\t{0x7d, 0x32},\n\t\t{0x02, 0x00},\n\t\t{0x01, 0x00},\n\t\t{0x04, 0x42},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\n\t\tmsleep(60);\n\t\tretval = jl2005c_write2(gspca_dev, instruction[i]);\n\t\tif (retval < 0)\n	f
62669	476	trace_event_raw_event_btrfs__writepage	fs/btrfs/super.c	info	1	13	\N	\N	\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\tenum btrfs_compression_type saved_compress_type;\n\tbool saved_compress_force;\n\tint no_compress = 0;\n\n\tcache_gen = btrfs_super_cache_generation(info->super_copy);\n\tif (btrfs_fs_compat_ro(info, FREE_SPACE_TREE))\n\t\tbtrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);\n\telse if (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\t/*\n\t * Even the options are empty, we still need to do extra check\n\t * against new flags\n\t */\n\tif (!options)\n\t\tgoto check;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, ",")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(info, "allowing degraded mounts");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(info, NODATASUM,\n\t\t\t\t\t   "setting nodatasum");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(info, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(info, NODATACOW))\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   "setting datasum, datacow enabled");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(info, "setting datasum");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(info, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(info, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(info, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   "setting nodatacow, compression disabled");\n\t\t\t\t} else {\n	f
20663	983	aa_replace_profiles	security/apparmor/policy.c	ent->new->ns	1	11	\N	\N	\tconst char *ns_name, *info = NULL;\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_load_ent *ent, *tmp;\n\tstruct aa_loaddata *rawdata_ent;\n\tconst char *op;\n\tssize_t count, error;\n\tLIST_HEAD(lh);\n\n\top = mask & AA_MAY_REPLACE_POLICY ? OP_PROF_REPL : OP_PROF_LOAD;\n\taa_get_loaddata(udata);\n\t/* released below */\n\terror = aa_unpack(udata, &lh, &ns_name);\n\tif (error)\n\t\tgoto out;\n\n\t/* ensure that profiles are all for the same ns\n\t * TODO: update locking to remove this constaint. All profiles in\n\t *       the load set must succeed as a set or the load will\n\t *       fail. Sort ent list and take ns locks in hierarchy order\n\t */\n\tcount = 0;\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (ns_name) {\n\t\t\tif (ent->ns_name &&\n\t\t\t    strcmp(ent->ns_name, ns_name) != 0) {\n\t\t\t\tinfo = "policy load has mixed namespaces";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if (ent->ns_name) {\n\t\t\tif (count) {\n\t\t\t\tinfo = "policy load has mixed namespaces";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tns_name = ent->ns_name;\n\t\t} else\n\t\t\tcount++;\n\t}\n\tif (ns_name) {\n\t\tns = aa_prepare_ns(policy_ns ? policy_ns : labels_ns(label),\n\t\t\t\t   ns_name);\n\t\tif (IS_ERR(ns)) {\n\t\t\top = OP_PROF_LOAD;\n\t\t\tinfo = "failed to prepare namespace";\n\t\t\terror = PTR_ERR(ns);\n\t\t\tns = NULL;\n\t\t\tent = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(label));\n\n\tmutex_lock(&ns->lock);\n\t/* check for duplicate rawdata blobs: space and file dedup */\n\tlist_for_each_entry(rawdata_ent, &ns->rawdata_list, list) {\n\t\tif (aa_rawdata_eq(rawdata_ent, udata)) {\n\t\t\tstruct aa_loaddata *tmp;\n\n\t\t\ttmp = __aa_get_loaddata(rawdata_ent);\n\t\t\t/* check we didn't fail the race */\n\t\t\tif (tmp) {\n\t\t\t\taa_put_loaddata(udata);\n\t\t\t\tudata = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* setup parent and ns info */\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tstruct aa_policy *policy;\n\n\t\tent->new->rawdata = aa_get_loaddata(udata);\n\t\terror = __lookup_replace(ns, ent->new->base.hname,\n\t\t\t\t\t !(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t &ent->old, &info);\n\t\tif (error)\n\t\t\tgoto fail_lock;\n\n\t\tif (ent->new->rename) {\n\t\t\terror = __lookup_replace(ns, ent->new->rename,\n\t\t\t\t\t\t!(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t\t&ent->rename, &info);\n\t\t\tif (error)\n\t\t\t\tgoto fail_lock;\n\t\t}\n\n\t\t/* released when @new is freed */\n\t\tent->new->ns = aa_get_ns(ns);\n\n\t\tif (ent->old || ent->rename)\n\t\t\tcontinue;\n\n\t\t/* no ref on policy only use inside lock */\n\t\tpolicy = __lookup_parent(ns, ent->new->base.hname);\n\t\tif (!policy) {\n\t\t\tstruct aa_profile *p;\n\t\t\tp = __list_lookup_parent(&lh, ent->new);\n\t\t\tif (!p) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tinfo = "parent does not exist";\n\t\t\t\tgoto fail_lock;\n\t\t\t}\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t} else if (policy != &ns->base) {\n\t\t\t/* released on profile replacement or free_profile */\n\t\t\tstruct aa_profile *p = (struct aa_profile *) policy;\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t}\n\t}\n\n\t/* create new fs entries for introspection if needed */\n\tif (!udata->dents[AAFS_LOADDATA_DIR]) {\n\t\terror = __aa_fs_create_rawdata(ns, udata);\n\t\tif (error) {\n\t\t\tinfo = "failed to create raw_data dir and files";\n\t\t\tent = NULL;\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (!ent->old) {\n\t\t\tstruct dentry *parent;\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *p;\n\t\t\t\tp = aa_deref_parent(ent->new);\n\t\t\t\tparent = prof_child_dir(p);\n\t\t\t} else\n\t\t\t\tparent = ns_subprofs_dir(ent->new->ns);\n	t
21215	309	pca9541_select_chan	drivers/i2c/muxes/i2c-mux-pca9541.c	ret	2	-11	\N	\N	\tstruct pca9541 *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tunsigned long timeout = jiffies + ARB2_TIMEOUT;\n\t\t/* give up after this time */\n\n\tdata->arb_timeout = jiffies + ARB_TIMEOUT;\n\t\t/* force bus ownership after this time */\n\n\tdo {\n\t\tret = pca9541_arbitrate(client);\n\t\tif (ret)\n	t
20953	448	acpi_ds_exec_end_op	drivers/acpi/acpica/dswexec.c	walk_state->operands	1	11	\N	\N	\tunion acpi_parse_object *op;\n\tacpi_status status = AE_OK;\n\tu32 op_type;\n\tu32 op_class;\n\tunion acpi_parse_object *next_op;\n\tunion acpi_parse_object *first_arg;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_exec_end_op, walk_state);\n\n\top = walk_state->op;\n\top_type = walk_state->op_info->type;\n\top_class = walk_state->op_info->class;\n\n\tif (op_class == AML_CLASS_UNKNOWN) {\n\t\tACPI_ERROR((AE_INFO, "Unknown opcode 0x%X",\n\t\t\t    op->common.aml_opcode));\n\t\treturn_ACPI_STATUS(AE_NOT_IMPLEMENTED);\n\t}\n\n\tfirst_arg = op->common.value.arg;\n\n\t/* Init the walk state */\n\n\twalk_state->num_operands = 0;\n\twalk_state->operand_index = 0;\n\twalk_state->return_desc = NULL;\n\twalk_state->result_obj = NULL;\n\n\t/* Call debugger for single step support (DEBUG build only) */\n\n\tstatus = acpi_db_single_step(walk_state, op, op_class);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Decode the Opcode Class */\n\n\tswitch (op_class) {\n\tcase AML_CLASS_ARGUMENT:\t/* Constants, literals, etc. */\n\n\t\tif (walk_state->opcode == AML_INT_NAMEPATH_OP) {\n\t\t\tstatus = acpi_ds_evaluate_name_path(walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase AML_CLASS_EXECUTE:\t/* Most operators with arguments */\n\n\t\t/* Build resolved operand stack */\n\n\t\tstatus = acpi_ds_create_operands(walk_state, first_arg);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/*\n\t\t * All opcodes require operand resolution, with the only exceptions\n\t\t * being the object_type and size_of operators.\n\t\t */\n\t\tif (!(walk_state->op_info->flags & AML_NO_OPERAND_RESOLVE)) {\n\n\t\t\t/* Resolve all operands */\n\n\t\t\tstatus = acpi_ex_resolve_operands(walk_state->opcode,\n\t\t\t\t\t\t\t  &(walk_state->\n\t\t\t\t\t\t\t    operands\n\t\t\t\t\t\t\t    [walk_state->\n\t\t\t\t\t\t\t     num_operands - 1]),\n\t\t\t\t\t\t\t  walk_state);\n\t\t}\n\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t/*\n\t\t\t * Dispatch the request to the appropriate interpreter handler\n\t\t\t * routine. There is one routine per opcode "type" based upon the\n\t\t\t * number of opcode arguments and return type.\n\t\t\t */\n\t\t\tstatus =\n\t\t\t    acpi_gbl_op_type_dispatch[op_type] (walk_state);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Treat constructs of the form "Store(LocalX,LocalX)" as noops when the\n\t\t\t * Local is uninitialized.\n\t\t\t */\n\t\t\tif ((status == AE_AML_UNINITIALIZED_LOCAL) &&\n\t\t\t    (walk_state->opcode == AML_STORE_OP) &&\n\t\t\t    (walk_state->operands[0]->common.type ==\n	t
21185	827	ezusb_firmware_download	drivers/net/wireless/intersil/orinoco/orinoco_usb.c	retval	1	11	\N	\N	\tu8 *fw_buffer;\n\tint retval, addr;\n\tint variant_offset;\n\n\tfw_buffer = kmalloc(FW_BUF_SIZE, GFP_KERNEL);\n\tif (!fw_buffer) {\n\t\tprintk(KERN_ERR PFX "Out of memory for firmware buffer.\\n");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * This byte is 1 and should be replaced with 0.  The offset is\n\t * 0x10AD in version 0.0.6.  The byte in question should follow\n\t * the end of the code pointed to by the jump in the beginning\n\t * of the firmware.  Also, it is read by code located at 0x358.\n\t */\n\tvariant_offset = be16_to_cpup((__be16 *) &fw->code[FW_VAR_OFFSET_PTR]);\n\tif (variant_offset >= fw->size) {\n\t\tprintk(KERN_ERR PFX "Invalid firmware variant offset: "\n\t\t       "0x%04x\\n", variant_offset);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tretval = ezusb_8051_cpucs(upriv, 1);\n\tif (retval < 0)\n	t
31003	305	usb6fire_fw_fpga_upload	sound/usb/6fire/firmware.c	usb6fire_fw_fpga_upload_$fw$obj$1	0	13	\N	\N	\tint ret;\n\tint i;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tu8 *buffer = kmalloc(FPGA_BUFSIZE, GFP_KERNEL);\n\tconst char *c;\n\tconst char *end;\n\tconst struct firmware *fw;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, fwname, &device->dev);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, "unable to get fpga firmware %s.\\n",\n\t\t\t\tfwname);\n\t\tkfree(buffer);\n\t\treturn -EIO;\n\t}\n\n\tc = fw->data;\n	f
21510	310	bcma_get_next_core	drivers/bcma/scan.c	ports	1	11	\N	\N	\tu32 tmp;\n\tu8 i, j, k;\n\ts32 cia, cib;\n\tu8 ports[2], wrappers[2];\n\n\t/* get CIs */\n\tcia = bcma_erom_get_ci(bus, eromptr);\n\tif (cia < 0) {\n\t\tbcma_erom_push_ent(eromptr);\n\t\tif (bcma_erom_is_end(bus, eromptr))\n\t\t\treturn -ESPIPE;\n\t\treturn -EILSEQ;\n\t}\n\tcib = bcma_erom_get_ci(bus, eromptr);\n\tif (cib < 0)\n\t\treturn -EILSEQ;\n\n\t/* parse CIs */\n\tcore->id.class = (cia & SCAN_CIA_CLASS) >> SCAN_CIA_CLASS_SHIFT;\n\tcore->id.id = (cia & SCAN_CIA_ID) >> SCAN_CIA_ID_SHIFT;\n\tcore->id.manuf = (cia & SCAN_CIA_MANUF) >> SCAN_CIA_MANUF_SHIFT;\n\tports[0] = (cib & SCAN_CIB_NMP) >> SCAN_CIB_NMP_SHIFT;\n\tports[1] = (cib & SCAN_CIB_NSP) >> SCAN_CIB_NSP_SHIFT;\n\twrappers[0] = (cib & SCAN_CIB_NMW) >> SCAN_CIB_NMW_SHIFT;\n\twrappers[1] = (cib & SCAN_CIB_NSW) >> SCAN_CIB_NSW_SHIFT;\n\tcore->id.rev = (cib & SCAN_CIB_REV) >> SCAN_CIB_REV_SHIFT;\n\n\tif (((core->id.manuf == BCMA_MANUF_ARM) &&\n\t     (core->id.id == 0xFFF)) ||\n\t    (ports[1] == 0)) {\n	t
21379	901	irlap_send_data_secondary_final	drivers/staging/irda/net/irlap_frame.c	tx_skb	1	11	\N	\N	\tstruct sk_buff *tx_skb = NULL;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\t/* Is this reliable or unreliable data? */\n\tif (skb->data[1] == I_FRAME) {\n\n\t\t/*\n\t\t *  Insert frame sequence number (Vs) in control field before\n\t\t *  inserting into transmit window queue.\n\t\t */\n\t\tskb->data[1] = I_FRAME | (self->vs << 1);\n\n\t\t/*\n\t\t *  Insert frame in store, in case of retransmissions\n\t\t *  Increase skb reference count, see irlap_do_event()\n\t\t */\n\t\tskb_get(skb);\n\t\tskb_queue_tail(&self->wx_list, skb);\n\n\t\ttx_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (tx_skb == NULL) {\n\t\t\treturn;\n\t\t}\n\n\t\ttx_skb->data[1] |= PF_BIT;\n\n\t\tself->vs = (self->vs + 1) % 8;\n\t\tself->ack_required = FALSE;\n\n\t\tirlap_send_i_frame(self, tx_skb, RSP_FRAME);\n	t
21423	973	dspi_probe	drivers/spi/spi-fsl-dspi.c	ret	1	11	\N	\N	\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spi_master *master;\n\tstruct fsl_dspi *dspi;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret = 0, cs_num, bus_num;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tdspi = spi_master_get_devdata(master);\n\tdspi->pdev = pdev;\n\tdspi->master = master;\n\n\tmaster->transfer = NULL;\n\tmaster->setup = dspi_setup;\n\tmaster->transfer_one_message = dspi_transfer_one_message;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\n\tmaster->cleanup = dspi_cleanup;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(4) | SPI_BPW_MASK(8) |\n\t\t\t\t\tSPI_BPW_MASK(16);\n\n\tret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);\n\tif (ret < 0) {\n	t
21568	1705	ipv6_dev_get_saddr	net/ipv6/addrconf.c	scores	1	11	\N	\N	\tstruct ipv6_saddr_score scores[2], *hiscore;\n\tstruct ipv6_saddr_dst dst;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\tint dst_type;\n\tbool use_oif_addr = false;\n\tint hiscore_idx = 0;\n\n\tdst_type = __ipv6_addr_type(daddr);\n\tdst.addr = daddr;\n\tdst.ifindex = dst_dev ? dst_dev->ifindex : 0;\n\tdst.scope = __ipv6_addr_src_scope(dst_type);\n\tdst.label = ipv6_addr_label(net, daddr, dst_type, dst.ifindex);\n\tdst.prefs = prefs;\n\n\tscores[hiscore_idx].rule = -1;\n\tscores[hiscore_idx].ifa = NULL;\n\n\trcu_read_lock();\n\n\t/* Candidate Source Address (section 4)\n\t *  - multicast and link-local destination address,\n\t *    the set of candidate source address MUST only\n\t *    include addresses assigned to interfaces\n\t *    belonging to the same link as the outgoing\n\t *    interface.\n\t * (- For site-local destination addresses, the\n\t *    set of candidate source addresses MUST only\n\t *    include addresses assigned to interfaces\n\t *    belonging to the same site as the outgoing\n\t *    interface.)\n\t *  - "It is RECOMMENDED that the candidate source addresses\n\t *    be the set of unicast addresses assigned to the\n\t *    interface that will be used to send to the destination\n\t *    (the 'outgoing' interface)." (RFC 6724)\n\t */\n\tif (dst_dev) {\n\t\tidev = __in6_dev_get(dst_dev);\n\t\tif ((dst_type & IPV6_ADDR_MULTICAST) ||\n\t\t    dst.scope <= IPV6_ADDR_SCOPE_LINKLOCAL ||\n\t\t    (idev && idev->cnf.use_oif_addrs_only)) {\n\t\t\tuse_oif_addr = true;\n\t\t}\n\t}\n\n\tif (use_oif_addr) {\n\t\tif (idev)\n\t\t\thiscore_idx = __ipv6_dev_get_saddr(net, &dst, idev, scores, hiscore_idx);\n	t
21451	796	rdma_addr_find_l2_eth_by_grh	drivers/infiniband/core/addr.c	ret	2	-11	\N	\N	\tint ret = 0;\n\tstruct rdma_dev_addr dev_addr;\n\tstruct resolve_cb_context ctx;\n\tstruct net_device *dev;\n\n\tunion {\n\t\tstruct sockaddr     _sockaddr;\n\t\tstruct sockaddr_in  _sockaddr_in;\n\t\tstruct sockaddr_in6 _sockaddr_in6;\n\t} sgid_addr, dgid_addr;\n\n\n\trdma_gid2ip(&sgid_addr._sockaddr, sgid);\n\trdma_gid2ip(&dgid_addr._sockaddr, dgid);\n\n\tmemset(&dev_addr, 0, sizeof(dev_addr));\n\tif (if_index)\n\t\tdev_addr.bound_dev_if = *if_index;\n\tdev_addr.net = &init_net;\n\n\tctx.addr = &dev_addr;\n\tinit_completion(&ctx.comp);\n\tret = rdma_resolve_ip(&self, &sgid_addr._sockaddr, &dgid_addr._sockaddr,\n\t\t\t&dev_addr, 1000, resolve_cb, &ctx);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&ctx.comp);\n\n\tret = ctx.status;\n\tif (ret)\n	t
24872	158	acpi_smbus_transaction	drivers/acpi/sbshc.c	sz	9	12	\N	\N	\tint ret = -EFAULT, i;\n\tu8 temp, sz = 0;\n\n\tif (!hc) {\n\t\tprintk(KERN_ERR PREFIX "host controller is not configured\\n");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&hc->lock);\n\thc->done = false;\n\tif (smb_hc_read(hc, ACPI_SMB_PROTOCOL, &temp))\n\t\tgoto end;\n\tif (temp) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_COMMAND, command);\n\tif (!(protocol & 0x01)) {\n\t\tsmb_hc_write(hc, ACPI_SMB_BLOCK_COUNT, length);\n\t\tfor (i = 0; i < length; ++i)\n\t\t\tsmb_hc_write(hc, ACPI_SMB_DATA + i, data[i]);\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_ADDRESS, address << 1);\n\tsmb_hc_write(hc, ACPI_SMB_PROTOCOL, protocol);\n\t/*\n\t * Wait for completion. Save the status code, data size,\n\t * and data into the return package (if required by the protocol).\n\t */\n\tret = wait_transaction_complete(hc, 1000);\n\tif (ret || !(protocol & 0x01))\n\t\tgoto end;\n\tswitch (protocol) {\n\tcase SMBUS_RECEIVE_BYTE:\n\tcase SMBUS_READ_BYTE:\n\t\tsz = 1;\n\t\tbreak;\n\tcase SMBUS_READ_WORD:\n\t\tsz = 2;\n\t\tbreak;\n\tcase SMBUS_READ_BLOCK:\n\t\tif (smb_hc_read(hc, ACPI_SMB_BLOCK_COUNT, &sz)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto end;\n\t\t}\n\t\tsz &= 0x1f;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < sz; ++i)\n	t
49855	2237	mxt_read_diagnostic_debug	drivers/input/touchscreen/atmel_mxt_ts.c	cmd_poll	1	13	\N	\N	\tstruct mxt_dbg *dbg = &data->dbg;\n\tint retries = 0;\n\tint page;\n\tint ret;\n\tu8 cmd = mode;\n\tstruct t37_debug *p;\n\tu8 cmd_poll;\n\n\tfor (page = 0; page < dbg->t37_pages; page++) {\n\t\tp = dbg->t37_buf + page;\n\n\t\tret = mxt_write_reg(data->client, dbg->diag_cmd_address,\n\t\t\t\t    cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tretries = 0;\n\t\tmsleep(20);\nwait_cmd:\n\t\t/* Read back command byte */\n\t\tret = __mxt_read_reg(data->client, dbg->diag_cmd_address,\n\t\t\t\t     sizeof(cmd_poll), &cmd_poll);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Field is cleared once the command has been processed */\n\t\tif (cmd_poll) {\n	f
21573	124	of_platform_serial_setup	drivers/tty/serial/8250/8250_of.c	prop	1	11	\N	\N	\tstruct resource resource;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tu32 clk, spd, prop;\n\tint ret;\n\n\tmemset(port, 0, sizeof *port);\n\n\tpm_runtime_enable(&ofdev->dev);\n\tpm_runtime_get_sync(&ofdev->dev);\n\n\tif (of_property_read_u32(np, "clock-frequency", &clk)) {\n\n\t\t/* Get clk rate through clk driver if present */\n\t\tinfo->clk = devm_clk_get(&ofdev->dev, NULL);\n\t\tif (IS_ERR(info->clk)) {\n\t\t\tdev_warn(&ofdev->dev,\n\t\t\t\t"clk or clock-frequency not defined\\n");\n\t\t\tret = PTR_ERR(info->clk);\n\t\t\tgoto err_pmruntime;\n\t\t}\n\n\t\tret = clk_prepare_enable(info->clk);\n\t\tif (ret < 0)\n\t\t\tgoto err_pmruntime;\n\n\t\tclk = clk_get_rate(info->clk);\n\t}\n\t/* If current-speed was set, then try not to change it. */\n\tif (of_property_read_u32(np, "current-speed", &spd) == 0)\n\t\tport->custom_divisor = clk / (16 * spd);\n\n\tret = of_address_to_resource(np, 0, &resource);\n\tif (ret) {\n\t\tdev_warn(&ofdev->dev, "invalid address\\n");\n\t\tgoto err_unprepare;\n\t}\n\n\tspin_lock_init(&port->lock);\n\tport->mapbase = resource.start;\n\tport->mapsize = resource_size(&resource);\n\n\t/* Check for shifted address mapping */\n\tif (of_property_read_u32(np, "reg-offset", &prop) == 0)\n\t\tport->mapbase += prop;\n\n\t/* Check for registers offset within the devices address range */\n\tif (of_property_read_u32(np, "reg-shift", &prop) == 0)\n\t\tport->regshift = prop;\n\n\t/* Check for fifo size */\n\tif (of_property_read_u32(np, "fifo-size", &prop) == 0)\n\t\tport->fifosize = prop;\n\n\t/* Check for a fixed line number */\n\tret = of_alias_get_id(np, "serial");\n\tif (ret >= 0)\n\t\tport->line = ret;\n\n\tport->irq = irq_of_parse_and_map(np, 0);\n\tport->iotype = UPIO_MEM;\n\tif (of_property_read_u32(np, "reg-io-width", &prop) == 0) {\n\t\tswitch (prop) {\n	t
22071	1635	qat_uclo_wr_suof_img	drivers/crypto/qat/qat_common/qat_uclo.c	desc)	1	11	\N	\N	\tunsigned int i;\n\tstruct icp_qat_fw_auth_desc *desc = NULL;\n\tstruct icp_qat_suof_handle *sobj_handle = handle->sobj_handle;\n\tstruct icp_qat_suof_img_hdr *simg_hdr = sobj_handle->img_table.simg_hdr;\n\n\tfor (i = 0; i < sobj_handle->img_table.num_simgs; i++) {\n\t\tif (qat_uclo_map_auth_fw(handle,\n\t\t\t\t\t (char *)simg_hdr[i].simg_buf,\n\t\t\t\t\t (unsigned int)\n\t\t\t\t\t (simg_hdr[i].simg_len),\n\t\t\t\t\t &desc))\n\t\t\tgoto wr_err;\n\t\tif (qat_uclo_auth_fw(handle, desc))\n	t
23231	499	xfs_cui_recover	fs/xfs/xfs_refcount_item.c	tp->t_mountp	1	11	\N	\N	\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\tunsigned int\t\t\trefc_type;\n\tstruct xfs_phys_extent\t\t*refc;\n\txfs_fsblock_t\t\t\tstartblock_fsb;\n\tbool\t\t\t\top_ok;\n\tstruct xfs_cud_log_item\t\t*cudp;\n\tstruct xfs_trans\t\t*tp;\n\tstruct xfs_btree_cur\t\t*rcur = NULL;\n\tenum xfs_refcount_intent_type\ttype;\n\txfs_fsblock_t\t\t\tfirstfsb;\n\txfs_fsblock_t\t\t\tnew_fsb;\n\txfs_extlen_t\t\t\tnew_len;\n\tstruct xfs_bmbt_irec\t\tirec;\n\tstruct xfs_defer_ops\t\tdfops;\n\tbool\t\t\t\trequeue_only = false;\n\n\tASSERT(!test_bit(XFS_CUI_RECOVERED, &cuip->cui_flags));\n\n\t/*\n\t * First check the validity of the extents described by the\n\t * CUI.  If any are bad, then assume that all are bad and\n\t * just toss the CUI.\n\t */\n\tfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\n\t\trefc = &cuip->cui_format.cui_extents[i];\n\t\tstartblock_fsb = XFS_BB_TO_FSB(mp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, refc->pe_startblock));\n\t\tswitch (refc->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK) {\n\t\tcase XFS_REFCOUNT_INCREASE:\n\t\tcase XFS_REFCOUNT_DECREASE:\n\t\tcase XFS_REFCOUNT_ALLOC_COW:\n\t\tcase XFS_REFCOUNT_FREE_COW:\n\t\t\top_ok = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (!op_ok || startblock_fsb == 0 ||\n\t\t    refc->pe_len == 0 ||\n\t\t    startblock_fsb >= mp->m_sb.sb_dblocks ||\n\t\t    refc->pe_len >= mp->m_sb.sb_agblocks ||\n\t\t    (refc->pe_flags & ~XFS_REFCOUNT_EXTENT_FLAGS)) {\n\t\t\t/*\n\t\t\t * This will pull the CUI from the AIL and\n\t\t\t * free the memory associated with it.\n\t\t\t */\n\t\t\tset_bit(XFS_CUI_RECOVERED, &cuip->cui_flags);\n\t\t\txfs_cui_release(cuip);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Under normal operation, refcount updates are deferred, so we\n\t * wouldn't be adding them directly to a transaction.  All\n\t * refcount updates manage reservation usage internally and\n\t * dynamically by deferring work that won't fit in the\n\t * transaction.  Normally, any work that needs to be deferred\n\t * gets attached to the same defer_ops that scheduled the\n\t * refcount update.  However, we're in log recovery here, so we\n\t * we create our own defer_ops and use that to finish up any\n\t * work that doesn't fit.\n\t */\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\tcudp = xfs_trans_get_cud(tp, cuip);\n\n\txfs_defer_init(&dfops, &firstfsb);\n\tfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\n\t\trefc = &cuip->cui_format.cui_extents[i];\n\t\trefc_type = refc->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK;\n\t\tswitch (refc_type) {\n\t\tcase XFS_REFCOUNT_INCREASE:\n\t\tcase XFS_REFCOUNT_DECREASE:\n\t\tcase XFS_REFCOUNT_ALLOC_COW:\n\t\tcase XFS_REFCOUNT_FREE_COW:\n\t\t\ttype = refc_type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto abort_error;\n\t\t}\n\t\tif (requeue_only) {\n\t\t\tnew_fsb = refc->pe_startblock;\n\t\t\tnew_len = refc->pe_len;\n\t\t} else\n\t\t\terror = xfs_trans_log_finish_refcount_update(tp, cudp,\n\t\t\t\t&dfops, type, refc->pe_startblock, refc->pe_len,\n\t\t\t\t&new_fsb, &new_len, &rcur);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\n\t\t/* Requeue what we didn't finish. */\n\t\tif (new_len > 0) {\n\t\t\tirec.br_startblock = new_fsb;\n\t\t\tirec.br_blockcount = new_len;\n\t\t\tswitch (type) {\n\t\t\tcase XFS_REFCOUNT_INCREASE:\n\t\t\t\terror = xfs_refcount_increase_extent(\n	t
21920	276	st95hf_send_recv_cmd	drivers/nfc/st95hf/core.c	&spi_cmd_buffer[3]	1	11	\N	\N	\tunsigned char spi_cmd_buffer[MAX_CMD_LEN];\n\tint i, ret;\n\tstruct device *dev = &st95context->spicontext.spidev->dev;\n\n\tif (cmd_array[cmd].cmd_len > MAX_CMD_LEN)\n\t\treturn -EINVAL;\n\tif (cmd_array[cmd].no_cmd_params < no_modif)\n\t\treturn -EINVAL;\n\tif (no_modif && !list_array)\n\t\treturn -EINVAL;\n\n\tspi_cmd_buffer[0] = ST95HF_COMMAND_SEND;\n\tspi_cmd_buffer[1] = cmd_array[cmd].cmd_id;\n\tspi_cmd_buffer[2] = cmd_array[cmd].no_cmd_params;\n\n\tmemcpy(&spi_cmd_buffer[3], cmd_array[cmd].cmd_params,\n	t
23733	315	ntfs_index_iget	fs/ntfs/inode.c	vi	1	11	\N	\N	\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad index inodes around.  This also\n\t * simplifies things in that we never need to check for bad index\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n	t
25395	607	eb_reserve	drivers/gpu/drm/i915/i915_gem_execbuffer.c	err	1	11	\N	\N	\tconst unsigned int count = eb->buffer_count;\n\tstruct list_head last;\n\tstruct i915_vma *vma;\n\tunsigned int i, pass;\n\tint err;\n\n\t/*\n\t * Attempt to pin all of the buffers into the GTT.\n\t * This is done in 3 phases:\n\t *\n\t * 1a. Unbind all objects that do not match the GTT constraints for\n\t *     the execbuffer (fenceable, mappable, alignment etc).\n\t * 1b. Increment pin count for already bound objects.\n\t * 2.  Bind new objects.\n\t * 3.  Decrement pin count.\n\t *\n\t * This avoid unnecessary unbinding of later objects in order to make\n\t * room for the earlier objects *unless* we need to defragment.\n\t */\n\n\tpass = 0;\n\terr = 0;\n\tdo {\n\t\tlist_for_each_entry(vma, &eb->unbound, exec_link) {\n\t\t\terr = eb_reserve_vma(eb, vma);\n\t\t\tif (err)\n	t
23901	1800	handle_mount_opt	fs/ext4/super.c	error	1	11	\N	\N	\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, "3.5");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, "Ignoring removed %s option", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= SB_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, "Unrecognized mount option \\"%s\\" "\n\t\t\t "or missing value", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Mount option \\"%s\\" incompatible with ext2", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Mount option \\"%s\\" incompatible with ext3", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT) {\n\t\tif (m->mount_opt & EXT4_MOUNT_DELALLOC) {\n\t\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\t\t} else if (m->mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) {\n\t\t\tset_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM);\n\t\t} else\n\t\t\treturn -1;\n\t}\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, "Cannot change quota "\n\t\t\t "options when quota turned on");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, "%s option not supported", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_debug_want_extra_isize) {\n\t\tsbi->s_want_extra_isize = arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "EXT4-fs: inode_readahead_blks must be "\n\t\t\t\t "0 or a power of 2 smaller than 2^31");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, "Invalid uid value %d", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, "Invalid gid value %d", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Cannot specify journal on remount");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Cannot specify journal on remount");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, "error: could not dup "\n\t\t\t\t"journal device string");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n	t
24023	634	cx231xx_gpio_set	drivers/media/usb/cx231xx/cx231xx-core.c	rc	1	11	\N	\N	\tint rc = 0;\n\n\tif (!gpio)\n\t\treturn rc;\n\n\t/* Send GPIO reset sequences specified at board entry */\n\twhile (gpio->sleep >= 0) {\n\t\trc = cx231xx_set_gpio_value(dev, gpio->bit, gpio->val);\n\t\tif (rc < 0)\n	t
24102	913	nidio_auto_attach	drivers/staging/comedi/drivers/ni_pcidio.c	ret	1	11	\N	\N	\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct nidio_board *board = NULL;\n\tstruct nidio96_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tunsigned int irq;\n\n\tif (context < ARRAY_SIZE(nidio_boards))\n\t\tboard = &nidio_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->mite_channel_lock);\n\n\tdevpriv->mite = mite_attach(dev, false);\t/* use win0 */\n\tif (!devpriv->mite)\n\t\treturn -ENOMEM;\n\n\tdevpriv->di_mite_ring = mite_alloc_ring(devpriv->mite);\n\tif (!devpriv->di_mite_ring)\n\t\treturn -ENOMEM;\n\n\tif (board->uses_firmware) {\n\t\tret = pci_6534_upload_firmware(dev);\n\t\tif (ret < 0)\n	t
24531	2062	__raid56_parity_recover	fs/btrfs/raid56.c	&bio_list	1	11	\N	\N	\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < rbio->stripe_npages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n	t
24658	1060	alloc_user_pages	drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_bo.c	pages[i]	1	11	\N	\N	\tint page_nr;\n\tint i;\n\tstruct vm_area_struct *vma;\n\tstruct page **pages;\n\n\tpages = kmalloc(sizeof(struct page *) * bo->pgnr, GFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tdev_err(atomisp_dev, "out of memory for pages...\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tbo->page_obj = kmalloc(sizeof(struct hmm_page_object) * bo->pgnr,\n\t\tGFP_KERNEL);\n\tif (unlikely(!bo->page_obj)) {\n\t\tdev_err(atomisp_dev, "out of memory for bo->page_obj...\\n");\n\t\tkfree(pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_unlock(&bo->mutex);\n\tdown_read(&current->mm->mmap_sem);\n\tvma = find_vma(current->mm, (unsigned long)userptr);\n\tup_read(&current->mm->mmap_sem);\n\tif (vma == NULL) {\n\t\tdev_err(atomisp_dev, "find_vma failed\\n");\n\t\tkfree(bo->page_obj);\n\t\tkfree(pages);\n\t\tmutex_lock(&bo->mutex);\n\t\treturn -EFAULT;\n\t}\n\tmutex_lock(&bo->mutex);\n\t/*\n\t * Handle frame buffer allocated in other kerenl space driver\n\t * and map to user space\n\t */\n\tif (vma->vm_flags & (VM_IO | VM_PFNMAP)) {\n\t\tpage_nr = get_pfnmap_pages(current, current->mm,\n\t\t\t\t\t   (unsigned long)userptr,\n\t\t\t\t\t   (int)(bo->pgnr), 1, 0,\n\t\t\t\t\t   pages, NULL);\n\t\tbo->mem_type = HMM_BO_MEM_TYPE_PFN;\n\t} else {\n\t\t/*Handle frame buffer allocated in user space*/\n\t\tmutex_unlock(&bo->mutex);\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tpage_nr = get_user_pages((unsigned long)userptr,\n\t\t\t\t\t (int)(bo->pgnr), 1, pages, NULL);\n\t\tup_read(&current->mm->mmap_sem);\n\t\tmutex_lock(&bo->mutex);\n\t\tbo->mem_type = HMM_BO_MEM_TYPE_USER;\n\t}\n\n\t/* can be written by caller, not forced */\n\tif (page_nr != bo->pgnr) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\t"get_user_pages err: bo->pgnr = %d, "\n\t\t\t\t"pgnr actually pinned = %d.\\n",\n\t\t\t\tbo->pgnr, page_nr);\n\t\tgoto out_of_mem;\n\t}\n\n\tfor (i = 0; i < bo->pgnr; i++) {\n\t\tbo->page_obj[i].page = pages[i];\n\t\tbo->page_obj[i].type = HMM_PAGE_TYPE_GENERAL;\n\t}\n\thmm_mem_stat.usr_size += bo->pgnr;\n\tkfree(pages);\n\n\treturn 0;\n\nout_of_mem:\n\tfor (i = 0; i < page_nr; i++)\n\t\tput_page(pages[i]);\n	t
24661	1877	hdlcdev_rx	drivers/tty/synclinkmp.c	skb	1	11	\N	\N	\tstruct sk_buff *skb = dev_alloc_skb(size);\n\tstruct net_device *dev = info->netdev;\n\n\tif (debug_level >= DEBUG_LEVEL_INFO)\n\t\tprintk("hdlcdev_rx(%s)\\n",dev->name);\n\n\tif (skb == NULL) {\n\t\tprintk(KERN_NOTICE "%s: can't alloc skb, dropping packet\\n",\n\t\t       dev->name);\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, buf, size);\n	t
24795	1633	ti_do_download	drivers/usb/serial/ti_usb_3410_5052.c	status	1	11	\N	\N	\tint pos;\n\tu8 cs = 0;\n\tint done;\n\tstruct ti_firmware_header *header;\n\tint status = 0;\n\tint len;\n\n\tfor (pos = sizeof(struct ti_firmware_header); pos < size; pos++)\n\t\tcs = (u8)(cs + buffer[pos]);\n\n\theader = (struct ti_firmware_header *)buffer;\n\theader->wLength = cpu_to_le16(size - sizeof(*header));\n\theader->bCheckSum = cs;\n\n\tdev_dbg(&dev->dev, "%s - downloading firmware\\n", __func__);\n\tfor (pos = 0; pos < size; pos += done) {\n\t\tlen = min(size - pos, TI_DOWNLOAD_MAX_PACKET_SIZE);\n\t\tstatus = usb_bulk_msg(dev, pipe, buffer + pos, len,\n\t\t\t\t\t\t\t\t&done, 1000);\n\t\tif (status)\n	t
25747	119	r8a7779_cpg_register_clock	drivers/clk/renesas/clk-r8a7779.c	parent_name	1	11	\N	\N	\tconst char *parent_name = "plla";\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\n\tif (!strcmp(name, "plla")) {\n\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\tmult = plla_mult;\n\t} else if (!strcmp(name, "z")) {\n\t\tdiv = config->z_div;\n\t\tmult = config->z_mult;\n\t} else if (!strcmp(name, "zs") || !strcmp(name, "s")) {\n\t\tdiv = config->zs_and_s_div;\n\t} else if (!strcmp(name, "s1")) {\n\t\tdiv = config->s1_div;\n\t} else if (!strcmp(name, "p")) {\n\t\tdiv = config->p_div;\n\t} else if (!strcmp(name, "b") || !strcmp(name, "out")) {\n\t\tdiv = config->b_and_out_div;\n\t} else {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clk_register_fixed_factor(NULL, name, parent_name, 0, mult, div);\n	t
25604	1474	rtllib_auth_challenge	drivers/staging/rtl8192e/rtllib_softmac.c	skb	1	11	\N	\N	\tu8 *c;\n\tstruct sk_buff *skb;\n\tstruct rtllib_network *beacon = &ieee->current_network;\n\n\tieee->associate_seq++;\n\tieee->softmac_stats.tx_auth_rq++;\n\n\tskb = rtllib_authentication_req(beacon, ieee, chlen + 2, beacon->bssid);\n\n\tif (!skb)\n\t\trtllib_associate_abort(ieee);\n\telse {\n\t\tc = skb_put(skb, chlen+2);\n	t
25731	924	ti_adpll_probe	drivers/clk/ti/adpll.c	d	1	11	\N	\N	\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tconst struct ti_adpll_platform_data *pdata;\n\tstruct ti_adpll_data *d;\n\tstruct resource *res;\n\tint err;\n\n\tmatch = of_match_device(ti_adpll_match, dev);\n\tif (match)\n\t\tpdata = match->data;\n\telse\n\t\treturn -ENODEV;\n\n\td = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\td->dev = dev;\n\td->np = node;\n\td->c = pdata;\n\tdev_set_drvdata(d->dev, d);\n\tspin_lock_init(&d->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\td->pa = res->start;\n\n\td->iobase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(d->iobase)) {\n\t\tdev_err(dev, "could not get IO base: %li\\n",\n\t\t\tPTR_ERR(d->iobase));\n\t\treturn PTR_ERR(d->iobase);\n\t}\n\n\terr = ti_adpll_init_registers(d);\n\tif (err)\n\t\treturn err;\n\n\terr = ti_adpll_init_inputs(d);\n\tif (err)\n\t\treturn err;\n\n\td->clocks = devm_kzalloc(d->dev, sizeof(struct ti_adpll_clock) *\n\t\t\t\t TI_ADPLL_NR_CLOCKS,\n\t\t\t\t GFP_KERNEL);\n\tif (!d->clocks)\n\t\treturn -ENOMEM;\n\n\terr = ti_adpll_init_dco(d);\n	t
25830	424	tc3589x_probe	drivers/mfd/tc3589x.c	ret	1	11	\N	\N	\tstruct device_node *np = i2c->dev.of_node;\n\tstruct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct tc3589x *tc3589x;\n\tenum tc3589x_version version;\n\tint ret;\n\n\tif (!pdata) {\n\t\tpdata = tc3589x_of_probe(&i2c->dev, &version);\n\t\tif (IS_ERR(pdata)) {\n\t\t\tdev_err(&i2c->dev, "No platform data or DT found\\n");\n\t\t\treturn PTR_ERR(pdata);\n\t\t}\n\t} else {\n\t\t/* When not probing from device tree we have this ID */\n\t\tversion = id->driver_data;\n\t}\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EIO;\n\n\ttc3589x = devm_kzalloc(&i2c->dev, sizeof(struct tc3589x),\n\t\t\t\tGFP_KERNEL);\n\tif (!tc3589x)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tc3589x->lock);\n\n\ttc3589x->dev = &i2c->dev;\n\ttc3589x->i2c = i2c;\n\ttc3589x->pdata = pdata;\n\n\tswitch (version) {\n\tcase TC3589X_TC35893:\n\tcase TC3589X_TC35895:\n\tcase TC3589X_TC35896:\n\t\ttc3589x->num_gpio = 20;\n\t\tbreak;\n\tcase TC3589X_TC35890:\n\tcase TC3589X_TC35892:\n\tcase TC3589X_TC35894:\n\tcase TC3589X_UNKNOWN:\n\tdefault:\n\t\ttc3589x->num_gpio = 24;\n\t\tbreak;\n\t}\n\n\ti2c_set_clientdata(i2c, tc3589x);\n\n\tret = tc3589x_chip_init(tc3589x);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc3589x_irq_init(tc3589x, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = request_threaded_irq(tc3589x->i2c->irq, NULL, tc3589x_irq,\n\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t   "tc3589x", tc3589x);\n\tif (ret) {\n\t\tdev_err(tc3589x->dev, "failed to request IRQ: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret = tc3589x_device_init(tc3589x);\n\tif (ret) {\n	t
26160	3472	quirk_apple_poweroff_thunderbolt	drivers/pci/quirks.c	SXIO	1	11	\N	\N	\tacpi_handle bridge, SXIO, SXFP, SXLV;\n\n\tif (!x86_apple_machine)\n\t\treturn;\n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)\n\t\treturn;\n\tbridge = ACPI_HANDLE(&dev->dev);\n\tif (!bridge)\n\t\treturn;\n\t/*\n\t * SXIO and SXLV are present only on machines requiring this quirk.\n\t * TB bridges in external devices might have the same device id as those\n\t * on the host, but they will not have the associated ACPI methods. This\n\t * implicitly checks that we are at the right bridge.\n\t */\n\tif (ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXIO", &SXIO))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXFP", &SXFP))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXLV", &SXLV)))\n\t\treturn;\n\tdev_info(&dev->dev, "quirk: cutting power to thunderbolt controller...\\n");\n\n\t/* magic sequence */\n\tacpi_execute_simple_method(SXIO, NULL, 1);\n	t
26473	697	encrypted_key_decrypt	security/keys/encrypted-keys/encrypted.c	master_key	1	11	\N	\N	\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n	t
26145	78	dpc_wait_rp_inactive	drivers/pci/pcie/pcie-dpc.c	status	2	-11	\N	\N	\tunsigned long timeout = jiffies + HZ;\n\tstruct pci_dev *pdev = dpc->dev->port;\n\tstruct device *dev = &dpc->dev->device;\n\tu16 status;\n\n\tpci_read_config_word(pdev, dpc->cap_pos + PCI_EXP_DPC_STATUS, &status);\n\twhile (status & PCI_EXP_DPC_RP_BUSY &&\n	t
49747	990	snd_mixart_pcm_analog	sound/pci/mixart/mixart.c	snd_mixart_pcm_analog_$pcm$obj$8	0	13	\N	\N	\tint err;\n\tstruct snd_pcm *pcm;\n\tchar name[32];\n\n\tsprintf(name, "miXart analog %d", chip->chip_idx);\n\tif ((err = snd_pcm_new(chip->card, name, MIXART_PCM_ANALOG,\n\t\t\t       MIXART_PLAYBACK_STREAMS,\n\t\t\t       MIXART_CAPTURE_STREAMS, &pcm)) < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t"cannot create the analog pcm %d\\n", chip->chip_idx);\n\t\treturn err;\n\t}\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_mixart_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_mixart_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, name);\n	f
26617	1755	piix_init_one	drivers/ata/ata_piix.c	host->flags	1	11	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct ata_port_info port_info[2];\n\tconst struct ata_port_info *ppi[] = { &port_info[0], &port_info[1] };\n\tstruct scsi_host_template *sht = &piix_sht;\n\tunsigned long port_flags;\n\tstruct ata_host *host;\n\tstruct piix_host_priv *hpriv;\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t/* no hotplugging support for later devices (FIXME) */\n\tif (!in_module_init && ent->driver_data >= ich5_sata)\n\t\treturn -ENODEV;\n\n\tif (piix_broken_system_poweroff(pdev)) {\n\t\tpiix_port_info[ent->driver_data].flags |=\n\t\t\t\tATA_FLAG_NO_POWEROFF_SPINDOWN |\n\t\t\t\t\tATA_FLAG_NO_HIBERNATE_SPINDOWN;\n\t\tdev_info(&pdev->dev, "quirky BIOS, skipping spindown "\n\t\t\t\t"on poweroff and hibernation\\n");\n\t}\n\n\tport_info[0] = piix_port_info[ent->driver_data];\n\tport_info[1] = piix_port_info[ent->driver_data];\n\n\tport_flags = port_info[0].flags;\n\n\t/* enable device and prepare host */\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\t/* Save IOCFG, this will be used for cable detection, quirk\n\t * detection and restoration on detach.  This is necessary\n\t * because some ACPI implementations mess up cable related\n\t * bits on _STM.  Reported on kernel bz#11879.\n\t */\n\tpci_read_config_dword(pdev, PIIX_IOCFG, &hpriv->saved_iocfg);\n\n\t/* ICH6R may be driven by either ata_piix or ahci driver\n\t * regardless of BIOS configuration.  Make sure AHCI mode is\n\t * off.\n\t */\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2652) {\n\t\trc = piix_disable_ahci(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* SATA map init can change port_info, do it before prepping host */\n\tif (port_flags & ATA_FLAG_SATA)\n\t\thpriv->map = piix_init_sata_map(pdev, port_info,\n\t\t\t\t\tpiix_map_db_table[ent->driver_data]);\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\thost->private_data = hpriv;\n\n\t/* initialize controller */\n\tif (port_flags & ATA_FLAG_SATA) {\n\t\tpiix_init_pcs(host, piix_map_db_table[ent->driver_data]);\n\t\trc = piix_init_sidpr(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (host->ports[0]->ops == &piix_sidpr_sata_ops)\n\t\t\tsht = &piix_sidpr_sht;\n\t}\n\n\t/* apply IOCFG bit18 quirk */\n\tpiix_iocfg_bit18_quirk(host);\n\n\t/* On ICH5, some BIOSen disable the interrupt using the\n\t * PCI_COMMAND_INTX_DISABLE bit added in PCI 2.3.\n\t * On ICH6, this bit has the same effect, but only when\n\t * MSI is disabled (and it is disabled, as we don't use\n\t * message-signalled interrupts currently).\n\t */\n\tif (port_flags & PIIX_FLAG_CHECKINTR)\n\t\tpci_intx(pdev, 1);\n\n\tif (piix_check_450nx_errata(pdev)) {\n\t\t/* This writes into the master table but it does not\n\t\t   really matter for this errata as we will apply it to\n\t\t   all the PIIX devices on the board */\n\t\thost->ports[0]->mwdma_mask = 0;\n\t\thost->ports[0]->udma_mask = 0;\n\t\thost->ports[1]->mwdma_mask = 0;\n\t\thost->ports[1]->udma_mask = 0;\n\t}\n\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n	t
26722	938	alb_send_lp_vid	drivers/net/bonding/bond_alb.c	skb	1	11	\N	\N	\tstruct learning_pkt pkt;\n\tstruct sk_buff *skb;\n\tint size = sizeof(struct learning_pkt);\n\n\tmemset(&pkt, 0, size);\n\tether_addr_copy(pkt.mac_dst, mac_addr);\n\tether_addr_copy(pkt.mac_src, mac_addr);\n\tpkt.type = cpu_to_be16(ETH_P_LOOPBACK);\n\n\tskb = dev_alloc_skb(size);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, &pkt, size);\n	t
27252	433	ath3k_load_patch	drivers/bluetooth/ath3k.c	firmware->data	1	11	\N	\N	\tunsigned char fw_state;\n\tchar filename[ATH3K_NAME_LEN] = {0};\n\tconst struct firmware *firmware;\n\tstruct ath3k_version fw_version;\n\t__u32 pt_rom_version, pt_build_version;\n\tint ret;\n\n\tret = ath3k_get_state(udev, &fw_state);\n\tif (ret < 0) {\n\t\tBT_ERR("Can't get state to change to load ram patch err");\n\t\treturn ret;\n\t}\n\n\tif (fw_state & ATH3K_PATCH_UPDATE) {\n\t\tBT_DBG("Patch was already downloaded");\n\t\treturn 0;\n\t}\n\n\tret = ath3k_get_version(udev, &fw_version);\n\tif (ret < 0) {\n\t\tBT_ERR("Can't get version to change to load ram patch err");\n\t\treturn ret;\n\t}\n\n\tsnprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",\n\t\t le32_to_cpu(fw_version.rom_version));\n\n\tret = request_firmware(&firmware, filename, &udev->dev);\n\tif (ret < 0) {\n\t\tBT_ERR("Patch file not found %s", filename);\n\t\treturn ret;\n\t}\n\n\tpt_rom_version = get_unaligned_le32(firmware->data +\n	t
30484	357	em_gio_probe	drivers/gpio/gpio-em.c	irq[0]->start	1	13	\N	\N	\tstruct em_gio_priv *p;\n\tstruct resource *io[2], *irq[2];\n\tstruct gpio_chip *gpio_chip;\n\tstruct irq_chip *irq_chip;\n\tconst char *name = dev_name(&pdev->dev);\n\tunsigned int ngpios;\n\tint ret;\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tp->pdev = pdev;\n\tplatform_set_drvdata(pdev, p);\n\tspin_lock_init(&p->sense_lock);\n\n\tio[0] = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tio[1] = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tirq[0] = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tirq[1] = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\n\n\tif (!io[0] || !io[1] || !irq[0] || !irq[1]) {\n\t\tdev_err(&pdev->dev, "missing IRQ or IOMEM\\n");\n\t\tret = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\tp->base0 = devm_ioremap_nocache(&pdev->dev, io[0]->start,\n\t\t\t\t\tresource_size(io[0]));\n\tif (!p->base0) {\n\t\tdev_err(&pdev->dev, "failed to remap low I/O memory\\n");\n\t\tret = -ENXIO;\n\t\tgoto err0;\n\t}\n\n\tp->base1 = devm_ioremap_nocache(&pdev->dev, io[1]->start,\n\t\t\t\t   resource_size(io[1]));\n\tif (!p->base1) {\n\t\tdev_err(&pdev->dev, "failed to remap high I/O memory\\n");\n\t\tret = -ENXIO;\n\t\tgoto err0;\n\t}\n\n\tif (of_property_read_u32(pdev->dev.of_node, "ngpios", &ngpios)) {\n\t\tdev_err(&pdev->dev, "Missing ngpios OF property\\n");\n\t\tret = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\tgpio_chip = &p->gpio_chip;\n\tgpio_chip->of_node = pdev->dev.of_node;\n\tgpio_chip->direction_input = em_gio_direction_input;\n\tgpio_chip->get = em_gio_get;\n\tgpio_chip->direction_output = em_gio_direction_output;\n\tgpio_chip->set = em_gio_set;\n\tgpio_chip->to_irq = em_gio_to_irq;\n\tgpio_chip->request = em_gio_request;\n\tgpio_chip->free = em_gio_free;\n\tgpio_chip->label = name;\n\tgpio_chip->parent = &pdev->dev;\n\tgpio_chip->owner = THIS_MODULE;\n\tgpio_chip->base = -1;\n\tgpio_chip->ngpio = ngpios;\n\n\tirq_chip = &p->irq_chip;\n\tirq_chip->name = name;\n\tirq_chip->irq_mask = em_gio_irq_disable;\n\tirq_chip->irq_unmask = em_gio_irq_enable;\n\tirq_chip->irq_set_type = em_gio_irq_set_type;\n\tirq_chip->irq_request_resources = em_gio_irq_reqres;\n\tirq_chip->irq_release_resources = em_gio_irq_relres;\n\tirq_chip->flags\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND;\n\n\tp->irq_domain = irq_domain_add_simple(pdev->dev.of_node, ngpios, 0,\n\t\t\t\t\t      &em_gio_irq_domain_ops, p);\n\tif (!p->irq_domain) {\n\t\tret = -ENXIO;\n\t\tdev_err(&pdev->dev, "cannot initialize irq domain\\n");\n\t\tgoto err0;\n\t}\n\n\tif (devm_request_irq(&pdev->dev, irq[0]->start,\n	f
27384	461	ovl_copy_up_inode	fs/overlayfs/copy_up.c	err	1	11	\N	\N	\tint err;\n\n\tif (S_ISREG(c->stat.mode)) {\n\t\tstruct path upperpath;\n\n\t\tovl_path_upper(c->dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = temp;\n\n\t\terr = ovl_copy_up_data(&c->lowerpath, &upperpath, c->stat.size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ovl_copy_xattr(c->lowerpath.dentry, temp);\n\tif (err)\n	t
28502	315	gfs2_dir_read_data	fs/gfs2/dir.c	bh	1	11	\N	\N	\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\t\tint new;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, 0, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n	t
56818	2292	trace_event_raw_event_ocfs2_rename_target_exists	fs/ocfs2/super.c	status	1	13	\N	\N	\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_journal *journal;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= MS_NOATIME;\n\t/* this is needed to support O_LARGEFILE */\n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\tmemcpy(&sb->s_uuid, di->id2.i_super.s_uuid,\n\t       sizeof(di->id2.i_super.s_uuid));\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t/* Copy the blockcheck stats from the superblock probe */\n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), "%u,%u",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, "Invalid number of node slots (%u)\\n",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, "Unable to initialize recovery state\\n");\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tstatus = ocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, "unable to alloc vol label\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, "couldn't mount because of unsupported "\n\t\t     "optional features (%x).\\n", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!sb_rdonly(osb->sb) && (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, "couldn't mount RDWR because of "\n\t\t     "unsupported optional features (%x).\\n", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tstrlcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN + 1);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     "couldn't mount because of an invalid "\n\t\t\t     "cluster stack label (%s) \\n",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tstrlcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN + 1);\n\t} else {\n\t\t/* The empty string is identical with classic tools that\n\t\t * don't know about s_cluster_info. */\n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t/* FIXME\n\t * This should be done in ocfs2_journal_init(), but unknown\n\t * ordering issues will cause the filesystem to crash.\n\t * If anyone wants to figure out what part of the code\n\t * refers to osb->journal before ocfs2_journal_init() is run,\n\t * be my guest.\n\t */\n\t/* initialize our journal structure */\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, "unable to alloc journal\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = (unsigned long) 1;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t/* get some pseudo constants for clustersize bits */\n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, "Volume has invalid cluster size (%d)\\n",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, "Volume too large "\n\t\t     "to mount safely on this system");\n\t\tstatus = -EFBIG;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, "Out of memory trying to setup our uuid.\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tstrlcpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n	f
36313	197	bcm203x_probe	drivers/bluetooth/bcm203x.c	bcm203x_probe_$firmware$obj$1$obj	0	13	\N	\N	\tconst struct firmware *firmware;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct bcm203x_data *data;\n\tint size;\n\n\tBT_DBG("intf %p id %p", intf, id);\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->udev  = udev;\n\tdata->state = BCM203X_LOAD_MINIDRV;\n\n\tdata->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!data->urb)\n\t\treturn -ENOMEM;\n\n\tif (request_firmware(&firmware, "BCM2033-MD.hex", &udev->dev) < 0) {\n\t\tBT_ERR("Mini driver request failed");\n\t\tusb_free_urb(data->urb);\n\t\treturn -EIO;\n\t}\n\n\tBT_DBG("minidrv data %p size %zu", firmware->data, firmware->size);\n	f
1129	119	iscsit_create_random_array	drivers/target/iscsi/iscsi_target_seq_pdu_list.c	array	1	13	\N	\N	\tint i, j, k;\n\n\tif (count == 1) {\n\t\tarray[0] = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < count; i++) {\nredo:\n\t\tget_random_bytes(&j, sizeof(u32));\n\t\tj = (1 + (int) (9999 + 1) - j) % count;\n\t\tfor (k = 0; k < i + 1; k++) {\n\t\t\tj |= 0x80000000;\n\t\t\tif ((array[k] & 0x80000000) && (array[k] == j))\n	f
28244	408	mlx5_ib_init_cong_debugfs	drivers/infiniband/hw/mlx5/cong.c	dbg_cc_params->params	1	11	\N	\N	\tstruct mlx5_ib_dbg_cc_params *dbg_cc_params;\n\tint i;\n\n\tif (!mlx5_debugfs_root)\n\t\tgoto out;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, cc_query_allowed) ||\n\t    !MLX5_CAP_GEN(dev->mdev, cc_modify_allowed))\n\t\tgoto out;\n\n\tdbg_cc_params = kzalloc(sizeof(*dbg_cc_params), GFP_KERNEL);\n\tif (!dbg_cc_params)\n\t\tgoto out;\n\n\tdev->dbg_cc_params = dbg_cc_params;\n\n\tdbg_cc_params->root = debugfs_create_dir("cc_params",\n\t\t\t\t\t\t dev->mdev->priv.dbg_root);\n\tif (!dbg_cc_params->root)\n\t\tgoto err;\n\n\tfor (i = 0; i < MLX5_IB_DBG_CC_MAX; i++) {\n\t\tdbg_cc_params->params[i].offset = i;\n\t\tdbg_cc_params->params[i].dev = dev;\n\t\tdbg_cc_params->params[i].dentry =\n\t\t\tdebugfs_create_file(mlx5_ib_dbg_cc_name[i],\n\t\t\t\t\t    0600, dbg_cc_params->root,\n\t\t\t\t\t    &dbg_cc_params->params[i],\n\t\t\t\t\t    &dbg_cc_fops);\n\t\tif (!dbg_cc_params->params[i].dentry)\n	t
27549	269	hfi1_file_ioctl	drivers/infiniband/hw/hfi1/file_ops.c	&tinfo	2	-11	\N	\N	\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_user_info uinfo;\n\tstruct hfi1_tid_info tinfo;\n\tint ret = 0;\n\tunsigned long addr;\n\tint uval = 0;\n\tunsigned long ul_uval = 0;\n\tu16 uval16 = 0;\n\n\thfi1_cdbg(IOCTL, "IOCTL recv: 0x%x", cmd);\n\tif (cmd != HFI1_IOCTL_ASSIGN_CTXT &&\n\t    cmd != HFI1_IOCTL_GET_VERS &&\n\t    !uctxt)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase HFI1_IOCTL_ASSIGN_CTXT:\n\t\tif (uctxt)\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&uinfo,\n\t\t\t\t   (struct hfi1_user_info __user *)arg,\n\t\t\t\t   sizeof(uinfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = assign_ctxt(fd, &uinfo);\n\t\tbreak;\n\tcase HFI1_IOCTL_CTXT_INFO:\n\t\tret = get_ctxt_info(fd, (void __user *)(unsigned long)arg,\n\t\t\t\t    sizeof(struct hfi1_ctxt_info));\n\t\tbreak;\n\tcase HFI1_IOCTL_USER_INFO:\n\t\tret = get_base_info(fd, (void __user *)(unsigned long)arg,\n\t\t\t\t    sizeof(struct hfi1_base_info));\n\t\tbreak;\n\tcase HFI1_IOCTL_CREDIT_UPD:\n\t\tif (uctxt)\n\t\t\tsc_return_credits(uctxt->sc);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_TID_UPDATE:\n\t\tif (copy_from_user(&tinfo,\n\t\t\t\t   (struct hfi11_tid_info __user *)arg,\n\t\t\t\t   sizeof(tinfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = hfi1_user_exp_rcv_setup(fd, &tinfo);\n	t
28353	1097	bnxt_re_ib_reg	drivers/infiniband/hw/bnxt_re/main.c	&rdev->dev_attr	1	11	\N	\N	\tint i, j, rc;\n\n\t/* Registered a new RoCE device instance to netdev */\n\trc = bnxt_re_register_netdev(rdev);\n\tif (rc) {\n\t\tpr_err("Failed to register with netedev: %#x\\n", rc);\n\t\treturn -EINVAL;\n\t}\n\tset_bit(BNXT_RE_FLAG_NETDEV_REGISTERED, &rdev->flags);\n\n\trc = bnxt_re_request_msix(rdev);\n\tif (rc) {\n\t\tpr_err("Failed to get MSI-X vectors: %#x\\n", rc);\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\tset_bit(BNXT_RE_FLAG_GOT_MSIX, &rdev->flags);\n\n\t/* Establish RCFW Communication Channel to initialize the context\n\t * memory for the function and all child VFs\n\t */\n\trc = bnxt_qplib_alloc_rcfw_channel(rdev->en_dev->pdev, &rdev->rcfw,\n\t\t\t\t\t   BNXT_RE_MAX_QPC_COUNT);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = bnxt_re_net_ring_alloc\n\t\t\t(rdev, rdev->rcfw.creq.pbl[PBL_LVL_0].pg_map_arr,\n\t\t\t rdev->rcfw.creq.pbl[rdev->rcfw.creq.level].pg_count,\n\t\t\t HWRM_RING_ALLOC_CMPL, BNXT_QPLIB_CREQE_MAX_CNT - 1,\n\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].ring_idx,\n\t\t\t &rdev->rcfw.creq_ring_id);\n\tif (rc) {\n\t\tpr_err("Failed to allocate CREQ: %#x\\n", rc);\n\t\tgoto free_rcfw;\n\t}\n\trc = bnxt_qplib_enable_rcfw_channel\n\t\t\t\t(rdev->en_dev->pdev, &rdev->rcfw,\n\t\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].vector,\n\t\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].db_offset,\n\t\t\t\t 0, &bnxt_re_aeq_handler);\n\tif (rc) {\n\t\tpr_err("Failed to enable RCFW channel: %#x\\n", rc);\n\t\tgoto free_ring;\n\t}\n\n\trc = bnxt_qplib_get_dev_attr(&rdev->rcfw, &rdev->dev_attr);\n	t
57693	309	data_sock_ioctl_bound	drivers/isdn/mISDN/socket.c	data_sock_ioctl_bound_$cq$1$obj	0	13	\N	\N	\tstruct mISDN_ctrl_req\tcq;\n\tint\t\t\terr = -EINVAL, val[2];\n\tstruct mISDNchannel\t*bchan, *next;\n\n\tlock_sock(sk);\n\tif (!_pms(sk)->dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\tswitch (cmd) {\n\tcase IMCTRLREQ:\n\t\tif (copy_from_user(&cq, p, sizeof(cq))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((sk->sk_protocol & ~ISDN_P_B_MASK) == ISDN_P_B_START) {\n\t\t\tlist_for_each_entry_safe(bchan, next,\n\t\t\t\t\t\t &_pms(sk)->dev->bchannels, list) {\n\t\t\t\tif (bchan->nr == cq.channel) {\n	f
30674	352	smsc47b397_init	drivers/hwmon/smsc47b397.c	ret	1	13	\N	\N	\tunsigned short address;\n\tint ret;\n\n\tret = smsc47b397_find();\n\tif (ret < 0)\n\t\treturn ret;\n\taddress = ret;\n\n\tret = platform_driver_register(&smsc47b397_driver);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* Sets global pdev as a side effect */\n\tret = smsc47b397_device_add(address);\n\tif (ret)\n	f
30747	887	dvb_feed_start_pid	drivers/media/pci/ttpci/av7110.c	npids	1	13	\N	\N	\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct av7110 *av7110 = dvbdmx->priv;\n\tu16 *pid = dvbdmx->pids, npids[5];\n\tint i;\n\tint ret = 0;\n\n\tdprintk(4, "%p\\n", av7110);\n\n\tnpids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;\n\ti = dvbdmxfeed->pes_type;\n\tnpids[i] = (pid[i]&0x8000) ? 0 : pid[i];\n\tif ((i == 2) && npids[i] && (dvbdmxfeed->ts_type & TS_PACKET)) {\n	f
29239	536	attr_sensitivity_store_tpkbd	drivers/hid/hid-lenovo.c	value	1	11	\N	\N	\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\n	t
29385	41	irst_show_wakeup_events	drivers/platform/x86/intel-rst.c	value	1	11	\N	\N	\tstruct acpi_device *acpi;\n\tunsigned long long value;\n\tacpi_status status;\n\n\tacpi = to_acpi_device(dev);\n\n\tstatus = acpi_evaluate_integer(acpi->handle, "GFFS", NULL, &value);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, "%lld\\n", value);\n	t
29541	132	ttusbir_process_ir_data	drivers/media/rc/ttusbir.c	&rawir)	1	11	\N	\N	\tstruct ir_raw_event rawir;\n\tunsigned i, v, b;\n\tbool event = false;\n\n\tinit_ir_raw_event(&rawir);\n\n\tfor (i = 0; i < 128; i++) {\n\t\tv = buf[i] & 0xfe;\n\t\tswitch (v) {\n\t\tcase 0xfe:\n\t\t\trawir.pulse = false;\n\t\t\trawir.duration = NS_PER_BYTE;\n\t\t\tif (ir_raw_event_store_with_filter(tt->rc, &rawir))\n	t
29921	1713	usbvision_set_output	drivers/media/usb/usbvision/usbvision-core.c	err_code	1	11	\N	\N	\tint err_code = 0;\n\tint usb_width, usb_height;\n\tunsigned int frame_rate = 0, frame_drop = 0;\n\tunsigned char *value = usbvision->ctrl_urb_buffer;\n\n\tif (!USBVISION_IS_OPERATIONAL(usbvision))\n\t\treturn 0;\n\n\tif (width > MAX_USB_WIDTH) {\n\t\tusb_width = width / 2;\n\t\tusbvision->stretch_width = 2;\n\t} else {\n\t\tusb_width = width;\n\t\tusbvision->stretch_width = 1;\n\t}\n\n\tif (height > MAX_USB_HEIGHT) {\n\t\tusb_height = height / 2;\n\t\tusbvision->stretch_height = 2;\n\t} else {\n\t\tusb_height = height;\n\t\tusbvision->stretch_height = 1;\n\t}\n\n\tRESTRICT_TO_RANGE(usb_width, MIN_FRAME_WIDTH, MAX_USB_WIDTH);\n\tusb_width &= ~(MIN_FRAME_WIDTH-1);\n\tRESTRICT_TO_RANGE(usb_height, MIN_FRAME_HEIGHT, MAX_USB_HEIGHT);\n\tusb_height &= ~(1);\n\n\tPDEBUG(DBG_FUNC, "usb %dx%d; screen %dx%d; stretch %dx%d",\n\t\t\t\t\t\tusb_width, usb_height, width, height,\n\t\t\t\t\t\tusbvision->stretch_width, usbvision->stretch_height);\n\n\t/* I'll not rewrite the same values */\n\tif ((usb_width != usbvision->curwidth) || (usb_height != usbvision->curheight)) {\n\t\tvalue[0] = usb_width & 0xff;\t\t/* LSB */\n\t\tvalue[1] = (usb_width >> 8) & 0x03;\t/* MSB */\n\t\tvalue[2] = usb_height & 0xff;\t\t/* LSB */\n\t\tvalue[3] = (usb_height >> 8) & 0x03;\t/* MSB */\n\n\t\terr_code = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\n\t\t\t     USBVISION_OP_CODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT,\n\t\t\t\t 0, (__u16) USBVISION_LXSIZE_O, value, 4, HZ);\n\n\t\tif (err_code < 0) {\n	t
29929	2102	mvneta_rx_hwbm	drivers/net/ethernet/marvell/mvneta.c	skb	1	11	\N	\N	\tstruct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);\n\tstruct net_device *dev = pp->dev;\n\tint rx_done;\n\tu32 rcvd_pkts = 0;\n\tu32 rcvd_bytes = 0;\n\n\t/* Get number of received packets */\n\trx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);\n\n\tif (rx_todo > rx_done)\n\t\trx_todo = rx_done;\n\n\trx_done = 0;\n\n\t/* Fairness NAPI loop */\n\twhile (rx_done < rx_todo) {\n\t\tstruct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);\n\t\tstruct mvneta_bm_pool *bm_pool = NULL;\n\t\tstruct sk_buff *skb;\n\t\tunsigned char *data;\n\t\tdma_addr_t phys_addr;\n\t\tu32 rx_status, frag_size;\n\t\tint rx_bytes, err;\n\t\tu8 pool_id;\n\n\t\trx_done++;\n\t\trx_status = rx_desc->status;\n\t\trx_bytes = rx_desc->data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);\n\t\tdata = (u8 *)(uintptr_t)rx_desc->buf_cookie;\n\t\tphys_addr = rx_desc->buf_phys_addr;\n\t\tpool_id = MVNETA_RX_GET_BM_POOL_ID(rx_desc);\n\t\tbm_pool = &pp->bm_priv->bm_pools[pool_id];\n\n\t\tif (!mvneta_rxq_desc_is_first_last(rx_status) ||\n\t\t    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {\nerr_drop_frame_ret_pool:\n\t\t\t/* Return the buffer to the pool */\n\t\t\tmvneta_bm_pool_put_bp(pp->bm_priv, bm_pool,\n\t\t\t\t\t      rx_desc->buf_phys_addr);\nerr_drop_frame:\n\t\t\tdev->stats.rx_errors++;\n\t\t\tmvneta_rx_error(pp, rx_desc);\n\t\t\t/* leave the descriptor untouched */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rx_bytes <= rx_copybreak) {\n\t\t\t/* better copy a small frame and not unmap the DMA region */\n\t\t\tskb = netdev_alloc_skb_ip_align(dev, rx_bytes);\n\t\t\tif (unlikely(!skb))\n\t\t\t\tgoto err_drop_frame_ret_pool;\n\n\t\t\tdma_sync_single_range_for_cpu(dev->dev.parent,\n\t\t\t                              rx_desc->buf_phys_addr,\n\t\t\t                              MVNETA_MH_SIZE + NET_SKB_PAD,\n\t\t\t                              rx_bytes,\n\t\t\t                              DMA_FROM_DEVICE);\n\t\t\tskb_put_data(skb, data + MVNETA_MH_SIZE + NET_SKB_PAD,\n	t
30008	121	vv6410_init	drivers/media/usb/gspca/stv06xx/stv06xx_vv6410.c	err	1	11	\N	\N	\tint err = 0, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stv_bridge_init); i++)\n\t\tstv06xx_write_bridge(sd, stv_bridge_init[i].addr, stv_bridge_init[i].data);\n\n\terr = stv06xx_write_sensor_bytes(sd, (u8 *) vv6410_sensor_init,\n\t\t\t\t\t ARRAY_SIZE(vv6410_sensor_init));\n\treturn (err < 0) ? err : 0;\n	t
30306	660	mmc_blk_ioctl_multi_cmd	drivers/mmc/core/block.c	idata	1	11	\N	\N	\tstruct mmc_blk_ioc_data **idata = NULL;\n\tstruct mmc_ioc_cmd __user *cmds = user->cmds;\n\tstruct mmc_card *card;\n\tstruct mmc_queue *mq;\n\tint i, err = 0, ioc_err = 0;\n\t__u64 num_of_cmds;\n\tstruct request *req;\n\n\tif (copy_from_user(&num_of_cmds, &user->num_of_cmds,\n\t\t\t   sizeof(num_of_cmds)))\n\t\treturn -EFAULT;\n\n\tif (!num_of_cmds)\n\t\treturn 0;\n\n\tif (num_of_cmds > MMC_IOC_MAX_CMDS)\n\t\treturn -EINVAL;\n\n\tidata = kcalloc(num_of_cmds, sizeof(*idata), GFP_KERNEL);\n\tif (!idata)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_of_cmds; i++) {\n\t\tidata[i] = mmc_blk_ioctl_copy_from_user(&cmds[i]);\n\t\tif (IS_ERR(idata[i])) {\n\t\t\terr = PTR_ERR(idata[i]);\n\t\t\tnum_of_cmds = i;\n\t\t\tgoto cmd_err;\n\t\t}\n\t}\n\n\tcard = md->queue.card;\n\tif (IS_ERR(card)) {\n\t\terr = PTR_ERR(card);\n\t\tgoto cmd_err;\n\t}\n\n\n\t/*\n\t * Dispatch the ioctl()s into the block request queue.\n\t */\n\tmq = &md->queue;\n\treq = blk_get_request(mq->queue,\n\t\tidata[0]->ic.write_flag ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN,\n\t\t__GFP_RECLAIM);\n\treq_to_mmc_queue_req(req)->drv_op = MMC_DRV_OP_IOCTL;\n\treq_to_mmc_queue_req(req)->drv_op_data = idata;\n\treq_to_mmc_queue_req(req)->ioc_count = num_of_cmds;\n\tblk_execute_rq(mq->queue, NULL, req, 0);\n\tioc_err = req_to_mmc_queue_req(req)->drv_op_result;\n\n\t/* copy to user if data and response */\n\tfor (i = 0; i < num_of_cmds && !err; i++)\n\t\terr = mmc_blk_ioctl_copy_to_user(&cmds[i], idata[i]);\n\n\tblk_put_request(req);\n\ncmd_err:\n\tfor (i = 0; i < num_of_cmds; i++) {\n\t\tkfree(idata[i]->buf);\n	t
52689	344	twl6040_soc_dapm_put_vibra_enum	sound/soc/codecs/twl6040.c	val	1	13	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int val;\n\n\t/* Do not allow changes while Input/FF efect is running */\n\tval = twl6040_read(codec, e->reg);\n\tif (val & TWL6040_VIBENA && !(val & TWL6040_VIBSEL))\n	f
30487	587	pcnet32_realloc_rx_ring	drivers/net/ethernet/amd/pcnet32.c	rx_skbuff->data	1	11	\N	\N	\tdma_addr_t new_ring_dma_addr;\n\tdma_addr_t *new_dma_addr_list;\n\tstruct pcnet32_rx_head *new_rx_ring;\n\tstruct sk_buff **new_skb_list;\n\tint new, overlap;\n\tunsigned int entries = BIT(size);\n\n\tnew_rx_ring =\n\t\tpci_zalloc_consistent(lp->pci_dev,\n\t\t\t\t      sizeof(struct pcnet32_rx_head) * entries,\n\t\t\t\t      &new_ring_dma_addr);\n\tif (new_rx_ring == NULL)\n\t\treturn;\n\n\tnew_dma_addr_list = kcalloc(entries, sizeof(dma_addr_t), GFP_ATOMIC);\n\tif (!new_dma_addr_list)\n\t\tgoto free_new_rx_ring;\n\n\tnew_skb_list = kcalloc(entries, sizeof(struct sk_buff *), GFP_ATOMIC);\n\tif (!new_skb_list)\n\t\tgoto free_new_lists;\n\n\t/* first copy the current receive buffers */\n\toverlap = min(entries, lp->rx_ring_size);\n\tfor (new = 0; new < overlap; new++) {\n\t\tnew_rx_ring[new] = lp->rx_ring[new];\n\t\tnew_dma_addr_list[new] = lp->rx_dma_addr[new];\n\t\tnew_skb_list[new] = lp->rx_skbuff[new];\n\t}\n\t/* now allocate any new buffers needed */\n\tfor (; new < entries; new++) {\n\t\tstruct sk_buff *rx_skbuff;\n\t\tnew_skb_list[new] = netdev_alloc_skb(dev, PKT_BUF_SKB);\n\t\trx_skbuff = new_skb_list[new];\n\t\tif (!rx_skbuff) {\n\t\t\t/* keep the original lists and buffers */\n\t\t\tnetif_err(lp, drv, dev, "%s netdev_alloc_skb failed\\n",\n\t\t\t\t  __func__);\n\t\t\tgoto free_all_new;\n\t\t}\n\t\tskb_reserve(rx_skbuff, NET_IP_ALIGN);\n\n\t\tnew_dma_addr_list[new] =\n\t\t\t    pci_map_single(lp->pci_dev, rx_skbuff->data,\n	t
30526	7459	rtl_rx	drivers/net/ethernet/realtek/r8169.c	skb	1	11	\N	\N	\tunsigned int cur_rx, rx_left;\n\tunsigned int count;\n\n\tcur_rx = tp->cur_rx;\n\n\tfor (rx_left = min(budget, NUM_RX_DESC); rx_left > 0; rx_left--, cur_rx++) {\n\t\tunsigned int entry = cur_rx % NUM_RX_DESC;\n\t\tstruct RxDesc *desc = tp->RxDescArray + entry;\n\t\tu32 status;\n\n\t\tstatus = le32_to_cpu(desc->opts1) & tp->opts1_mask;\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\n\t\t/* This barrier is needed to keep us from reading\n\t\t * any other fields out of the Rx descriptor until\n\t\t * we know the status of DescOwn\n\t\t */\n\t\tdma_rmb();\n\n\t\tif (unlikely(status & RxRES)) {\n\t\t\tnetif_info(tp, rx_err, dev, "Rx ERROR. status = %08x\\n",\n\t\t\t\t   status);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status & (RxRWT | RxRUNT))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (status & RxCRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & RxFOVF) {\n\t\t\t\trtl_schedule_task(tp, RTL_FLAG_TASK_RESET_PENDING);\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\t\t\tif ((status & (RxRUNT | RxCRC)) &&\n\t\t\t    !(status & (RxRWT | RxFOVF)) &&\n\t\t\t    (dev->features & NETIF_F_RXALL))\n\t\t\t\tgoto process_pkt;\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\t\t\tdma_addr_t addr;\n\t\t\tint pkt_size;\n\nprocess_pkt:\n\t\t\taddr = le64_to_cpu(desc->addr);\n\t\t\tif (likely(!(dev->features & NETIF_F_RXFCS)))\n\t\t\t\tpkt_size = (status & 0x00003fff) - 4;\n\t\t\telse\n\t\t\t\tpkt_size = status & 0x00003fff;\n\n\t\t\t/*\n\t\t\t * The driver does not support incoming fragmented\n\t\t\t * frames. They are seen as a symptom of over-mtu\n\t\t\t * sized frames.\n\t\t\t */\n\t\t\tif (unlikely(rtl8169_fragmented_frame(status))) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tgoto release_descriptor;\n\t\t\t}\n\n\t\t\tskb = rtl8169_try_rx_copy(tp->Rx_databuff[entry],\n\t\t\t\t\t\t  tp, pkt_size, addr);\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tgoto release_descriptor;\n\t\t\t}\n\n\t\t\trtl8169_rx_csum(skb, status);\n	t
30654	5176	btrfs_search_forward	fs/btrfs/ctree.c	slot	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n	t
30673	899	via686a_pci_probe	drivers/hwmon/via686a.c	val	1	11	\N	\N	\tu16 address, val;\n\n\tif (force_addr) {\n\t\taddress = force_addr & ~(VIA686A_EXTENT - 1);\n\t\tdev_warn(&dev->dev, "Forcing ISA address 0x%x\\n", address);\n\t\tif (PCIBIOS_SUCCESSFUL !=\n\t\t    pci_write_config_word(dev, VIA686A_BASE_REG, address | 1))\n\t\t\treturn -ENODEV;\n\t}\n\tif (PCIBIOS_SUCCESSFUL !=\n\t    pci_read_config_word(dev, VIA686A_BASE_REG, &val))\n\t\treturn -ENODEV;\n\n\taddress = val & ~(VIA686A_EXTENT - 1);\n\tif (address == 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t"base address not set - upgrade BIOS or use force_addr=0xaddr\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tif (PCIBIOS_SUCCESSFUL !=\n\t    pci_read_config_word(dev, VIA686A_ENABLE_REG, &val))\n\t\treturn -ENODEV;\n\tif (!(val & 0x0001)) {\n	t
30984	1219	epic_rx	drivers/net/ethernet/smsc/epic100.c	skb->data	1	13	\N	\N	\tstruct epic_private *ep = netdev_priv(dev);\n\tint entry = ep->cur_rx % RX_RING_SIZE;\n\tint rx_work_limit = ep->dirty_rx + RX_RING_SIZE - ep->cur_rx;\n\tint work_done = 0;\n\n\tif (debug > 4)\n\t\tnetdev_dbg(dev, " In epic_rx(), entry %d %8.8x.\\n", entry,\n\t\t\t   ep->rx_ring[entry].rxstatus);\n\n\tif (rx_work_limit > budget)\n\t\trx_work_limit = budget;\n\n\t/* If we own the next entry, it's a new packet. Send it up. */\n\twhile ((ep->rx_ring[entry].rxstatus & DescOwn) == 0) {\n\t\tint status = ep->rx_ring[entry].rxstatus;\n\n\t\tif (debug > 4)\n\t\t\tnetdev_dbg(dev, "  epic_rx() status was %8.8x.\\n",\n\t\t\t\t   status);\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\t\tif (status & 0x2006) {\n\t\t\tif (debug > 2)\n\t\t\t\tnetdev_dbg(dev, "epic_rx() error status was %8.8x.\\n",\n\t\t\t\t\t   status);\n\t\t\tif (status & 0x2000) {\n\t\t\t\tnetdev_warn(dev, "Oversized Ethernet frame spanned multiple buffers, status %4.4x!\\n",\n\t\t\t\t\t    status);\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t} else if (status & 0x0006)\n\t\t\t\t/* Rx Frame errors are counted in hardware. */\n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\t/* Malloc up new buffer, compatible with net-2e. */\n\t\t\t/* Omit the four octet CRC from the length. */\n\t\t\tshort pkt_len = (status >> 16) - 4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len > PKT_BUF_SZ - 4) {\n\t\t\t\tnetdev_err(dev, "Oversized Ethernet frame, status %x %d bytes.\\n",\n\t\t\t\t\t   status, pkt_len);\n\t\t\t\tpkt_len = 1514;\n\t\t\t}\n\t\t\t/* Check if the packet is long enough to accept without copying\n\t\t\t   to a minimally-sized skbuff. */\n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t/* 16 byte align the IP header */\n\t\t\t\tpci_dma_sync_single_for_cpu(ep->pci_dev,\n\t\t\t\t\t\t\t    ep->rx_ring[entry].bufaddr,\n\t\t\t\t\t\t\t    ep->rx_buf_sz,\n\t\t\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_copy_to_linear_data(skb, ep->rx_skbuff[entry]->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tpci_dma_sync_single_for_device(ep->pci_dev,\n\t\t\t\t\t\t\t       ep->rx_ring[entry].bufaddr,\n\t\t\t\t\t\t\t       ep->rx_buf_sz,\n\t\t\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t} else {\n\t\t\t\tpci_unmap_single(ep->pci_dev,\n\t\t\t\t\tep->rx_ring[entry].bufaddr,\n\t\t\t\t\tep->rx_buf_sz, PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_put(skb = ep->rx_skbuff[entry], pkt_len);\n\t\t\t\tep->rx_skbuff[entry] = NULL;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\t\twork_done++;\n\t\tentry = (++ep->cur_rx) % RX_RING_SIZE;\n\t}\n\n\t/* Refill the Rx ring buffers. */\n\tfor (; ep->cur_rx - ep->dirty_rx > 0; ep->dirty_rx++) {\n\t\tentry = ep->dirty_rx % RX_RING_SIZE;\n\t\tif (ep->rx_skbuff[entry] == NULL) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tskb = ep->rx_skbuff[entry] = netdev_alloc_skb(dev, ep->rx_buf_sz + 2);\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\n\t\t\tskb_reserve(skb, 2);\t/* Align IP on 16 byte boundaries */\n\t\t\tep->rx_ring[entry].bufaddr = pci_map_single(ep->pci_dev,\n	f
31122	6191	handle_active_stripes	drivers/md/raid5.c	batch[i]	1	11	\N	\N	\tstruct stripe_head *batch[MAX_STRIPE_BATCH], *sh;\n\tint i, batch_size = 0, hash;\n\tbool release_inactive = false;\n\n\twhile (batch_size < MAX_STRIPE_BATCH &&\n\t\t\t(sh = __get_priority_stripe(conf, group)) != NULL)\n\t\tbatch[batch_size++] = sh;\n\n\tif (batch_size == 0) {\n\t\tfor (i = 0; i < NR_STRIPE_HASH_LOCKS; i++)\n\t\t\tif (!list_empty(temp_inactive_list + i))\n\t\t\t\tbreak;\n\t\tif (i == NR_STRIPE_HASH_LOCKS) {\n\t\t\tspin_unlock_irq(&conf->device_lock);\n\t\t\tr5l_flush_stripe_to_raid(conf->log);\n\t\t\tspin_lock_irq(&conf->device_lock);\n\t\t\treturn batch_size;\n\t\t}\n\t\trelease_inactive = true;\n\t}\n\tspin_unlock_irq(&conf->device_lock);\n\n\trelease_inactive_stripe_list(conf, temp_inactive_list,\n\t\t\t\t     NR_STRIPE_HASH_LOCKS);\n\n\tr5l_flush_stripe_to_raid(conf->log);\n\tif (release_inactive) {\n\t\tspin_lock_irq(&conf->device_lock);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < batch_size; i++)\n\t\thandle_stripe(batch[i]);\n	t
47759	768	scsifront_init_ring	drivers/scsi/xen-scsifront.c	scsifront_init_ring_$info.addr$obj$5$obj	0	13	\N	\N	\tstruct xenbus_device *dev = info->dev;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\n\tpr_debug("%s\\n", __func__);\n\n\terr = scsifront_alloc_ring(info);\n\tif (err)\n\t\treturn err;\n\tpr_debug("%s: %u %u\\n", __func__, info->ring_ref, info->evtchn);\n	f
31626	236	i915_gem_render_state_emit	drivers/gpu/drm/i915/i915_gem_render_state.c	ret	1	11	\N	\N	\tstruct intel_render_state *so;\n\tint ret;\n\n\tlockdep_assert_held(&req->i915->drm.struct_mutex);\n\n\tso = req->engine->render_state;\n\tif (!so)\n\t\treturn 0;\n\n\t/* Recreate the page after shrinking */\n\tif (!so->vma->obj->mm.pages)\n\t\tso->batch_offset = -1;\n\n\tret = i915_vma_pin(so->vma, 0, 0, PIN_GLOBAL | PIN_HIGH);\n\tif (ret)\n	t
31628	1314	intel_ring_pin	drivers/gpu/drm/i915/intel_ringbuffer.c	ret	1	11	\N	\N	\tenum i915_map_type map = HAS_LLC(i915) ? I915_MAP_WB : I915_MAP_WC;\n\tstruct i915_vma *vma = ring->vma;\n\tunsigned int flags;\n\tvoid *addr;\n\tint ret;\n\n\tGEM_BUG_ON(ring->vaddr);\n\n\n\tflags = PIN_GLOBAL;\n\tif (offset_bias)\n\t\tflags |= PIN_OFFSET_BIAS | offset_bias;\n\tif (vma->obj->stolen)\n\t\tflags |= PIN_MAPPABLE;\n\n\tif (!(vma->flags & I915_VMA_GLOBAL_BIND)) {\n\t\tif (flags & PIN_MAPPABLE || map == I915_MAP_WC)\n\t\t\tret = i915_gem_object_set_to_gtt_domain(vma->obj, true);\n\t\telse\n\t\t\tret = i915_gem_object_set_to_cpu_domain(vma->obj, true);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = i915_vma_pin(vma, 0, PAGE_SIZE, flags);\n\tif (unlikely(ret))\n	t
31693	427	da7219_aad_irq_thread	sound/soc/codecs/da7219-aad.c	events	1	11	\N	\N	\tstruct da7219_aad_priv *da7219_aad = data;\n\tstruct snd_soc_codec *codec = da7219_aad->codec;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\n\tstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\n\tu8 events[DA7219_AAD_IRQ_REG_MAX];\n\tu8 statusa;\n\tint i, report = 0, mask = 0;\n\n\t/* Read current IRQ events */\n\tregmap_bulk_read(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,\n\t\t\t events, DA7219_AAD_IRQ_REG_MAX);\n\n\tif (!events[DA7219_AAD_IRQ_REG_A] && !events[DA7219_AAD_IRQ_REG_B])\n\t\treturn IRQ_NONE;\n\n\t/* Read status register for jack insertion & type status */\n\tstatusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);\n\n\t/* Clear events */\n\tregmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,\n\t\t\t  events, DA7219_AAD_IRQ_REG_MAX);\n\n\tdev_dbg(codec->dev, "IRQ events = 0x%x|0x%x, status = 0x%x\\n",\n\t\tevents[DA7219_AAD_IRQ_REG_A], events[DA7219_AAD_IRQ_REG_B],\n\t\tstatusa);\n\n\tif (statusa & DA7219_JACK_INSERTION_STS_MASK) {\n\t\t/* Jack Insertion */\n\t\tif (events[DA7219_AAD_IRQ_REG_A] &\n\t\t    DA7219_E_JACK_INSERTED_MASK) {\n\t\t\treport |= SND_JACK_MECHANICAL;\n\t\t\tmask |= SND_JACK_MECHANICAL;\n\t\t\tda7219_aad->jack_inserted = true;\n\t\t}\n\n\t\t/* Jack type detection */\n\t\tif (events[DA7219_AAD_IRQ_REG_A] &\n\t\t    DA7219_E_JACK_DETECT_COMPLETE_MASK) {\n\t\t\t/*\n\t\t\t * If 4-pole, then enable button detection, else perform\n\t\t\t * HP impedance test to determine output type to report.\n\t\t\t *\n\t\t\t * We schedule work here as the tasks themselves can\n\t\t\t * take time to complete, and in particular for hptest\n\t\t\t * we want to be able to check if the jack was removed\n\t\t\t * during the procedure as this will invalidate the\n\t\t\t * result. By doing this as work, the IRQ thread can\n\t\t\t * handle a removal, and we can check at the end of\n\t\t\t * hptest if we have a valid result or not.\n\t\t\t */\n\t\t\tif (statusa & DA7219_JACK_TYPE_STS_MASK) {\n\t\t\t\treport |= SND_JACK_HEADSET;\n\t\t\t\tmask |=\tSND_JACK_HEADSET | SND_JACK_LINEOUT;\n\t\t\t\tschedule_work(&da7219_aad->btn_det_work);\n\t\t\t} else {\n\t\t\t\tschedule_work(&da7219_aad->hptest_work);\n\t\t\t}\n\t\t}\n\n\t\t/* Button support for 4-pole jack */\n\t\tif (statusa & DA7219_JACK_TYPE_STS_MASK) {\n\t\t\tfor (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {\n\t\t\t\t/* Button Press */\n\t\t\t\tif (events[DA7219_AAD_IRQ_REG_B] &\n\t\t\t\t    (DA7219_E_BUTTON_A_PRESSED_MASK << i)) {\n\t\t\t\t\treport |= SND_JACK_BTN_0 >> i;\n\t\t\t\t\tmask |= SND_JACK_BTN_0 >> i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnd_soc_jack_report(da7219_aad->jack, report, mask);\n\n\t\t\tfor (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {\n\t\t\t\t/* Button Release */\n\t\t\t\tif (events[DA7219_AAD_IRQ_REG_B] &\n\t\t\t\t    (DA7219_E_BUTTON_A_RELEASED_MASK >> i)) {\n\t\t\t\t\treport &= ~(SND_JACK_BTN_0 >> i);\n\t\t\t\t\tmask |= SND_JACK_BTN_0 >> i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Jack removal */\n\t\tif (events[DA7219_AAD_IRQ_REG_A] & DA7219_E_JACK_REMOVED_MASK) {\n	t
31737	633	pblk_lines_alloc_metadata	drivers/lightnvm/pblk-init.c	l_mg->eline_meta[i]->buf	1	11	\N	\N	\tstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\n\tstruct pblk_line_meta *lm = &pblk->lm;\n\tint i;\n\n\t/* smeta is always small enough to fit on a kmalloc memory allocation,\n\t * emeta depends on the number of LUNs allocated to the pblk instance\n\t */\n\tfor (i = 0; i < PBLK_DATA_LINES; i++) {\n\t\tl_mg->sline_meta[i] = kmalloc(lm->smeta_len, GFP_KERNEL);\n\t\tif (!l_mg->sline_meta[i])\n\t\t\tgoto fail_free_smeta;\n\t}\n\n\t/* emeta allocates three different buffers for managing metadata with\n\t * in-memory and in-media layouts\n\t */\n\tfor (i = 0; i < PBLK_DATA_LINES; i++) {\n\t\tstruct pblk_emeta *emeta;\n\n\t\temeta = kmalloc(sizeof(struct pblk_emeta), GFP_KERNEL);\n\t\tif (!emeta)\n\t\t\tgoto fail_free_emeta;\n\n\t\tif (lm->emeta_len[0] > KMALLOC_MAX_CACHE_SIZE) {\n\t\t\tl_mg->emeta_alloc_type = PBLK_VMALLOC_META;\n\n\t\t\temeta->buf = vmalloc(lm->emeta_len[0]);\n\t\t\tif (!emeta->buf) {\n\t\t\t\tkfree(emeta);\n\t\t\t\tgoto fail_free_emeta;\n\t\t\t}\n\n\t\t\temeta->nr_entries = lm->emeta_sec[0];\n\t\t\tl_mg->eline_meta[i] = emeta;\n\t\t} else {\n\t\t\tl_mg->emeta_alloc_type = PBLK_KMALLOC_META;\n\n\t\t\temeta->buf = kmalloc(lm->emeta_len[0], GFP_KERNEL);\n\t\t\tif (!emeta->buf) {\n\t\t\t\tkfree(emeta);\n\t\t\t\tgoto fail_free_emeta;\n\t\t\t}\n\n\t\t\temeta->nr_entries = lm->emeta_sec[0];\n\t\t\tl_mg->eline_meta[i] = emeta;\n\t\t}\n\t}\n\n\tl_mg->vsc_list = kcalloc(l_mg->nr_lines, sizeof(__le32), GFP_KERNEL);\n\tif (!l_mg->vsc_list)\n\t\tgoto fail_free_emeta;\n\n\tfor (i = 0; i < l_mg->nr_lines; i++)\n\t\tl_mg->vsc_list[i] = cpu_to_le32(EMPTY_ENTRY);\n\n\treturn 0;\n\nfail_free_emeta:\n\twhile (--i >= 0) {\n\t\tvfree(l_mg->eline_meta[i]->buf);\n	t
30990	800	aem_register_bmc	drivers/hwmon/ibmaem.c	probe.user	1	13	\N	\N	\tstruct aem_ipmi_data probe;\n\n\tif (aem_init_ipmi_data(&probe, iface, dev))\n\t\treturn;\n\n\t/* Ignore probe errors; they won't cause problems */\n\taem_init_aem1(&probe);\n\taem_init_aem2(&probe);\n\n\tipmi_destroy_user(probe.user);\n	f
32068	5872	intel_edp_init_connector	drivers/gpu/drm/i915/intel_dp.c	edid)	1	11	\N	\N	\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *intel_encoder = &intel_dig_port->base;\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_display_mode *fixed_mode = NULL;\n\tstruct drm_display_mode *alt_fixed_mode = NULL;\n\tstruct drm_display_mode *downclock_mode = NULL;\n\tbool has_dpcd;\n\tstruct drm_display_mode *scan;\n\tstruct edid *edid;\n\tenum pipe pipe = INVALID_PIPE;\n\n\tif (!is_edp(intel_dp))\n\t\treturn true;\n\n\t/*\n\t * On IBX/CPT we may get here with LVDS already registered. Since the\n\t * driver uses the only internal power sequencer available for both\n\t * eDP and LVDS bail out early in this case to prevent interfering\n\t * with an already powered-on LVDS power sequencer.\n\t */\n\tif (intel_get_lvds_encoder(dev)) {\n\t\tWARN_ON(!(HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)));\n\t\tDRM_INFO("LVDS was detected, not registering eDP\\n");\n\n\t\treturn false;\n\t}\n\n\tpps_lock(intel_dp);\n\n\tintel_dp_init_panel_power_timestamps(intel_dp);\n\tintel_dp_pps_init(dev, intel_dp);\n\tintel_edp_panel_vdd_sanitize(intel_dp);\n\n\tpps_unlock(intel_dp);\n\n\t/* Cache DPCD and EDID for edp. */\n\thas_dpcd = intel_edp_init_dpcd(intel_dp);\n\n\tif (!has_dpcd) {\n\t\t/* if this fails, presume the device is a ghost */\n\t\tDRM_INFO("failed to retrieve link info, disabling eDP\\n");\n\t\tgoto out_vdd_off;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tedid = drm_get_edid(connector, &intel_dp->aux.ddc);\n\tif (edid) {\n\t\tif (drm_add_edid_modes(connector, edid)) {\n	t
4751	139	viafb_lvds_identify_vt1636	drivers/video/fbdev/via/vt1636.c	Buffer	1	13	\N	\N	\tu8 Buffer[2];\n\n\tDEBUG_MSG(KERN_INFO "viafb_lvds_identify_vt1636.\\n");\n\n\t/* Sense VT1636 LVDS Transmiter */\n\tviaparinfo->chip_info->lvds_chip_info.lvds_chip_slave_addr =\n\t\tVT1636_LVDS_I2C_ADDR;\n\n\t/* Check vendor ID first: */\n\tif (viafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR,\n\t\t\t\t\t0x00, &Buffer[0]))\n\t\treturn false;\n\tviafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR, 0x01, &Buffer[1]);\n\n\tif (!((Buffer[0] == 0x06) && (Buffer[1] == 0x11)))\n	f
32142	1985	handle_pspoll	drivers/net/wireless/intersil/hostap/hostap_ap.c	skb	1	11	\N	\N	\tstruct net_device *dev = local->dev;\n\tstruct sta_info *sta;\n\tu16 aid;\n\tstruct sk_buff *skb;\n\n\tPDEBUG(DEBUG_PS2, "handle_pspoll: BSSID=%pM, TA=%pM PWRMGT=%d\\n",\n\t       hdr->addr1, hdr->addr2, !!ieee80211_has_pm(hdr->frame_control));\n\n\tif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\tPDEBUG(DEBUG_AP,\n\t\t       "handle_pspoll - addr1(BSSID)=%pM not own MAC\\n",\n\t\t       hdr->addr1);\n\t\treturn;\n\t}\n\n\taid = le16_to_cpu(hdr->duration_id);\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14))) {\n\t\tPDEBUG(DEBUG_PS, "   PSPOLL and AID[15:14] not set\\n");\n\t\treturn;\n\t}\n\taid &= ~(BIT(15) | BIT(14));\n\tif (aid == 0 || aid > MAX_AID_TABLE_SIZE) {\n\t\tPDEBUG(DEBUG_PS, "   invalid aid=%d\\n", aid);\n\t\treturn;\n\t}\n\tPDEBUG(DEBUG_PS2, "   aid=%d\\n", aid);\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tif (sta == NULL) {\n\t\tPDEBUG(DEBUG_PS, "   STA not found\\n");\n\t\treturn;\n\t}\n\tif (sta->aid != aid) {\n\t\tPDEBUG(DEBUG_PS, "   received aid=%i does not match with "\n\t\t       "assoc.aid=%d\\n", aid, sta->aid);\n\t\treturn;\n\t}\n\n\t/* FIX: todo:\n\t * - add timeout for buffering (clear aid in TIM vector if buffer timed\n\t *   out (expiry time must be longer than ListenInterval for\n\t *   the corresponding STA; "8802-11: 11.2.1.9 AP aging function"\n\t * - what to do, if buffered, pspolled, and sent frame is not ACKed by\n\t *   sta; store buffer for later use and leave TIM aid bit set? use\n\t *   TX event to check whether frame was ACKed?\n\t */\n\n\twhile ((skb = skb_dequeue(&sta->tx_buf)) != NULL) {\n\t\t/* send buffered frame .. */\n\t\tPDEBUG(DEBUG_PS2, "Sending buffered frame to STA after PS POLL"\n\t\t       " (buffer_count=%d)\\n", skb_queue_len(&sta->tx_buf));\n\n\t\tpspoll_send_buffered(local, sta, skb);\n	t
32465	846	check_firmware	drivers/media/tuners/tuner-xc2028.c	version	1	11	\N	\N	\tstruct xc2028_data         *priv = fe->tuner_priv;\n\tstruct firmware_properties new_fw;\n\tint\t\t\t   rc, retry_count = 0;\n\tu16\t\t\t   version, hwmodel;\n\tv4l2_std_id\t\t   std0;\n\n\ttuner_dbg("%s called\\n", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (priv->ctrl.mts && !(type & FM))\n\t\ttype |= MTS;\n\nretry:\n\tnew_fw.type = type;\n\tnew_fw.id = std;\n\tnew_fw.std_req = std;\n\tnew_fw.scode_table = SCODE | priv->ctrl.scode_table;\n\tnew_fw.scode_nr = 0;\n\tnew_fw.int_freq = int_freq;\n\n\ttuner_dbg("checking firmware, user requested type=");\n\tif (debug) {\n\t\tdump_firm_type(new_fw.type);\n\t\tprintk(KERN_CONT "(%x), id %016llx, ", new_fw.type,\n\t\t       (unsigned long long)new_fw.std_req);\n\t\tif (!int_freq) {\n\t\t\tprintk(KERN_CONT "scode_tbl ");\n\t\t\tdump_firm_type(priv->ctrl.scode_table);\n\t\t\tprintk(KERN_CONT "(%x), ", priv->ctrl.scode_table);\n\t\t} else\n\t\t\tprintk(KERN_CONT "int_freq %d, ", new_fw.int_freq);\n\t\tprintk(KERN_CONT "scode_nr %d\\n", new_fw.scode_nr);\n\t}\n\n\t/*\n\t * No need to reload base firmware if it matches and if the tuner\n\t * is not at sleep mode\n\t */\n\tif ((priv->state == XC2028_ACTIVE) &&\n\t    (((BASE | new_fw.type) & BASE_TYPES) ==\n\t    (priv->cur_fw.type & BASE_TYPES))) {\n\t\ttuner_dbg("BASE firmware not changed.\\n");\n\t\tgoto skip_base;\n\t}\n\n\t/* Updating BASE - forget about all currently loaded firmware */\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\t/* Reset is needed before loading firmware */\n\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* BASE firmwares are all std0 */\n\tstd0 = 0;\n\trc = load_firmware(fe, BASE | new_fw.type, &std0);\n\tif (rc < 0) {\n\t\ttuner_err("Error %d while loading base firmware\\n",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\n\t/* Load INIT1, if needed */\n\ttuner_dbg("Load init1 firmware, if exists\\n");\n\n\trc = load_firmware(fe, BASE | INIT1 | new_fw.type, &std0);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, (BASE | INIT1 | new_fw.type) & ~F8MHZ,\n\t\t\t\t   &std0);\n\tif (rc < 0 && rc != -ENOENT) {\n\t\ttuner_err("Error %d while loading init1 firmware\\n",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\nskip_base:\n\t/*\n\t * No need to reload standard specific firmware if base firmware\n\t * was not reloaded and requested video standards have not changed.\n\t */\n\tif (priv->cur_fw.type == (BASE | new_fw.type) &&\n\t    priv->cur_fw.std_req == std) {\n\t\ttuner_dbg("Std-specific firmware already loaded.\\n");\n\t\tgoto skip_std_specific;\n\t}\n\n\t/* Reloading std-specific firmware forces a SCODE update */\n\tpriv->cur_fw.scode_table = 0;\n\n\trc = load_firmware(fe, new_fw.type, &new_fw.id);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, new_fw.type & ~F8MHZ, &new_fw.id);\n\n\tif (rc < 0)\n\t\tgoto fail;\n\nskip_std_specific:\n\tif (priv->cur_fw.scode_table == new_fw.scode_table &&\n\t    priv->cur_fw.scode_nr == new_fw.scode_nr) {\n\t\ttuner_dbg("SCODE firmware already loaded.\\n");\n\t\tgoto check_device;\n\t}\n\n\tif (new_fw.type & FM)\n\t\tgoto check_device;\n\n\t/* Load SCODE firmware, if exists */\n\ttuner_dbg("Trying to load scode %d\\n", new_fw.scode_nr);\n\n\trc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\n\t\t\tnew_fw.int_freq, new_fw.scode_nr);\n\ncheck_device:\n\tif (xc2028_get_reg(priv, 0x0004, &version) < 0 ||\n\t    xc2028_get_reg(priv, 0x0008, &hwmodel) < 0) {\n\t\ttuner_err("Unable to read tuner registers.\\n");\n\t\tgoto fail;\n\t}\n\n\ttuner_dbg("Device is Xceive %d version %d.%d, firmware version %d.%d\\n",\n	t
32544	53	ath_rxbuf_alloc	drivers/net/wireless/ath/main.c	skb	1	11	\N	\N	\tstruct sk_buff *skb;\n\tu32 off;\n\n\t/*\n\t * Cache-line-align.  This is important (for the\n\t * 5210 at least) as not doing so causes bogus data\n\t * in rx'd frames.\n\t */\n\n\t/* Note: the kernel can allocate a value greater than\n\t * what we ask it to give us. We really only need 4 KB as that\n\t * is this hardware supports and in fact we need at least 3849\n\t * as that is the MAX AMSDU size this hardware supports.\n\t * Unfortunately this means we may get 8 KB here from the\n\t * kernel... and that is actually what is observed on some\n\t * systems :( */\n\tskb = __dev_alloc_skb(len + common->cachelsz - 1, gfp_mask);\n\tif (skb != NULL) {\n\t\toff = ((unsigned long) skb->data) % common->cachelsz;\n\t\tif (off != 0)\n\t\t\tskb_reserve(skb, common->cachelsz - off);\n	t
33329	3580	cxd2841er_tune_tc	drivers/media/dvb-frontends/cxd2841er.c	carrier_offset	1	11	\N	\N	\tint ret, carrier_offset;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdev_dbg(&priv->i2c->dev, "%s(): re_tune %d bandwidth=%d\\n", __func__,\n\t\t\tre_tune, p->bandwidth_hz);\n\tif (re_tune) {\n\t\tret = cxd2841er_set_frontend_tc(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcxd2841er_read_status_tc(fe, status);\n\t\tif (*status & FE_HAS_LOCK) {\n\t\t\tswitch (priv->system) {\n\t\t\tcase SYS_ISDBT:\n\t\t\t\tret = cxd2841er_get_carrier_offset_i(\n\t\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBT:\n\t\t\t\tret = cxd2841er_get_carrier_offset_t(\n\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBT2:\n\t\t\t\tret = cxd2841er_get_carrier_offset_t2(\n\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBC_ANNEX_A:\n\t\t\t\tret = cxd2841er_get_carrier_offset_c(\n\t\t\t\t\tpriv, &carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\t"%s(): invalid delivery system %d\\n",\n\t\t\t\t\t__func__, priv->system);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\\n",\n	t
33574	15273	tg3_get_eeprom_hw_cfg	drivers/net/ethernet/broadcom/tg3.c	cfg3	1	11	\N	\N	\tu32 val;\n\n\ttp->phy_id = TG3_PHY_ID_INVALID;\n\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t/* Assume an onboard device and WOL capable by default.  */\n\ttg3_flag_set(tp, EEPROM_WRITE_PROT);\n\ttg3_flag_set(tp, WOL_CAP);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tif (!(tr32(PCIE_TRANSACTION_CFG) & PCIE_TRANS_CFG_LOM)) {\n\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t\ttg3_flag_set(tp, IS_NIC);\n\t\t}\n\t\tval = tr32(VCPU_CFGSHDW);\n\t\tif (val & VCPU_CFGSHDW_ASPM_DBNC)\n\t\t\ttg3_flag_set(tp, ASPM_WORKAROUND);\n\t\tif ((val & VCPU_CFGSHDW_WOL_ENABLE) &&\n\t\t    (val & VCPU_CFGSHDW_WOL_MAGPKT)) {\n\t\t\ttg3_flag_set(tp, WOL_ENABLE);\n\t\t\tdevice_set_wakeup_enable(&tp->pdev->dev, true);\n\t\t}\n\t\tgoto done;\n\t}\n\n\ttg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);\n\tif (val == NIC_SRAM_DATA_SIG_MAGIC) {\n\t\tu32 nic_cfg, led_cfg;\n\t\tu32 cfg2 = 0, cfg4 = 0, cfg5 = 0;\n\t\tu32 nic_phy_id, ver, eeprom_phy_id;\n\t\tint eeprom_phy_serdes = 0;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);\n\t\ttp->nic_sram_data_cfg = nic_cfg;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_VER, &ver);\n\t\tver >>= NIC_SRAM_DATA_VER_SHIFT;\n\t\tif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5701 &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5703 &&\n\t\t    (ver > 0) && (ver < 0x100))\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_2, &cfg2);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_4, &cfg4);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_5, &cfg5);\n\n\t\tif ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==\n\t\t    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER)\n\t\t\teeprom_phy_serdes = 1;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_PHY_ID, &nic_phy_id);\n\t\tif (nic_phy_id != 0) {\n\t\t\tu32 id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;\n\t\t\tu32 id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;\n\n\t\t\teeprom_phy_id  = (id1 >> 16) << 10;\n\t\t\teeprom_phy_id |= (id2 & 0xfc00) << 16;\n\t\t\teeprom_phy_id |= (id2 & 0x03ff) <<  0;\n\t\t} else\n\t\t\teeprom_phy_id = 0;\n\n\t\ttp->phy_id = eeprom_phy_id;\n\t\tif (eeprom_phy_serdes) {\n\t\t\tif (!tg3_flag(tp, 5705_PLUS))\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\n\t\t\telse\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_MII_SERDES;\n\t\t}\n\n\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\tled_cfg = cfg2 & (NIC_SRAM_DATA_CFG_LED_MODE_MASK |\n\t\t\t\t    SHASTA_EXT_LED_MODE_MASK);\n\t\telse\n\t\t\tled_cfg = nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK;\n\n\t\tswitch (led_cfg) {\n\t\tdefault:\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_PHY_1:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\t\t\tbreak;\n\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_PHY_2:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_2;\n\t\t\tbreak;\n\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_MAC:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_MAC;\n\n\t\t\t/* Default to PHY_1_MODE if 0 (MAC_MODE) is\n\t\t\t * read on some older 5700/5701 bootcode.\n\t\t\t */\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5701)\n\t\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_SHARED:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_SHARED;\n\t\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0 &&\n\t\t\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A1)\n\t\t\t\ttp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\n\t\t\t\t\t\t LED_CTRL_MODE_PHY_2);\n\n\t\t\tif (tg3_flag(tp, 5717_PLUS) ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\t\ttp->led_ctrl |= LED_CTRL_BLINK_RATE_OVERRIDE |\n\t\t\t\t\t\tLED_CTRL_BLINK_RATE_MASK;\n\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_MAC:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_SHASTA_MAC;\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_COMBO:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_COMBO;\n\t\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0)\n\t\t\t\ttp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\n\t\t\t\t\t\t LED_CTRL_MODE_PHY_2);\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ((tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t     tg3_asic_rev(tp) == ASIC_REV_5701) &&\n\t\t    tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL)\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_2;\n\n\t\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX)\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t\tif (nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP) {\n\t\t\ttg3_flag_set(tp, EEPROM_WRITE_PROT);\n\t\t\tif ((tp->pdev->subsystem_vendor ==\n\t\t\t     PCI_VENDOR_ID_ARIMA) &&\n\t\t\t    (tp->pdev->subsystem_device == 0x205a ||\n\t\t\t     tp->pdev->subsystem_device == 0x2063))\n\t\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t} else {\n\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t\ttg3_flag_set(tp, IS_NIC);\n\t\t}\n\n\t\tif (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE) {\n\t\t\ttg3_flag_set(tp, ENABLE_ASF);\n\t\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\t\ttg3_flag_set(tp, ASF_NEW_HANDSHAKE);\n\t\t}\n\n\t\tif ((nic_cfg & NIC_SRAM_DATA_CFG_APE_ENABLE) &&\n\t\t    tg3_flag(tp, 5750_PLUS))\n\t\t\ttg3_flag_set(tp, ENABLE_APE);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES &&\n\t\t    !(nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL))\n\t\t\ttg3_flag_clear(tp, WOL_CAP);\n\n\t\tif (tg3_flag(tp, WOL_CAP) &&\n\t\t    (nic_cfg & NIC_SRAM_DATA_CFG_WOL_ENABLE)) {\n\t\t\ttg3_flag_set(tp, WOL_ENABLE);\n\t\t\tdevice_set_wakeup_enable(&tp->pdev->dev, true);\n\t\t}\n\n\t\tif (cfg2 & (1 << 17))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_CAPACITIVE_COUPLING;\n\n\t\t/* serdes signal pre-emphasis in register 0x590 set by */\n\t\t/* bootcode if bit 18 is set */\n\t\tif (cfg2 & (1 << 18))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_SERDES_PREEMPHASIS;\n\n\t\tif ((tg3_flag(tp, 57765_PLUS) ||\n\t\t     (tg3_asic_rev(tp) == ASIC_REV_5784 &&\n\t\t      tg3_chip_rev(tp) != CHIPREV_5784_AX)) &&\n\t\t    (cfg2 & NIC_SRAM_DATA_CFG_2_APD_EN))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_ENABLE_APD;\n\n\t\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\t\tu32 cfg3;\n\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_3, &cfg3);\n\t\t\tif (tg3_asic_rev(tp) != ASIC_REV_5785 &&\n\t\t\t    !tg3_flag(tp, 57765_PLUS) &&\n\t\t\t    (cfg3 & NIC_SRAM_ASPM_DEBOUNCE))\n	t
33685	1539	gss_marshal	net/sunrpc/auth_gss/auth_gss.c	mic.len	1	11	\N	\N	\tstruct rpc_rqst *req = task->tk_rqstp;\n\tstruct rpc_cred *cred = req->rq_cred;\n\tstruct gss_cred\t*gss_cred = container_of(cred, struct gss_cred,\n\t\t\t\t\t\t gc_base);\n\tstruct gss_cl_ctx\t*ctx = gss_cred_get_ctx(cred);\n\t__be32\t\t*cred_len;\n\tu32             maj_stat = 0;\n\tstruct xdr_netobj mic;\n\tstruct kvec\tiov;\n\tstruct xdr_buf\tverf_buf;\n\n\tdprintk("RPC: %5u %s\\n", task->tk_pid, __func__);\n\n\t*p++ = htonl(RPC_AUTH_GSS);\n\tcred_len = p++;\n\n\tspin_lock(&ctx->gc_seq_lock);\n\treq->rq_seqno = ctx->gc_seq++;\n\tspin_unlock(&ctx->gc_seq_lock);\n\n\t*p++ = htonl((u32) RPC_GSS_VERSION);\n\t*p++ = htonl((u32) ctx->gc_proc);\n\t*p++ = htonl((u32) req->rq_seqno);\n\t*p++ = htonl((u32) gss_cred->gc_service);\n\tp = xdr_encode_netobj(p, &ctx->gc_wire_ctx);\n\t*cred_len = htonl((p - (cred_len + 1)) << 2);\n\n\t/* We compute the checksum for the verifier over the xdr-encoded bytes\n\t * starting with the xid and ending at the end of the credential: */\n\tiov.iov_base = xprt_skip_transport_header(req->rq_xprt,\n\t\t\t\t\treq->rq_snd_buf.head[0].iov_base);\n\tiov.iov_len = (u8 *)p - (u8 *)iov.iov_base;\n\txdr_buf_from_iov(&iov, &verf_buf);\n\n\t/* set verifier flavor*/\n\t*p++ = htonl(RPC_AUTH_GSS);\n\n\tmic.data = (u8 *)(p + 1);\n\tmaj_stat = gss_get_mic(ctx->gc_gss_ctx, &verf_buf, &mic);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED) {\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\t} else if (maj_stat != 0) {\n\t\tprintk("gss_marshal: gss_get_mic FAILED (%d)\\n", maj_stat);\n\t\tgoto out_put_ctx;\n\t}\n\tp = xdr_encode_opaque(p, NULL, mic.len);\n	t
33700	262	minstrel_update_stats	net/mac80211/rc80211_minstrel.c	mi	1	11	\N	\N	\tu8 tmp_tp_rate[MAX_THR_RATES];\n\tu8 tmp_prob_rate = 0;\n\tint i, tmp_cur_tp, tmp_prob_tp;\n\n\tfor (i = 0; i < MAX_THR_RATES; i++)\n\t    tmp_tp_rate[i] = 0;\n\n\tfor (i = 0; i < mi->n_rates; i++) {\n\t\tstruct minstrel_rate *mr = &mi->r[i];\n\t\tstruct minstrel_rate_stats *mrs = &mi->r[i].stats;\n\t\tstruct minstrel_rate_stats *tmp_mrs = &mi->r[tmp_prob_rate].stats;\n\n\t\t/* Update statistics of success probability per rate */\n\t\tminstrel_calc_rate_stats(mrs);\n\n\t\t/* Sample less often below the 10% chance of success.\n\t\t * Sample less often above the 95% chance of success. */\n\t\tif (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||\n\t\t    mrs->prob_ewma < MINSTREL_FRAC(10, 100)) {\n\t\t\tmr->adjusted_retry_count = mrs->retry_count >> 1;\n\t\t\tif (mr->adjusted_retry_count > 2)\n\t\t\t\tmr->adjusted_retry_count = 2;\n\t\t\tmr->sample_limit = 4;\n\t\t} else {\n\t\t\tmr->sample_limit = -1;\n\t\t\tmr->adjusted_retry_count = mrs->retry_count;\n\t\t}\n\t\tif (!mr->adjusted_retry_count)\n\t\t\tmr->adjusted_retry_count = 2;\n\n\t\tminstrel_sort_best_tp_rates(mi, i, tmp_tp_rate);\n\n\t\t/* To determine the most robust rate (max_prob_rate) used at\n\t\t * 3rd mmr stage we distinct between two cases:\n\t\t * (1) if any success probabilitiy >= 95%, out of those rates\n\t\t * choose the maximum throughput rate as max_prob_rate\n\t\t * (2) if all success probabilities < 95%, the rate with\n\t\t * highest success probability is chosen as max_prob_rate */\n\t\tif (mrs->prob_ewma >= MINSTREL_FRAC(95, 100)) {\n\t\t\ttmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_ewma);\n\t\t\ttmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate],\n\t\t\t\t\t\t\t  tmp_mrs->prob_ewma);\n\t\t\tif (tmp_cur_tp >= tmp_prob_tp)\n\t\t\t\ttmp_prob_rate = i;\n\t\t} else {\n\t\t\tif (mrs->prob_ewma >= tmp_mrs->prob_ewma)\n\t\t\t\ttmp_prob_rate = i;\n\t\t}\n\t}\n\n\t/* Assign the new rate set */\n\tmemcpy(mi->max_tp_rate, tmp_tp_rate, sizeof(mi->max_tp_rate));\n\tmi->max_prob_rate = tmp_prob_rate;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t/* use fixed index if set */\n\tif (mp->fixed_rate_idx != -1) {\n\t\tmi->max_tp_rate[0] = mp->fixed_rate_idx;\n\t\tmi->max_tp_rate[1] = mp->fixed_rate_idx;\n\t\tmi->max_prob_rate = mp->fixed_rate_idx;\n\t}\n#endif\n\n\t/* Reset update timer */\n\tmi->last_stats_update = jiffies;\n\n\tminstrel_update_rates(mp, mi);\n	t
34174	384	bzImage64_load	arch/x86/kernel/kexec-bzimage64.c	ret	1	11	\N	\N	\n\tstruct setup_header *header;\n\tint setup_sects, kern16_size, ret = 0;\n\tunsigned long setup_header_size, params_cmdline_sz;\n\tstruct boot_params *params;\n\tunsigned long bootparam_load_addr, kernel_load_addr, initrd_load_addr;\n\tunsigned long purgatory_load_addr;\n\tstruct bzimage64_data *ldata;\n\tstruct kexec_entry64_regs regs64;\n\tvoid *stack;\n\tunsigned int setup_hdr_offset = offsetof(struct boot_params, hdr);\n\tunsigned int efi_map_offset, efi_map_sz, efi_setup_data_offset;\n\tstruct kexec_buf kbuf = { .image = image, .buf_max = ULONG_MAX,\n\t\t\t\t  .top_down = true };\n\n\theader = (struct setup_header *)(kernel + setup_hdr_offset);\n\tsetup_sects = header->setup_sects;\n\tif (setup_sects == 0)\n\t\tsetup_sects = 4;\n\n\tkern16_size = (setup_sects + 1) * 512;\n\tif (kernel_len < kern16_size) {\n\t\tpr_err("bzImage truncated\\n");\n\t\treturn ERR_PTR(-ENOEXEC);\n\t}\n\n\tif (cmdline_len > header->cmdline_size) {\n\t\tpr_err("Kernel command line too long\\n");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * In case of crash dump, we will append elfcorehdr=<addr> to\n\t * command line. Make sure it does not overflow\n\t */\n\tif (cmdline_len + MAX_ELFCOREHDR_STR_LEN > header->cmdline_size) {\n\t\tpr_debug("Appending elfcorehdr=<addr> to command line exceeds maximum allowed length\\n");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* Allocate and load backup region */\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tret = crash_load_segments(image);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Load purgatory. For 64bit entry point, purgatory  code can be\n\t * anywhere.\n\t */\n\tret = kexec_load_purgatory(image, MIN_PURGATORY_ADDR, ULONG_MAX, 1,\n\t\t\t\t   &purgatory_load_addr);\n\tif (ret) {\n	t
34483	4834	send_clone	fs/btrfs/send.c	p	1	11	\N	\N	\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tbtrfs_debug(sctx->send_root->fs_info,\n\t\t    "send_clone offset=%llu, len=%d, clone_root=%llu, clone_inode=%llu, clone_offset=%llu",\n\t\t    offset, len, clone_root->root->objectid, clone_root->ino,\n\t\t    clone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n	t
57563	220	test_abba	kernel/locking/test-ww_mutex.c	&abba.a_mutex	1	13	\N	\N	\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba.a_mutex, &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n	f
60325	417	fsl_pq_mdio_probe	drivers/net/ethernet/freescale/fsl_pq_mdio.c	res.start	1	13	\N	\N	\tconst struct of_device_id *id =\n\t\tof_match_device(fsl_pq_mdio_match, &pdev->dev);\n\tconst struct fsl_pq_mdio_data *data;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource res;\n\tstruct device_node *tbi;\n\tstruct fsl_pq_mdio_priv *priv;\n\tstruct mii_bus *new_bus;\n\tint err;\n\n\tif (!id) {\n\t\tdev_err(&pdev->dev, "Failed to match device\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = id->data;\n\n\tdev_dbg(&pdev->dev, "found %s compatible node\\n", id->compatible);\n\n\tnew_bus = mdiobus_alloc_size(sizeof(*priv));\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\tpriv = new_bus->priv;\n\tnew_bus->name = "Freescale PowerQUICC MII Bus",\n\tnew_bus->read = &fsl_pq_mdio_read;\n\tnew_bus->write = &fsl_pq_mdio_write;\n\tnew_bus->reset = &fsl_pq_mdio_reset;\n\n\terr = of_address_to_resource(np, 0, &res);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, "could not obtain address information\\n");\n\t\tgoto error;\n\t}\n\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%s@%llx", np->name,\n	f
34488	3543	btrfs_orphan_cleanup	fs/btrfs/inode.c	found_key.objectid	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = READA_BACK;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  "Error removing orphan entry, stopping orphan cleanup");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ENOENT)\n\t\t\tgoto out;\n\n\t\tif (ret == -ENOENT && root == fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n	t
34549	2405	btrfs_ioctl_snap_destroy	fs/btrfs/ioctl.c	dest	1	11	\N	\N	\tstruct dentry *parent = file->f_path.dentry;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(parent->d_sb);\n\tstruct dentry *dentry;\n\tstruct inode *dir = d_inode(parent);\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tu64 qgroup_reserved;\n\tint namelen;\n\tint ret;\n\tint err = 0;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn -ENOTDIR;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tnamelen = strlen(vol_args->name);\n\tif (strchr(vol_args->name, '/') ||\n\t    strncmp(vol_args->name, "..", namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\n\terr = down_write_killable_nested(&dir->i_rwsem, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto out_drop_write;\n\tdentry = lookup_one_len(vol_args->name, parent, namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (d_really_is_negative(dentry)) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = d_inode(dentry);\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * Regular user.  Only allow this with a special mount\n\t\t * option, when the user has write+exec access to the\n\t\t * subvol root, and when rmdir(2) would have been\n\t\t * allowed.\n\t\t *\n\t\t * Note that this is _not_ check that the subvol is\n\t\t * empty or doesn't contain data that we wouldn't\n\t\t * otherwise be able to delete.\n\t\t *\n\t\t * Users who want to delete empty subvols should try\n\t\t * rmdir(2).\n\t\t */\n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(fs_info, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t/*\n\t\t * Do not allow deletion if the parent dir is the same\n\t\t * as the dir to be deleted.  That means the ioctl\n\t\t * must be called on the dentry referencing the root\n\t\t * of the subvol, not a random directory contained\n\t\t * within it.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (root == dest)\n	t
34844	3908	btrfs_balance	fs/btrfs/volumes.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 meta_target, data_target;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  "with mixed groups data and metadata balance options must be the same");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace, 0);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace, 0);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE | BTRFS_BLOCK_GROUP_DUP;\n\tif (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif (validate_convert_profile(&bctl->data, allowed)) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  "unable to start balance with target data profile %llu",\n\t\t\t  bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (validate_convert_profile(&bctl->meta, allowed)) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  "unable to start balance with target metadata profile %llu",\n\t\t\t  bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (validate_convert_profile(&bctl->sys, allowed)) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  "unable to start balance with target system profile %llu",\n\t\t\t  bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info,\n\t\t\t\t\t   "force reducing metadata integrity");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t  "balance will reduce metadata integrity, use force if you want this");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\t/* if we're not converting, the target field is uninitialized */\n\tmeta_target = (bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) ?\n\t\tbctl->meta.target : fs_info->avail_metadata_alloc_bits;\n\tdata_target = (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) ?\n\t\tbctl->data.target : fs_info->avail_data_alloc_bits;\n\tif (btrfs_get_num_tolerated_disk_barrier_failures(meta_target) <\n\t\tbtrfs_get_num_tolerated_disk_barrier_failures(data_target)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   "metadata profile 0x%llx has lower redundancy than data profile 0x%llx",\n\t\t\t   meta_target, data_target);\n\t}\n\n\tret = insert_balance_item(fs_info, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n	t
34999	359	fm10k_fetch_rx_buffer	drivers/net/ethernet/intel/fm10k/fm10k_main.c	skb)	1	11	\N	\N	\tunsigned int size = le16_to_cpu(rx_desc->w.length);\n\tstruct fm10k_rx_buffer *rx_buffer;\n\tstruct page *page;\n\n\trx_buffer = &rx_ring->rx_buffer[rx_ring->next_to_clean];\n\tpage = rx_buffer->page;\n\tprefetchw(page);\n\n\tif (likely(!skb)) {\n\t\tvoid *page_addr = page_address(page) +\n\t\t\t\t  rx_buffer->page_offset;\n\n\t\t/* prefetch first cache line of first page */\n\t\tprefetch(page_addr);\n#if L1_CACHE_BYTES < 128\n\t\tprefetch(page_addr + L1_CACHE_BYTES);\n#endif\n\n\t\t/* allocate a skb to store the frags */\n\t\tskb = napi_alloc_skb(&rx_ring->q_vector->napi,\n\t\t\t\t     FM10K_RX_HDR_LEN);\n\t\tif (unlikely(!skb)) {\n\t\t\trx_ring->rx_stats.alloc_failed++;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* we will be copying header into skb->data in\n\t\t * pskb_may_pull so it is in our interest to prefetch\n\t\t * it now to avoid a possible cache miss\n\t\t */\n\t\tprefetchw(skb->data);\n\t}\n\n\t/* we are reusing so sync this buffer for CPU use */\n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      size,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\t/* pull page into skb */\n\tif (fm10k_add_rx_frag(rx_buffer, size, rx_desc, skb)) {\n	t
35146	2411	prism54_process_trap_helper	drivers/net/wireless/intersil/prism54/isl_ioctl.c	wpa_ie	1	11	\N	\N	\tstruct obj_mlme *mlme = (struct obj_mlme *) data;\n\tstruct obj_mlmeex *mlmeex = (struct obj_mlmeex *) data;\n\tstruct obj_mlmeex *confirm;\n\tu8 wpa_ie[MAX_WPA_IE_LEN];\n\tint wpa_ie_len;\n\tsize_t len = 0; /* u16, better? */\n\tu8 *payload = NULL, *pos = NULL;\n\tint ret;\n\n\t/* I think all trapable objects are listed here.\n\t * Some oids have a EX version. The difference is that they are emitted\n\t * in DOT11_MLME_EXTENDED mode (set with DOT11_OID_MLMEAUTOLEVEL)\n\t * with more info.\n\t * The few events already defined by the wireless tools are not really\n\t * suited. We use the more flexible custom event facility.\n\t */\n\n\tif (oid >= DOT11_OID_BEACON) {\n\t\tlen = mlmeex->size;\n\t\tpayload = pos = mlmeex->data;\n\t}\n\n\t/* I fear prism54_process_bss_data won't work with big endian data */\n\tif ((oid == DOT11_OID_BEACON) || (oid == DOT11_OID_PROBE))\n\t\tprism54_process_bss_data(priv, oid, mlmeex->address,\n\t\t\t\t\t payload, len);\n\n\tmgt_le_to_cpu(isl_oid[oid].flags & OID_FLAG_TYPE, (void *) mlme);\n\n\tswitch (oid) {\n\n\tcase GEN_OID_LINKSTATE:\n\t\tlink_changed(priv->ndev, (u32) *data);\n\t\tbreak;\n\n\tcase DOT11_OID_MICFAILURE:\n\t\tsend_simple_event(priv, "Mic failure");\n\t\tbreak;\n\n\tcase DOT11_OID_DEAUTHENTICATE:\n\t\tsend_formatted_event(priv, "DeAuthenticate request", mlme, 0);\n\t\tbreak;\n\n\tcase DOT11_OID_AUTHENTICATE:\n\t\thandle_request(priv, mlme, oid);\n\t\tsend_formatted_event(priv, "Authenticate request", mlme, 1);\n\t\tbreak;\n\n\tcase DOT11_OID_DISASSOCIATE:\n\t\tsend_formatted_event(priv, "Disassociate request", mlme, 0);\n\t\tbreak;\n\n\tcase DOT11_OID_ASSOCIATE:\n\t\thandle_request(priv, mlme, oid);\n\t\tsend_formatted_event(priv, "Associate request", mlme, 1);\n\t\tbreak;\n\n\tcase DOT11_OID_REASSOCIATE:\n\t\thandle_request(priv, mlme, oid);\n\t\tsend_formatted_event(priv, "ReAssociate request", mlme, 1);\n\t\tbreak;\n\n\tcase DOT11_OID_BEACON:\n\t\tsend_formatted_event(priv,\n\t\t\t\t     "Received a beacon from an unknown AP",\n\t\t\t\t     mlme, 0);\n\t\tbreak;\n\n\tcase DOT11_OID_PROBE:\n\t\t/* we received a probe from a client. */\n\t\tsend_formatted_event(priv, "Received a probe from client", mlme,\n\t\t\t\t     0);\n\t\tbreak;\n\n\t\t/* Note : "mlme" is actually a "struct obj_mlmeex *" here, but this\n\t\t * is backward compatible layout-wise with "struct obj_mlme".\n\t\t */\n\n\tcase DOT11_OID_DEAUTHENTICATEEX:\n\t\tsend_formatted_event(priv, "DeAuthenticate request", mlme, 0);\n\t\tbreak;\n\n\tcase DOT11_OID_AUTHENTICATEEX:\n\t\thandle_request(priv, mlme, oid);\n\t\tsend_formatted_event(priv, "Authenticate request (ex)", mlme, 1);\n\n\t\tif (priv->iw_mode != IW_MODE_MASTER\n\t\t\t\t&& mlmeex->state != DOT11_STATE_AUTHING)\n\t\t\tbreak;\n\n\t\tconfirm = kmalloc(sizeof(struct obj_mlmeex) + 6, GFP_ATOMIC);\n\n\t\tif (!confirm)\n\t\t\tbreak;\n\n\t\tmemcpy(&confirm->address, mlmeex->address, ETH_ALEN);\n\t\tprintk(KERN_DEBUG "Authenticate from: address:\\t%pM\\n",\n\t\t       mlmeex->address);\n\t\tconfirm->id = -1; /* or mlmeex->id ? */\n\t\tconfirm->state = 0; /* not used */\n\t\tconfirm->code = 0;\n\t\tconfirm->size = 6;\n\t\tconfirm->data[0] = 0x00;\n\t\tconfirm->data[1] = 0x00;\n\t\tconfirm->data[2] = 0x02;\n\t\tconfirm->data[3] = 0x00;\n\t\tconfirm->data[4] = 0x00;\n\t\tconfirm->data[5] = 0x00;\n\n\t\tret = mgt_set_varlen(priv, DOT11_OID_ASSOCIATEEX, confirm, 6);\n\n\t\tkfree(confirm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase DOT11_OID_DISASSOCIATEEX:\n\t\tsend_formatted_event(priv, "Disassociate request (ex)", mlme, 0);\n\t\tbreak;\n\n\tcase DOT11_OID_ASSOCIATEEX:\n\t\thandle_request(priv, mlme, oid);\n\t\tsend_formatted_event(priv, "Associate request (ex)", mlme, 1);\n\n\t\tif (priv->iw_mode != IW_MODE_MASTER\n\t\t\t\t&& mlmeex->state != DOT11_STATE_ASSOCING)\n\t\t\tbreak;\n\n\t\tconfirm = kmalloc(sizeof(struct obj_mlmeex), GFP_ATOMIC);\n\n\t\tif (!confirm)\n\t\t\tbreak;\n\n\t\tmemcpy(&confirm->address, mlmeex->address, ETH_ALEN);\n\n\t\tconfirm->id = ((struct obj_mlmeex *)mlme)->id;\n\t\tconfirm->state = 0; /* not used */\n\t\tconfirm->code = 0;\n\n\t\twpa_ie_len = prism54_wpa_bss_ie_get(priv, mlmeex->address, wpa_ie);\n\n\t\tif (!wpa_ie_len) {\n\t\t\tprintk(KERN_DEBUG "No WPA IE found from address:\\t%pM\\n",\n\t\t\t       mlmeex->address);\n\t\t\tkfree(confirm);\n\t\t\tbreak;\n\t\t}\n\n\t\tconfirm->size = wpa_ie_len;\n\t\tmemcpy(&confirm->data, wpa_ie, wpa_ie_len);\n	t
35468	1144	ath_rx_tasklet	drivers/net/wireless/ath/ath9k/recv.c	requeue_skb->data	1	11	\N	\N	\tstruct ath_rxbuf *bf;\n\tstruct sk_buff *skb = NULL, *requeue_skb, *hdr_skb;\n\tstruct ieee80211_rx_status *rxs;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_hw *hw = sc->hw;\n\tint retval;\n\tstruct ath_rx_status rs;\n\tenum ath9k_rx_qtype qtype;\n\tbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\n\tint dma_type;\n\tu64 tsf = 0;\n\tunsigned long flags;\n\tdma_addr_t new_buf_addr;\n\tunsigned int budget = 512;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (edma)\n\t\tdma_type = DMA_BIDIRECTIONAL;\n\telse\n\t\tdma_type = DMA_FROM_DEVICE;\n\n\tqtype = hp ? ATH9K_RX_QUEUE_HP : ATH9K_RX_QUEUE_LP;\n\n\ttsf = ath9k_hw_gettsf64(ah);\n\n\tdo {\n\t\tbool decrypt_error = false;\n\n\t\tmemset(&rs, 0, sizeof(rs));\n\t\tif (edma)\n\t\t\tbf = ath_edma_get_next_rx_buf(sc, &rs, qtype);\n\t\telse\n\t\t\tbf = ath_get_next_rx_buf(sc, &rs);\n\n\t\tif (!bf)\n\t\t\tbreak;\n\n\t\tskb = bf->bf_mpdu;\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Take frame header from the first fragment and RX status from\n\t\t * the last one.\n\t\t */\n\t\tif (sc->rx.frag)\n\t\t\thdr_skb = sc->rx.frag;\n\t\telse\n\t\t\thdr_skb = skb;\n\n\t\trxs = IEEE80211_SKB_RXCB(hdr_skb);\n\t\tmemset(rxs, 0, sizeof(struct ieee80211_rx_status));\n\n\t\tretval = ath9k_rx_skb_preprocess(sc, hdr_skb, &rs, rxs,\n\t\t\t\t\t\t &decrypt_error, tsf);\n\t\tif (retval)\n\t\t\tgoto requeue_drop_frag;\n\n\t\t/* Ensure we always have an skb to requeue once we are done\n\t\t * processing the current buffer's skb */\n\t\trequeue_skb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_ATOMIC);\n\n\t\t/* If there is no memory we ignore the current RX'd frame,\n\t\t * tell hardware it can give us a new frame using the old\n\t\t * skb and put it at the tail of the sc->rx.rxbuf list for\n\t\t * processing. */\n\t\tif (!requeue_skb) {\n\t\t\tRX_STAT_INC(rx_oom_err);\n\t\t\tgoto requeue_drop_frag;\n\t\t}\n\n\t\t/* We will now give hardware our shiny new allocated skb */\n\t\tnew_buf_addr = dma_map_single(sc->dev, requeue_skb->data,\n	t
35942	168	iwl_dbgfs_pm_params_write	drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c	val	1	11	\N	\N	\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tenum iwl_dbgfs_pm_mask param;\n\tint val, ret;\n\n\tif (!strncmp("keep_alive=", buf, 11)) {\n\t\tif (sscanf(buf + 11, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_KEEP_ALIVE;\n\t} else if (!strncmp("skip_over_dtim=", buf, 15)) {\n\t\tif (sscanf(buf + 15, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_SKIP_OVER_DTIM;\n\t} else if (!strncmp("skip_dtim_periods=", buf, 18)) {\n\t\tif (sscanf(buf + 18, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS;\n\t} else if (!strncmp("rx_data_timeout=", buf, 16)) {\n\t\tif (sscanf(buf + 16, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_RX_DATA_TIMEOUT;\n\t} else if (!strncmp("tx_data_timeout=", buf, 16)) {\n\t\tif (sscanf(buf + 16, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_TX_DATA_TIMEOUT;\n\t} else if (!strncmp("lprx=", buf, 5)) {\n\t\tif (sscanf(buf + 5, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_LPRX_ENA;\n\t} else if (!strncmp("lprx_rssi_threshold=", buf, 20)) {\n\t\tif (sscanf(buf + 20, "%d", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (val > POWER_LPRX_RSSI_THRESHOLD_MAX || val <\n	t
35967	3752	qib_do_7322_reset	drivers/infiniband/hw/qib/qib_iba7322.c	msix_vecsave	1	11	\N	\N	\tu64 val;\n\tu64 *msix_vecsave = NULL;\n\tint i, msix_entries, ret = 1;\n\tu16 cmdval;\n\tu8 int_line, clinesz;\n\tunsigned long flags;\n\n\t/* Use dev_err so it shows up in logs, etc. */\n\tqib_dev_err(dd, "Resetting InfiniPath unit %u\\n", dd->unit);\n\n\tqib_pcie_getcmd(dd, &cmdval, &int_line, &clinesz);\n\n\tmsix_entries = dd->cspec->num_msix_entries;\n\n\t/* no interrupts till re-initted */\n\tqib_7322_set_intr_state(dd, 0);\n\n\tif (msix_entries) {\n\t\tqib_7322_nomsix(dd);\n\t\t/* can be up to 512 bytes, too big for stack */\n\t\tmsix_vecsave = kmalloc(2 * dd->cspec->num_msix_entries *\n\t\t\tsizeof(u64), GFP_KERNEL);\n\t}\n\n\t/*\n\t * Core PCI (as of 2.6.18) doesn't save or rewrite the full vector\n\t * info that is set up by the BIOS, so we have to save and restore\n\t * it ourselves.   There is some risk something could change it,\n\t * after we save it, but since we have disabled the MSIx, it\n\t * shouldn't be touched...\n\t */\n\tfor (i = 0; i < msix_entries; i++) {\n\t\tu64 vecaddr, vecdata;\n\n\t\tvecaddr = qib_read_kreg64(dd, 2 * i +\n\t\t\t\t  (QIB_7322_MsixTable_OFFS / sizeof(u64)));\n\t\tvecdata = qib_read_kreg64(dd, 1 + 2 * i +\n\t\t\t\t  (QIB_7322_MsixTable_OFFS / sizeof(u64)));\n\t\tif (msix_vecsave) {\n\t\t\tmsix_vecsave[2 * i] = vecaddr;\n\t\t\t/* save it without the masked bit set */\n\t\t\tmsix_vecsave[1 + 2 * i] = vecdata & ~0x100000000ULL;\n\t\t}\n\t}\n\n\tdd->pport->cpspec->ibdeltainprog = 0;\n\tdd->pport->cpspec->ibsymdelta = 0;\n\tdd->pport->cpspec->iblnkerrdelta = 0;\n\tdd->pport->cpspec->ibmalfdelta = 0;\n\t/* so we check interrupts work again */\n\tdd->z_int_counter = qib_int_counter(dd);\n\n\t/*\n\t * Keep chip from being accessed until we are ready.  Use\n\t * writeq() directly, to allow the write even though QIB_PRESENT\n\t * isn't set.\n\t */\n\tdd->flags &= ~(QIB_INITTED | QIB_PRESENT | QIB_BADINTR);\n\tdd->flags |= QIB_DOING_RESET;\n\tval = dd->control | QLOGIC_IB_C_RESET;\n\twriteq(val, &dd->kregbase[kr_control]);\n\n\tfor (i = 1; i <= 5; i++) {\n\t\t/*\n\t\t * Allow MBIST, etc. to complete; longer on each retry.\n\t\t * We sometimes get machine checks from bus timeout if no\n\t\t * response, so for now, make it *really* long.\n\t\t */\n\t\tmsleep(1000 + (1 + i) * 3000);\n\n\t\tqib_pcie_reenable(dd, cmdval, int_line, clinesz);\n\n\t\t/*\n\t\t * Use readq directly, so we don't need to mark it as PRESENT\n\t\t * until we get a successful indication that all is well.\n\t\t */\n\t\tval = readq(&dd->kregbase[kr_revision]);\n\t\tif (val == dd->revision)\n\t\t\tbreak;\n\t\tif (i == 5) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t"Failed to initialize after reset, unusable\\n");\n\t\t\tret = 0;\n\t\t\tgoto  bail;\n\t\t}\n\t}\n\n\tdd->flags |= QIB_PRESENT; /* it's back */\n\n\tif (msix_entries) {\n\t\t/* restore the MSIx vector address and data if saved above */\n\t\tfor (i = 0; i < msix_entries; i++) {\n\t\t\tif (!msix_vecsave || !msix_vecsave[2 * i])\n	t
35703	1030	lpc_ich_init_wdt	drivers/mfd/lpc_ich.c	base_addr	1	11	\N	\N	\tstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\n\tu32 base_addr_cfg;\n\tu32 base_addr;\n\tint ret;\n\tstruct resource *res;\n\n\t/* If we have ACPI based watchdog use that instead */\n\tif (acpi_has_watchdog())\n\t\treturn -ENODEV;\n\n\t/* Setup power management base register */\n\tpci_read_config_dword(dev, priv->abase, &base_addr_cfg);\n\tbase_addr = base_addr_cfg & 0x0000ff80;\n\tif (!base_addr) {\n	t
36016	829	collect_rx_frame	drivers/isdn/hisax/hfc_usb.c	fifo->skbuff->len - 3	1	11	\N	\N	\thfcusb_data *hfc = fifo->hfc;\n\tint transp_mode, fifon;\n\n\tfifon = fifo->fifonum;\n\ttransp_mode = 0;\n\tif (fifon < 4 && hfc->b_mode[fifon / 2] == L1_MODE_TRANS)\n\t\ttransp_mode = 1;\n\n\tif (!fifo->skbuff) {\n\t\tfifo->skbuff = dev_alloc_skb(fifo->max_size + 3);\n\t\tif (!fifo->skbuff) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       "HFC-S USB: cannot allocate buffer for fifo(%d)\\n",\n\t\t\t       fifon);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (len) {\n\t\tif (fifo->skbuff->len + len < fifo->max_size) {\n\t\t\tskb_put_data(fifo->skbuff, data, len);\n\t\t} else {\n\t\t\tDBG(HFCUSB_DBG_FIFO_ERR,\n\t\t\t    "HCF-USB: got frame exceeded fifo->max_size(%d) fifo(%d)",\n\t\t\t    fifo->max_size, fifon);\n\t\t\tDBG_SKB(HFCUSB_DBG_VERBOSE_USB, fifo->skbuff);\n\t\t\tskb_trim(fifo->skbuff, 0);\n\t\t}\n\t}\n\tif (transp_mode && fifo->skbuff->len >= 128) {\n\t\tfifo->hif->l1l2(fifo->hif, PH_DATA | INDICATION,\n\t\t\t\tfifo->skbuff);\n\t\tfifo->skbuff = NULL;\n\t\treturn;\n\t}\n\t/* we have a complete hdlc packet */\n\tif (finish) {\n\t\tif (fifo->skbuff->len > 3 &&\n\t\t    !fifo->skbuff->data[fifo->skbuff->len - 1]) {\n\n\t\t\tif (fifon == HFCUSB_D_RX) {\n\t\t\t\tDBG(HFCUSB_DBG_DCHANNEL,\n\t\t\t\t    "HFC-S USB: D-RX len(%d)", fifo->skbuff->len);\n\t\t\t\tDBG_SKB(HFCUSB_DBG_DCHANNEL, fifo->skbuff);\n\t\t\t}\n\n\t\t\t/* remove CRC & status */\n\t\t\tskb_trim(fifo->skbuff, fifo->skbuff->len - 3);\n	t
21841	973	WMI_execute_u32	drivers/platform/x86/acer-wmi.c	status	1	13	\N	\N	\tstruct acpi_buffer input = { (acpi_size) sizeof(u32), (void *)(&in) };\n\tstruct acpi_buffer result = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tu32 tmp = 0;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(WMID_GUID1, 0, method_id, &input, &result);\n\n\tif (ACPI_FAILURE(status))\n	f
25725	1100	port100_in_set_rf	drivers/nfc/port100.c	resp->data	1	13	\N	\N	\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint rc;\n\n\tif (rf >= NFC_DIGITAL_RF_TECH_LAST)\n\t\treturn -EINVAL;\n\n\tskb = port100_alloc_skb(dev, sizeof(struct port100_in_rf_setting));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &in_rf_settings[rf],\n\t\t     sizeof(struct port100_in_rf_setting));\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_IN_SET_RF, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n	f
36027	1147	ath10k_core_fetch_board_data_api_n	drivers/net/wireless/ath/ath10k/core.c	hdr->id	1	11	\N	\N	\tsize_t len, magic_len, ie_len;\n\tstruct ath10k_fw_ie *hdr;\n\tconst u8 *data;\n\tint ret, ie_id;\n\n\tar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,\n\t\t\t\t\t\t\tar->hw_params.fw.dir,\n\t\t\t\t\t\t\tfilename);\n\tif (IS_ERR(ar->normal_mode_fw.board))\n\t\treturn PTR_ERR(ar->normal_mode_fw.board);\n\n\tdata = ar->normal_mode_fw.board->data;\n\tlen = ar->normal_mode_fw.board->size;\n\n\t/* magic has extra null byte padded */\n\tmagic_len = strlen(ATH10K_BOARD_MAGIC) + 1;\n\tif (len < magic_len) {\n\t\tath10k_err(ar, "failed to find magic value in %s/%s, file too short: %zu\\n",\n\t\t\t   ar->hw_params.fw.dir, filename, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(data, ATH10K_BOARD_MAGIC, magic_len)) {\n\t\tath10k_err(ar, "found invalid board magic\\n");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* magic is padded to 4 bytes */\n\tmagic_len = ALIGN(magic_len, 4);\n\tif (len < magic_len) {\n\t\tath10k_err(ar, "failed: %s/%s too small to contain board data, len: %zu\\n",\n\t\t\t   ar->hw_params.fw.dir, filename, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata += magic_len;\n\tlen -= magic_len;\n\n\twhile (len > sizeof(struct ath10k_fw_ie)) {\n\t\thdr = (struct ath10k_fw_ie *)data;\n\t\tie_id = le32_to_cpu(hdr->id);\n	t
31039	403	dm_btree_lookup	drivers/md/persistent-data/dm-btree.c	&spine	1	13	\N	\N	\tunsigned level, last_level = info->levels - 1;\n\tint r = -ENODATA;\n\tuint64_t rkey;\n\t__le64 internal_value_le;\n\tstruct ro_spine spine;\n\n\tinit_ro_spine(&spine, info);\n\tfor (level = 0; level < info->levels; level++) {\n\t\tsize_t size;\n\t\tvoid *value_p;\n\n\t\tif (level == last_level) {\n\t\t\tvalue_p = value_le;\n\t\t\tsize = info->value_type.size;\n\n\t\t} else {\n\t\t\tvalue_p = &internal_value_le;\n\t\t\tsize = sizeof(uint64_t);\n\t\t}\n\n\t\tr = btree_lookup_raw(&spine, root, keys[level],\n\t\t\t\t     lower_bound, &rkey,\n\t\t\t\t     value_p, size);\n\n\t\tif (!r) {\n\t\t\tif (rkey != keys[level]) {\n\t\t\t\texit_ro_spine(&spine);\n	f
49249	137	ceph_set_acl	fs/ceph/acl.c	&newattrs	1	13	\N	\N	\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tret = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_ctime = current_time(inode);\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n	f
21307	430	cafe_nand_read_page	drivers/mtd/nand/cafe_nand.c	p	9	12	\N	\N	\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tunsigned int max_bitflips = 0;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, "ECC result %08x SYN1,2 %08x\\n",\n\t\t     cafe_readl(cafe, NAND_ECC_RESULT),\n\t\t     cafe_readl(cafe, NAND_ECC_SYN01));\n\n\tchip->read_buf(mtd, buf, mtd->writesize);\n\tchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\n\n\tif (checkecc && cafe_readl(cafe, NAND_ECC_RESULT) & (1<<18)) {\n\t\tunsigned short syn[8], pat[4];\n\t\tint pos[4];\n\t\tu8 *oob = chip->oob_poi;\n\t\tint i, n;\n\n\t\tfor (i=0; i<8; i+=2) {\n\t\t\tuint32_t tmp = cafe_readl(cafe, NAND_ECC_SYN01 + (i*2));\n\t\t\tsyn[i] = cafe->rs->index_of[tmp & 0xfff];\n\t\t\tsyn[i+1] = cafe->rs->index_of[(tmp >> 16) & 0xfff];\n\t\t}\n\n\t\tn = decode_rs16(cafe->rs, NULL, NULL, 1367, syn, 0, pos, 0,\n\t\t                pat);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint p = pos[i];\n\n\t\t\t/* The 12-bit symbols are mapped to bytes here */\n\n\t\t\tif (p > 1374) {\n\t\t\t\t/* out of range */\n\t\t\t\tn = -1374;\n\t\t\t} else if (p == 0) {\n\t\t\t\t/* high four bits do not correspond to data */\n\t\t\t\tif (pat[i] > 0xff)\n\t\t\t\t\tn = -2048;\n\t\t\t\telse\n\t\t\t\t\tbuf[0] ^= pat[i];\n\t\t\t} else if (p == 1365) {\n\t\t\t\tbuf[2047] ^= pat[i] >> 4;\n\t\t\t\toob[0] ^= pat[i] << 4;\n\t\t\t} else if (p > 1365) {\n\t\t\t\tif ((p & 1) == 1) {\n	t
7778	393	rsi_prepare_beacon	drivers/net/wireless/rsi/rsi_91x_hal.c	mac_bcn->data	6	12	\N	heap variable, variable-length 	\tstruct rsi_hw *adapter = (struct rsi_hw *)common->priv;\n\tstruct rsi_data_desc *bcn_frm;\n\tstruct ieee80211_hw *hw = common->priv->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct sk_buff *mac_bcn;\n\tu8 vap_id = 0;\n\tu16 tim_offset;\n\n\tmac_bcn = ieee80211_beacon_get_tim(adapter->hw,\n\t\t\t\t\t   adapter->vifs[adapter->sc_nvifs - 1],\n\t\t\t\t\t   &tim_offset, NULL);\n\tif (!mac_bcn) {\n\t\trsi_dbg(ERR_ZONE, "Failed to get beacon from mac80211\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tcommon->beacon_cnt++;\n\tbcn_frm = (struct rsi_data_desc *)skb->data;\n\trsi_set_len_qno(&bcn_frm->len_qno, mac_bcn->len, RSI_WIFI_DATA_Q);\n\tbcn_frm->header_len = MIN_802_11_HDR_LEN;\n\tbcn_frm->frame_info = cpu_to_le16(RSI_DATA_DESC_MAC_BBP_INFO |\n\t\t\t\t\t  RSI_DATA_DESC_NO_ACK_IND |\n\t\t\t\t\t  RSI_DATA_DESC_BEACON_FRAME |\n\t\t\t\t\t  RSI_DATA_DESC_INSERT_TSF |\n\t\t\t\t\t  RSI_DATA_DESC_INSERT_SEQ_NO |\n\t\t\t\t\t  RATE_INFO_ENABLE);\n\tbcn_frm->rate_info = cpu_to_le16(vap_id << 14);\n\tbcn_frm->qid_tid = BEACON_HW_Q;\n\n\tif (conf_is_ht40_plus(conf)) {\n\t\tbcn_frm->bbp_info = cpu_to_le16(LOWER_20_ENABLE);\n\t\tbcn_frm->bbp_info |= cpu_to_le16(LOWER_20_ENABLE >> 12);\n\t} else if (conf_is_ht40_minus(conf)) {\n\t\tbcn_frm->bbp_info = cpu_to_le16(UPPER_20_ENABLE);\n\t\tbcn_frm->bbp_info |= cpu_to_le16(UPPER_20_ENABLE >> 12);\n\t}\n\n\tif (common->band == NL80211_BAND_2GHZ)\n\t\tbcn_frm->bbp_info |= cpu_to_le16(RSI_RATE_1);\n\telse\n\t\tbcn_frm->bbp_info |= cpu_to_le16(RSI_RATE_6);\n\n\tif (mac_bcn->data[tim_offset + 2] == 0)\n	t
36861	1448	intel_sdvo_get_config	drivers/gpu/drm/i915/intel_sdvo.c	dtd.part2.dtd_flags	1	11	\N	\N	\tstruct drm_device *dev = encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\n\tstruct intel_sdvo_dtd dtd;\n\tint encoder_pixel_multiplier = 0;\n\tint dotclock;\n\tu32 flags = 0, sdvox;\n\tu8 val;\n\tbool ret;\n\n\tsdvox = I915_READ(intel_sdvo->sdvo_reg);\n\n\tret = intel_sdvo_get_input_timing(intel_sdvo, &dtd);\n\tif (!ret) {\n\t\t/* Some sdvo encoders are not spec compliant and don't\n\t\t * implement the mandatory get_timings function. */\n\t\tDRM_DEBUG_DRIVER("failed to retrieve SDVO DTD\\n");\n\t\tpipe_config->quirks |= PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS;\n\t} else {\n\t\tif (dtd.part2.dtd_flags & DTD_FLAG_HSYNC_POSITIVE)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (dtd.part2.dtd_flags & DTD_FLAG_VSYNC_POSITIVE)\n	t
34281	1447	scan_async_group	drivers/media/platform/soc_camera/soc_camera.c	scan_async_group_$sasd$obj$0$1$0	0	13	\N	\N	\tstruct soc_camera_async_subdev *sasd;\n\tstruct soc_camera_async_client *sasc;\n\tstruct soc_camera_device *icd;\n\tstruct soc_camera_desc sdesc = {.host_desc.bus_id = ici->nr,};\n\tchar clk_name[V4L2_CLK_NAME_SIZE];\n\tunsigned int i;\n\tint ret;\n\n\t/* First look for a sensor */\n\tfor (i = 0; i < size; i++) {\n\t\tsasd = container_of(asd[i], struct soc_camera_async_subdev, asd);\n\t\tif (sasd->role == SOCAM_SUBDEV_DATA_SOURCE)\n\t\t\tbreak;\n\t}\n\n\tif (i >= size || asd[i]->match_type != V4L2_ASYNC_MATCH_I2C) {\n\t\t/* All useless */\n\t\tdev_err(ici->v4l2_dev.dev, "No I2C data source found!\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Or shall this be managed by the soc-camera device? */\n\tsasc = devm_kzalloc(ici->v4l2_dev.dev, sizeof(*sasc), GFP_KERNEL);\n\tif (!sasc)\n\t\treturn -ENOMEM;\n\n\t/* HACK: just need a != NULL */\n\tsdesc.host_desc.board_info = ERR_PTR(-ENODATA);\n\n\tret = soc_camera_dyn_pdev(&sdesc, sasc);\n\tif (ret < 0)\n\t\tgoto eallocpdev;\n\n\tsasc->sensor = &sasd->asd;\n\n\ticd = soc_camera_add_pdev(sasc);\n\tif (!icd) {\n\t\tret = -ENOMEM;\n\t\tgoto eaddpdev;\n\t}\n\n\tsasc->notifier.subdevs = asd;\n\tsasc->notifier.num_subdevs = size;\n\tsasc->notifier.bound = soc_camera_async_bound;\n\tsasc->notifier.unbind = soc_camera_async_unbind;\n\tsasc->notifier.complete = soc_camera_async_complete;\n\n\ticd->sasc = sasc;\n\ticd->parent = ici->v4l2_dev.dev;\n\n\tv4l2_clk_name_i2c(clk_name, sizeof(clk_name),\n	f
30568	3489	bttv_init_card2	drivers/media/pci/bt8xx/bttv-cards.c	btv->tuner_type	1	13	\N	\N	\tbtv->tuner_type = UNSET;\n\n\tif (BTTV_BOARD_UNKNOWN == btv->c.type) {\n\t\tbttv_readee(btv,eeprom_data,0xa0);\n\t\tidentify_by_eeprom(btv,eeprom_data);\n\t}\n\n\tswitch (btv->c.type) {\n\tcase BTTV_BOARD_MIRO:\n\tcase BTTV_BOARD_MIROPRO:\n\tcase BTTV_BOARD_PINNACLE:\n\tcase BTTV_BOARD_PINNACLEPRO:\n\t\t/* miro/pinnacle */\n\t\tmiro_pinnacle_gpio(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_FLYVIDEO_98:\n\tcase BTTV_BOARD_MAXI:\n\tcase BTTV_BOARD_LIFE_FLYKIT:\n\tcase BTTV_BOARD_FLYVIDEO:\n\tcase BTTV_BOARD_TYPHOON_TVIEW:\n\tcase BTTV_BOARD_CHRONOS_VS2:\n\tcase BTTV_BOARD_FLYVIDEO_98FM:\n\tcase BTTV_BOARD_FLYVIDEO2000:\n\tcase BTTV_BOARD_FLYVIDEO98EZ:\n\tcase BTTV_BOARD_CONFERENCETV:\n\tcase BTTV_BOARD_LIFETEC_9415:\n\t\tflyvideo_gpio(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_HAUPPAUGE:\n\tcase BTTV_BOARD_HAUPPAUGE878:\n\tcase BTTV_BOARD_HAUPPAUGEPVR:\n\t\t/* pick up some config infos from the eeprom */\n\t\tbttv_readee(btv,eeprom_data,0xa0);\n\t\thauppauge_eeprom(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_AVERMEDIA98:\n\tcase BTTV_BOARD_AVPHONE98:\n\t\tbttv_readee(btv,eeprom_data,0xa0);\n\t\tavermedia_eeprom(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_PXC200:\n\t\tinit_PXC200(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_PICOLO_TETRA_CHIP:\n\t\tpicolo_tetra_init(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_VHX:\n\t\tbtv->has_radio    = 1;\n\t\tbtv->has_tea575x  = 1;\n\t\tbtv->tea_gpio.wren = 5;\n\t\tbtv->tea_gpio.most = 6;\n\t\tbtv->tea_gpio.clk  = 3;\n\t\tbtv->tea_gpio.data = 4;\n\t\ttea575x_init(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_VOBIS_BOOSTAR:\n\tcase BTTV_BOARD_TERRATV:\n\t\tterratec_active_radio_upgrade(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_MAGICTVIEW061:\n\t\tif (btv->cardid == 0x3002144f) {\n\t\t\tbtv->has_radio=1;\n\t\t\tpr_info("%d: radio detected by subsystem id (CPH05x)\\n",\n\t\t\t\tbtv->c.nr);\n\t\t}\n\t\tbreak;\n\tcase BTTV_BOARD_STB2:\n\t\tif (btv->cardid == 0x3060121a) {\n\t\t\t/* Fix up entry for 3DFX VoodooTV 100,\n\t\t\t   which is an OEM STB card variant. */\n\t\t\tbtv->has_radio=0;\n\t\t\tbtv->tuner_type=TUNER_TEMIC_NTSC;\n\t\t}\n\t\tbreak;\n\tcase BTTV_BOARD_OSPREY1x0:\n\tcase BTTV_BOARD_OSPREY1x0_848:\n\tcase BTTV_BOARD_OSPREY101_848:\n\tcase BTTV_BOARD_OSPREY1x1:\n\tcase BTTV_BOARD_OSPREY1x1_SVID:\n\tcase BTTV_BOARD_OSPREY2xx:\n\tcase BTTV_BOARD_OSPREY2x0_SVID:\n\tcase BTTV_BOARD_OSPREY2x0:\n\tcase BTTV_BOARD_OSPREY440:\n\tcase BTTV_BOARD_OSPREY500:\n\tcase BTTV_BOARD_OSPREY540:\n\tcase BTTV_BOARD_OSPREY2000:\n\t\tbttv_readee(btv,eeprom_data,0xa0);\n\t\tosprey_eeprom(btv, eeprom_data);\n\t\tbreak;\n\tcase BTTV_BOARD_IDS_EAGLE:\n\t\tinit_ids_eagle(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_MODTEC_205:\n\t\tbttv_readee(btv,eeprom_data,0xa0);\n\t\tmodtec_eeprom(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_LMLBT4:\n\t\tinit_lmlbt4x(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_TIBET_CS16:\n\t\ttibetCS16_init(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_KODICOM_4400R:\n\t\tkodicom4400r_init(btv);\n\t\tbreak;\n\tcase BTTV_BOARD_GEOVISION_GV800S:\n\t\tgv800s_init(btv);\n\t\tbreak;\n\t}\n\n\t/* pll configuration */\n\tif (!(btv->id==848 && btv->revision==0x11)) {\n\t\t/* defaults from card list */\n\t\tif (PLL_28 == bttv_tvcards[btv->c.type].pll) {\n\t\t\tbtv->pll.pll_ifreq=28636363;\n\t\t\tbtv->pll.pll_crystal=BT848_IFORM_XT0;\n\t\t}\n\t\tif (PLL_35 == bttv_tvcards[btv->c.type].pll) {\n\t\t\tbtv->pll.pll_ifreq=35468950;\n\t\t\tbtv->pll.pll_crystal=BT848_IFORM_XT1;\n\t\t}\n\t\tif (PLL_14 == bttv_tvcards[btv->c.type].pll) {\n\t\t\tbtv->pll.pll_ifreq = 14318181;\n\t\t\tbtv->pll.pll_crystal = BT848_IFORM_XT0;\n\t\t}\n\t\t/* insmod options can override */\n\t\tswitch (pll[btv->c.nr]) {\n\t\tcase 0: /* none */\n\t\t\tbtv->pll.pll_crystal = 0;\n\t\t\tbtv->pll.pll_ifreq   = 0;\n\t\t\tbtv->pll.pll_ofreq   = 0;\n\t\t\tbreak;\n\t\tcase 1: /* 28 MHz */\n\t\tcase 28:\n\t\t\tbtv->pll.pll_ifreq   = 28636363;\n\t\t\tbtv->pll.pll_ofreq   = 0;\n\t\t\tbtv->pll.pll_crystal = BT848_IFORM_XT0;\n\t\t\tbreak;\n\t\tcase 2: /* 35 MHz */\n\t\tcase 35:\n\t\t\tbtv->pll.pll_ifreq   = 35468950;\n\t\t\tbtv->pll.pll_ofreq   = 0;\n\t\t\tbtv->pll.pll_crystal = BT848_IFORM_XT1;\n\t\t\tbreak;\n\t\tcase 3: /* 14 MHz */\n\t\tcase 14:\n\t\t\tbtv->pll.pll_ifreq   = 14318181;\n\t\t\tbtv->pll.pll_ofreq   = 0;\n\t\t\tbtv->pll.pll_crystal = BT848_IFORM_XT0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbtv->pll.pll_current = -1;\n\n\t/* tuner configuration (from card list / autodetect / insmod option) */\n\tif (UNSET != bttv_tvcards[btv->c.type].tuner_type)\n\t\tif (UNSET == btv->tuner_type)\n	f
31087	178	sm_disk_new_block	drivers/md/persistent-data/dm-space-map-disk.c	ev	1	13	\N	\N	\tint r;\n\tenum allocation_event ev;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\t/* FIXME: we should loop round a couple of times */\n\tr = sm_ll_find_free_block(&smd->old_ll, smd->begin, smd->old_ll.nr_blocks, b);\n\tif (r)\n\t\treturn r;\n\n\tsmd->begin = *b + 1;\n\tr = sm_ll_inc(&smd->ll, *b, &ev);\n\tif (!r) {\n\t\tBUG_ON(ev != SM_ALLOC);\n	f
37286	834	setup_sedlbauer	drivers/isdn/hisax/sedlbauer.c	ver	1	11	\N	\N	\tint bytecnt = 8, ver, val, rc;\n\tstruct IsdnCardState *cs = card->cs;\n\tchar tmp[64];\n\n\tstrcpy(tmp, Sedlbauer_revision);\n\tprintk(KERN_INFO "HiSax: Sedlbauer driver Rev. %s\\n", HiSax_getrev(tmp));\n\n\tif (cs->typ == ISDN_CTYPE_SEDLBAUER) {\n\t\tcs->subtyp = SEDL_SPEED_CARD_WIN;\n\t\tcs->hw.sedl.bus = SEDL_BUS_ISA;\n\t\tcs->hw.sedl.chip = SEDL_CHIP_TEST;\n\t} else if (cs->typ == ISDN_CTYPE_SEDLBAUER_PCMCIA) {\n\t\tcs->subtyp = SEDL_SPEED_STAR;\n\t\tcs->hw.sedl.bus = SEDL_BUS_PCMCIA;\n\t\tcs->hw.sedl.chip = SEDL_CHIP_TEST;\n\t} else if (cs->typ == ISDN_CTYPE_SEDLBAUER_FAX) {\n\t\tcs->subtyp = SEDL_SPEED_FAX;\n\t\tcs->hw.sedl.bus = SEDL_BUS_ISA;\n\t\tcs->hw.sedl.chip = SEDL_CHIP_ISAC_ISAR;\n\t} else\n\t\treturn (0);\n\n\tbytecnt = 8;\n\tif (card->para[1]) {\n\t\tcs->hw.sedl.cfg_reg = card->para[1];\n\t\tcs->irq = card->para[0];\n\t\tif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\n\t\t\tbytecnt = 16;\n\t\t}\n\t} else {\n\t\trc = setup_sedlbauer_isapnp(card, &bytecnt);\n\t\tif (!rc)\n\t\t\treturn (0);\n\t\tif (rc > 0)\n\t\t\tgoto ready;\n\n\t\t/* Probe for Sedlbauer speed pci */\n\t\trc = setup_sedlbauer_pci(card);\n\t\tif (!rc)\n\t\t\treturn (0);\n\n\t\tbytecnt = 256;\n\t}\n\nready:\n\n\t/* In case of the sedlbauer pcmcia card, this region is in use,\n\t * reserved for us by the card manager. So we do not check it\n\t * here, it would fail.\n\t */\n\tif (cs->hw.sedl.bus != SEDL_BUS_PCMCIA &&\n\t    !request_region(cs->hw.sedl.cfg_reg, bytecnt, "sedlbauer isdn")) {\n\t\tprintk(KERN_WARNING\n\t\t       "HiSax: %s config port %x-%x already in use\\n",\n\t\t       CardType[card->typ],\n\t\t       cs->hw.sedl.cfg_reg,\n\t\t       cs->hw.sedl.cfg_reg + bytecnt);\n\t\treturn (0);\n\t}\n\n\tprintk(KERN_INFO\n\t       "Sedlbauer: defined at 0x%x-0x%x IRQ %d\\n",\n\t       cs->hw.sedl.cfg_reg,\n\t       cs->hw.sedl.cfg_reg + bytecnt,\n\t       cs->irq);\n\n\tcs->BC_Read_Reg = &ReadHSCX;\n\tcs->BC_Write_Reg = &WriteHSCX;\n\tcs->BC_Send_Data = &hscx_fill_fifo;\n\tcs->cardmsg = &Sedl_card_msg;\n\n/*\n * testing ISA and PCMCIA Cards for IPAC, default is ISAC\n * do not test for PCI card, because ports are different\n * and PCI card uses only IPAC (for the moment)\n */\n\tif (cs->hw.sedl.bus != SEDL_BUS_PCI) {\n\t\tval = readreg(cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_ADR,\n\t\t\t      cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC, IPAC_ID);\n\t\tprintk(KERN_DEBUG "Sedlbauer: testing IPAC version %x\\n", val);\n\t\tif ((val == 1) || (val == 2)) {\n\t\t\t/* IPAC */\n\t\t\tcs->subtyp = SEDL_SPEED_WIN2_PC104;\n\t\t\tif (cs->hw.sedl.bus == SEDL_BUS_PCMCIA) {\n\t\t\t\tcs->subtyp = SEDL_SPEED_STAR2;\n\t\t\t}\n\t\t\tcs->hw.sedl.chip = SEDL_CHIP_IPAC;\n\t\t} else {\n\t\t\t/* ISAC_HSCX oder ISAC_ISAR */\n\t\t\tif (cs->hw.sedl.chip == SEDL_CHIP_TEST) {\n\t\t\t\tcs->hw.sedl.chip = SEDL_CHIP_ISAC_HSCX;\n\t\t\t}\n\t\t}\n\t}\n\n/*\n * hw.sedl.chip is now properly set\n */\n\tprintk(KERN_INFO "Sedlbauer: %s detected\\n",\n\t       Sedlbauer_Types[cs->subtyp]);\n\n\tsetup_isac(cs);\n\tif (cs->hw.sedl.chip == SEDL_CHIP_IPAC) {\n\t\tif (cs->hw.sedl.bus == SEDL_BUS_PCI) {\n\t\t\tcs->hw.sedl.adr  = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_ADR;\n\t\t\tcs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_IPAC;\n\t\t\tcs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_IPAC;\n\t\t} else {\n\t\t\tcs->hw.sedl.adr  = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_ADR;\n\t\t\tcs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC;\n\t\t\tcs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC;\n\t\t}\n\t\ttest_and_set_bit(HW_IPAC, &cs->HW_Flags);\n\t\tcs->readisac = &ReadISAC_IPAC;\n\t\tcs->writeisac = &WriteISAC_IPAC;\n\t\tcs->readisacfifo = &ReadISACfifo_IPAC;\n\t\tcs->writeisacfifo = &WriteISACfifo_IPAC;\n\t\tcs->irq_func = &sedlbauer_interrupt_ipac;\n\t\tval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_ID);\n\t\tprintk(KERN_INFO "Sedlbauer: IPAC version %x\\n", val);\n\t} else {\n\t\t/* ISAC_HSCX oder ISAC_ISAR */\n\t\tcs->readisac = &ReadISAC;\n\t\tcs->writeisac = &WriteISAC;\n\t\tcs->readisacfifo = &ReadISACfifo;\n\t\tcs->writeisacfifo = &WriteISACfifo;\n\t\tif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\n\t\t\tif (cs->hw.sedl.bus == SEDL_BUS_PCI) {\n\t\t\t\tcs->hw.sedl.adr = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_PCI_ADR;\n\t\t\t\tcs->hw.sedl.isac = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_PCI_ISAC;\n\t\t\t\tcs->hw.sedl.hscx = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_PCI_ISAR;\n\t\t\t} else {\n\t\t\t\tcs->hw.sedl.adr = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_ISA_ADR;\n\t\t\t\tcs->hw.sedl.isac = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_ISA_ISAC;\n\t\t\t\tcs->hw.sedl.hscx = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_ISA_ISAR;\n\t\t\t\tcs->hw.sedl.reset_on = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_ISA_ISAR_RESET_ON;\n\t\t\t\tcs->hw.sedl.reset_off = cs->hw.sedl.cfg_reg +\n\t\t\t\t\tSEDL_ISAR_ISA_ISAR_RESET_OFF;\n\t\t\t}\n\t\t\tcs->bcs[0].hw.isar.reg = &cs->hw.sedl.isar;\n\t\t\tcs->bcs[1].hw.isar.reg = &cs->hw.sedl.isar;\n\t\t\ttest_and_set_bit(HW_ISAR, &cs->HW_Flags);\n\t\t\tcs->irq_func = &sedlbauer_interrupt_isar;\n\t\t\tcs->auxcmd = &isar_auxcmd;\n\t\t\tISACVersion(cs, "Sedlbauer:");\n\t\t\tcs->BC_Read_Reg = &ReadISAR;\n\t\t\tcs->BC_Write_Reg = &WriteISAR;\n\t\t\tcs->BC_Send_Data = &isar_fill_fifo;\n\t\t\tbytecnt = 3;\n\t\t\twhile (bytecnt) {\n\t\t\t\tver = ISARVersion(cs, "Sedlbauer:");\n\t\t\t\tif (ver < 0)\n	t
37293	1197	gtp_genl_get_pdp	drivers/net/gtp.c	skb2	1	11	\N	\N	\tstruct pdp_ctx *pctx = NULL;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (!info->attrs[GTPA_VERSION])\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\n\tpctx = gtp_find_pdp(sock_net(skb->sk), info->attrs);\n\tif (IS_ERR(pctx)) {\n\t\terr = PTR_ERR(pctx);\n\t\tgoto err_unlock;\n\t}\n\n\tskb2 = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\terr = gtp_genl_fill_info(skb2, NETLINK_CB(skb).portid,\n	t
37114	660	av7110_firmversion	drivers/media/pci/ttpci/av7110_hw.c	av7110->arm_app	1	11	\N	\N	\tu16 buf[20];\n\tu16 tag = ((COMTYPE_REQUEST << 8) + ReqVersion);\n\n\tdprintk(4, "%p\\n", av7110);\n\n\tif (av7110_fw_query(av7110, tag, buf, 16)) {\n\t\tprintk("dvb-ttpci: failed to boot firmware @ card %d\\n",\n\t\t       av7110->dvb_adapter.num);\n\t\treturn -EIO;\n\t}\n\n\tav7110->arm_fw = (buf[0] << 16) + buf[1];\n\tav7110->arm_rtsl = (buf[2] << 16) + buf[3];\n\tav7110->arm_vid = (buf[4] << 16) + buf[5];\n\tav7110->arm_app = (buf[6] << 16) + buf[7];\n\tav7110->avtype = (buf[8] << 16) + buf[9];\n\n\tprintk("dvb-ttpci: info @ card %d: firm %08x, rtsl %08x, vid %08x, app %08x\\n",\n\t       av7110->dvb_adapter.num, av7110->arm_fw,\n\t       av7110->arm_rtsl, av7110->arm_vid, av7110->arm_app);\n\n\t/* print firmware capabilities */\n\tif (FW_CI_LL_SUPPORT(av7110->arm_app))\n	t
37558	5515	ocfs2_rm_xattr_cluster	fs/ocfs2/xattr.c	&dealloc	1	11	\N	\N	\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tret = ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t  ocfs2_delete_xattr_in_bucket, para);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_rm_xattr_cluster(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)blkno, cpos, len);\n\n\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       len);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, 1, NULL, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_remove_extent_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, meta_ac,\n\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, -len);\n\tocfs2_journal_dirty(handle, root_bh);\n\n\tret = ocfs2_truncate_log_append(osb, handle, blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tinode_unlock(tl_inode);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n	t
38364	1394	ef4_probe_interrupts	drivers/net/ethernet/sfc/falcon/efx.c	rc	1	11	\N	\N	\tunsigned int extra_channels = 0;\n\tunsigned int i, j;\n\tint rc;\n\n\tfor (i = 0; i < EF4_MAX_EXTRA_CHANNELS; i++)\n\t\tif (efx->extra_channel_type[i])\n\t\t\t++extra_channels;\n\n\tif (efx->interrupt_mode == EF4_INT_MODE_MSIX) {\n\t\tstruct msix_entry xentries[EF4_MAX_CHANNELS];\n\t\tunsigned int n_channels;\n\n\t\tn_channels = ef4_wanted_parallelism(efx);\n\t\tif (ef4_separate_tx_channels)\n\t\t\tn_channels *= 2;\n\t\tn_channels += extra_channels;\n\t\tn_channels = min(n_channels, efx->max_channels);\n\n\t\tfor (i = 0; i < n_channels; i++)\n\t\t\txentries[i].entry = i;\n\t\trc = pci_enable_msix_range(efx->pci_dev,\n\t\t\t\t\t   xentries, 1, n_channels);\n\t\tif (rc < 0) {\n	t
40033	1478	mip4_probe	drivers/input/touchscreen/melfas_mip4.c	ts	1	11	\N	\N	\tstruct mip4_ts *ts;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, "Not supported I2C adapter\\n");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\tts->input = input;\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t "%s/input0", dev_name(&client->dev));\n\n\tts->gpio_ce = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t      "ce", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->gpio_ce)) {\n\t\terror = PTR_ERR(ts->gpio_ce);\n\t\tif (error != EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t"Failed to get gpio: %d\\n", error);\n\t\treturn error;\n\t}\n\n\terror = mip4_power_on(ts);\n	t
53347	251	cyapa_gen6_read_sys_info	drivers/input/mouse/cyapa_gen6.c	cyapa_gen6_read_sys_info_$cyapa.addr$obj$27$obj	0	13	\N	\N	\tu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\n\tint resp_len;\n\tu16 product_family;\n\tu8 rotat_align;\n\tint error;\n\n\t/* Get App System Information to determine Gen5 or Gen6. */\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t2000, cyapa_pip_sort_system_info_data, false);\n\tif (error || resp_len < sizeof(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tproduct_family = get_unaligned_le16(&resp_data[7]);\n\tif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\n\t\tPIP_PRODUCT_FAMILY_TRACKPAD)\n\t\treturn -EINVAL;\n\n\tcyapa->platform_ver = (resp_data[67] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\tcyapa->fw_maj_ver = resp_data[9];\n\tcyapa->fw_min_ver = resp_data[10];\n\n\tcyapa->electrodes_x = resp_data[33];\n\tcyapa->electrodes_y = resp_data[34];\n\n\tcyapa->physical_size_x =  get_unaligned_le16(&resp_data[35]) / 100;\n\tcyapa->physical_size_y = get_unaligned_le16(&resp_data[37]) / 100;\n\n\tcyapa->max_abs_x = get_unaligned_le16(&resp_data[39]);\n\tcyapa->max_abs_y = get_unaligned_le16(&resp_data[41]);\n\n\tcyapa->max_z = get_unaligned_le16(&resp_data[43]);\n\n\tcyapa->x_origin = resp_data[45] & 0x01;\n\tcyapa->y_origin = resp_data[46] & 0x01;\n\n\tcyapa->btn_capability = (resp_data[70] << 3) & CAPABILITY_BTN_MASK;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[51], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[56], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[62], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\t/* Get the number of Rx electrodes. */\n\trotat_align = resp_data[68];\n\tcyapa->electrodes_rx =\n\t\trotat_align ? cyapa->electrodes_y : cyapa->electrodes_x;\n\tcyapa->aligned_electrodes_rx = (cyapa->electrodes_rx + 3) & ~3u;\n\n\tif (!cyapa->electrodes_x || !cyapa->electrodes_y ||\n\t\t!cyapa->physical_size_x || !cyapa->physical_size_y ||\n	f
38575	1522	fc_lport_enter_ms	drivers/scsi/libfc/fc_lport.c	fp	1	11	\N	\N	\tstruct fc_frame *fp;\n\tenum fc_fdmi_req cmd;\n\tint size = sizeof(struct fc_ct_hdr);\n\tsize_t len;\n\tint numattrs;\n\n\tFC_LPORT_DBG(lport, "Entered %s state from %s state\\n",\n\t\t     fc_lport_state_names[state],\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, state);\n\n\tswitch (state) {\n\tcase LPORT_ST_RHBA:\n\t\tcmd = FC_FDMI_RHBA;\n\t\t/* Number of HBA Attributes */\n\t\tnumattrs = 10;\n\t\tlen = sizeof(struct fc_fdmi_rhba);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\t\tlen += FC_FDMI_HBA_ATTR_NODENAME_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MANUFACTURER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_SERIALNUMBER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODEL_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODELDESCR_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_DRIVERVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN;\n\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_RPA:\n\t\tcmd = FC_FDMI_RPA;\n\t\t/* Number of Port Attributes */\n\t\tnumattrs = 6;\n\t\tlen = sizeof(struct fc_fdmi_rpa);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\t\tlen += FC_FDMI_PORT_ATTR_FC4TYPES_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_OSDEVICENAME_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_HOSTNAME_LEN;\n\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_DPRT:\n\t\tcmd = FC_FDMI_DPRT;\n\t\tlen = sizeof(struct fc_fdmi_dprt);\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_DHBA:\n\t\tcmd = FC_FDMI_DHBA;\n\t\tlen = sizeof(struct fc_fdmi_dhba);\n\t\tsize += len;\n\t\tbreak;\n\tdefault:\n\t\tfc_lport_error(lport, NULL);\n\t\treturn;\n\t}\n\n\tFC_LPORT_DBG(lport, "Cmd=0x%x Len %d size %d\\n",\n\t\t\t     cmd, (int)len, size);\n\tfp = fc_frame_alloc(lport, size);\n\tif (!fp) {\n\t\tfc_lport_error(lport, fp);\n	t
38750	313	xfs_dir_createname	fs/xfs/libxfs/xfs_dir2.c	v	1	11	\N	\N	\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(dp->i_mount, xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->dfops = dfops;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n	t
39461	103	ifb_ri_tasklet	drivers/net/ifb.c	skb	1	11	\N	\N	\tstruct ifb_q_private *txp = (struct ifb_q_private *)_txp;\n\tstruct netdev_queue *txq;\n\tstruct sk_buff *skb;\n\n\ttxq = netdev_get_tx_queue(txp->dev, txp->txqnum);\n\tskb = skb_peek(&txp->tq);\n\tif (!skb) {\n\t\tif (!__netif_tx_trylock(txq))\n\t\t\tgoto resched;\n\t\tskb_queue_splice_tail_init(&txp->rq, &txp->tq);\n\t\t__netif_tx_unlock(txq);\n\t}\n\n\twhile ((skb = __skb_dequeue(&txp->tq)) != NULL) {\n\t\tskb->tc_redirected = 0;\n\t\tskb->tc_skip_classify = 1;\n\n\t\tu64_stats_update_begin(&txp->tsync);\n\t\ttxp->tx_packets++;\n\t\ttxp->tx_bytes += skb->len;\n\t\tu64_stats_update_end(&txp->tsync);\n\n\t\trcu_read_lock();\n\t\tskb->dev = dev_get_by_index_rcu(dev_net(txp->dev), skb->skb_iif);\n\t\tif (!skb->dev) {\n\t\t\trcu_read_unlock();\n\t\t\tdev_kfree_skb(skb);\n\t\t\ttxp->dev->stats.tx_dropped++;\n\t\t\tif (skb_queue_len(&txp->tq) != 0)\n\t\t\t\tgoto resched;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tskb->skb_iif = txp->dev->ifindex;\n\n\t\tif (!skb->tc_from_ingress) {\n\t\t\tdev_queue_xmit(skb);\n	t
39021	679	cyttsp_probe	drivers/input/touchscreen/cyttsp_core.c	ts	2	-11	\N	\N	\tstruct cyttsp *ts;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tts = devm_kzalloc(dev, sizeof(*ts) + xfer_buf_size, GFP_KERNEL);\n\tif (!ts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tts->dev = dev;\n\tts->input = input_dev;\n\tts->bus_ops = bus_ops;\n\tts->irq = irq;\n\n\tts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(dev, "Failed to request reset gpio, error %d\\n", error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = cyttsp_parse_properties(ts);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinit_completion(&ts->bl_ready);\n\tsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));\n\n\tinput_dev->name = "Cypress TTSP TouchScreen";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id.bustype = bus_ops->bustype;\n\tinput_dev->dev.parent = ts->dev;\n\n\tinput_dev->open = cyttsp_open;\n\tinput_dev->close = cyttsp_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\ttouchscreen_parse_properties(input_dev, true, NULL);\n\n\terror = input_mt_init_slots(input_dev, CY_MAX_ID, 0);\n\tif (error) {\n\t\tdev_err(dev, "Unable to init MT slots.\\n");\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = devm_request_threaded_irq(dev, ts->irq, NULL, cyttsp_irq,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  "cyttsp", ts);\n\tif (error) {\n\t\tdev_err(ts->dev, "failed to request IRQ %d, err: %d\\n",\n\t\t\tts->irq, error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tdisable_irq(ts->irq);\n\n\tcyttsp_hard_reset(ts);\n	t
30613	455	of_phy_register_fixed_link	drivers/of/of_mdio.c	of_phy_register_fixed_link_	1	13	\N	\N	\tstruct fixed_phy_status status = {};\n\tstruct device_node *fixed_link_node;\n\tu32 fixed_link_prop[5];\n\tconst char *managed;\n\tint link_gpio = -1;\n\n\tif (of_property_read_string(np, "managed", &managed) == 0 &&\n\t    strcmp(managed, "in-band-status") == 0) {\n\t\t/* status is zeroed, namely its .link member */\n\t\tgoto register_phy;\n\t}\n\n\t/* New binding */\n\tfixed_link_node = of_get_child_by_name(np, "fixed-link");\n\tif (fixed_link_node) {\n\t\tstatus.link = 1;\n\t\tstatus.duplex = of_property_read_bool(fixed_link_node,\n\t\t\t\t\t\t      "full-duplex");\n\t\tif (of_property_read_u32(fixed_link_node, "speed",\n	f
40056	1007	fjn_rx	drivers/net/ethernet/fujitsu/fmvj18x_cs.c	skb->data	1	11	\N	\N	    unsigned int ioaddr = dev->base_addr;\n    int boguscount = 10;\t/* 5 -> 10: by agy 19940922 */\n\n    pr_debug("%s: in rx_packet(), rx_status %02x.\\n",\n\t  dev->name, inb(ioaddr + RX_STATUS));\n\n    while ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {\n\tu_short status = inw(ioaddr + DATAPORT);\n\n\tnetdev_dbg(dev, "Rxing packet mode %02x status %04x.\\n",\n\t\t   inb(ioaddr + RX_MODE), status);\n#ifndef final_version\n\tif (status == 0) {\n\t    outb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t    break;\n\t}\n#endif\n\tif ((status & 0xF0) != 0x20) {\t/* There was an error. */\n\t    dev->stats.rx_errors++;\n\t    if (status & F_LEN_ERR) dev->stats.rx_length_errors++;\n\t    if (status & F_ALG_ERR) dev->stats.rx_frame_errors++;\n\t    if (status & F_CRC_ERR) dev->stats.rx_crc_errors++;\n\t    if (status & F_OVR_FLO) dev->stats.rx_over_errors++;\n\t} else {\n\t    u_short pkt_len = inw(ioaddr + DATAPORT);\n\t    /* Malloc up new buffer. */\n\t    struct sk_buff *skb;\n\n\t    if (pkt_len > 1550) {\n\t\tnetdev_notice(dev, "The FMV-18x claimed a very large packet, size %d\\n",\n\t\t\t      pkt_len);\n\t\toutb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t\tdev->stats.rx_errors++;\n\t\tbreak;\n\t    }\n\t    skb = netdev_alloc_skb(dev, pkt_len + 2);\n\t    if (skb == NULL) {\n\t\toutb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t\tdev->stats.rx_dropped++;\n\t\tbreak;\n\t    }\n\n\t    skb_reserve(skb, 2);\n\t    insw(ioaddr + DATAPORT, skb_put(skb, pkt_len),\n\t\t (pkt_len + 1) >> 1);\n\t    skb->protocol = eth_type_trans(skb, dev);\n\n\t    {\n\t\tint i;\n\t\tpr_debug("%s: Rxed packet of length %d: ",\n\t\t\tdev->name, pkt_len);\n\t\tfor (i = 0; i < 14; i++)\n\t\t\tpr_debug(" %02x", skb->data[i]);\n	t
40202	1094	si2165_probe	drivers/media/dvb-frontends/si2165.c	state->chip_revcode	1	11	\N	\N	\tstruct si2165_state *state = NULL;\n\tstruct si2165_platform_data *pdata = client->dev.platform_data;\n\tint n;\n\tint ret = 0;\n\tu8 val;\n\tchar rev_char;\n\tconst char *chip_name;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 16,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x08ff,\n\t};\n\n\t/* allocate memory for the internal state */\n\tstate = kzalloc(sizeof(struct si2165_state), GFP_KERNEL);\n\tif (state == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* create regmap */\n\tstate->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(state->regmap)) {\n\t\tret = PTR_ERR(state->regmap);\n\t\tgoto error;\n\t}\n\n\t/* setup the state */\n\tstate->client = client;\n\tstate->config.i2c_addr = client->addr;\n\tstate->config.chip_mode = pdata->chip_mode;\n\tstate->config.ref_freq_Hz = pdata->ref_freq_Hz;\n\tstate->config.inversion = pdata->inversion;\n\n\tif (state->config.ref_freq_Hz < 4000000\n\t    || state->config.ref_freq_Hz > 27000000) {\n\t\tdev_err(&state->client->dev, "%s: ref_freq of %d Hz not supported by this driver\\n",\n\t\t\t KBUILD_MODNAME, state->config.ref_freq_Hz);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t/* create dvb_frontend */\n\tmemcpy(&state->fe.ops, &si2165_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->fe.ops.release = NULL;\n\tstate->fe.demodulator_priv = state;\n\ti2c_set_clientdata(client, state);\n\n\t/* powerup */\n\tret = si2165_writereg8(state, 0x0000, state->config.chip_mode);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, 0x0000, &val);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\tif (val != state->config.chip_mode)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, 0x0023, &state->chip_revcode);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, 0x0118, &state->chip_type);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\t/* powerdown */\n\tret = si2165_writereg8(state, 0x0000, SI2165_MODE_OFF);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tif (state->chip_revcode < 26)\n	t
40254	856	af9005_fe_init	drivers/media/usb/dvb-usb/af9005-fe.c	ret	1	11	\N	\N	\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tint ret, i, scriptlen;\n\tu8 temp, temp0 = 0, temp1 = 0, temp2 = 0;\n\tu8 buf[2];\n\tu16 if1;\n\n\tdeb_info("in af9005_fe_init\\n");\n\n\t/* reset */\n\tdeb_info("reset\\n");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst_en,\n\t\t\t\t\t4, 1, 0x01)))\n\t\treturn ret;\n\tif ((ret = af9005_write_ofdm_register(state->d, APO_REG_RESET, 0)))\n\t\treturn ret;\n\t/* clear ofdm reset */\n\tdeb_info("clear ofdm reset\\n");\n\tfor (i = 0; i < 150; i++) {\n\t\tif ((ret =\n\t\t     af9005_read_ofdm_register(state->d,\n\t\t\t\t\t       xd_I2C_reg_ofdm_rst, &temp)))\n\t\t\treturn ret;\n\t\tif (temp & (regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (i == 150)\n\t\treturn -ETIMEDOUT;\n\n\t/*FIXME in the dump\n\t   write B200 A9\n\t   write xd_g_reg_ofsm_clk 7\n\t   read eepr c6 (2)\n\t   read eepr c7 (2)\n\t   misc ctrl 3 -> 1\n\t   read eepr ca (6)\n\t   write xd_g_reg_ofsm_clk 0\n\t   write B200 a1\n\t */\n\tret = af9005_write_ofdm_register(state->d, 0xb200, 0xa9);\n\tif (ret)\n	t
40596	610	nouveau_connector_detect	drivers/gpu/drm/nouveau/nouveau_connector.c	nv_connector->edid->input	1	11	\N	\N	\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct nouveau_encoder *nv_partner;\n\tstruct i2c_adapter *i2c;\n\tint type;\n\tint ret;\n\tenum drm_connector_status conn_status = connector_status_disconnected;\n\n\t/* Cleanup the previous EDID block. */\n\tif (nv_connector->edid) {\n\t\tdrm_mode_connector_update_edid_property(connector, NULL);\n\t\tkfree(nv_connector->edid);\n\t\tnv_connector->edid = NULL;\n\t}\n\n\tret = pm_runtime_get_sync(connector->dev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn conn_status;\n\n\tnv_encoder = nouveau_connector_ddc_detect(connector);\n\tif (nv_encoder && (i2c = nv_encoder->i2c) != NULL) {\n\t\tif ((vga_switcheroo_handler_flags() &\n\t\t     VGA_SWITCHEROO_CAN_SWITCH_DDC) &&\n\t\t    nv_connector->type == DCB_CONNECTOR_LVDS)\n\t\t\tnv_connector->edid = drm_get_edid_switcheroo(connector,\n\t\t\t\t\t\t\t\t     i2c);\n\t\telse\n\t\t\tnv_connector->edid = drm_get_edid(connector, i2c);\n\n\t\tdrm_mode_connector_update_edid_property(connector,\n\t\t\t\t\t\t\tnv_connector->edid);\n\t\tif (!nv_connector->edid) {\n\t\t\tNV_ERROR(drm, "DDC responded, but no EDID for %s\\n",\n\t\t\t\t connector->name);\n\t\t\tgoto detect_analog;\n\t\t}\n\n\t\t/* Override encoder type for DVI-I based on whether EDID\n\t\t * says the display is digital or analog, both use the\n\t\t * same i2c channel so the value returned from ddc_detect\n\t\t * isn't necessarily correct.\n\t\t */\n\t\tnv_partner = NULL;\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\n\t\t\tnv_partner = find_encoder(connector, DCB_OUTPUT_ANALOG);\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)\n\t\t\tnv_partner = find_encoder(connector, DCB_OUTPUT_TMDS);\n\n\t\tif (nv_partner && ((nv_encoder->dcb->type == DCB_OUTPUT_ANALOG &&\n\t\t\t\t    nv_partner->dcb->type == DCB_OUTPUT_TMDS) ||\n\t\t\t\t   (nv_encoder->dcb->type == DCB_OUTPUT_TMDS &&\n\t\t\t\t    nv_partner->dcb->type == DCB_OUTPUT_ANALOG))) {\n\t\t\tif (nv_connector->edid->input & DRM_EDID_INPUT_DIGITAL)\n	t
41306	1479	ds1307_probe	drivers/rtc/rtc-ds1307.c	regs	1	11	\N	\N	\tstruct ds1307\t\t*ds1307;\n\tint\t\t\terr = -ENODEV;\n\tint\t\t\ttmp, wday;\n\tconst struct chip_desc\t*chip;\n\tbool\t\t\twant_irq;\n\tbool\t\t\tds1307_can_wakeup_device = false;\n\tunsigned char\t\tregs[8];\n\tstruct ds1307_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct rtc_time\t\ttm;\n\tunsigned long\t\ttimestamp;\n\tu8\t\t\ttrickle_charger_setup = 0;\n\n\tds1307 = devm_kzalloc(&client->dev, sizeof(struct ds1307), GFP_KERNEL);\n\tif (!ds1307)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&client->dev, ds1307);\n\tds1307->dev = &client->dev;\n\tds1307->name = client->name;\n\n\tds1307->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(ds1307->regmap)) {\n\t\tdev_err(ds1307->dev, "regmap allocation failed\\n");\n\t\treturn PTR_ERR(ds1307->regmap);\n\t}\n\n\ti2c_set_clientdata(client, ds1307);\n\n\tif (client->dev.of_node) {\n\t\tds1307->type = (enum ds_type)\n\t\t\tof_device_get_match_data(&client->dev);\n\t\tchip = &chips[ds1307->type];\n\t} else if (id) {\n\t\tchip = &chips[id->driver_data];\n\t\tds1307->type = id->driver_data;\n\t} else {\n\t\tconst struct acpi_device_id *acpi_id;\n\n\t\tacpi_id = acpi_match_device(ACPI_PTR(ds1307_acpi_ids),\n\t\t\t\t\t    ds1307->dev);\n\t\tif (!acpi_id)\n\t\t\treturn -ENODEV;\n\t\tchip = &chips[acpi_id->driver_data];\n\t\tds1307->type = acpi_id->driver_data;\n\t}\n\n\twant_irq = client->irq > 0 && chip->alarm;\n\n\tif (!pdata)\n\t\ttrickle_charger_setup = ds1307_trickle_init(ds1307, chip);\n\telse if (pdata->trickle_charger_setup)\n\t\ttrickle_charger_setup = pdata->trickle_charger_setup;\n\n\tif (trickle_charger_setup && chip->trickle_charger_reg) {\n\t\ttrickle_charger_setup |= DS13XX_TRICKLE_CHARGER_MAGIC;\n\t\tdev_dbg(ds1307->dev,\n\t\t\t"writing trickle charger info 0x%x to 0x%x\\n",\n\t\t\ttrickle_charger_setup, chip->trickle_charger_reg);\n\t\tregmap_write(ds1307->regmap, chip->trickle_charger_reg,\n\t\t\t     trickle_charger_setup);\n\t}\n\n#ifdef CONFIG_OF\n/*\n * For devices with no IRQ directly connected to the SoC, the RTC chip\n * can be forced as a wakeup source by stating that explicitly in\n * the device's .dts file using the "wakeup-source" boolean property.\n * If the "wakeup-source" property is set, don't request an IRQ.\n * This will guarantee the 'wakealarm' sysfs entry is available on the device,\n * if supported by the RTC.\n */\n\tif (chip->alarm && of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t\t "wakeup-source"))\n\t\tds1307_can_wakeup_device = true;\n#endif\n\n\tswitch (ds1307->type) {\n\tcase ds_1337:\n\tcase ds_1339:\n\tcase ds_1341:\n\tcase ds_3231:\n\t\t/* get registers that the "rtc" read below won't read... */\n\t\terr = regmap_bulk_read(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t\t       regs, 2);\n\t\tif (err) {\n\t\t\tdev_dbg(ds1307->dev, "read error %d\\n", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* oscillator off?  turn it on, so clock can tick. */\n\t\tif (regs[0] & DS1337_BIT_nEOSC)\n\t\t\tregs[0] &= ~DS1337_BIT_nEOSC;\n\n\t\t/*\n\t\t * Using IRQ or defined as wakeup-source?\n\t\t * Disable the square wave and both alarms.\n\t\t * For some variants, be sure alarms can trigger when we're\n\t\t * running on Vbackup (BBSQI/BBSQW)\n\t\t */\n\t\tif (want_irq || ds1307_can_wakeup_device) {\n\t\t\tregs[0] |= DS1337_BIT_INTCN | chip->bbsqi_bit;\n\t\t\tregs[0] &= ~(DS1337_BIT_A2IE | DS1337_BIT_A1IE);\n\t\t}\n\n\t\tregmap_write(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t     regs[0]);\n\n\t\t/* oscillator fault?  clear flag, and warn */\n\t\tif (regs[1] & DS1337_BIT_OSF) {\n\t\t\tregmap_write(ds1307->regmap, DS1337_REG_STATUS,\n\t\t\t\t     regs[1] & ~DS1337_BIT_OSF);\n\t\t\tdev_warn(ds1307->dev, "SET TIME!\\n");\n\t\t}\n\t\tbreak;\n\n\tcase rx_8025:\n\t\terr = regmap_bulk_read(ds1307->regmap,\n\t\t\t\t       RX8025_REG_CTRL1 << 4 | 0x08, regs, 2);\n\t\tif (err) {\n\t\t\tdev_dbg(ds1307->dev, "read error %d\\n", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* oscillator off?  turn it on, so clock can tick. */\n\t\tif (!(regs[1] & RX8025_BIT_XST)) {\n	t
43354	1098	rtl2832_probe	drivers/media/dvb-frontends/rtl2832.c	dev->muxc	1	11	\N	\N	\tstruct rtl2832_platform_data *pdata = client->dev.platform_data;\n\tstruct i2c_adapter *i2c = client->adapter;\n\tstruct rtl2832_dev *dev;\n\tint ret;\n\tu8 tmp;\n\tstatic const struct regmap_range_cfg regmap_range_cfg[] = {\n\t\t{\n\t\t\t.selector_reg     = 0x00,\n\t\t\t.selector_mask    = 0xff,\n\t\t\t.selector_shift   = 0,\n\t\t\t.window_start     = 0,\n\t\t\t.window_len       = 0x100,\n\t\t\t.range_min        = 0 * 0x100,\n\t\t\t.range_max        = 5 * 0x100,\n\t\t},\n\t};\n\n\tdev_dbg(&client->dev, "\\n");\n\n\t/* allocate memory for the internal state */\n\tdev = kzalloc(sizeof(struct rtl2832_dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* setup the state */\n\ti2c_set_clientdata(client, dev);\n\tdev->client = client;\n\tdev->pdata = client->dev.platform_data;\n\tdev->sleeping = true;\n\tINIT_DELAYED_WORK(&dev->i2c_gate_work, rtl2832_i2c_gate_work);\n\t/* create regmap */\n\tdev->regmap_config.reg_bits =  8,\n\tdev->regmap_config.val_bits =  8,\n\tdev->regmap_config.volatile_reg = rtl2832_volatile_reg,\n\tdev->regmap_config.max_register = 5 * 0x100,\n\tdev->regmap_config.ranges = regmap_range_cfg,\n\tdev->regmap_config.num_ranges = ARRAY_SIZE(regmap_range_cfg),\n\tdev->regmap_config.cache_type = REGCACHE_NONE,\n\tdev->regmap = regmap_init_i2c(client, &dev->regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t/* check if the demod is there */\n\tret = regmap_bulk_read(dev->regmap, 0x000, &tmp, 1);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t/* create muxed i2c adapter for demod tuner bus */\n\tdev->muxc = i2c_mux_alloc(i2c, &i2c->dev, 1, 0, I2C_MUX_LOCKED,\n\t\t\t\t  rtl2832_select, rtl2832_deselect);\n\tif (!dev->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap_exit;\n\t}\n\tdev->muxc->priv = dev;\n\tret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\n	t
44501	6517	btrfs_add_link	fs/btrfs/inode.c	ret	1	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->vfs_inode.i_sb);\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = parent_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &inode->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, fs_info, key.objectid,\n\t\t\t\t\t root->root_key.objectid, parent_ino,\n\t\t\t\t\t index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(&inode->vfs_inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->vfs_inode.i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(&parent_inode->vfs_inode);\n\tparent_inode->vfs_inode.i_mtime = parent_inode->vfs_inode.i_ctime =\n\t\tcurrent_time(&parent_inode->vfs_inode);\n\tret = btrfs_update_inode(trans, root, &parent_inode->vfs_inode);\n\tif (ret)\n	t
45350	3021	airo_process_scan_results	drivers/net/wireless/cisco/airo.c	&bss	2	-11	\N	\N	\tint i;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (reset_card (dev, 1))\n\t\treturn -1;\n\n\tif ( setup_card(ai, dev->dev_addr, 1 ) != SUCCESS ) {\n\t\tairo_print_err(dev->name, "MAC could not be enabled");\n\t\treturn -1;\n\t}\n\tairo_print_info(dev->name, "MAC enabled %pM", dev->dev_addr);\n\t/* Allocate the transmit buffers if needed */\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ )\n\t\t\tai->fids[i] = transmit_allocate (ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\n\n\tenable_interrupts( ai );\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(reset_airo_card);\n\nstatic void airo_send_event(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tunion iwreq_data wrqu;\n\tStatusRid status_rid;\n\n\tclear_bit(JOB_EVENT, &ai->jobs);\n\tPC4500_readrid(ai, RID_STATUS, &status_rid, sizeof(status_rid), 0);\n\tup(&ai->sem);\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\tmemcpy(wrqu.ap_addr.sa_data, status_rid.bssid[0], ETH_ALEN);\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t/* Send event to user space */\n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void airo_process_scan_results (struct airo_info *ai) {\n\tunion iwreq_data\twrqu;\n\tBSSListRid bss;\n\tint rc;\n\tBSSListElement * loop_net;\n\tBSSListElement * tmp_net;\n\n\t/* Blow away current list of scan results */\n\tlist_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {\n\t\tlist_move_tail (&loop_net->list, &ai->network_free_list);\n\t\t/* Don't blow away ->list, just BSS data */\n\t\tmemset (loop_net, 0, sizeof (loop_net->bss));\n\t}\n\n\t/* Try to read the first entry of the scan result */\n\trc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);\n\tif((rc) || (bss.index == cpu_to_le16(0xffff))) {\n\t\t/* No scan results */\n\t\tgoto out;\n\t}\n\n\t/* Read and parse all entries */\n\ttmp_net = NULL;\n\twhile((!rc) && (bss.index != cpu_to_le16(0xffff))) {\n\t\t/* Grab a network off the free list */\n\t\tif (!list_empty(&ai->network_free_list)) {\n\t\t\ttmp_net = list_entry(ai->network_free_list.next,\n\t\t\t\t\t    BSSListElement, list);\n\t\t\tlist_del(ai->network_free_list.next);\n\t\t}\n\n\t\tif (tmp_net != NULL) {\n\t\t\tmemcpy(tmp_net, &bss, sizeof(tmp_net->bss));\n	t
-613	386	f2fs_move_inline_dirents	fs/f2fs/inline.c	src.filename	2	3	\N	\N	\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\tzero_user_segment(page, MAX_INLINE_DATA(dir), PAGE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n	f
45614	306	pio2_probe	drivers/staging/vme/devices/vme_pio2_core.c	reg	1	11	\N	\N	\tstruct pio2_card *card;\n\tint retval;\n\tint i;\n\tu8 reg;\n\tint vec;\n\n\tcard = devm_kzalloc(&vdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->id = vdev->num;\n\tcard->bus = bus[card->id];\n\tcard->base = base[card->id];\n\tcard->irq_vector = vector[card->id];\n\tcard->irq_level = level[card->id] & PIO2_VME_INT_MASK;\n\tstrncpy(card->variant, variant[card->id], PIO2_VARIANT_LENGTH);\n\tcard->vdev = vdev;\n\n\tfor (i = 0; i < PIO2_VARIANT_LENGTH; i++) {\n\t\tif (!isdigit(card->variant[i])) {\n\t\t\tdev_err(&card->vdev->dev, "Variant invalid\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Bottom 4 bits of VME interrupt vector used to determine source,\n\t * provided vector should only use upper 4 bits.\n\t */\n\tif (card->irq_vector & ~PIO2_VME_VECTOR_MASK) {\n\t\tdev_err(&card->vdev->dev,\n\t\t\t"Invalid VME IRQ Vector, vector must not use lower 4 bits\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * There is no way to determine the build variant or whether each bank\n\t * is input, output or both at run time. The inputs are also inverted\n\t * if configured as both.\n\t *\n\t * We pass in the board variant and use that to determine the\n\t * configuration of the banks.\n\t */\n\tfor (i = 1; i < PIO2_VARIANT_LENGTH; i++) {\n\t\tswitch (card->variant[i]) {\n\t\tcase '0':\n\t\t\tcard->bank[i - 1].config = NOFIT;\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\t\tcard->bank[i - 1].config = INPUT;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tcard->bank[i - 1].config = OUTPUT;\n\t\t\tbreak;\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tcard->bank[i - 1].config = BOTH;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Get a master window and position over regs */\n\tcard->window = vme_master_request(vdev, VME_A24, VME_SCT, VME_D16);\n\tif (!card->window) {\n\t\tdev_err(&card->vdev->dev,\n\t\t\t"Unable to assign VME master resource\\n");\n\t\treturn -EIO;\n\t}\n\n\tretval = vme_master_set(card->window, 1, card->base, 0x10000, VME_A24,\n\t\t\t\tVME_SCT | VME_USER | VME_DATA, VME_D16);\n\tif (retval) {\n\t\tdev_err(&card->vdev->dev,\n\t\t\t"Unable to configure VME master resource\\n");\n\t\tgoto err_set;\n\t}\n\n\t/*\n\t * There is also no obvious register which we can probe to determine\n\t * whether the provided base is valid. If we can read the "ID Register"\n\t * offset and the reset function doesn't error, assume we have a valid\n\t * location.\n\t */\n\tretval = vme_master_read(card->window, &reg, 1, PIO2_REGS_ID);\n\tif (retval < 0) {\n\t\tdev_err(&card->vdev->dev, "Unable to read from device\\n");\n\t\tgoto err_read;\n\t}\n\n\tdev_dbg(&card->vdev->dev, "ID Register:%x\\n", reg);\n	t
45935	877	wusb_dev_add_ncb	drivers/usb/wusbcore/devconnect.c	result	1	11	\N	\N	\tint result = 0;\n\tstruct wusb_dev *wusb_dev;\n\tstruct wusbhc *wusbhc;\n\tstruct device *dev = &usb_dev->dev;\n\tu8 port_idx;\n\n\tif (usb_dev->wusb == 0 || usb_dev->devnum == 1)\n\t\treturn;\t\t/* skip non wusb and wusb RHs */\n\n\tusb_set_device_state(usb_dev, USB_STATE_UNAUTHENTICATED);\n\n\twusbhc = wusbhc_get_by_usb_dev(usb_dev);\n\tif (wusbhc == NULL)\n\t\tgoto error_nodev;\n\tmutex_lock(&wusbhc->mutex);\n\twusb_dev = __wusb_dev_get_by_usb_dev(wusbhc, usb_dev);\n\tport_idx = wusb_port_no_to_idx(usb_dev->portnum);\n\tmutex_unlock(&wusbhc->mutex);\n\tif (wusb_dev == NULL)\n\t\tgoto error_nodev;\n\twusb_dev->usb_dev = usb_get_dev(usb_dev);\n\tusb_dev->wusb_dev = wusb_dev_get(wusb_dev);\n\tresult = wusb_dev_sec_add(wusbhc, usb_dev, wusb_dev);\n\tif (result < 0) {\n	t
31149	1855	map_bio	drivers/md/dm-cache-target.c	cblock)	1	13	\N	\N	\tint r, data_dir;\n\tbool rb, background_queued;\n\tdm_cblock_t cblock;\n\tsize_t pb_data_size = get_per_bio_data_size(cache);\n\tstruct per_bio_data *pb = get_per_bio_data(bio, pb_data_size);\n\n\t*commit_needed = false;\n\n\trb = bio_detain_shared(cache, block, bio);\n\tif (!rb) {\n\t\t/*\n\t\t * An exclusive lock is held for this block, so we have to\n\t\t * wait.  We set the commit_needed flag so the current\n\t\t * transaction will be committed asap, allowing this lock\n\t\t * to be dropped.\n\t\t */\n\t\t*commit_needed = true;\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\tdata_dir = bio_data_dir(bio);\n\n\tif (optimisable_bio(cache, bio, block)) {\n\t\tstruct policy_work *op = NULL;\n\n\t\tr = policy_lookup_with_work(cache->policy, block, &cblock, data_dir, true, &op);\n\t\tif (unlikely(r && r != -ENOENT)) {\n\t\t\tDMERR_LIMIT("%s: policy_lookup_with_work() failed with r = %d",\n\t\t\t\t    cache_device_name(cache), r);\n\t\t\tbio_io_error(bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t}\n\n\t\tif (r == -ENOENT && op) {\n\t\t\tbio_drop_shared_lock(cache, bio);\n\t\t\tBUG_ON(op->op != POLICY_PROMOTE);\n\t\t\tmg_start(cache, op, bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t}\n\t} else {\n\t\tr = policy_lookup(cache->policy, block, &cblock, data_dir, false, &background_queued);\n\t\tif (unlikely(r && r != -ENOENT)) {\n\t\t\tDMERR_LIMIT("%s: policy_lookup() failed with r = %d",\n\t\t\t\t    cache_device_name(cache), r);\n\t\t\tbio_io_error(bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t}\n\n\t\tif (background_queued)\n\t\t\twake_migration_worker(cache);\n\t}\n\n\tif (r == -ENOENT) {\n\t\t/*\n\t\t * Miss.\n\t\t */\n\t\tinc_miss_counter(cache, bio);\n\t\tif (pb->req_nr == 0) {\n\t\t\taccounted_begin(cache, bio);\n\t\t\tremap_to_origin_clear_discard(cache, bio, block);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a duplicate writethrough io that is no\n\t\t\t * longer needed because the block has been demoted.\n\t\t\t */\n\t\t\tbio_endio(bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Hit.\n\t\t */\n\t\tinc_hit_counter(cache, bio);\n\n\t\t/*\n\t\t * Passthrough always maps to the origin, invalidating any\n\t\t * cache blocks that are written to.\n\t\t */\n\t\tif (passthrough_mode(&cache->features)) {\n\t\t\tif (bio_data_dir(bio) == WRITE) {\n\t\t\t\tbio_drop_shared_lock(cache, bio);\n\t\t\t\tatomic_inc(&cache->stats.demotion);\n\t\t\t\tinvalidate_start(cache, cblock, block, bio);\n\t\t\t} else\n\t\t\t\tremap_to_origin_clear_discard(cache, bio, block);\n\n\t\t} else {\n\t\t\tif (bio_data_dir(bio) == WRITE && writethrough_mode(&cache->features) &&\n\t\t\t    !is_dirty(cache, cblock)) {\n	f
31261	53	qlcnic_store_bridged_mode	drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c	!!new)	1	13	\N	\N	\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tunsigned long new;\n\tint ret = -EINVAL;\n\n\tif (!(adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG))\n\t\tgoto err_out;\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\tgoto err_out;\n\n\tif (kstrtoul(buf, 2, &new))\n\t\tgoto err_out;\n\n\tif (!qlcnic_config_bridged_mode(adapter, !!new))\n	f
31282	3158	cache_preresume	drivers/md/dm-cache-target.c	&li	1	13	\N	\N	\tint r = 0;\n\tstruct cache *cache = ti->private;\n\tdm_cblock_t csize = get_cache_dev_size(cache);\n\n\t/*\n\t * Check to see if the cache has resized.\n\t */\n\tif (!cache->sized) {\n\t\tr = resize_cache_dev(cache, csize);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tcache->sized = true;\n\n\t} else if (csize != cache->cache_size) {\n\t\tif (!can_resize(cache, csize))\n\t\t\treturn -EINVAL;\n\n\t\tr = resize_cache_dev(cache, csize);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (!cache->loaded_mappings) {\n\t\tr = dm_cache_load_mappings(cache->cmd, cache->policy,\n\t\t\t\t\t   load_mapping, cache);\n\t\tif (r) {\n\t\t\tDMERR("%s: could not load cache mappings", cache_device_name(cache));\n\t\t\tmetadata_operation_failed(cache, "dm_cache_load_mappings", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tcache->loaded_mappings = true;\n\t}\n\n\tif (!cache->loaded_discards) {\n\t\tstruct discard_load_info li;\n\n\t\t/*\n\t\t * The discard bitset could have been resized, or the\n\t\t * discard block size changed.  To be safe we start by\n\t\t * setting every dblock to not discarded.\n\t\t */\n\t\tclear_bitset(cache->discard_bitset, from_dblock(cache->discard_nr_blocks));\n\n\t\tdiscard_load_info_init(cache, &li);\n\t\tr = dm_cache_load_discards(cache->cmd, load_discard, &li);\n\t\tif (r) {\n\t\t\tDMERR("%s: could not load origin discards", cache_device_name(cache));\n\t\t\tmetadata_operation_failed(cache, "dm_cache_load_discards", r);\n\t\t\treturn r;\n\t\t}\n\t\tset_discard_range(&li);\n	f
31368	1407	hva_to_pfn_slow	virt/kvm/kvm_main.c	page[0]	1	13	\N	\N	\tstruct page *page[1];\n\tint npages = 0;\n\n\tmight_sleep();\n\n\tif (writable)\n\t\t*writable = write_fault;\n\n\tif (async) {\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tnpages = get_user_page_nowait(addr, write_fault, page);\n\t\tup_read(&current->mm->mmap_sem);\n\t} else {\n\t\tunsigned int flags = FOLL_HWPOISON;\n\n\t\tif (write_fault)\n\t\t\tflags |= FOLL_WRITE;\n\n\t\tnpages = get_user_pages_unlocked(addr, 1, page, flags);\n\t}\n\tif (npages != 1)\n\t\treturn npages;\n\n\t/* map read fault as writable if possible */\n\tif (unlikely(!write_fault) && writable) {\n\t\tstruct page *wpage[1];\n\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\tif (npages == 1) {\n\t\t\t*writable = true;\n\t\t\tput_page(page[0]);\n	f
48007	588	f2fs_issue_flush	fs/f2fs/segment.c	tmp	1	11	\N	\N	\tstruct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;\n\tstruct flush_cmd cmd;\n\tint ret;\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE)) {\n\t\tret = submit_flush_wait(sbi);\n\t\tatomic_inc(&fcc->issued_flush);\n\t\treturn ret;\n\t}\n\n\tif (atomic_inc_return(&fcc->issing_flush) == 1) {\n\t\tret = submit_flush_wait(sbi);\n\t\tatomic_dec(&fcc->issing_flush);\n\n\t\tatomic_inc(&fcc->issued_flush);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\t/* update issue_list before we wake up issue_flush thread */\n\tsmp_mb();\n\n\tif (waitqueue_active(&fcc->flush_wait_queue))\n\t\twake_up(&fcc->flush_wait_queue);\n\n\tif (fcc->f2fs_issue_flush) {\n\t\twait_for_completion(&cmd.wait);\n\t\tatomic_dec(&fcc->issing_flush);\n\t} else {\n\t\tstruct llist_node *list;\n\n\t\tlist = llist_del_all(&fcc->issue_list);\n\t\tif (!list) {\n\t\t\twait_for_completion(&cmd.wait);\n\t\t\tatomic_dec(&fcc->issing_flush);\n\t\t} else {\n\t\t\tstruct flush_cmd *tmp, *next;\n\n\t\t\tret = submit_flush_wait(sbi);\n\n\t\t\tllist_for_each_entry_safe(tmp, next, list, llnode) {\n	t
47724	244	ds3232_set_alarm	drivers/rtc/rtc-ds3232.c	stat	1	11	\N	\N	\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint control, stat;\n\tint ret;\n\tu8 buf[4];\n\n\tif (ds3232->irq <= 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = bin2bcd(alarm->time.tm_sec);\n\tbuf[1] = bin2bcd(alarm->time.tm_min);\n\tbuf[2] = bin2bcd(alarm->time.tm_hour);\n\tbuf[3] = bin2bcd(alarm->time.tm_mday);\n\n\t/* clear alarm interrupt enable bit */\n\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\tif (ret)\n\t\tgoto out;\n\tcontrol &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);\n\tret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\n\tif (ret)\n\t\tgoto out;\n\n\t/* clear any pending alarm flag */\n\tret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\n\tif (ret)\n\t\tgoto out;\n\tstat &= ~(DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);\n\tret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\n	t
47831	1440	nfsd4_layoutget	fs/nfsd/nfs4proc.c	ls->ls_mutex	1	11	\N	\N	\tstruct nfsd4_layoutget *lgp = &u->layoutget;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode = NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode = NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk("%s: invalid iomode %d\\n",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t/*\n\t * Verify minlength and range as per RFC5661:\n\t *  o  If loga_length is less than loga_minlength,\n\t *     the metadata server MUST return NFS4ERR_INVAL.\n\t *  o  If the sum of loga_offset and loga_minlength exceeds\n\t *     NFS4_UINT64_MAX, and loga_minlength is not\n\t *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.\n\t *  o  If the sum of loga_offset and loga_length exceeds\n\t *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,\n\t *     the error NFS4ERR_INVAL MUST result.\n\t */\n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(d_inode(current_fh->fh_dentry),\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tmutex_unlock(&ls->ls_mutex);\n	t
49248	10064	btrfs_rename	fs/btrfs/inode.c	trans	2	11	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(old_dir->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int trans_num_items;\n\tstruct btrfs_root *root = BTRFS_I(old_dir)->root;\n\tstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tu64 index = 0;\n\tu64 root_objectid;\n\tint ret;\n\tu64 old_ino = btrfs_ino(BTRFS_I(old_inode));\n\tbool log_pinned = false;\n\n\tif (btrfs_ino(BTRFS_I(new_dir)) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\n\t\treturn -EPERM;\n\n\t/* we only allow rename subvolume link between subvolumes */\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\n\t\treturn -EXDEV;\n\n\tif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n\t    (new_inode && btrfs_ino(BTRFS_I(new_inode)) == BTRFS_FIRST_FREE_OBJECTID))\n\t\treturn -ENOTEMPTY;\n\n\tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n\t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n\t\treturn -ENOTEMPTY;\n\n\n\t/* check for collisions, even if the  name isn't there */\n\tret = btrfs_check_dir_item_collision(dest, new_dir->i_ino,\n\t\t\t     new_dentry->d_name.name,\n\t\t\t     new_dentry->d_name.len);\n\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\t/* we shouldn't get\n\t\t\t * eexist without a new_inode */\n\t\t\tif (WARN_ON(!new_inode)) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* maybe -EOVERFLOW */\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = 0;\n\n\t/*\n\t * we're using rename to replace one file with another.  Start IO on it\n\t * now so  we don't add too much work to the end of the transaction\n\t */\n\tif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size)\n\t\tfilemap_flush(old_inode->i_mapping);\n\n\t/* close the racy window with snapshot create/destroy ioctl */\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tdown_read(&fs_info->subvol_sem);\n\t/*\n\t * We want to reserve the absolute worst case amount of items.  So if\n\t * both inodes are subvols and we need to unlink them then that would\n\t * require 4 item modifications, but if they are both normal inodes it\n\t * would require 5 item modifications, so we'll assume they are normal\n\t * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items\n\t * should cover the worst case number of items we'll modify.\n\t * If our rename has the whiteout flag, we need more 5 units for the\n\t * new inode (1 inode item, 1 inode ref, 2 dir items and 1 xattr item\n\t * when selinux is enabled).\n\t */\n\ttrans_num_items = 11;\n\tif (flags & RENAME_WHITEOUT)\n\t\ttrans_num_items += 5;\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_notrans;\n\t}\n\n\tif (dest != root)\n\t\tbtrfs_record_root_in_trans(trans, dest);\n	t
40679	131	mlx5e_test_get_udp_skb	drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c	skb->data	7	12	\N	\N	\tstruct sk_buff *skb = NULL;\n\tstruct mlx5ehdr *mlxh;\n\tstruct ethhdr *ethh;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\tint datalen, iplen;\n\n\tdatalen = MLX5E_TEST_PKT_SIZE -\n\t\t  (sizeof(*ethh) + sizeof(*iph) + sizeof(*udph));\n\n\tskb = netdev_alloc_skb(priv->netdev, MLX5E_TEST_PKT_SIZE);\n\tif (!skb) {\n\t\tnetdev_err(priv->netdev, "\\tFailed to alloc loopback skb\\n");\n\t\treturn NULL;\n\t}\n\n\tprefetchw(skb->data);\n	t
31520	487	da9211_i2c_probe	drivers/regulator/da9211-regulator.c	chip	1	13	\N	\N	\tstruct da9211 *chip;\n\tint error, ret;\n\tunsigned int data;\n\n\tchip = devm_kzalloc(&i2c->dev, sizeof(struct da9211), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &i2c->dev;\n\tchip->regmap = devm_regmap_init_i2c(i2c, &da9211_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\terror = PTR_ERR(chip->regmap);\n\t\tdev_err(chip->dev, "Failed to allocate register map: %d\\n",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(i2c, chip);\n\n\tchip->pdata = i2c->dev.platform_data;\n\n\tret = regmap_read(chip->regmap, DA9211_REG_DEVICE_ID, &data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, "Failed to read DEVICE_ID reg: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (data) {\n\tcase DA9211_DEVICE_ID:\n\t\tchip->chip_id = DA9211;\n\t\tbreak;\n\tcase DA9213_DEVICE_ID:\n\t\tchip->chip_id = DA9213;\n\t\tbreak;\n\tcase DA9215_DEVICE_ID:\n\t\tchip->chip_id = DA9215;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, "Unsupported device id = 0x%x.\\n", data);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!chip->pdata)\n\t\tchip->pdata = da9211_parse_regulators_dt(chip->dev);\n\n\tif (IS_ERR(chip->pdata)) {\n\t\tdev_err(chip->dev, "No regulators defined for the platform\\n");\n\t\treturn PTR_ERR(chip->pdata);\n\t}\n\n\tchip->chip_irq = i2c->irq;\n\n\tif (chip->chip_irq != 0) {\n\t\tret = devm_request_threaded_irq(chip->dev, chip->chip_irq, NULL,\n\t\t\t\t\tda9211_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_LOW|IRQF_ONESHOT,\n\t\t\t\t\t"da9211", chip);\n\t\tif (ret != 0) {\n\t\t\tdev_err(chip->dev, "Failed to request IRQ: %d\\n",\n\t\t\t\tchip->chip_irq);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_warn(chip->dev, "No IRQ configured\\n");\n\t}\n\n\tret = da9211_regulator_init(chip);\n	f
31124	358	__write_initial_superblock	drivers/md/dm-cache-metadata.c	sblock	1	13	\N	\N	\tint r;\n\tstruct dm_block *sblock;\n\tstruct cache_disk_superblock *disk_super;\n\tsector_t bdev_size = i_size_read(cmd->bdev->bd_inode) >> SECTOR_SHIFT;\n\n\t/* FIXME: see if we can lose the max sectors limit */\n\tif (bdev_size > DM_CACHE_METADATA_MAX_SECTORS)\n\t\tbdev_size = DM_CACHE_METADATA_MAX_SECTORS;\n\n\tr = dm_tm_pre_commit(cmd->tm);\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * dm_sm_copy_root() can fail.  So we need to do it before we start\n\t * updating the superblock.\n\t */\n\tr = __save_sm_root(cmd);\n\tif (r)\n\t\treturn r;\n\n\tr = superblock_lock_zero(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n	f
31590	150	intel_dp_link_training_clock_recovery	drivers/gpu/drm/i915/intel_dp_link_training.c	link_bw	1	13	\N	\N	\tuint8_t voltage;\n\tint voltage_tries, max_vswing_tries;\n\tuint8_t link_config[2];\n\tuint8_t link_bw, rate_select;\n\n\tif (intel_dp->prepare_link_retrain)\n\t\tintel_dp->prepare_link_retrain(intel_dp);\n\n\tintel_dp_compute_rate(intel_dp, intel_dp->link_rate,\n\t\t\t      &link_bw, &rate_select);\n\n\t/* Write the link configuration data */\n\tlink_config[0] = link_bw;\n\tlink_config[1] = intel_dp->lane_count;\n\tif (drm_dp_enhanced_frame_cap(intel_dp->dpcd))\n\t\tlink_config[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\tdrm_dp_dpcd_write(&intel_dp->aux, DP_LINK_BW_SET, link_config, 2);\n\n\t/* eDP 1.4 rate select method. */\n\tif (!link_bw)\n	f
31630	641	intel_rcs_ctx_init	drivers/gpu/drm/i915/intel_ringbuffer.c	ret	1	13	\N	\N	\tint ret;\n\n\tret = intel_ring_workarounds_emit(req);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = i915_gem_render_state_emit(req);\n\tif (ret)\n	f
31772	195	usb_port_runtime_resume	drivers/usb/core/port.c	usb_port_runtime_resume_	1	13	\N	\N	\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *hdev = to_usb_device(dev->parent->parent);\n\tstruct usb_interface *intf = to_usb_interface(dev->parent);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_port *peer = port_dev->peer;\n\tint port1 = port_dev->portnum;\n\tint retval;\n\n\tif (!hub)\n\t\treturn -EINVAL;\n\tif (hub->in_reset) {\n\t\tset_bit(port1, hub->power_bits);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Power on our usb3 peer before this usb2 port to prevent a usb3\n\t * device from degrading to its usb2 connection\n\t */\n\tif (!port_dev->is_superspeed && peer)\n\t\tpm_runtime_get_sync(&peer->dev);\n\n\tusb_autopm_get_interface(intf);\n\tretval = usb_hub_set_port_power(hdev, hub, port1, true);\n\tmsleep(hub_power_on_good_delay(hub));\n\tif (udev && !retval) {\n\t\t/*\n\t\t * Our preference is to simply wait for the port to reconnect,\n\t\t * as that is the lowest latency method to restart the port.\n\t\t * However, there are cases where toggling port power results in\n\t\t * the host port and the device port getting out of sync causing\n\t\t * a link training live lock.  Upon timeout, flag the port as\n\t\t * needing warm reset recovery (to be performed later by\n\t\t * usb_port_resume() as requested via usb_wakeup_notification())\n\t\t */\n\t\tif (hub_port_debounce_be_connected(hub, port1) < 0) {\n	f
31885	3389	maybe_resize_metadata_dev	drivers/md/dm-thin.c	sb_metadata_dev_size	1	13	\N	\N	\tint r;\n\tstruct pool_c *pt = ti->private;\n\tstruct pool *pool = pt->pool;\n\tdm_block_t metadata_dev_size, sb_metadata_dev_size;\n\n\t*need_commit = false;\n\n\tmetadata_dev_size = get_metadata_dev_size_in_blocks(pool->md_dev);\n\n\tr = dm_pool_get_metadata_dev_size(pool->pmd, &sb_metadata_dev_size);\n\tif (r) {\n\t\tDMERR("%s: failed to retrieve metadata device size",\n\t\t      dm_device_name(pool->pool_md));\n\t\treturn r;\n\t}\n\n\tif (metadata_dev_size < sb_metadata_dev_size) {\n	f
32247	1255	amdgpu_atombios_encoder_setup_external_encoder	drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	index	1	13	\N	\N	\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_device *adev = dev->dev_private;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_encoder *ext_amdgpu_encoder = to_amdgpu_encoder(ext_encoder);\n\tunion external_encoder_control args;\n\tstruct drm_connector *connector;\n\tint index = GetIndexIntoMasterTable(COMMAND, ExternalEncoderControl);\n\tu8 frev, crev;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint connector_object_id = 0;\n\tu32 ext_enum = (ext_amdgpu_encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\n\n\tif (action == EXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT)\n\t\tconnector = amdgpu_get_connector_for_encoder_init(encoder);\n\telse\n\t\tconnector = amdgpu_get_connector_for_encoder(encoder);\n\n\tif (connector) {\n\t\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\t\tstruct amdgpu_connector_atom_dig *dig_connector =\n\t\t\tamdgpu_connector->con_priv;\n\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\tconnector_object_id =\n\t\t\t(amdgpu_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev, &crev))\n	f
-523	512	snd_ak4113_build	sound/i2c/other/ak4113.c	kctl	1000	3	\N	\N	\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cap_substream))\n\t\treturn -EINVAL;\n\tak4113->substream = cap_substream;\n\tfor (idx = 0; idx < AK4113_CONTROLS; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_ak4113_iec958_controls[idx], ak4113);\n\t\tif (kctl == NULL)\n	f
-524	816	rds_ib_conn_path_shutdown	net/rds/ib_cm.c	err	1000	3	\N	\N	\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tint err = 0;\n\n\trdsdebug("cm %p pd %p cq %p %p qp %p\\n", ic->i_cm_id,\n\t\t ic->i_pd, ic->i_send_cq, ic->i_recv_cq,\n\t\t ic->i_cm_id ? ic->i_cm_id->qp : NULL);\n\n\tif (ic->i_cm_id) {\n\t\tstruct ib_device *dev = ic->i_cm_id->device;\n\n\t\trdsdebug("disconnecting cm %p\\n", ic->i_cm_id);\n\t\terr = rdma_disconnect(ic->i_cm_id);\n\t\tif (err) {\n	f
-509	475	af9035_i2c_master_xfer	drivers/media/usb/dvb-usb-v2/af9035.c	ret	1000	3	\N	\N	\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct state *state = d_to_priv(d);\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * AF9035 I2C sub header is 5 bytes long. Meaning of those bytes are:\n\t * 0: data len\n\t * 1: I2C addr << 1\n\t * 2: reg addr len\n\t *    byte 3 and 4 can be used as reg addr\n\t * 3: reg addr MSB\n\t *    used when reg addr len is set to 2\n\t * 4: reg addr LSB\n\t *    used when reg addr len is set to 1 or 2\n\t *\n\t * For the simplify we do not use register addr at all.\n\t * NOTE: As a firmware knows tuner type there is very small possibility\n\t * there could be some tuner I2C hacks done by firmware and this may\n\t * lead problems if firmware expects those bytes are used.\n\t *\n\t * TODO: Here is few hacks. AF9035 chip integrates AF9033 demodulator.\n\t * IT9135 chip integrates AF9033 demodulator and RF tuner. For dual\n\t * tuner devices, there is also external AF9033 demodulator connected\n\t * via external I2C bus. All AF9033 demod I2C traffic, both single and\n\t * dual tuner configuration, is covered by firmware - actual USB IO\n\t * looks just like a memory access.\n\t * In case of IT913x chip, there is own tuner driver. It is implemented\n\t * currently as a I2C driver, even tuner IP block is likely build\n\t * directly into the demodulator memory space and there is no own I2C\n\t * bus. I2C subsystem does not allow register multiple devices to same\n\t * bus, having same slave address. Due to that we reuse demod address,\n\t * shifted by one bit, on that case.\n\t *\n\t * For IT930x we use a different command and the sub header is\n\t * different as well:\n\t * 0: data len\n\t * 1: I2C bus (0x03 seems to be only value used)\n\t * 2: I2C addr << 1\n\t */\n#define AF9035_IS_I2C_XFER_WRITE_READ(_msg, _num) \\\n\t(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_WRITE(_msg, _num) \\\n\t(_num == 1 && !(_msg[0].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_READ(_msg, _num) \\\n\t(_num == 1 && (_msg[0].flags & I2C_M_RD))\n\n\tif (AF9035_IS_I2C_XFER_WRITE_READ(msg, num)) {\n\t\tif (msg[0].len > 40 || msg[1].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\t/* demod access via firmware interface */\n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_rd_regs(d, reg, &msg[1].buf[0],\n\t\t\t\t\tmsg[1].len);\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[1].buf, 0, msg[1].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* I2C write + read */\n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, msg[1].len, msg[1].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\n\t\t\tbuf[0] = msg[1].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\n\t\t\t\t/* Keep prev behavior for write req len > 2*/\n\t\t\t\tif (msg[0].len > 2) {\n\t\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\n\t\t\t\t/* Use reg addr fields if write req len <= 2 */\n\t\t\t\t} else {\n\t\t\t\t\treq.wlen = 5;\n\t\t\t\t\tbuf[2] = msg[0].len;\n\t\t\t\t\tif (msg[0].len == 2) {\n\t\t\t\t\t\tbuf[3] = msg[0].buf[0];\n\t\t\t\t\t\tbuf[4] = msg[0].buf[1];\n\t\t\t\t\t} else if (msg[0].len == 1) {\n\t\t\t\t\t\tbuf[4] = msg[0].buf[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_WRITE(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\t/* demod access via firmware interface */\n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_wr_regs(d, reg, &msg[0].buf[3],\n\t\t\t\t\tmsg[0].len - 3);\n\t\t} else {\n\t\t\t/* I2C write */\n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_WR, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, 0, NULL };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_WR;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_READ(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t/* TODO: correct limits > 40 */\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[0].buf, 0, msg[0].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* I2C read */\n\t\t\tu8 buf[5];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\n\t\t\t\t\t\tbuf, msg[0].len, msg[0].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03; /* I2C bus */\n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00; /* reg addr len */\n\t\t\t\tbuf[3] = 0x00; /* reg addr MSB */\n\t\t\t\tbuf[4] = 0x00; /* reg addr LSB */\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We support only three kind of I2C transactions:\n\t\t * 1) 1 x write + 1 x read (repeated start)\n\t\t * 2) 1 x write\n\t\t * 3) 1 x read\n\t\t */\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n	f
40301	1609	smsc75xx_enter_suspend3	drivers/net/usb/smsc75xx.c	val	8	12	\N	\N	\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, FCT_RX_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, "Error reading FCT_RX_CTL\\n");\n\t\treturn ret;\n\t}\n\n\tif (val & FCT_RX_CTL_RXUSED) {\n	t
30492	234	twl_request	drivers/gpio/gpio-twl4030.c	status	1	13	\N	\N	\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint status = 0;\n\n\tmutex_lock(&priv->mutex);\n\n\t/* Support the two LED outputs as output-only GPIOs. */\n\tif (offset >= TWL4030_GPIO_MAX) {\n\t\tu8\tledclr_mask = LEDEN_LEDAON | LEDEN_LEDAEXT\n\t\t\t\t| LEDEN_LEDAPWM | LEDEN_PWM_LENGTHA;\n\t\tu8\treg = TWL4030_PWMAON_REG;\n\n\t\toffset -= TWL4030_GPIO_MAX;\n\t\tif (offset) {\n\t\t\tledclr_mask <<= 1;\n\t\t\treg = TWL4030_PWMBON_REG;\n\t\t}\n\n\t\t/* initialize PWM to always-drive */\n\t\t/* Configure PWM OFF register first */\n\t\tstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg + 1);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\n\t\t/* Followed by PWM ON register */\n\t\tstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\n\t\t/* init LED to not-driven (high) */\n\t\tstatus = twl_i2c_read_u8(TWL4030_MODULE_LED, &cached_leden,\n\t\t\t\t\t TWL4030_LED_LEDEN_REG);\n\t\tif (status < 0)\n	f
44835	562	opti82c46x_set_piomode	drivers/ata/pata_legacy.c	&tp	6	12	\N	\N	\tu8 active, recover, setup;\n\tstruct ata_timing t;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint clock;\n\tint khz[4] = { 50000, 40000, 33000, 25000 };\n\tu8 rc;\n\tu8 sysclk;\n\n\t/* Get the clock */\n\tsysclk = (opti_syscfg(0xAC) & 0xC0) >> 6;\t/* BIOS set */\n\n\t/* Enter configuration mode */\n\tioread16(ap->ioaddr.error_addr);\n\tioread16(ap->ioaddr.error_addr);\n\tiowrite8(3, ap->ioaddr.nsect_addr);\n\n\t/* Read VLB clock strapping */\n\tclock = 1000000000 / khz[sysclk];\n\n\t/* Get the timing data in cycles */\n\tata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\n\n\t/* Setup timing is shared */\n\tif (pair) {\n\t\tstruct ata_timing tp;\n\t\tata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\n	t
46085	719	snd_card_dummy_pcm	sound/drivers/dummy.c	pcm->name	6	12	\N	\N	\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_ops *ops;\n\tint err;\n\n\terr = snd_pcm_new(dummy->card, "Dummy PCM", device,\n\t\t\t       substreams, substreams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tdummy->pcm = pcm;\n\tif (fake_buffer)\n\t\tops = &dummy_pcm_ops_no_buf;\n\telse\n\t\tops = &dummy_pcm_ops;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, ops);\n\tpcm->private_data = dummy;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, "Dummy PCM");\n	t
32363	3484	gfx_v8_0_write_harvested_raster_configs	drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c	se_mask	1	13	\N	\N	\tunsigned sh_per_se = max_t(unsigned, adev->gfx.config.max_sh_per_se, 1);\n\tunsigned num_se = max_t(unsigned, adev->gfx.config.max_shader_engines, 1);\n\tunsigned rb_per_pkr = min_t(unsigned, num_rb / num_se / sh_per_se, 2);\n\tunsigned rb_per_se = num_rb / num_se;\n\tunsigned se_mask[4];\n\tunsigned se;\n\n\tse_mask[0] = ((1 << rb_per_se) - 1) & rb_mask;\n\tse_mask[1] = (se_mask[0] << rb_per_se) & rb_mask;\n\tse_mask[2] = (se_mask[1] << rb_per_se) & rb_mask;\n\tse_mask[3] = (se_mask[2] << rb_per_se) & rb_mask;\n\n\tWARN_ON(!(num_se == 1 || num_se == 2 || num_se == 4));\n\tWARN_ON(!(sh_per_se == 1 || sh_per_se == 2));\n\tWARN_ON(!(rb_per_pkr == 1 || rb_per_pkr == 2));\n\n\tif ((num_se > 2) && ((!se_mask[0] && !se_mask[1]) ||\n	f
46483	1643	process_lcf	net/netfilter/nf_conntrack_h323_main.c	&addr	6	12	\N	\N	\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\tpr_debug("nf_ct_ras: LCF\\n");\n\n\tif (!get_h225_addr(ct, *data, &lcf->callSignalAddress,\n	t
32402	414	tpm_get_timeouts	drivers/char/tpm/tpm-interface.c	chip->dev.parent	1	13	\N	\N	\tstruct tpm_output_header *header = (void *)buf;\n\tint rc;\n\tssize_t len = 0;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\tbool need_locality;\n\n\tif (!tpm_validate_command(chip, space, buf, bufsiz))\n\t\treturn -EINVAL;\n\n\tif (bufsiz > TPM_BUFSIZE)\n\t\tbufsiz = TPM_BUFSIZE;\n\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(&chip->dev,\n\t\t\t"invalid count value %x %zx\\n", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\tif (!(flags & TPM_TRANSMIT_UNLOCKED))\n\t\tmutex_lock(&chip->tpm_mutex);\n\n\tif (chip->dev.parent)\n\t\tpm_runtime_get_sync(chip->dev.parent);\n	f
51355	823	__ocfs2_move_extents_range	fs/ocfs2/move_extents.c	alloc_size	8	12	\N	\N	\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t/*\n\t * TO-DO XXX:\n\t *\n\t * - xattr extents.\n\t */\n\n\tdo_defrag = context->auto_defrag;\n\n\t/*\n\t * extents moving happens in unit of clusters, for the sake\n\t * of simplicity, we may ignore two clusters where 'byte_start'\n\t * and 'byte_start + len' were within.\n\t */\n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, "Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, "\n\t     "thresh: %u\\n",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n	t
32512	534	iwpm_add_and_query_mapping_cb	drivers/infiniband/core/iwpm_msg.c	mapped_loc_sockaddr->ss_family	1	13	\N	\N	\tstruct iwpm_sa_data *pm_msg;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlattr *nltb[IWPM_NLA_RQUERY_MAPPING_MAX];\n\tstruct sockaddr_storage *local_sockaddr, *remote_sockaddr;\n\tstruct sockaddr_storage *mapped_loc_sockaddr, *mapped_rem_sockaddr;\n\tconst char *msg_type;\n\tu32 msg_seq;\n\tu16 err_code;\n\n\tmsg_type = "Query Mapping response";\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_RQUERY_MAPPING_MAX,\n\t\t\t\tresp_query_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\n\tmsg_seq = nla_get_u32(nltb[IWPM_NLA_QUERY_MAPPING_SEQ]);\n\tnlmsg_request = iwpm_find_nlmsg_request(msg_seq);\n\tif (!nlmsg_request) {\n\t\tpr_info("%s: Could not find a matching request (seq = %u)\\n",\n\t\t\t\t __func__, msg_seq);\n\t\treturn -EINVAL;\n\t}\n\tpm_msg = nlmsg_request->req_buffer;\n\tlocal_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_QUERY_LOCAL_ADDR]);\n\tremote_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_QUERY_REMOTE_ADDR]);\n\tmapped_loc_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_LOC_ADDR]);\n\tmapped_rem_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_REM_ADDR]);\n\n\terr_code = nla_get_u16(nltb[IWPM_NLA_RQUERY_MAPPING_ERR]);\n\tif (err_code == IWPM_REMOTE_QUERY_REJECT) {\n\t\tpr_info("%s: Received a Reject (pid = %u, echo seq = %u)\\n",\n\t\t\t__func__, cb->nlh->nlmsg_pid, msg_seq);\n\t\tnlmsg_request->err_code = IWPM_REMOTE_QUERY_REJECT;\n\t}\n\tif (iwpm_compare_sockaddr(local_sockaddr, &pm_msg->loc_addr) ||\n\t\tiwpm_compare_sockaddr(remote_sockaddr, &pm_msg->rem_addr)) {\n\t\tpr_info("%s: Incorrect local sockaddr\\n", __func__);\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto query_mapping_response_exit;\n\t}\n\tif (mapped_loc_sockaddr->ss_family != local_sockaddr->ss_family ||\n	f
32554	1377	gfx_v6_0_write_harvested_raster_configs	drivers/gpu/drm/amd/amdgpu/gfx_v6_0.c	se_mask	1	13	\N	\N	\tunsigned sh_per_se = max_t(unsigned, adev->gfx.config.max_sh_per_se, 1);\n\tunsigned num_se = max_t(unsigned, adev->gfx.config.max_shader_engines, 1);\n\tunsigned rb_per_pkr = min_t(unsigned, num_rb / num_se / sh_per_se, 2);\n\tunsigned rb_per_se = num_rb / num_se;\n\tunsigned se_mask[4];\n\tunsigned se;\n\n\tse_mask[0] = ((1 << rb_per_se) - 1) & rb_mask;\n\tse_mask[1] = (se_mask[0] << rb_per_se) & rb_mask;\n\tse_mask[2] = (se_mask[1] << rb_per_se) & rb_mask;\n\tse_mask[3] = (se_mask[2] << rb_per_se) & rb_mask;\n\n\tWARN_ON(!(num_se == 1 || num_se == 2 || num_se == 4));\n\tWARN_ON(!(sh_per_se == 1 || sh_per_se == 2));\n\tWARN_ON(!(rb_per_pkr == 1 || rb_per_pkr == 2));\n\n\tfor (se = 0; se < num_se; se++) {\n\t\tunsigned raster_config_se = raster_config;\n\t\tunsigned pkr0_mask = ((1 << rb_per_pkr) - 1) << (se * rb_per_se);\n\t\tunsigned pkr1_mask = pkr0_mask << rb_per_pkr;\n\t\tint idx = (se / 2) * 2;\n\n\t\tif ((num_se > 1) && (!se_mask[idx] || !se_mask[idx + 1])) {\n	f
32614	640	__igt_insert	drivers/gpu/drm/selftests/test-drm_mm.c	&nodes[n]	1	13	\N	\N	\tDRM_RND_STATE(prng, random_seed);\n\tconst struct insert_mode *mode;\n\tstruct drm_mm mm;\n\tstruct drm_mm_node *nodes, *node, *next;\n\tunsigned int *order, n, m, o = 0;\n\tint ret;\n\n\t/* Fill a range with lots of nodes, check it doesn't fail too early */\n\n\tDRM_MM_BUG_ON(!count);\n\tDRM_MM_BUG_ON(!size);\n\n\tret = -ENOMEM;\n\tnodes = vmalloc(count * sizeof(*nodes));\n\tif (!nodes)\n\t\tgoto err;\n\n\torder = drm_random_order(count, &prng);\n\tif (!order)\n\t\tgoto err_nodes;\n\n\tret = -EINVAL;\n\tdrm_mm_init(&mm, 0, count * size);\n\n\tfor (mode = insert_modes; mode->name; mode++) {\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tstruct drm_mm_node tmp;\n\n\t\t\tnode = replace ? &tmp : &nodes[n];\n\t\t\tmemset(node, 0, sizeof(*node));\n\t\t\tif (!expect_insert(&mm, node, size, 0, n, mode)) {\n\t\t\t\tpr_err("%s insert failed, size %llu step %d\\n",\n\t\t\t\t       mode->name, size, n);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (replace) {\n\t\t\t\tdrm_mm_replace_node(&tmp, &nodes[n]);\n\t\t\t\tif (drm_mm_node_allocated(&tmp)) {\n\t\t\t\t\tpr_err("replaced old-node still allocated! step %d\\n",\n\t\t\t\t\t       n);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!assert_node(&nodes[n], &mm, size, 0, n)) {\n\t\t\t\t\tpr_err("replaced node did not inherit parameters, size %llu step %d\\n",\n\t\t\t\t\t       size, n);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (tmp.start != nodes[n].start) {\n\t\t\t\t\tpr_err("replaced node mismatch location expected [%llx + %llx], found [%llx + %llx]\\n",\n\t\t\t\t\t       tmp.start, size,\n\t\t\t\t\t       nodes[n].start, nodes[n].size);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* After random insertion the nodes should be in order */\n\t\tif (!assert_continuous(&mm, size))\n\t\t\tgoto out;\n\n\t\t/* Repeated use should then fail */\n\t\tif (!expect_insert_fail(&mm, size))\n\t\t\tgoto out;\n\n\t\t/* Remove one and reinsert, as the only hole it should refill itself */\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tu64 addr = nodes[n].start;\n\n\t\t\tdrm_mm_remove_node(&nodes[n]);\n	f
40245	1670	hot_remove_store	drivers/block/zram/zram_drv.c	dev_id	1	13	\N	\N	\tstruct zram *zram;\n\tint ret, dev_id;\n\n\t/* dev_id is gendisk->first_minor, which is `int' */\n\tret = kstrtoint(buf, 10, &dev_id);\n\tif (ret)\n\t\treturn ret;\n\tif (dev_id < 0)\n	f
56486	6372	ftrace_pid_write	kernel/trace/ftrace.c	ftrace_pid_write_$_r_a_p__v$obj	0	13	\N	\N	\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n	f
33016	1008	radeon_vm_bo_update	drivers/gpu/drm/radeon/radeon_vm.c	&ib.sync	1	13	\N	\N	\tstruct radeon_vm *vm = bo_va->vm;\n\tstruct radeon_ib ib;\n\tunsigned nptes, ncmds, ndw;\n\tuint64_t addr;\n\tuint32_t flags;\n\tint r;\n\n\tif (!bo_va->it.start) {\n\t\tdev_err(rdev->dev, "bo %p don't has a mapping in vm %p\\n",\n\t\t\tbo_va->bo, vm);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&vm->status_lock);\n\tif (mem) {\n\t\tif (list_empty(&bo_va->vm_status)) {\n\t\t\tspin_unlock(&vm->status_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tlist_del_init(&bo_va->vm_status);\n\t} else {\n\t\tlist_del(&bo_va->vm_status);\n\t\tlist_add(&bo_va->vm_status, &vm->cleared);\n\t}\n\tspin_unlock(&vm->status_lock);\n\n\tbo_va->flags &= ~RADEON_VM_PAGE_VALID;\n\tbo_va->flags &= ~RADEON_VM_PAGE_SYSTEM;\n\tbo_va->flags &= ~RADEON_VM_PAGE_SNOOPED;\n\tif (bo_va->bo && radeon_ttm_tt_is_readonly(bo_va->bo->tbo.ttm))\n\t\tbo_va->flags &= ~RADEON_VM_PAGE_WRITEABLE;\n\n\tif (mem) {\n\t\taddr = mem->start << PAGE_SHIFT;\n\t\tif (mem->mem_type != TTM_PL_SYSTEM) {\n\t\t\tbo_va->flags |= RADEON_VM_PAGE_VALID;\n\t\t}\n\t\tif (mem->mem_type == TTM_PL_TT) {\n\t\t\tbo_va->flags |= RADEON_VM_PAGE_SYSTEM;\n\t\t\tif (!(bo_va->bo->flags & (RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC)))\n\t\t\t\tbo_va->flags |= RADEON_VM_PAGE_SNOOPED;\n\n\t\t} else {\n\t\t\taddr += rdev->vm_manager.vram_base_offset;\n\t\t}\n\t} else {\n\t\taddr = 0;\n\t}\n\n\ttrace_radeon_vm_bo_update(bo_va);\n\n\tnptes = bo_va->it.last - bo_va->it.start + 1;\n\n\t/* reserve space for one command every (1 << BLOCK_SIZE) entries\n\t   or 2k dwords (whatever is smaller) */\n\tncmds = (nptes >> min(radeon_vm_block_size, 11)) + 1;\n\n\t/* padding, etc. */\n\tndw = 64;\n\n\tflags = radeon_vm_page_flags(bo_va->flags);\n\tif ((flags & R600_PTE_GART_MASK) == R600_PTE_GART_MASK) {\n\t\t/* only copy commands needed */\n\t\tndw += ncmds * 7;\n\n\t} else if (flags & R600_PTE_SYSTEM) {\n\t\t/* header for write data commands */\n\t\tndw += ncmds * 4;\n\n\t\t/* body of write data command */\n\t\tndw += nptes * 2;\n\n\t} else {\n\t\t/* set page commands needed */\n\t\tndw += ncmds * 10;\n\n\t\t/* two extra commands for begin/end of fragment */\n\t\tndw += 2 * 10;\n\t}\n\n\t/* update too big for an IB */\n\tif (ndw > 0xfffff)\n\t\treturn -ENOMEM;\n\n\tr = radeon_ib_get(rdev, R600_RING_TYPE_DMA_INDEX, &ib, NULL, ndw * 4);\n\tif (r)\n\t\treturn r;\n\tib.length_dw = 0;\n\n\tif (!(bo_va->flags & RADEON_VM_PAGE_VALID)) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < RADEON_NUM_RINGS; ++i)\n\t\t\tradeon_sync_fence(&ib.sync, vm->ids[i].last_id_use);\n	f
33183	993	vmw_surface_reference_ioctl	drivers/gpu/drm/vmwgfx/vmwgfx_surface.c	rep->mip_levels	1	13	\N	\N	\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tunion drm_vmw_surface_reference_arg *arg =\n\t    (union drm_vmw_surface_reference_arg *)data;\n\tstruct drm_vmw_surface_arg *req = &arg->req;\n\tstruct drm_vmw_surface_create_req *rep = &arg->rep;\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_surface *srf;\n\tstruct vmw_user_surface *user_srf;\n\tstruct drm_vmw_size __user *user_sizes;\n\tstruct ttm_base_object *base;\n\tint ret;\n\n\tret = vmw_surface_handle_reference(dev_priv, file_priv, req->sid,\n\t\t\t\t\t   req->handle_type, &base);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tuser_srf = container_of(base, struct vmw_user_surface, prime.base);\n\tsrf = &user_srf->srf;\n\n\trep->flags = srf->flags;\n\trep->format = srf->format;\n\tmemcpy(rep->mip_levels, srf->mip_levels, sizeof(srf->mip_levels));\n	f
33249	427	vmw_gb_context_unbind	drivers/gpu/drm/vmwgfx/vmwgfx_context.c	fence	1	13	\N	\N	\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tstruct vmw_fence_obj *fence;\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(res, struct vmw_user_context, res);\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdReadbackGBContext body;\n\t} *cmd1;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBContext body;\n\t} *cmd2;\n\tuint32_t submit_size;\n\tuint8_t *cmd;\n\n\n\tBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tvmw_binding_state_scrub(uctx->cbs);\n\n\tsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\n\n\tcmd = vmw_fifo_reserve(dev_priv, submit_size);\n\tif (unlikely(cmd == NULL)) {\n\t\tDRM_ERROR("Failed reserving FIFO space for context "\n\t\t\t  "unbinding.\\n");\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd2 = (void *) cmd;\n\tif (readback) {\n\t\tcmd1 = (void *) cmd;\n\t\tcmd1->header.id = SVGA_3D_CMD_READBACK_GB_CONTEXT;\n\t\tcmd1->header.size = sizeof(cmd1->body);\n\t\tcmd1->body.cid = res->id;\n\t\tcmd2 = (void *) (&cmd1[1]);\n\t}\n\tcmd2->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\n\tcmd2->header.size = sizeof(cmd2->body);\n\tcmd2->body.cid = res->id;\n\tcmd2->body.mobid = SVGA3D_INVALID_ID;\n\n\tvmw_fifo_commit(dev_priv, submit_size);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\t/*\n\t * Create a fence object and fence the backup buffer.\n\t */\n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv,\n\t\t\t\t\t  &fence, NULL);\n\n\tvmw_fence_single_bo(bo, fence);\n	f
33252	327	vmw_cotable_unbind	drivers/gpu/drm/vmwgfx/vmwgfx_cotable.c	fence	1	13	\N	\N	\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tstruct vmw_fence_obj *fence;\n\n\tif (list_empty(&res->mob_head))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(bo->mem.mem_type != VMW_PL_MOB);\n\tlockdep_assert_held(&bo->resv->lock.base);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tif (!vcotbl->scrubbed)\n\t\tvmw_dx_context_scrub_cotables(vcotbl->ctx, readback);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\n\tvmw_fence_single_bo(bo, fence);\n	f
33290	1520	brcmf_fws_txs_process	drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c	ifp	1	13	\N	\N	\tu32 fifo;\n\tint ret;\n\tbool remove_from_hanger = true;\n\tstruct sk_buff *skb;\n\tstruct brcmf_skbuff_cb *skcb;\n\tstruct brcmf_fws_mac_descriptor *entry = NULL;\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(DATA, "flags %d\\n", flags);\n\n\tif (flags == BRCMF_FWS_TXSTATUS_DISCARD)\n\t\tfws->stats.txs_discard++;\n\telse if (flags == BRCMF_FWS_TXSTATUS_CORE_SUPPRESS) {\n\t\tfws->stats.txs_supp_core++;\n\t\tremove_from_hanger = false;\n\t} else if (flags == BRCMF_FWS_TXSTATUS_FW_PS_SUPPRESS) {\n\t\tfws->stats.txs_supp_ps++;\n\t\tremove_from_hanger = false;\n\t} else if (flags == BRCMF_FWS_TXSTATUS_FW_TOSSED)\n\t\tfws->stats.txs_tossed++;\n\telse if (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)\n\t\tfws->stats.txs_host_tossed++;\n\telse\n\t\tbrcmf_err("unexpected txstatus\\n");\n\n\tret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,\n\t\t\t\t      remove_from_hanger);\n\tif (ret != 0) {\n\t\tbrcmf_err("no packet in hanger slot: hslot=%d\\n", hslot);\n\t\treturn ret;\n\t}\n\n\tskcb = brcmf_skbcb(skb);\n\tentry = skcb->mac;\n\tif (WARN_ON(!entry)) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tentry->transit_count--;\n\tif (entry->suppressed && entry->suppr_transit_count)\n\t\tentry->suppr_transit_count--;\n\n\tbrcmf_dbg(DATA, "%s flags %d htod %X seq %X\\n", entry->name, flags,\n\t\t  skcb->htod, seq);\n\n\t/* pick up the implicit credit from this packet */\n\tfifo = brcmf_skb_htod_tag_get_field(skb, FIFO);\n\tif ((fws->fcmode == BRCMF_FWS_FCMODE_IMPLIED_CREDIT) ||\n\t    (brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) ||\n\t    (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)) {\n\t\tbrcmf_fws_return_credits(fws, fifo, 1);\n\t\tbrcmf_fws_schedule_deq(fws);\n\t}\n\tbrcmf_fws_macdesc_return_req_credit(skb);\n\n\tret = brcmf_proto_hdrpull(fws->drvr, false, skb, &ifp);\n\tif (ret) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tif (!remove_from_hanger)\n\t\tret = brcmf_fws_txstatus_suppressed(fws, fifo, skb,\n\t\t\t\t\t\t    genbit, seq);\n\tif (remove_from_hanger || ret)\n\t\tbrcmf_txfinalize(ifp, skb, true);\n	f
39128	169	ide_cmd_ioctl	drivers/ide/ide-ioctls.c	xfer_rate	6	12	\N	\N	\tu8 *buf = NULL;\n\tint bufsize = 0, err = 0;\n\tu8 args[4], xfer_rate = 0;\n\tstruct ide_cmd cmd;\n\tstruct ide_taskfile *tf = &cmd.tf;\n\n\tif (NULL == (void *) arg) {\n\t\tstruct request *rq;\n\n\t\trq = blk_get_request(drive->queue, REQ_OP_DRV_IN, __GFP_RECLAIM);\n\t\tide_req(rq)->type = ATA_PRIV_TASKFILE;\n\t\tblk_execute_rq(drive->queue, NULL, rq, 0);\n\t\terr = scsi_req(rq)->result ? -EIO : 0;\n\t\tblk_put_request(rq);\n\n\t\treturn err;\n\t}\n\n\tif (copy_from_user(args, (void __user *)arg, 4))\n\t\treturn -EFAULT;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\ttf->feature = args[2];\n\tif (args[0] == ATA_CMD_SMART) {\n\t\ttf->nsect = args[3];\n\t\ttf->lbal  = args[1];\n\t\ttf->lbam  = ATA_SMART_LBAM_PASS;\n\t\ttf->lbah  = ATA_SMART_LBAH_PASS;\n\t\tcmd.valid.out.tf = IDE_VALID_OUT_TF;\n\t\tcmd.valid.in.tf  = IDE_VALID_NSECT;\n\t} else {\n\t\ttf->nsect = args[1];\n\t\tcmd.valid.out.tf = IDE_VALID_FEATURE | IDE_VALID_NSECT;\n\t\tcmd.valid.in.tf  = IDE_VALID_NSECT;\n\t}\n\ttf->command = args[0];\n\tcmd.protocol = args[3] ? ATA_PROT_PIO : ATA_PROT_NODATA;\n\n\tif (args[3]) {\n\t\tcmd.tf_flags |= IDE_TFLAG_IO_16BIT;\n\t\tbufsize = SECTOR_SIZE * args[3];\n\t\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (tf->command == ATA_CMD_SET_FEATURES &&\n\t    tf->feature == SETFEATURES_XFER &&\n\t    tf->nsect >= XFER_SW_DMA_0) {\n\t\txfer_rate = ide_find_dma_mode(drive, tf->nsect);\n\t\tif (xfer_rate != tf->nsect) {\n	t
39105	722	bpf_jit_blind_constants	kernel/bpf/core.c	insn	1	11	\N	\N	\tstruct bpf_insn insn_buff[16], aux[2];\n\tstruct bpf_prog *clone, *tmp;\n\tint insn_delta, insn_cnt;\n\tstruct bpf_insn *insn;\n\tint i, rewritten;\n\n\tif (!bpf_jit_blinding_enabled())\n\t\treturn prog;\n\n\tclone = bpf_prog_clone_create(prog, GFP_USER);\n\tif (!clone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinsn_cnt = clone->len;\n\tinsn = clone->insnsi;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\t/* We temporarily need to hold the original ld64 insn\n\t\t * so that we can still access the first part in the\n\t\t * second blinding run.\n\t\t */\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW) &&\n	t
33575	702	b43_calc_nrssi_slope	drivers/net/wireless/broadcom/b43/phy_g.c	dev	1	13	\N	\N	\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tu16 backup[18] = { 0 };\n\tu16 tmp;\n\ts16 nrssi0, nrssi1;\n\n\tB43_WARN_ON(phy->type != B43_PHYTYPE_G);\n\n\tif (phy->radio_rev >= 9)\n\t\treturn;\n\tif (phy->radio_rev == 8)\n\t\tb43_calc_nrssi_offset(dev);\n\n\tb43_phy_mask(dev, B43_PHY_G_CRS, 0x7FFF);\n\tb43_phy_mask(dev, 0x0802, 0xFFFC);\n\tbackup[7] = b43_read16(dev, 0x03E2);\n\tb43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);\n\tbackup[0] = b43_radio_read16(dev, 0x007A);\n\tbackup[1] = b43_radio_read16(dev, 0x0052);\n\tbackup[2] = b43_radio_read16(dev, 0x0043);\n\tbackup[3] = b43_phy_read(dev, 0x0015);\n\tbackup[4] = b43_phy_read(dev, 0x005A);\n\tbackup[5] = b43_phy_read(dev, 0x0059);\n\tbackup[6] = b43_phy_read(dev, 0x0058);\n\tbackup[8] = b43_read16(dev, 0x03E6);\n\tbackup[9] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);\n\tif (phy->rev >= 3) {\n\t\tbackup[10] = b43_phy_read(dev, 0x002E);\n\t\tbackup[11] = b43_phy_read(dev, 0x002F);\n\t\tbackup[12] = b43_phy_read(dev, 0x080F);\n\t\tbackup[13] = b43_phy_read(dev, B43_PHY_G_LO_CONTROL);\n\t\tbackup[14] = b43_phy_read(dev, 0x0801);\n\t\tbackup[15] = b43_phy_read(dev, 0x0060);\n\t\tbackup[16] = b43_phy_read(dev, 0x0014);\n\t\tbackup[17] = b43_phy_read(dev, 0x0478);\n\t\tb43_phy_write(dev, 0x002E, 0);\n\t\tb43_phy_write(dev, B43_PHY_G_LO_CONTROL, 0);\n\t\tswitch (phy->rev) {\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tb43_phy_set(dev, 0x0478, 0x0100);\n\t\t\tb43_phy_set(dev, 0x0801, 0x0040);\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tb43_phy_mask(dev, 0x0801, 0xFFBF);\n\t\t\tbreak;\n\t\t}\n\t\tb43_phy_set(dev, 0x0060, 0x0040);\n\t\tb43_phy_set(dev, 0x0014, 0x0200);\n\t}\n\tb43_radio_set(dev, 0x007A, 0x0070);\n\tb43_set_all_gains(dev, 0, 8, 0);\n\tb43_radio_mask(dev, 0x007A, 0x00F7);\n\tif (phy->rev >= 2) {\n\t\tb43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0030);\n\t\tb43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0010);\n\t}\n\tb43_radio_set(dev, 0x007A, 0x0080);\n\tudelay(20);\n\n\tnrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);\n\tif (nrssi0 >= 0x0020)\n\t\tnrssi0 -= 0x0040;\n\n\tb43_radio_mask(dev, 0x007A, 0x007F);\n\tif (phy->rev >= 2) {\n\t\tb43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);\n\t}\n\n\tb43_write16(dev, B43_MMIO_CHANNEL_EXT,\n\t\t    b43_read16(dev, B43_MMIO_CHANNEL_EXT)\n\t\t    | 0x2000);\n\tb43_radio_set(dev, 0x007A, 0x000F);\n\tb43_phy_write(dev, 0x0015, 0xF330);\n\tif (phy->rev >= 2) {\n\t\tb43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0020);\n\t\tb43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0020);\n\t}\n\n\tb43_set_all_gains(dev, 3, 0, 1);\n\tif (phy->radio_rev == 8) {\n\t\tb43_radio_write16(dev, 0x0043, 0x001F);\n\t} else {\n\t\ttmp = b43_radio_read16(dev, 0x0052) & 0xFF0F;\n\t\tb43_radio_write16(dev, 0x0052, tmp | 0x0060);\n\t\ttmp = b43_radio_read16(dev, 0x0043) & 0xFFF0;\n\t\tb43_radio_write16(dev, 0x0043, tmp | 0x0009);\n\t}\n\tb43_phy_write(dev, 0x005A, 0x0480);\n\tb43_phy_write(dev, 0x0059, 0x0810);\n\tb43_phy_write(dev, 0x0058, 0x000D);\n\tudelay(20);\n\tnrssi1 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);\n\tif (nrssi1 >= 0x0020)\n\t\tnrssi1 -= 0x0040;\n\tif (nrssi0 == nrssi1)\n\t\tgphy->nrssislope = 0x00010000;\n\telse\n\t\tgphy->nrssislope = 0x00400000 / (nrssi0 - nrssi1);\n\tif (nrssi0 >= -4) {\n\t\tgphy->nrssi[0] = nrssi1;\n\t\tgphy->nrssi[1] = nrssi0;\n\t}\n\tif (phy->rev >= 3) {\n\t\tb43_phy_write(dev, 0x002E, backup[10]);\n\t\tb43_phy_write(dev, 0x002F, backup[11]);\n\t\tb43_phy_write(dev, 0x080F, backup[12]);\n\t\tb43_phy_write(dev, B43_PHY_G_LO_CONTROL, backup[13]);\n\t}\n\tif (phy->rev >= 2) {\n\t\tb43_phy_mask(dev, 0x0812, 0xFFCF);\n\t\tb43_phy_mask(dev, 0x0811, 0xFFCF);\n\t}\n\n\tb43_radio_write16(dev, 0x007A, backup[0]);\n\tb43_radio_write16(dev, 0x0052, backup[1]);\n\tb43_radio_write16(dev, 0x0043, backup[2]);\n\tb43_write16(dev, 0x03E2, backup[7]);\n\tb43_write16(dev, 0x03E6, backup[8]);\n\tb43_write16(dev, B43_MMIO_CHANNEL_EXT, backup[9]);\n\tb43_phy_write(dev, 0x0015, backup[3]);\n\tb43_phy_write(dev, 0x005A, backup[4]);\n\tb43_phy_write(dev, 0x0059, backup[5]);\n\tb43_phy_write(dev, 0x0058, backup[6]);\n\tb43_synth_pu_workaround(dev, phy->channel);\n\tb43_phy_set(dev, 0x0802, (0x0001 | 0x0002));\n\tb43_set_original_gains(dev);\n\tb43_phy_set(dev, B43_PHY_G_CRS, 0x8000);\n\tif (phy->rev >= 3) {\n\t\tb43_phy_write(dev, 0x0801, backup[14]);\n	f
9577	1840	fman_port_probe	drivers/net/ethernet/freescale/fman/fman_port.c	res.start	0	21	\N	\N	\tstruct fman_port *port;\n\tstruct fman *fman;\n\tstruct device_node *fm_node, *port_node;\n\tstruct resource res;\n\tstruct resource *dev_res;\n\tu32 val;\n\tint err = 0, lenp;\n\tenum fman_port_type port_type;\n\tu16 port_speed;\n\tu8 port_id;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = &of_dev->dev;\n\n\tport_node = of_node_get(of_dev->dev.of_node);\n\n\t/* Get the FM node */\n\tfm_node = of_get_parent(port_node);\n\tif (!fm_node) {\n\t\tdev_err(port->dev, "%s: of_get_parent() failed\\n", __func__);\n\t\terr = -ENODEV;\n\t\tgoto return_err;\n\t}\n\n\tfman = dev_get_drvdata(&of_find_device_by_node(fm_node)->dev);\n\tof_node_put(fm_node);\n\tif (!fman) {\n\t\terr = -EINVAL;\n\t\tgoto return_err;\n\t}\n\n\terr = of_property_read_u32(port_node, "cell-index", &val);\n\tif (err) {\n\t\tdev_err(port->dev, "%s: reading cell-index for %pOF failed\\n",\n\t\t\t__func__, port_node);\n\t\terr = -EINVAL;\n\t\tgoto return_err;\n\t}\n\tport_id = (u8)val;\n\tport->dts_params.id = port_id;\n\n\tif (of_device_is_compatible(port_node, "fsl,fman-v3-port-tx")) {\n\t\tport_type = FMAN_PORT_TYPE_TX;\n\t\tport_speed = 1000;\n\t\tif (of_find_property(port_node, "fsl,fman-10g-port", &lenp))\n\t\t\tport_speed = 10000;\n\n\t} else if (of_device_is_compatible(port_node, "fsl,fman-v2-port-tx")) {\n\t\tif (port_id >= TX_10G_PORT_BASE)\n\t\t\tport_speed = 10000;\n\t\telse\n\t\t\tport_speed = 1000;\n\t\tport_type = FMAN_PORT_TYPE_TX;\n\n\t} else if (of_device_is_compatible(port_node, "fsl,fman-v3-port-rx")) {\n\t\tport_type = FMAN_PORT_TYPE_RX;\n\t\tport_speed = 1000;\n\t\tif (of_find_property(port_node, "fsl,fman-10g-port", &lenp))\n\t\t\tport_speed = 10000;\n\n\t} else if (of_device_is_compatible(port_node, "fsl,fman-v2-port-rx")) {\n\t\tif (port_id >= RX_10G_PORT_BASE)\n\t\t\tport_speed = 10000;\n\t\telse\n\t\t\tport_speed = 1000;\n\t\tport_type = FMAN_PORT_TYPE_RX;\n\n\t}  else {\n\t\tdev_err(port->dev, "%s: Illegal port type\\n", __func__);\n\t\terr = -EINVAL;\n\t\tgoto return_err;\n\t}\n\n\tport->dts_params.type = port_type;\n\tport->dts_params.speed = port_speed;\n\n\tif (port_type == FMAN_PORT_TYPE_TX) {\n\t\tu32 qman_channel_id;\n\n\t\tqman_channel_id = fman_get_qman_channel_id(fman, port_id);\n\t\tif (qman_channel_id == 0) {\n\t\t\tdev_err(port->dev, "%s: incorrect qman-channel-id\\n",\n\t\t\t\t__func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto return_err;\n\t\t}\n\t\tport->dts_params.qman_channel_id = qman_channel_id;\n\t}\n\n\terr = of_address_to_resource(port_node, 0, &res);\n\tif (err < 0) {\n\t\tdev_err(port->dev, "%s: of_address_to_resource() failed\\n",\n\t\t\t__func__);\n\t\terr = -ENOMEM;\n\t\tgoto return_err;\n\t}\n\n\tport->dts_params.fman = fman;\n\n\tof_node_put(port_node);\n\n\tdev_res = __devm_request_region(port->dev, &res, res.start,\n	f
8559	1075	dm_remap_zone_report	drivers/md/dm.c	bvec.bv_len	0	21	\N	\N	#ifdef CONFIG_BLK_DEV_ZONED\n\tstruct dm_target_io *tio = container_of(bio, struct dm_target_io, clone);\n\tstruct bio *report_bio = tio->io->bio;\n\tstruct blk_zone_report_hdr *hdr = NULL;\n\tstruct blk_zone *zone;\n\tunsigned int nr_rep = 0;\n\tunsigned int ofst;\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tvoid *addr;\n\n\tif (bio->bi_status)\n\t\treturn;\n\n\t/*\n\t * Remap the start sector of the reported zones. For sequential zones,\n\t * also remap the write pointer position.\n\t */\n\tbio_for_each_segment(bvec, report_bio, iter) {\n\t\taddr = kmap_atomic(bvec.bv_page);\n\n\t\t/* Remember the report header in the first page */\n\t\tif (!hdr) {\n\t\t\thdr = addr;\n\t\t\tofst = sizeof(struct blk_zone_report_hdr);\n\t\t} else\n\t\t\tofst = 0;\n\n\t\t/* Set zones start sector */\n\t\twhile (hdr->nr_zones && ofst < bvec.bv_len) {\n	f
61808	1721	atalk_sendmsg	net/appletalk/ddp.c	&usat->sat_addr	0	11	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_at *, usat, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\tif (usat) {\n\t\terr = -EBUSY;\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\tgoto out;\n\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\tgoto out;\n\n\t\terr = -EPERM;\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, "SK %p: Got address.\\n", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\terr = -ENETUNREACH;\n\tif (!rt)\n\t\tgoto out;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, "SK %p: Size needed %d, device %s\\n",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, "SK %p: Begin build.\\n", sk);\n\n\tddp = skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, "SK %p: Copy user data (%zd bytes).\\n", sk, len);\n\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_no_check_tx)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, "SK %p: send out(copy).\\n", sk);\n\t\t\t/*\n\t\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t\t */\n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, "SK %p: Loop back.\\n", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tstruct atalk_addr at_lo;\n\n\t\t\tat_lo.s_node = 0;\n\t\t\tat_lo.s_net  = 0;\n\n\t\t\trt = atrtr_find(&at_lo);\n\t\t\tif (!rt) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\terr = -ENETUNREACH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdev = rt->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, "SK %p: send out.\\n", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t/*\n\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t */\n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n	f
-518	61	dwc3_of_simple_clk_init	drivers/usb/dwc3/dwc3-of-simple.c	simple->clks[i]	1000	3	\N	\N	\tstruct device\t\t*dev = simple->dev;\n\tstruct device_node\t*np = dev->of_node;\n\tint\t\t\ti;\n\n\tsimple->num_clocks = count;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsimple->clks = devm_kcalloc(dev, simple->num_clocks,\n\t\t\tsizeof(struct clk *), GFP_KERNEL);\n\tif (!simple->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < simple->num_clocks; i++) {\n\t\tstruct clk\t*clk;\n\t\tint\t\tret;\n\n\t\tclk = of_clk_get(np, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_put(simple->clks[i]);\n	f
33857	236	ath9k_htc_send_beacon	drivers/net/wireless/ath/ath9k/htc_drv_beacon.c	hdr->seq_ctrl	1	13	\N	\N	\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_vif *vif;\n\tstruct ath9k_htc_vif *avp;\n\tstruct tx_beacon_header beacon_hdr;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *beacon;\n\tu8 *tx_fhdr;\n\tint ret;\n\n\tmemset(&beacon_hdr, 0, sizeof(struct tx_beacon_header));\n\n\tspin_lock_bh(&priv->beacon_lock);\n\n\tvif = priv->beacon.bslot[slot];\n\tavp = (struct ath9k_htc_vif *)vif->drv_priv;\n\n\tif (unlikely(test_bit(ATH_OP_SCANNING, &common->op_flags))) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t/* Get a new beacon */\n\tbeacon = ieee80211_beacon_get(priv->hw, vif);\n\tif (!beacon) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the TSF adjust value here, the HW will\n\t * add this value for every beacon.\n\t */\n\tmgmt = (struct ieee80211_mgmt *)beacon->data;\n\tmgmt->u.beacon.timestamp = avp->tsfadjust;\n\n\tinfo = IEEE80211_SKB_CB(beacon);\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tstruct ieee80211_hdr *hdr =\n\t\t\t(struct ieee80211_hdr *) beacon->data;\n\t\tavp->seq_no += 0x10;\n\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n	f
34432	4366	process_all_refs	fs/btrfs/send.c	found_key.type	1	13	\N	\N	\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t"Wrong command %d in process_all_refs", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n	f
34457	1727	extent_from_logical	fs/btrfs/backref.c	flags	1	13	\N	\N	\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tconst struct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tbtrfs_debug(fs_info,\n\t\t\t"logical %llu is not within any extent", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tbtrfs_debug(fs_info,\n\t\t"logical %llu is at position %llu within the extent (%llu EXTENT_ITEM %llu) flags %#llx size %u",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n	f
34465	1729	extent_from_logical	fs/btrfs/backref.c	flags	1	13	\N	\N	\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tconst struct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tbtrfs_debug(fs_info,\n\t\t\t"logical %llu is not within any extent", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tbtrfs_debug(fs_info,\n\t\t"logical %llu is at position %llu within the extent (%llu EXTENT_ITEM %llu) flags %#llx size %u",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n	f
34600	5956	btrfs_subvolume_reserve_metadata	fs/btrfs/extent-tree.c	ret	1	13	\N	\N	\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *global_rsv = &fs_info->global_block_rsv;\n\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags)) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * fs_info->nodesize;\n\t\tret = btrfs_qgroup_reserve_meta(root, num_bytes, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(fs_info, items);\n\trsv->space_info = __find_space_info(fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n	f
-510	2625	dme1737_isa_device_add	drivers/hwmon/dme1737.c	err	1000	3	\N	\N	\tstruct resource res = {\n\t\t.start\t= addr,\n\t\t.end\t= addr + DME1737_EXTENT - 1,\n\t\t.name\t= "dme1737",\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc("dme1737", addr);\n\tif (!pdev) {\n\t\tpr_err("Failed to allocate device\\n");\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err("Failed to add device resource (err = %d)\\n", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n	f
2834	219	efx_mcdi_send_request	drivers/net/ethernet/sfc/mcdi.c	hdr	0	21	\N	\N	\tstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tchar *buf = mcdi->logging_buffer; /* page-sized */\n#endif\n\tefx_dword_t hdr[2];\n\tsize_t hdr_len;\n\tu32 xflags, seqno;\n\n\tBUG_ON(mcdi->state == MCDI_STATE_QUIESCENT);\n\n\t/* Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */\n\tspin_lock_bh(&mcdi->iface_lock);\n\t++mcdi->seqno;\n\tspin_unlock_bh(&mcdi->iface_lock);\n\n\tseqno = mcdi->seqno & SEQ_MASK;\n\txflags = 0;\n\tif (mcdi->mode == MCDI_MODE_EVENTS)\n\t\txflags |= MCDI_HEADER_XFLAGS_EVREQ;\n\n\tif (efx->type->mcdi_max_ver == 1) {\n\t\t/* MCDI v1 */\n\t\tEFX_POPULATE_DWORD_7(hdr[0],\n\t\t\t\t     MCDI_HEADER_RESPONSE, 0,\n\t\t\t\t     MCDI_HEADER_RESYNC, 1,\n\t\t\t\t     MCDI_HEADER_CODE, cmd,\n\t\t\t\t     MCDI_HEADER_DATALEN, inlen,\n\t\t\t\t     MCDI_HEADER_SEQ, seqno,\n\t\t\t\t     MCDI_HEADER_XFLAGS, xflags,\n\t\t\t\t     MCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\n\t\thdr_len = 4;\n\t} else {\n\t\t/* MCDI v2 */\n\t\tBUG_ON(inlen > MCDI_CTL_SDU_LEN_MAX_V2);\n\t\tEFX_POPULATE_DWORD_7(hdr[0],\n\t\t\t\t     MCDI_HEADER_RESPONSE, 0,\n\t\t\t\t     MCDI_HEADER_RESYNC, 1,\n\t\t\t\t     MCDI_HEADER_CODE, MC_CMD_V2_EXTN,\n\t\t\t\t     MCDI_HEADER_DATALEN, 0,\n\t\t\t\t     MCDI_HEADER_SEQ, seqno,\n\t\t\t\t     MCDI_HEADER_XFLAGS, xflags,\n\t\t\t\t     MCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\n\t\tEFX_POPULATE_DWORD_2(hdr[1],\n\t\t\t\t     MC_CMD_V2_EXTN_IN_EXTENDED_CMD, cmd,\n\t\t\t\t     MC_CMD_V2_EXTN_IN_ACTUAL_LEN, inlen);\n\t\thdr_len = 8;\n\t}\n\n#ifdef CONFIG_SFC_MCDI_LOGGING\n\tif (mcdi->logging_enabled && !WARN_ON_ONCE(!buf)) {\n\t\tint bytes = 0;\n\t\tint i;\n\t\t/* Lengths should always be a whole number of dwords, so scream\n\t\t * if they're not.\n\t\t */\n\t\tWARN_ON_ONCE(hdr_len % 4);\n\t\tWARN_ON_ONCE(inlen % 4);\n\n\t\t/* We own the logging buffer, as only one MCDI can be in\n\t\t * progress on a NIC at any one time.  So no need for locking.\n\t\t */\n\t\tfor (i = 0; i < hdr_len / 4 && bytes < PAGE_SIZE; i++)\n\t\t\tbytes += snprintf(buf + bytes, PAGE_SIZE - bytes,\n	f
167	1177	btrfs_get_extent_inline_ref_type	fs/btrfs/extent-tree.c	offset	0	21	\N	\N	\tint type = btrfs_extent_inline_ref_type(eb, iref);\n\tu64 offset = btrfs_extent_inline_ref_offset(eb, iref);\n\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_DATA_REF_KEY ||\n\t    type == BTRFS_EXTENT_DATA_REF_KEY) {\n\t\tif (is_data == BTRFS_REF_TYPE_BLOCK) {\n\t\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY)\n\t\t\t\treturn type;\n\t\t\tif (type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\t\t\tASSERT(eb->fs_info);\n\t\t\t\t/*\n\t\t\t\t * Every shared one has parent tree\n\t\t\t\t * block, which must be aligned to\n\t\t\t\t * nodesize.\n\t\t\t\t */\n\t\t\t\tif (offset &&\n	f
6582	1612	futex_atomic_op_inuser	kernel/futex.c	oldval	0	21	\N	\N	\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 12);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 12);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t/*\n\t\t\t * kill this print and return -EINVAL when userspace\n\t\t\t * is sane again\n\t\t\t */\n\t\t\tpr_info_ratelimited("futex_wake_op: %s tries to shift op by %d; fix this program\\n",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n	f
5127	1280	gen8_dump_ppgtt	drivers/gpu/drm/i915/i915_gem_gtt.c	pdp	0	21	\N	\N	\tstruct i915_address_space *vm = &ppgtt->base;\n\tconst gen8_pte_t scratch_pte =\n\t\tgen8_pte_encode(vm->scratch_page.daddr, I915_CACHE_LLC);\n\tu64 start = 0, length = ppgtt->base.total;\n\n\tif (use_4lvl(vm)) {\n\t\tu64 pml4e;\n\t\tstruct i915_pml4 *pml4 = &ppgtt->pml4;\n\t\tstruct i915_page_directory_pointer *pdp;\n\n\t\tgen8_for_each_pml4e(pdp, pml4, start, length, pml4e) {\n\t\t\tif (pml4->pdps[pml4e] == ppgtt->base.scratch_pdp)\n\t\t\t\tcontinue;\n\n\t\t\tseq_printf(m, "    PML4E #%llu\\n", pml4e);\n\t\t\tgen8_dump_pdp(ppgtt, pdp, start, length, scratch_pte, m);\n	f
8523	2473	btc8192e2ant_action_hid_a2dp	drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8192e2ant.c	wifi_bw	1	11	\N	\N	\tu8 wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;\n\tu32 wifi_bw;\n\n\twifi_rssi_state = btc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15, 0);\n\tbt_rssi_state = btc8192e2ant_bt_rssi_state(btcoexist, 3, 34, 42);\n\n\tbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);\n\tbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);\n\n\tbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);\n\n\tif ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||\n\t    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);\n\t\tbtc8192e2ant_tdma_duration_adjust(btcoexist, true, true, 2);\n\t} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||\n\t\t   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM))\t{\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);\n\t\tbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);\n\t} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||\n\t\t   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);\n\t\tbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);\n\t}\n\n\t/* sw mechanism */\n\tif (BTC_WIFI_BW_HT40 == wifi_bw) {\n	t
34678	1378	btrfs_defrag_file	fs/btrfs/ioctl.c	ret	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = SZ_256K >> PAGE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)SZ_128K - 1);\n\tstruct page **pages = NULL;\n\tbool do_compress = range->flags & BTRFS_DEFRAG_RANGE_COMPRESS;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (do_compress) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = SZ_256K;\n\n\t/*\n\t * If we were not given a file, allocate a readahead context. As\n\t * readahead is just an optimization, defrag will work without it so\n\t * we don't error out.\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (ra)\n\t\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, SZ_64K);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index - i + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(fs_info)) {\n\t\t\tbtrfs_debug(fs_info, "defrag_file cancelled");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, do_compress)){\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tif (ra)\n\t\t\t\tpage_cache_sync_readahead(inode->i_mapping, ra,\n\t\t\t\t\t\tfile, ra_index, cluster);\n\t\t\tra_index += cluster;\n\t\t}\n\n\t\tinode_lock(inode);\n\t\tif (do_compress)\n\t\t\tBTRFS_I(inode)->defrag_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n	f
34849	3784	scrub_enumerate_chunks	fs/btrfs/scrub.c	found_key.type	1	13	\N	\N	\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *fs_info = sctx->fs_info;\n\tstruct btrfs_root *root = fs_info->dev_root;\n\tu64 length;\n\tu64 chunk_offset;\n\tint ret = 0;\n\tint ro_set;\n\tint slot;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = READA_FORWARD;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = scrub_dev->devid;\n\tkey.offset = 0ull;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.objectid != scrub_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n	f
36431	1486	bond_alb_xmit	drivers/net/bonding/bond_alb.c	skb	0	11	\N	\N	\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct ethhdr *eth_data;\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct slave *tx_slave = NULL;\n\tstatic const __be32 ip_bcast = htonl(0xffffffff);\n\tint hash_size = 0;\n\tbool do_tx_balance = true;\n\tu32 hash_index = 0;\n\tconst u8 *hash_start = NULL;\n\tstruct ipv6hdr *ip6hdr;\n\n\tskb_reset_mac_header(skb);\n\teth_data = eth_hdr(skb);\n\n\tswitch (ntohs(skb->protocol)) {\n\tcase ETH_P_IP: {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast) ||\n\t\t    (iph->daddr == ip_bcast) ||\n\t\t    (iph->protocol == IPPROTO_IGMP)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\t\thash_start = (char *)&(iph->daddr);\n\t\thash_size = sizeof(iph->daddr);\n\t}\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\t/* IPv6 doesn't really use broadcast mac address, but leave\n\t\t * that here just in case.\n\t\t */\n\t\tif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IPv6 uses all-nodes multicast as an equivalent to\n\t\t * broadcasts in IPv4.\n\t\t */\n\t\tif (ether_addr_equal_64bits(eth_data->h_dest, mac_v6_allmcast)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Additianally, DAD probes should not be tx-balanced as that\n\t\t * will lead to false positives for duplicate addresses and\n\t\t * prevent address configuration from working.\n\t\t */\n\t\tip6hdr = ipv6_hdr(skb);\n\t\tif (ipv6_addr_any(&ip6hdr->saddr)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\thash_start = (char *)&(ipv6_hdr(skb)->daddr);\n\t\thash_size = sizeof(ipv6_hdr(skb)->daddr);\n\t\tbreak;\n\tcase ETH_P_IPX:\n\t\tif (ipx_hdr(skb)->ipx_checksum != IPX_NO_CHECKSUM) {\n\t\t\t/* something is wrong with this packet */\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ipx_hdr(skb)->ipx_type != IPX_TYPE_NCP) {\n\t\t\t/* The only protocol worth balancing in\n\t\t\t * this family since it has an "ARP" like\n\t\t\t * mechanism\n\t\t\t */\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\thash_start = (char *)eth_data->h_dest;\n\t\thash_size = ETH_ALEN;\n\t\tbreak;\n\tcase ETH_P_ARP:\n\t\tdo_tx_balance = false;\n\t\tif (bond_info->rlb_enabled)\n\t\t\ttx_slave = rlb_arp_xmit(skb, bond);\n\t\tbreak;\n\tdefault:\n\t\tdo_tx_balance = false;\n\t\tbreak;\n\t}\n\n\tif (do_tx_balance) {\n\t\thash_index = _simple_hash(hash_start, hash_size);\n\t\ttx_slave = tlb_choose_channel(bond, hash_index, skb->len);\n\t}\n\n\treturn bond_do_alb_xmit(skb, bond, tx_slave);\n	f
39618	6876	btrfs_read_chunk_tree	fs/btrfs/volumes.c	chunk	0	11	\N	\N	\tstruct btrfs_root *root = fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\tint slot;\n\tu64 total_dev = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&uuid_mutex);\n\tmutex_lock(&fs_info->chunk_mutex);\n\n\t/*\n\t * Read all device items, and then all the chunk items. All\n\t * device items are found before any chunk item (their object id\n\t * is smaller than the lowest possible object id for a chunk\n\t * item - BTRFS_FIRST_CHUNK_TREE_OBJECTID).\n\t */\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.type == BTRFS_DEV_ITEM_KEY) {\n\t\t\tstruct btrfs_dev_item *dev_item;\n\t\t\tdev_item = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\t  struct btrfs_dev_item);\n\t\t\tret = read_one_dev(fs_info, leaf, dev_item);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t\ttotal_dev++;\n\t\t} else if (found_key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tstruct btrfs_chunk *chunk;\n\t\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\t\tret = read_one_chunk(fs_info, &found_key, leaf, chunk);\n	f
28205	1256	create_raw_packet_qp	drivers/infiniband/hw/mlx5/qp.c	sq	0	11	\N	\N	\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct ib_uobject *uobj = pd->uobject;\n\tstruct ib_ucontext *ucontext = uobj->context;\n\tstruct mlx5_ib_ucontext *mucontext = to_mucontext(ucontext);\n\tint err;\n\tu32 tdn = mucontext->tdn;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = create_raw_packet_qp_tis(dev, qp, sq, tdn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = create_raw_packet_qp_sq(dev, sq, in, pd);\n	f
908	229	cfi_qry_present	drivers/mtd/chips/cfi_util.c	val[0])	1	11	\N	\N	\tint osf = cfi->interleave * cfi->device_type;\t/* scale factor */\n\tmap_word val[3];\n\tmap_word qry[3];\n\n\tqry[0] = cfi_build_cmd('Q', map, cfi);\n\tqry[1] = cfi_build_cmd('R', map, cfi);\n\tqry[2] = cfi_build_cmd('Y', map, cfi);\n\n\tval[0] = map_read(map, base + osf*0x10);\n\tval[1] = map_read(map, base + osf*0x11);\n\tval[2] = map_read(map, base + osf*0x12);\n\n\tif (!map_word_equal(map, qry[0], val[0]))\n	t
41982	210	btrfs_get_parent	fs/btrfs/export.c	key.objectid	1	-11	\N	\N	\tstruct inode *dir = d_inode(child);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root_ref *ref;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (btrfs_ino(BTRFS_I(dir)) == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tkey.objectid = root->root_key.objectid;\n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = fs_info->tree_root;\n\t} else {\n\t\tkey.objectid = btrfs_ino(BTRFS_I(dir));\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t\tkey.offset = (u64)-1;\n\t}\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tBUG_ON(ret == 0); /* Key with offset of -1 found */\n\tif (path->slots[0] == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpath->slots[0]--;\n\tleaf = path->nodes[0];\n\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tif (found_key.objectid != key.objectid || found_key.type != key.type) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tif (found_key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\t\tkey.objectid = btrfs_root_ref_dirid(leaf, ref);\n\t} else {\n\t\tkey.objectid = found_key.offset;\n\t}\n\tbtrfs_free_path(path);\n\n\tif (found_key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\treturn btrfs_get_dentry(fs_info->sb, key.objectid,\n	f
34872	2177	btrfs_ioctl_tree_search_v2	fs/btrfs/ioctl.c	buf_size	1	13	\N	\N	\tstruct btrfs_ioctl_search_args_v2 __user *uarg;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\tconst size_t buf_limit = SZ_16M;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* copy search header and buffer size */\n\tuarg = (struct btrfs_ioctl_search_args_v2 __user *)argp;\n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\t/* limit result size to 16MB */\n\tif (buf_size > buf_limit)\n	f
34991	581	vt642x_interrupt	drivers/ata/sata_via.c	serror	1	13	\N	\N	\tstruct ata_host *host = dev_instance;\n\tirqreturn_t rc = ata_bmdma_interrupt(irq, dev_instance);\n\n\t/* if the IRQ was not handled, it might be a hotplug IRQ */\n\tif (rc != IRQ_HANDLED) {\n\t\tu32 serror;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\t/* check for hotplug on port 0 */\n\t\tsvia_scr_read(&host->ports[0]->link, SCR_ERROR, &serror);\n\t\tif (serror & SERR_PHYRDY_CHG) {\n	f
48170	1069	mv_xor_channel_add	drivers/dma/mv_xor.c	dma_dev->dev	0	11	\N	\N	\tint ret = 0;\n\tstruct mv_xor_chan *mv_chan;\n\tstruct dma_device *dma_dev;\n\n\tmv_chan = devm_kzalloc(&pdev->dev, sizeof(*mv_chan), GFP_KERNEL);\n\tif (!mv_chan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmv_chan->idx = idx;\n\tmv_chan->irq = irq;\n\tif (xordev->xor_type == XOR_ORION)\n\t\tmv_chan->op_in_desc = XOR_MODE_IN_REG;\n\telse\n\t\tmv_chan->op_in_desc = XOR_MODE_IN_DESC;\n\n\tdma_dev = &mv_chan->dmadev;\n\tmv_chan->xordev = xordev;\n\n\t/*\n\t * These source and destination dummy buffers are used to implement\n\t * a DMA_INTERRUPT operation as a minimum-sized XOR operation.\n\t * Hence, we only need to map the buffers at initialization-time.\n\t */\n\tmv_chan->dummy_src_addr = dma_map_single(dma_dev->dev,\n	f
51926	1724	edge_interrupt_callback	drivers/usb/serial/io_ti.c	urb	0	11	\N	\N	\tstruct edgeport_serial *edge_serial = urb->context;\n\tstruct usb_serial_port *port;\n\tstruct edgeport_port *edge_port;\n\tstruct device *dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint length = urb->actual_length;\n\tint port_number;\n\tint function;\n\tint retval;\n\t__u8 lsr;\n\t__u8 msr;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\\n",\n\t\t    __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, "%s - nonzero urb status received: "\n\t\t\t"%d\\n", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tif (!length) {\n\t\tdev_dbg(&urb->dev->dev, "%s - no data in urb\\n", __func__);\n\t\tgoto exit;\n\t}\n\n\tdev = &edge_serial->serial->dev->dev;\n\tusb_serial_debug_data(dev, __func__, length, data);\n\n\tif (length != 2) {\n\t\tdev_dbg(dev, "%s - expecting packet of size 2, got %d\\n", __func__, length);\n\t\tgoto exit;\n\t}\n\n\tport_number = TIUMP_GET_PORT_FROM_CODE(data[0]);\n\tfunction    = TIUMP_GET_FUNC_FROM_CODE(data[0]);\n\tdev_dbg(dev, "%s - port_number %d, function %d, info 0x%x\\n", __func__,\n\t\tport_number, function, data[1]);\n\n\tif (port_number >= edge_serial->serial->num_ports) {\n\t\tdev_err(dev, "bad port number %d\\n", port_number);\n\t\tgoto exit;\n\t}\n\n\tport = edge_serial->serial->port[port_number];\n\tedge_port = usb_get_serial_port_data(port);\n\tif (!edge_port) {\n\t\tdev_dbg(dev, "%s - edge_port not found\\n", __func__);\n\t\treturn;\n\t}\n\tswitch (function) {\n\tcase TIUMP_INTERRUPT_CODE_LSR:\n\t\tlsr = map_line_status(data[1]);\n\t\tif (lsr & UMP_UART_LSR_DATA_MASK) {\n\t\t\t/*\n\t\t\t * Save the LSR event for bulk read completion routine\n\t\t\t */\n\t\t\tdev_dbg(dev, "%s - LSR Event Port %u LSR Status = %02x\\n",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\tedge_port->lsr_event = 1;\n\t\t\tedge_port->lsr_mask = lsr;\n\t\t} else {\n\t\t\tdev_dbg(dev, "%s - ===== Port %d LSR Status = %02x ======\\n",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\thandle_new_lsr(edge_port, 0, lsr, 0);\n\t\t}\n\t\tbreak;\n\n\tcase TIUMP_INTERRUPT_CODE_MSR:\t/* MSR */\n\t\t/* Copy MSR from UMP */\n\t\tmsr = data[1];\n\t\tdev_dbg(dev, "%s - ===== Port %u MSR Status = %02x ======\\n",\n\t\t\t__func__, port_number, msr);\n\t\thandle_new_msr(edge_port, msr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&urb->dev->dev,\n\t\t\t"%s - Unknown Interrupt code from UMP %x\\n",\n\t\t\t__func__, data[1]);\n\t\tbreak;\n\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n	f
50726	160	edsa_rcv	net/dsa/tag_edsa.c	new_header	0	11	\N	\N	\tstruct dsa_switch_tree *dst = dev->dsa_ptr;\n\tstruct dsa_switch *ds;\n\tu8 *edsa_header;\n\tint source_device;\n\tint source_port;\n\n\tif (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))\n\t\treturn NULL;\n\n\t/*\n\t * Skip the two null bytes after the ethertype.\n\t */\n\tedsa_header = skb->data + 2;\n\n\t/*\n\t * Check that frame type is either TO_CPU or FORWARD.\n\t */\n\tif ((edsa_header[0] & 0xc0) != 0x00 && (edsa_header[0] & 0xc0) != 0xc0)\n\t\treturn NULL;\n\n\t/*\n\t * Determine source device and port.\n\t */\n\tsource_device = edsa_header[0] & 0x1f;\n\tsource_port = (edsa_header[1] >> 3) & 0x1f;\n\n\t/*\n\t * Check that the source device exists and that the source\n\t * port is a registered DSA port.\n\t */\n\tif (source_device >= DSA_MAX_SWITCHES)\n\t\treturn NULL;\n\n\tds = dst->ds[source_device];\n\tif (!ds)\n\t\treturn NULL;\n\n\tif (source_port >= ds->num_ports || !ds->ports[source_port].netdev)\n\t\treturn NULL;\n\n\t/*\n\t * If the 'tagged' bit is set, convert the DSA tag to a 802.1q\n\t * tag and delete the ethertype part.  If the 'tagged' bit is\n\t * clear, delete the ethertype and the DSA tag parts.\n\t */\n\tif (edsa_header[0] & 0x20) {\n\t\tu8 new_header[4];\n\n\t\t/*\n\t\t * Insert 802.1q ethertype and copy the VLAN-related\n\t\t * fields, but clear the bit that will hold CFI (since\n\t\t * DSA uses that bit location for another purpose).\n\t\t */\n\t\tnew_header[0] = (ETH_P_8021Q >> 8) & 0xff;\n\t\tnew_header[1] = ETH_P_8021Q & 0xff;\n\t\tnew_header[2] = edsa_header[2] & ~0x10;\n\t\tnew_header[3] = edsa_header[3];\n\n\t\t/*\n\t\t * Move CFI bit from its place in the DSA header to\n\t\t * its 802.1q-designated place.\n\t\t */\n\t\tif (edsa_header[1] & 0x01)\n\t\t\tnew_header[2] |= 0x10;\n\n\t\tskb_pull_rcsum(skb, DSA_HLEN);\n\n\t\t/*\n\t\t * Update packet checksum if skb is CHECKSUM_COMPLETE.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\t\t__wsum c = skb->csum;\n\t\t\tc = csum_add(c, csum_partial(new_header + 2, 2, 0));\n\t\t\tc = csum_sub(c, csum_partial(edsa_header + 2, 2, 0));\n\t\t\tskb->csum = c;\n\t\t}\n\n\t\tmemcpy(edsa_header, new_header, DSA_HLEN);\n	f
21762	484	efivar_init	drivers/firmware/efi/vars.c	variable_name_size	0	11	\N	\N	\tconst struct efivar_operations *ops = __efivars->ops;\n\tunsigned long variable_name_size = 1024;\n\tefi_char16_t *variable_name;\n\tefi_status_t status;\n\tefi_guid_t vendor_guid;\n\tint err = 0;\n\n\tvariable_name = kzalloc(variable_name_size, GFP_KERNEL);\n\tif (!variable_name) {\n\t\tprintk(KERN_ERR "efivars: Memory allocation failed.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (down_interruptible(&efivars_lock)) {\n\t\terr = -EINTR;\n\t\tgoto free;\n\t}\n\n\t/*\n\t * Per EFI spec, the maximum storage allocated for both\n\t * the variable name and variable data is 1024 bytes.\n\t */\n\n\tdo {\n\t\tvariable_name_size = 1024;\n\n\t\tstatus = ops->get_next_variable(&variable_name_size,\n\t\t\t\t\t\tvariable_name,\n\t\t\t\t\t\t&vendor_guid);\n\t\tswitch (status) {\n\t\tcase EFI_SUCCESS:\n\t\t\tif (duplicates)\n\t\t\t\tup(&efivars_lock);\n\n\t\t\tvariable_name_size = var_name_strnsize(variable_name,\n\t\t\t\t\t\t\t       variable_name_size);\n\n\t\t\t/*\n\t\t\t * Some firmware implementations return the\n\t\t\t * same variable name on multiple calls to\n\t\t\t * get_next_variable(). Terminate the loop\n\t\t\t * immediately as there is no guarantee that\n\t\t\t * we'll ever see a different variable name,\n\t\t\t * and may end up looping here forever.\n\t\t\t */\n\t\t\tif (duplicates &&\n\t\t\t    variable_is_present(variable_name, &vendor_guid,\n\t\t\t\t\t\thead)) {\n\t\t\t\tdup_variable_bug(variable_name, &vendor_guid,\n\t\t\t\t\t\t variable_name_size);\n\t\t\t\tstatus = EFI_NOT_FOUND;\n\t\t\t} else {\n\t\t\t\terr = func(variable_name, vendor_guid,\n	f
7225	547	atombios_crtc_program_ss	drivers/gpu/drm/radeon/atombios_crtc.c	index	1	11	\N	\N	\tunsigned i;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableSpreadSpectrumOnPPLL);\n\tunion atom_enable_ss args;\n\n\tif (enable) {\n\t\t/* Don't mess with SS if percentage is 0 or external ss.\n\t\t * SS is already disabled previously, and disabling it\n\t\t * again can cause display problems if the pll is already\n\t\t * programmed.\n\t\t */\n\t\tif (ss->percentage == 0)\n\t\t\treturn;\n\t\tif (ss->type & ATOM_EXTERNAL_SS_MASK)\n\t\t\treturn;\n\t} else {\n\t\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\t\tif (rdev->mode_info.crtcs[i] &&\n\t\t\t    rdev->mode_info.crtcs[i]->enabled &&\n\t\t\t    i != crtc_id &&\n\t\t\t    pll_id == rdev->mode_info.crtcs[i]->pll_id) {\n\t\t\t\t/* one other crtc is using this pll don't turn\n\t\t\t\t * off spread spectrum as it might turn off\n\t\t\t\t * display on active crtc\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (ASIC_IS_DCE5(rdev)) {\n\t\targs.v3.usSpreadSpectrumAmountFrac = cpu_to_le16(0);\n\t\targs.v3.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P1PLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P2PLL;\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_DCPLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t\targs.v3.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\n\t\targs.v3.usSpreadSpectrumStep = cpu_to_le16(ss->step);\n\t\targs.v3.ucEnable = enable;\n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\targs.v2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.v2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P1PLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P2PLL;\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_DCPLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t\targs.v2.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\n\t\targs.v2.usSpreadSpectrumStep = cpu_to_le16(ss->step);\n\t\targs.v2.ucEnable = enable;\n\t} else if (ASIC_IS_DCE3(rdev)) {\n\t\targs.v1.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.v1.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.v1.ucSpreadSpectrumStep = ss->step;\n\t\targs.v1.ucSpreadSpectrumDelay = ss->delay;\n\t\targs.v1.ucSpreadSpectrumRange = ss->range;\n\t\targs.v1.ucPpll = pll_id;\n\t\targs.v1.ucEnable = enable;\n\t} else if (ASIC_IS_AVIVO(rdev)) {\n\t\tif ((enable == ATOM_DISABLE) || (ss->percentage == 0) ||\n\t\t    (ss->type & ATOM_EXTERNAL_SS_MASK)) {\n\t\t\tatombios_disable_ss(rdev, pll_id);\n\t\t\treturn;\n\t\t}\n\t\targs.lvds_ss_2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.lvds_ss_2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.lvds_ss_2.ucSpreadSpectrumStep = ss->step;\n\t\targs.lvds_ss_2.ucSpreadSpectrumDelay = ss->delay;\n\t\targs.lvds_ss_2.ucSpreadSpectrumRange = ss->range;\n\t\targs.lvds_ss_2.ucEnable = enable;\n\t} else {\n\t\tif (enable == ATOM_DISABLE) {\n\t\t\tatombios_disable_ss(rdev, pll_id);\n\t\t\treturn;\n\t\t}\n\t\targs.lvds_ss.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.lvds_ss.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.lvds_ss.ucSpreadSpectrumStepSize_Delay = (ss->step & 3) << 2;\n\t\targs.lvds_ss.ucSpreadSpectrumStepSize_Delay |= (ss->delay & 7) << 4;\n\t\targs.lvds_ss.ucEnable = enable;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n	t
35040	3844	intel_map_sg	drivers/iommu/intel-iommu.c	start_vpfn	1	13	\N	\N	\tint i;\n\tstruct dmar_domain *domain;\n\tsize_t size = 0;\n\tint prot = 0;\n\tunsigned long iova_pfn;\n\tint ret;\n\tstruct scatterlist *sg;\n\tunsigned long start_vpfn;\n\tstruct intel_iommu *iommu;\n\n\tBUG_ON(dir == DMA_NONE);\n\tif (iommu_no_mapping(dev))\n\t\treturn intel_nontranslate_map_sg(dev, sglist, nelems, dir);\n\n\tdomain = get_valid_domain_for_dev(dev);\n\tif (!domain)\n\t\treturn 0;\n\n\tiommu = domain_get_iommu(domain);\n\n\tfor_each_sg(sglist, sg, nelems, i)\n\t\tsize += aligned_nrpages(sg->offset, sg->length);\n\n\tiova_pfn = intel_alloc_iova(dev, domain, dma_to_mm_pfn(size),\n\t\t\t\t*dev->dma_mask);\n\tif (!iova_pfn) {\n\t\tsglist->dma_length = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if DMAR supports zero-length reads on write only\n\t * mappings..\n\t */\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL || \\\n\t\t\t!cap_zlr(iommu->cap))\n\t\tprot |= DMA_PTE_READ;\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tprot |= DMA_PTE_WRITE;\n\n\tstart_vpfn = mm_to_dma_pfn(iova_pfn);\n\n\tret = domain_sg_mapping(domain, start_vpfn, sglist, size, prot);\n	f
35048	3395	ath6kl_wmi_ap_profile_commit	drivers/net/wireless/ath/ath6kl/wmi.c	cm	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_connect_cmd *cm;\n\tint res;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cm));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcm = (struct wmi_connect_cmd *) skb->data;\n\tmemcpy(cm, p, sizeof(*cm));\n	f
35881	392	mwifiex_uap_parse_tail_ies	drivers/net/wireless/marvell/mwifiex/ie.c	mwifiex_uap_parse_tail_ies_	0	11	\N	\N	\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t/* Many IEs are generated in FW by parsing bss configuration.\n\t * Let's not add them here; else we may end up duplicating these IEs\n\t */\n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr,\n\t\t\t       hdr->len + sizeof(struct ieee_types_header));\n\t\t\tie_len += hdr->len + sizeof(struct ieee_types_header);\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= hdr->len + sizeof(struct ieee_types_header);\n\t\tparsed_len += hdr->len + sizeof(struct ieee_types_header);\n\t}\n\n\t/* parse only WPA vendor IE from tail, WMM IE is configured by\n\t * bss_config command\n\t */\n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr,\n\t\t       vendorhdr->len + sizeof(struct ieee_types_header));\n\t\tie_len += vendorhdr->len + sizeof(struct ieee_types_header);\n\t}\n\n\tif (!ie_len) {\n\t\tkfree(gen_ie);\n\t\treturn 0;\n\t}\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n	f
53076	504	hfsplus_rename_cat	fs/hfsplus/catalog.c	&entry	0	11	\N	\N	\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, "rename_cat: %u - %lu,%s - %lu,%s\\n",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = current_time(dst_dir);\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = current_time(src_dir);\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n	f
46149	144	ip6_finish_output	net/ipv6/ip6_output.c	skb	0	11	\N	\N	\tint ret;\n\n\tret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && skb->len > IP6CB(skb)->frag_max_size))\n\t\treturn ip6_fragment(net, sk, skb, ip6_finish_output2);\n	f
1934	732	CARDvSetRSPINF	drivers/staging/vt6655/card.c	priv->PortOffset	1	11	\N	\N	\tunion vnt_phy_field_swap phy;\n\tunsigned char byTxRate, byRsvTime;      /* For OFDM */\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t/* Set to Page1 */\n\tMACvSelectPage1(priv->PortOffset);\n\n\t/* RSPINF_b_1 */\n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_1M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\t /* swap over to get correct write order */\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tVNSvOutPortD(priv->PortOffset + MAC_REG_RSPINF_B_1, phy.field_write);\n\n\t/* RSPINF_b_2 */\n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_2M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tVNSvOutPortD(priv->PortOffset + MAC_REG_RSPINF_B_2, phy.field_write);\n\n\t/* RSPINF_b_5 */\n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_5M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tVNSvOutPortD(priv->PortOffset + MAC_REG_RSPINF_B_5, phy.field_write);\n\n\t/* RSPINF_b_11 */\n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_11M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tVNSvOutPortD(priv->PortOffset + MAC_REG_RSPINF_B_11, phy.field_write);\n\n\t/* RSPINF_a_6 */\n\ts_vCalculateOFDMRParameter(RATE_6M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tVNSvOutPortW(priv->PortOffset + MAC_REG_RSPINF_A_6,\n	t
50428	1066	iomap_dio_rw	fs/iomap.c	dio	1	11	\N	\N	\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tsize_t count = iov_iter_count(iter);\n\tloff_t pos = iocb->ki_pos, start = pos;\n\tloff_t end = iocb->ki_pos + count - 1, ret = 0;\n\tunsigned int flags = IOMAP_DIRECT;\n\tstruct blk_plug plug;\n\tstruct iomap_dio *dio;\n\n\tlockdep_assert_held(&inode->i_rwsem);\n\n\tif (!count)\n\t\treturn 0;\n\n\tdio = kmalloc(sizeof(*dio), GFP_KERNEL);\n\tif (!dio)\n\t\treturn -ENOMEM;\n\n\tdio->iocb = iocb;\n\tatomic_set(&dio->ref, 1);\n\tdio->size = 0;\n\tdio->i_size = i_size_read(inode);\n\tdio->end_io = end_io;\n\tdio->error = 0;\n\tdio->flags = 0;\n\n\tdio->submit.iter = iter;\n\tif (is_sync_kiocb(iocb)) {\n\t\tdio->submit.waiter = current;\n\t\tdio->submit.cookie = BLK_QC_T_NONE;\n\t\tdio->submit.last_queue = NULL;\n\t}\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tif (pos >= dio->i_size)\n\t\t\tgoto out_free_dio;\n\n\t\tif (iter->type == ITER_IOVEC)\n\t\t\tdio->flags |= IOMAP_DIO_DIRTY;\n\t} else {\n\t\tdio->flags |= IOMAP_DIO_WRITE;\n\t\tflags |= IOMAP_WRITE;\n\t}\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (filemap_range_has_page(mapping, start, end)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_free_dio;\n\t\t}\n\t\tflags |= IOMAP_NOWAIT;\n\t}\n\n\tret = filemap_write_and_wait_range(mapping, start, end);\n\tif (ret)\n\t\tgoto out_free_dio;\n\n\tret = invalidate_inode_pages2_range(mapping,\n\t\t\tstart >> PAGE_SHIFT, end >> PAGE_SHIFT);\n\tWARN_ON_ONCE(ret);\n\tret = 0;\n\n\tif (iov_iter_rw(iter) == WRITE && !is_sync_kiocb(iocb) &&\n\t    !inode->i_sb->s_dio_done_wq) {\n\t\tret = sb_init_dio_done_wq(inode->i_sb);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_dio;\n\t}\n\n\tinode_dio_begin(inode);\n\n\tblk_start_plug(&plug);\n\tdo {\n\t\tret = iomap_apply(inode, pos, count, flags, ops, dio,\n\t\t\t\tiomap_dio_actor);\n\t\tif (ret <= 0) {\n\t\t\t/* magic error code to fall back to buffered I/O */\n\t\t\tif (ret == -ENOTBLK)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpos += ret;\n\n\t\tif (iov_iter_rw(iter) == READ && pos >= dio->i_size)\n\t\t\tbreak;\n\t} while ((count = iov_iter_count(iter)) > 0);\n\tblk_finish_plug(&plug);\n\n\tif (ret < 0)\n\t\tiomap_dio_set_error(dio, ret);\n\n\tif (!atomic_dec_and_test(&dio->ref)) {\n\t\tif (!is_sync_kiocb(iocb))\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!READ_ONCE(dio->submit.waiter))\n\t\t\t\tbreak;\n\n\t\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t\t    !dio->submit.last_queue ||\n\t\t\t    !blk_mq_poll(dio->submit.last_queue,\n\t\t\t\t\t dio->submit.cookie))\n\t\t\t\tio_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\n\tret = iomap_dio_complete(dio);\n	t
35089	2002	at76_hw_scan	drivers/net/wireless/atmel/at76c50x-usb.c	ret	1	13	\N	\N	\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct at76_priv *priv = hw->priv;\n\tstruct at76_req_scan scan;\n\tu8 *ssid = NULL;\n\tint ret, len = 0;\n\n\tat76_dbg(DBG_MAC80211, "%s():", __func__);\n\n\tif (priv->device_unplugged)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mtx);\n\n\tieee80211_stop_queues(hw);\n\n\tmemset(&scan, 0, sizeof(struct at76_req_scan));\n\teth_broadcast_addr(scan.bssid);\n\n\tif (req->n_ssids) {\n\t\tscan.scan_type = SCAN_TYPE_ACTIVE;\n\t\tssid = req->ssids[0].ssid;\n\t\tlen = req->ssids[0].ssid_len;\n\t} else {\n\t\tscan.scan_type = SCAN_TYPE_PASSIVE;\n\t}\n\n\tif (len) {\n\t\tmemcpy(scan.essid, ssid, len);\n\t\tscan.essid_size = len;\n\t}\n\n\tscan.min_channel_time = cpu_to_le16(priv->scan_min_time);\n\tscan.max_channel_time = cpu_to_le16(priv->scan_max_time);\n\tscan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);\n\tscan.international_scan = 0;\n\n\tat76_dbg(DBG_MAC80211, "%s: sending CMD_SCAN", __func__);\n\tret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));\n\n\tif (ret < 0) {\n	f
40673	6027	ext4_page_mkwrite	fs/ext4/inode.c	ext4_page_mkwrite_	1	-11	\N	\N	\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\n\tret = ext4_convert_inline_data(inode);\n\tif (ret)\n\t\tgoto out_ret;\n\n\t/* Delalloc case is easy... */\n\tif (test_opt(inode->i_sb, DELALLOC) &&\n\t    !ext4_should_journal_data(inode) &&\n	f
23446	549	do_blk_trace_setup	kernel/trace/blktrace.c	bt	0	11	\N	\N	\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tif (!blk_debugfs_root)\n\t\tgoto err;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file("dropped", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file("msg", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open("trace", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tif (atomic_inc_return(&blk_probes_ref) == 1)\n\t\tblk_register_tracepoints();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n	f
24131	296	efivar_store_raw	drivers/firmware/efi/efivars.c	size	0	11	\N	\N	\tstruct efi_variable *new_var, *var = &entry->var;\n\tefi_char16_t *name;\n\tunsigned long size;\n\tefi_guid_t vendor;\n\tu32 attributes;\n\tu8 *data;\n\tint err;\n\n\tif (is_compat()) {\n\t\tstruct compat_efi_variable *compat;\n\n\t\tif (count != sizeof(*compat))\n\t\t\treturn -EINVAL;\n\n\t\tcompat = (struct compat_efi_variable *)buf;\n\t\tattributes = compat->Attributes;\n\t\tvendor = compat->VendorGuid;\n\t\tname = compat->VariableName;\n\t\tsize = compat->DataSize;\n\t\tdata = compat->Data;\n\n\t\terr = sanity_check(var, name, vendor, size, attributes, data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_out_compat(&entry->var, compat);\n\t} else {\n\t\tif (count != sizeof(struct efi_variable))\n\t\t\treturn -EINVAL;\n\n\t\tnew_var = (struct efi_variable *)buf;\n\n\t\tattributes = new_var->Attributes;\n\t\tvendor = new_var->VendorGuid;\n\t\tname = new_var->VariableName;\n\t\tsize = new_var->DataSize;\n\t\tdata = new_var->Data;\n\n\t\terr = sanity_check(var, name, vendor, size, attributes, data);\n	f
24271	95	compat_exit_robust_list	kernel/futex_compat.c	pending	0	11	\N	\N	\tstruct compat_robust_list_head __user *head = curr->compat_robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tcompat_uptr_t uentry, next_uentry, upending;\n\tcompat_long_t futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&uentry, &entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&upending, &pending,\n\t\t\t       &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != (struct robust_list __user *) &head->list) {\n\t\t/*\n\t\t * Fetch the next entry in the list before calling\n\t\t * handle_futex_death:\n\t\t */\n\t\trc = fetch_robust_entry(&next_uentry, &next_entry,\n\t\t\t(compat_uptr_t __user *)&entry->next, &next_pi);\n\t\t/*\n\t\t * A pending lock might already be on the list, so\n\t\t * dont process it twice:\n\t\t */\n\t\tif (entry != pending) {\n	f
25193	89	kiblnd_tx_done	drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c	lntmsg	0	11	\N	\N	\tstruct lnet_msg *lntmsg[2];\n\tstruct kib_net *net = ni->ni_data;\n\tint rc;\n\tint i;\n\n\tLASSERT(net);\n\tLASSERT(!in_interrupt());\n\tLASSERT(!tx->tx_queued);\t       /* mustn't be queued for sending */\n\tLASSERT(!tx->tx_sending);\t  /* mustn't be awaiting sent callback */\n\tLASSERT(!tx->tx_waiting);\t      /* mustn't be awaiting peer response */\n\tLASSERT(tx->tx_pool);\n\n\tkiblnd_unmap_tx(ni, tx);\n\n\t/* tx may have up to 2 lnet msgs to finalise */\n\tlntmsg[0] = tx->tx_lntmsg[0]; tx->tx_lntmsg[0] = NULL;\n\tlntmsg[1] = tx->tx_lntmsg[1]; tx->tx_lntmsg[1] = NULL;\n\trc = tx->tx_status;\n\n\tif (tx->tx_conn) {\n\t\tLASSERT(ni == tx->tx_conn->ibc_peer->ibp_ni);\n\n\t\tkiblnd_conn_decref(tx->tx_conn);\n\t\ttx->tx_conn = NULL;\n\t}\n\n\ttx->tx_nwrq = 0;\n\ttx->tx_status = 0;\n\n\tkiblnd_pool_free_node(&tx->tx_pool->tpo_pool, &tx->tx_list);\n\n\t/* delay finalize until my descs have been freed */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!lntmsg[i])\n	f
27185	270	hsi_add_client_from_dt	drivers/hsi/hsi_core.c	cells	0	11	\N	\N	\tstruct hsi_client *cl;\n\tstruct hsi_channel channel;\n\tstruct property *prop;\n\tchar name[32];\n\tint length, cells, err, i, max_chan, mode;\n\n\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\treturn;\n\n\terr = of_modalias_node(client, name, sizeof(name));\n\tif (err)\n\t\tgoto err;\n\n\tdev_set_name(&cl->device, "%s", name);\n\n\terr = hsi_of_property_parse_mode(client, "hsi-mode", &mode);\n\tif (err) {\n\t\terr = hsi_of_property_parse_mode(client, "hsi-rx-mode",\n\t\t\t\t\t\t &cl->rx_cfg.mode);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = hsi_of_property_parse_mode(client, "hsi-tx-mode",\n\t\t\t\t\t\t &cl->tx_cfg.mode);\n\t\tif (err)\n\t\t\tgoto err;\n\t} else {\n\t\tcl->rx_cfg.mode = mode;\n\t\tcl->tx_cfg.mode = mode;\n\t}\n\n\terr = of_property_read_u32(client, "hsi-speed-kbps",\n\t\t\t\t   &cl->tx_cfg.speed);\n\tif (err)\n\t\tgoto err;\n\tcl->rx_cfg.speed = cl->tx_cfg.speed;\n\n\terr = hsi_of_property_parse_flow(client, "hsi-flow",\n\t\t\t\t\t &cl->rx_cfg.flow);\n\tif (err)\n\t\tgoto err;\n\n\terr = hsi_of_property_parse_arb_mode(client, "hsi-arb-mode",\n\t\t\t\t\t     &cl->rx_cfg.arb_mode);\n\tif (err)\n\t\tgoto err;\n\n\tprop = of_find_property(client, "hsi-channel-ids", &length);\n\tif (!prop) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcells = length / sizeof(u32);\n\n\tcl->rx_cfg.num_channels = cells;\n\tcl->tx_cfg.num_channels = cells;\n\tcl->rx_cfg.channels = kcalloc(cells, sizeof(channel), GFP_KERNEL);\n	f
35129	3406	prism2_ioctl_giwencodeext	drivers/net/wireless/intersil/hostap/hostap_ioctl.c	crypt	1	13	\N	\N	\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tstruct lib80211_crypt_data **crypt;\n\tvoid *sta_ptr;\n\tint max_key_len, i;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\n\tu8 *addr;\n\n\tmax_key_len = erq->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\ti = erq->flags & IW_ENCODE_INDEX;\n\tif (i < 1 || i > WEP_KEYS)\n\t\ti = local->crypt_info.tx_keyidx;\n\telse\n\t\ti--;\n\n\taddr = ext->addr.sa_data;\n\tif (is_broadcast_ether_addr(addr)) {\n\t\tsta_ptr = NULL;\n\t\tcrypt = &local->crypt_info.crypt[i];\n\t} else {\n\t\ti = 0;\n\t\tsta_ptr = ap_crypt_get_ptrs(local->ap, addr, 0, &crypt);\n\t\tif (sta_ptr == NULL)\n\t\t\treturn -EINVAL;\n\t}\n\terq->flags = i + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tif (*crypt == NULL || (*crypt)->ops == NULL) {\n	f
31127	1871	bitmap_create	drivers/md/bitmap.c	bitmap	0	11	\N	\N	\tstruct bitmap *bitmap;\n\tsector_t blocks = mddev->resync_max_sectors;\n\tstruct file *file = mddev->bitmap_info.file;\n\tint err;\n\tstruct kernfs_node *bm = NULL;\n\n\tBUILD_BUG_ON(sizeof(bitmap_super_t) != 256);\n\n\tBUG_ON(file && mddev->bitmap_info.offset);\n\n\tbitmap = kzalloc(sizeof(*bitmap), GFP_KERNEL);\n\tif (!bitmap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&bitmap->counts.lock);\n\tatomic_set(&bitmap->pending_writes, 0);\n\tinit_waitqueue_head(&bitmap->write_wait);\n\tinit_waitqueue_head(&bitmap->overflow_wait);\n\tinit_waitqueue_head(&bitmap->behind_wait);\n\n\tbitmap->mddev = mddev;\n\tbitmap->cluster_slot = slot;\n\n\tif (mddev->kobj.sd)\n\t\tbm = sysfs_get_dirent(mddev->kobj.sd, "bitmap");\n\tif (bm) {\n\t\tbitmap->sysfs_can_clear = sysfs_get_dirent(bm, "can_clear");\n\t\tsysfs_put(bm);\n\t} else\n\t\tbitmap->sysfs_can_clear = NULL;\n\n\tbitmap->storage.file = file;\n\tif (file) {\n\t\tget_file(file);\n\t\t/* As future accesses to this file will use bmap,\n\t\t * and bypass the page cache, we must sync the file\n\t\t * first.\n\t\t */\n\t\tvfs_fsync(file, 1);\n\t}\n\t/* read superblock from bitmap file (this sets mddev->bitmap_info.chunksize) */\n\tif (!mddev->bitmap_info.external) {\n\t\t/*\n\t\t * If 'MD_ARRAY_FIRST_USE' is set, then device-mapper is\n\t\t * instructing us to create a new on-disk bitmap instance.\n\t\t */\n\t\tif (test_and_clear_bit(MD_ARRAY_FIRST_USE, &mddev->flags))\n\t\t\terr = bitmap_new_disk_sb(bitmap);\n\t\telse\n\t\t\terr = bitmap_read_sb(bitmap);\n\t} else {\n\t\terr = 0;\n\t\tif (mddev->bitmap_info.chunksize == 0 ||\n\t\t    mddev->bitmap_info.daemon_sleep == 0)\n\t\t\t/* chunksize and time_base need to be\n\t\t\t * set first. */\n\t\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto error;\n\n\tbitmap->daemon_lastrun = jiffies;\n\terr = bitmap_resize(bitmap, blocks, mddev->bitmap_info.chunksize, 1);\n	f
34406	1446	find_extent_clone	fs/btrfs/send.c	num_bytes	0	11	\N	\N	\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_KERNEL);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbackref_ctx->path = tmp_path;\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&fs_info->commit_root_sem);\n\tret = extent_from_logical(fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&fs_info->commit_root_sem);\n\tbtrfs_release_path(tmp_path);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\t/*\n\t * For non-compressed extents iterate_extent_inodes() gives us extent\n\t * offsets that already take into account the data offset, but not for\n\t * compressed extents, since the offset is logical and not relative to\n\t * the physical extent locations. We must take this into account to\n\t * avoid sending clone offsets that go beyond the source file's size,\n\t * which would result in the clone ioctl failing with -EINVAL on the\n\t * receiving end.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\tbackref_ctx->data_offset = 0;\n\telse\n\t\tbackref_ctx->data_offset = btrfs_file_extent_offset(eb, fi);\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t    extent_item_pos, 1, __iterate_backrefs,\n\t\t\t\t    backref_ctx);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(fs_info,\n\t\t\t  "did not find backref in send_root. inode=%llu, offset=%llu, disk_byte=%llu found extent=%llu",\n\t\t\t  ino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\n\tbtrfs_debug(fs_info,\n	f
34441	6067	changed_extent	fs/btrfs/send.c	changed_extent_	0	11	\N	\N	\tint ret = 0;\n\n\tif (sctx->cur_ino != sctx->cmp_key->objectid) {\n\n\t\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t\tstruct extent_buffer *leaf_l;\n\t\t\tstruct extent_buffer *leaf_r;\n\t\t\tstruct btrfs_file_extent_item *ei_l;\n\t\t\tstruct btrfs_file_extent_item *ei_r;\n\n\t\t\tleaf_l = sctx->left_path->nodes[0];\n\t\t\tleaf_r = sctx->right_path->nodes[0];\n\t\t\tei_l = btrfs_item_ptr(leaf_l,\n\t\t\t\t\t      sctx->left_path->slots[0],\n\t\t\t\t\t      struct btrfs_file_extent_item);\n\t\t\tei_r = btrfs_item_ptr(leaf_r,\n\t\t\t\t\t      sctx->right_path->slots[0],\n\t\t\t\t\t      struct btrfs_file_extent_item);\n\n\t\t\t/*\n\t\t\t * We may have found an extent item that has changed\n\t\t\t * only its disk_bytenr field and the corresponding\n\t\t\t * inode item was not updated. This case happens due to\n\t\t\t * very specific timings during relocation when a leaf\n\t\t\t * that contains file extent items is COWed while\n\t\t\t * relocation is ongoing and its in the stage where it\n\t\t\t * updates data pointers. So when this happens we can\n\t\t\t * safely ignore it since we know it's the same extent,\n\t\t\t * but just at different logical and physical locations\n\t\t\t * (when an extent is fully replaced with a new one, we\n\t\t\t * know the generation number must have changed too,\n\t\t\t * since snapshot creation implies committing the current\n\t\t\t * transaction, and the inode item must have been updated\n\t\t\t * as well).\n\t\t\t * This replacement of the disk_bytenr happens at\n\t\t\t * relocation.c:replace_file_extents() through\n\t\t\t * relocation.c:btrfs_reloc_cow_block().\n\t\t\t */\n\t\t\tif (btrfs_file_extent_generation(leaf_l, ei_l) ==\n	f
35228	1210	qla82xx_pinit_from_rom	drivers/scsi/qla2xxx/qla_nx.c	n	1	13	\N	\N	\tint addr, val;\n\tint i ;\n\tstruct crb_addr_pair *buf;\n\tunsigned long off;\n\tunsigned offset, n;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tstruct crb_addr_pair {\n\t\tlong addr;\n\t\tlong data;\n\t};\n\n\t/* Halt all the individual PEGs and other blocks of the ISP */\n\tqla82xx_rom_lock(ha);\n\n\t/* disable all I2Q */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\n\n\t/* disable all niu interrupts */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\n\t/* disable xge rx/tx */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\n\t/* disable xg1 rx/tx */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\n\t/* disable sideband mac */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\n\t/* disable ap0 mac */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\n\t/* disable ap1 mac */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\n\n\t/* halt sre */\n\tval = qla82xx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\n\n\t/* halt epg */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\n\n\t/* halt timers */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\n\n\t/* halt pegs */\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\n\tmsleep(20);\n\n\t/* big hammer */\n\tif (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\n\t\t/* don't reset CAM block on reset */\n\t\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\n\telse\n\t\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\n\tqla82xx_rom_unlock(ha);\n\n\t/* Read the signature value from the flash.\n\t * Offset 0: Contain signature (0xcafecafe)\n\t * Offset 4: Offset and number of addr/value pairs\n\t * that present in CRB initialize sequence\n\t */\n\tif (qla82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\n	f
35574	1112	ndisc_ra_useropt	net/ipv6/ndisc.c	skb	1	13	\N	\N	\tstruct icmp6hdr *icmp6h = (struct icmp6hdr *)skb_transport_header(ra);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tstruct nduseroptmsg *ndmsg;\n\tstruct net *net = dev_net(ra->dev);\n\tint err;\n\tint base_size = NLMSG_ALIGN(sizeof(struct nduseroptmsg)\n\t\t\t\t    + (opt->nd_opt_len << 3));\n\tsize_t msg_size = base_size + nla_total_size(sizeof(struct in6_addr));\n\n\tskb = nlmsg_new(msg_size, GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWNDUSEROPT, base_size, 0);\n	f
35598	1717	mwl8k_txq_reclaim	drivers/net/wireless/marvell/mwl8k.c	sta_info	1	13	\N	\N	\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_tx_queue *txq = priv->txq + index;\n\tint processed;\n\n\tprocessed = 0;\n\twhile (txq->len > 0 && limit--) {\n\t\tint tx;\n\t\tstruct mwl8k_tx_desc *tx_desc;\n\t\tunsigned long addr;\n\t\tint size;\n\t\tstruct sk_buff *skb;\n\t\tstruct ieee80211_tx_info *info;\n\t\tu32 status;\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct mwl8k_sta *sta_info = NULL;\n\t\tu16 rate_info;\n\t\tstruct ieee80211_hdr *wh;\n\n\t\ttx = txq->head;\n\t\ttx_desc = txq->txd + tx;\n\n\t\tstatus = le32_to_cpu(tx_desc->status);\n\n\t\tif (status & MWL8K_TXD_STATUS_FW_OWNED) {\n\t\t\tif (!force)\n\t\t\t\tbreak;\n\t\t\ttx_desc->status &=\n\t\t\t\t~cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED);\n\t\t}\n\n\t\ttxq->head = (tx + 1) % MWL8K_TX_DESCS;\n\t\tBUG_ON(txq->len == 0);\n\t\ttxq->len--;\n\t\tpriv->pending_tx_pkts--;\n\n\t\taddr = le32_to_cpu(tx_desc->pkt_phys_addr);\n\t\tsize = le16_to_cpu(tx_desc->pkt_len);\n\t\tskb = txq->skb[tx];\n\t\ttxq->skb[tx] = NULL;\n\n\t\tBUG_ON(skb == NULL);\n\t\tpci_unmap_single(priv->pdev, addr, size, PCI_DMA_TODEVICE);\n\n\t\tmwl8k_remove_dma_header(skb, tx_desc->qos_control);\n\n\t\twh = (struct ieee80211_hdr *) skb->data;\n\n\t\t/* Mark descriptor as unused */\n\t\ttx_desc->pkt_phys_addr = 0;\n\t\ttx_desc->pkt_len = 0;\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\tif (ieee80211_is_data(wh->frame_control)) {\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta_by_ifaddr(hw, wh->addr1,\n\t\t\t\t\t\t\t   wh->addr2);\n\t\t\tif (sta) {\n\t\t\t\tsta_info = MWL8K_STA(sta);\n\t\t\t\tBUG_ON(sta_info == NULL);\n	f
4863	961	odm_rx_phy_status_jaguar_series_parsing	drivers/staging/rtlwifi/phydm/phydm_hwconfig.c	rx_pwr[i]	1	11	\N	\N	\tu8 i, max_spatial_stream;\n\ts8 rx_pwr[4], rx_pwr_all = 0;\n\tu8 EVM = 0, evm_dbm, pwdb_all = 0, pwdb_all_bt;\n\tu8 RSSI, avg_rssi = 0, best_rssi = 0, second_rssi = 0;\n\tu8 is_cck_rate = 0;\n\tu8 rf_rx_num = 0;\n\tu8 cck_highpwr = 0;\n\tu8 LNA_idx, VGA_idx;\n\tstruct phy_status_rpt_8812 *phy_sta_rpt =\n\t\t(struct phy_status_rpt_8812 *)phy_status;\n\tstruct fast_antenna_training *fat_tab = &dm->dm_fat_table;\n\tu8 num_ss;\n\n\todm_rx_phy_bw_jaguar_series_parsing(phy_info, pktinfo, phy_sta_rpt);\n\n\tif (pktinfo->data_rate <= ODM_RATE11M)\n\t\tis_cck_rate = true;\n\telse\n\t\tis_cck_rate = false;\n\n\tif (pktinfo->is_to_self)\n\t\tdm->curr_station_id = pktinfo->station_id;\n\telse\n\t\tdm->curr_station_id = 0xff;\n\n\tphy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = -1;\n\tphy_info->rx_mimo_signal_quality[ODM_RF_PATH_B] = -1;\n\tphy_info->rx_mimo_signal_quality[ODM_RF_PATH_C] = -1;\n\tphy_info->rx_mimo_signal_quality[ODM_RF_PATH_D] = -1;\n\n\tif (is_cck_rate) {\n\t\tu8 cck_agc_rpt;\n\n\t\tdm->phy_dbg_info.num_qry_phy_status_cck++;\n\n\t\t/*(1)Hardware does not provide RSSI for CCK*/\n\t\t/*(2)PWDB, Average PWDB calculated by hardware (for RA)*/\n\n\t\tcck_highpwr = dm->is_cck_high_power;\n\n\t\tcck_agc_rpt = phy_sta_rpt->cfosho[0];\n\t\tLNA_idx = ((cck_agc_rpt & 0xE0) >> 5);\n\t\tVGA_idx = (cck_agc_rpt & 0x1F);\n\n\t\tif (dm->support_ic_type == ODM_RTL8812) {\n\t\t\trx_pwr_all =\n\t\t\t\tphydm_get_rx_pwr(LNA_idx, VGA_idx, cck_highpwr);\n\t\t\trx_pwr_all += 6;\n\t\t\tpwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);\n\t\t\tpwdb_all = phydm_adjust_pwdb(cck_highpwr, pwdb_all);\n\n\t\t} else if (dm->support_ic_type & (ODM_RTL8821 | ODM_RTL8881A)) {\n\t\t\ts8 pout = -6;\n\n\t\t\tswitch (LNA_idx) {\n\t\t\tcase 5:\n\t\t\t\trx_pwr_all = pout - 32 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\trx_pwr_all = pout - 24 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trx_pwr_all = pout - 11 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trx_pwr_all = pout + 5 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\trx_pwr_all = pout + 21 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);\n\t\t} else if (dm->support_ic_type == ODM_RTL8814A ||\n\t\t\t   dm->support_ic_type == ODM_RTL8822B) {\n\t\t\ts8 pout = -6;\n\n\t\t\tswitch (LNA_idx) {\n\t\t\t/*CCK only use LNA: 2, 3, 5, 7*/\n\t\t\tcase 7:\n\t\t\t\trx_pwr_all = pout - 32 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\trx_pwr_all = pout - 22 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\trx_pwr_all = pout - 2 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trx_pwr_all = pout + 5 - (2 * VGA_idx);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);\n\t\t}\n\n\t\tdm->cck_lna_idx = LNA_idx;\n\t\tdm->cck_vga_idx = VGA_idx;\n\t\tphy_info->rx_pwdb_all = pwdb_all;\n\t\tphy_info->bt_rx_rssi_percentage = pwdb_all;\n\t\tphy_info->recv_signal_power = rx_pwr_all;\n\t\t/*(3) Get Signal Quality (EVM)*/\n\t\t{\n\t\t\tu8 sq;\n\n\t\t\tif ((dm->support_platform == ODM_WIN) &&\n\t\t\t    (dm->patch_id == RT_CID_819X_LENOVO))\n\t\t\t\tsq = odm_sq_process_patch_rt_cid_819x_lenovo(\n\t\t\t\t\tdm, is_cck_rate, pwdb_all, 0, 0);\n\t\t\telse\n\t\t\t\tsq = phydm_get_signal_quality_8812(phy_info, dm,\n\t\t\t\t\t\t\t\t   phy_sta_rpt);\n\n\t\t\tphy_info->signal_quality = sq;\n\t\t\tphy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = sq;\n\t\t}\n\n\t\tfor (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {\n\t\t\tif (i == 0)\n\t\t\t\tphy_info->rx_mimo_signal_strength[0] = pwdb_all;\n\t\t\telse\n\t\t\t\tphy_info->rx_mimo_signal_strength[i] = 0;\n\t\t}\n\t} else {\n\t\t/*is OFDM rate*/\n\t\tfat_tab->hw_antsw_occur = phy_sta_rpt->hw_antsw_occur;\n\n\t\tdm->phy_dbg_info.num_qry_phy_status_ofdm++;\n\n\t\t/*(1)Get RSSI for OFDM rate*/\n\n\t\tfor (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {\n\t\t\t/*2008/01/30 MH we will judge RF RX path now.*/\n\t\t\tif (dm->rf_path_rx_enable & BIT(i))\n\t\t\t\trf_rx_num++;\n\t\t\t/*2012.05.25 LukeLee: Testchip AGC report is wrong,\n\t\t\t *it should be restored back to old formula in MP chip\n\t\t\t */\n\t\t\tif (i < ODM_RF_PATH_C)\n\t\t\t\trx_pwr[i] = (phy_sta_rpt->gain_trsw[i] & 0x7F) -\n\t\t\t\t\t    110;\n\t\t\telse\n\t\t\t\trx_pwr[i] = (phy_sta_rpt->gain_trsw_cd[i - 2] &\n\t\t\t\t\t     0x7F) -\n\t\t\t\t\t    110;\n\n\t\t\tphy_info->rx_pwr[i] = rx_pwr[i];\n\n\t\t\t/* Translate DBM to percentage. */\n\t\t\tRSSI = odm_query_rx_pwr_percentage(rx_pwr[i]);\n	t
44993	789	ovl_lower_positive	fs/overlayfs/namei.c	this->d_inode	1	11	\N	\N	\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct ovl_entry *poe = dentry->d_parent->d_fsdata;\n\tconst struct qstr *name = &dentry->d_name;\n\tunsigned int i;\n\tbool positive = false;\n\tbool done = false;\n\n\t/*\n\t * If dentry is negative, then lower is positive iff this is a\n\t * whiteout.\n\t */\n\tif (!dentry->d_inode)\n\t\treturn oe->opaque;\n\n\t/* Negative upper -> positive lower */\n\tif (!ovl_dentry_upper(dentry))\n\t\treturn true;\n\n\t/* Positive upper -> have to look up lower to see whether it exists */\n\tfor (i = 0; !done && !positive && i < poe->numlower; i++) {\n\t\tstruct dentry *this;\n\t\tstruct dentry *lowerdir = poe->lowerstack[i].dentry;\n\n\t\tthis = lookup_one_len_unlocked(name->name, lowerdir,\n\t\t\t\t\t       name->len);\n\t\tif (IS_ERR(this)) {\n\t\t\tswitch (PTR_ERR(this)) {\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENAMETOOLONG:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Assume something is there, we just couldn't\n\t\t\t\t * access it.\n\t\t\t\t */\n\t\t\t\tpositive = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this->d_inode) {\n	t
57185	2253	dib9000_read_signal_strength	drivers/media/dvb-frontends/dib9000.c	val	1	11	\N	\N	\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu16 *c = (u16 *)state->i2c_read_buffer;\n\tu16 val;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk("could not get the lock\\n");\n\t\treturn -EINTR;\n\t}\n\t*strength = 0;\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\n\t\tif (val > 65535 - *strength)\n	t
58863	850	ubifs_unlink	fs/ubifs/dir.c	&nm	1	11	\N	\N	\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint err, sz_change, budgeted = 1;\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\tunsigned int saved_nlink = inode->i_nlink;\n\tstruct fscrypt_name nm;\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode (+1 for\n\t * @dirtied_ino), changing the parent directory inode. If budgeting\n\t * fails, go ahead anyway because we have extra space reserved for\n\t * deletions.\n\t */\n\n\tdbg_gen("dent '%pd' from ino %lu (nlink %d) in dir ino %lu",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\n\tif (ubifs_crypt_is_encrypted(dir)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err && err != -ENOKEY)\n\t\t\treturn err;\n\t}\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 1, &nm);\n\tif (err)\n\t\treturn err;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tubifs_assert(inode_is_locked(dir));\n\tubifs_assert(inode_is_locked(inode));\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\tgoto out_fname;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\tgoto out_fname;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = current_time(dir);\n\tdrop_nlink(inode);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 1, 0);\n	t
63197	780	apparmor_bprm_set_creds	security/apparmor/domain.c	new	1	11	\N	\N	\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *new = NULL;\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\tbool unsafe = false;\n\tstruct path_cond cond = {\n\t\tfile_inode(bprm->file)->i_uid,\n\t\tfile_inode(bprm->file)->i_mode\n\t};\n\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n\n\tctx = cred_ctx(bprm->cred);\n\tAA_BUG(!ctx);\n\n\tlabel = aa_get_newest_label(ctx->label);\n\n\t/* buffer freed below, name is pointer into buffer */\n\tget_buffers(buffer);\n\t/* Test for onexec first as onexec override other x transitions. */\n\tif (ctx->onexec)\n\t\tnew = handle_onexec(label, ctx->onexec, ctx->token,\n\t\t\t\t    bprm, buffer, &cond, &unsafe);\n\telse\n\t\tnew = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   &cond, &unsafe));\n\n\tAA_BUG(!new);\n	t
35600	903	dummy_pullup	drivers/usb/gadget/udc/dummy_hcd.c	dum_hcd	1	13	\N	\N	\tstruct dummy_hcd *dum_hcd;\n\tstruct dummy\t*dum;\n\tunsigned long\tflags;\n\n\tdum = gadget_dev_to_dummy(&_gadget->dev);\n\tdum_hcd = gadget_to_dummy_hcd(_gadget);\n\n\tspin_lock_irqsave(&dum->lock, flags);\n\tdum->pullup = (value != 0);\n\tset_link_state(dum_hcd);\n	f
54060	4271	fixup_bpf_calls	kernel/bpf/verifier.c	prog->aux->ops	0	11	\N	\N	\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tenv->prog->aux->stack_depth = MAX_BPF_STACK;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * handlers are currently limited to 64 bit only.\n\t\t */\n\t\tif (ebpf_jit_enabled() && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_map_lookup_elem) {\n\t\t\tmap_ptr = env->insn_aux_data[i + delta].map_ptr;\n\t\t\tif (map_ptr == BPF_MAP_PTR_POISON ||\n\t\t\t    !map_ptr->ops->map_gen_lookup)\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tcnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose("bpf verifier is misconfigured\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta += cnt - 1;\n\n\t\t\t/* keep walking new program and skip insns we just inserted */\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->imm == BPF_FUNC_redirect_map) {\n\t\t\t/* Note, we cannot use prog directly as imm as subsequent\n\t\t\t * rewrites would still change the prog pointer. The only\n\t\t\t * stable address we can use is aux, which also works with\n\t\t\t * prog clones during blinding.\n\t\t\t */\n\t\t\tu64 addr = (unsigned long)prog->aux;\n\t\t\tstruct bpf_insn r4_ld[] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_4, addr),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tcnt = ARRAY_SIZE(r4_ld);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, r4_ld, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t}\npatch_call_imm:\n\t\tfn = prog->aux->ops->get_func_proto(insn->imm);\n	f
54245	187	ext4_readdir	fs/ext4/dir.c	inode->i_blocks	0	11	\N	\N	\tunsigned int offset;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tint dir_has_error = 0;\n\tstruct fscrypt_str fstr = FSTR_INIT(NULL, 0);\n\n\tif (ext4_encrypted_inode(inode)) {\n\t\terr = fscrypt_get_encryption_info(inode);\n\t\tif (err && err != -ENOKEY)\n\t\t\treturn err;\n\t}\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext4_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR) {\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * We don't set the inode dirty flag since it's not\n\t\t * critical that it get flushed back to the disk.\n\t\t */\n\t\text4_clear_inode_flag(file_inode(file),\n\t\t\t\t      EXT4_INODE_INDEX);\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_read_inline_dir(file, ctx,\n\t\t\t\t\t   &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_encrypted_inode(inode)) {\n\t\terr = fscrypt_fname_alloc_buffer(inode, EXT4_NAME_LEN, &fstr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tstruct ext4_map_blocks map;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto errout;\n\t\t}\n\t\tcond_resched();\n\t\tmap.m_lblk = ctx->pos >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\tmap.m_len = 1;\n\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map.m_pblk >>\n\t\t\t\t\t(PAGE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_SHIFT;\n\t\t\tbh = ext4_bread(NULL, inode, map.m_lblk, 0);\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\terr = PTR_ERR(bh);\n\t\t\t\tbh = NULL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (!bh) {\n\t\t\tif (!dir_has_error) {\n\t\t\t\tEXT4_ERROR_FILE(file, 0,\n\t\t\t\t\t\t"directory contains a "\n\t\t\t\t\t\t"hole at offset %llu",\n\t\t\t\t\t   (unsigned long long) ctx->pos);\n\t\t\t\tdir_has_error = 1;\n\t\t\t}\n\t\t\t/* corrupt size?  Maybe no more blocks to read */\n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n	f
47499	2065	fcoe_ctlr_vn_send	drivers/scsi/fcoe/fcoe_ctlr.c	frame->eth.h_source + 3	1	11	\N	\N	\tstruct sk_buff *skb;\n\tstruct fip_vn2vn_probe_frame {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct fip_mac_desc mac;\n\t\tstruct fip_wwn_desc wwnn;\n\t\tstruct fip_vn_desc vn;\n\t} __packed * frame;\n\tstruct fip_fc4_feat *ff;\n\tstruct fip_size_desc *size;\n\tu32 fcp_feat;\n\tsize_t len;\n\tsize_t dlen;\n\n\tlen = sizeof(*frame);\n\tdlen = 0;\n\tif (sub == FIP_SC_VN_CLAIM_NOTIFY || sub == FIP_SC_VN_CLAIM_REP) {\n\t\tdlen = sizeof(struct fip_fc4_feat) +\n\t\t       sizeof(struct fip_size_desc);\n\t\tlen += dlen;\n\t}\n\tdlen += sizeof(frame->mac) + sizeof(frame->wwnn) + sizeof(frame->vn);\n\tlen = max(len, min_len + sizeof(struct ethhdr));\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\tframe = (struct fip_vn2vn_probe_frame *)skb->data;\n\tmemset(frame, 0, len);\n\tmemcpy(frame->eth.h_dest, dest, ETH_ALEN);\n\n\tif (sub == FIP_SC_VN_BEACON) {\n\t\thton24(frame->eth.h_source, FIP_VN_FC_MAP);\n\t\thton24(frame->eth.h_source + 3, fip->port_id);\n	t
55198	2250	ace_open	drivers/net/ethernet/alteon/acenic.c	&cmd	1	11	\N	\N	\tstruct ace_private *ap = netdev_priv(dev);\n\tstruct ace_regs __iomem *regs = ap->regs;\n\tstruct cmd cmd;\n\n\tif (!(ap->fw_running)) {\n\t\tprintk(KERN_WARNING "%s: Firmware not running!\\n", dev->name);\n\t\treturn -EBUSY;\n\t}\n\n\twritel(dev->mtu + ETH_HLEN + 4, &regs->IfMtu);\n\n\tcmd.evt = C_CLEAR_STATS;\n\tcmd.code = 0;\n\tcmd.idx = 0;\n\tace_issue_cmd(regs, &cmd);\n	t
59912	1835	hp100_rx	drivers/net/ethernet/hp/hp100.c	ptr	1	11	\N	\N	\tint packets, pkt_len;\n\tint ioaddr = dev->base_addr;\n\tstruct hp100_private *lp = netdev_priv(dev);\n\tu_int header;\n\tstruct sk_buff *skb;\n\n#ifdef DEBUG_B\n\thp100_outw(0x4213, TRACE);\n\tprintk("hp100: %s: rx\\n", dev->name);\n#endif\n\n\t/* First get indication of received lan packet */\n\t/* RX_PKT_CND indicates the number of packets which have been fully */\n\t/* received onto the card but have not been fully transferred of the card */\n\tpackets = hp100_inb(RX_PKT_CNT);\n#ifdef HP100_DEBUG_RX\n\tif (packets > 1)\n\t\tprintk("hp100: %s: rx: waiting packets = %d\\n", dev->name, packets);\n#endif\n\n\twhile (packets-- > 0) {\n\t\t/* If ADV_NXT_PKT is still set, we have to wait until the card has */\n\t\t/* really advanced to the next packet. */\n\t\tfor (pkt_len = 0; pkt_len < 6000 && (hp100_inb(OPTION_MSW) & HP100_ADV_NXT_PKT); pkt_len++) {\n#ifdef HP100_DEBUG_RX\n\t\t\tprintk ("hp100: %s: rx: busy, remaining packets = %d\\n", dev->name, packets);\n#endif\n\t\t}\n\n\t\t/* First we get the header, which contains information about the */\n\t\t/* actual length of the received packet. */\n\t\tif (lp->mode == 2) {\t/* memory mapped mode */\n\t\t\theader = readl(lp->mem_ptr_virt);\n\t\t} else\t\t/* programmed i/o */\n\t\t\theader = hp100_inl(DATA32);\n\n\t\tpkt_len = ((header & HP100_PKT_LEN_MASK) + 3) & ~3;\n\n#ifdef HP100_DEBUG_RX\n\t\tprintk("hp100: %s: rx: new packet - length=%d, errors=0x%x, dest=0x%x\\n",\n\t\t\t\t     dev->name, header & HP100_PKT_LEN_MASK,\n\t\t\t\t     (header >> 16) & 0xfff8, (header >> 16) & 7);\n#endif\n\n\t\t/* Now we allocate the skb and transfer the data into it. */\n\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\tif (skb == NULL) {\t/* Not enough memory->drop packet */\n#ifdef HP100_DEBUG\n\t\t\tprintk("hp100: %s: rx: couldn't allocate a sk_buff of size %d\\n",\n\t\t\t\t\t     dev->name, pkt_len);\n#endif\n\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\t/* skb successfully allocated */\n\n\t\t\tu_char *ptr;\n\n\t\t\tskb_reserve(skb,2);\n\n\t\t\t/* ptr to start of the sk_buff data area */\n\t\t\tskb_put(skb, pkt_len);\n\t\t\tptr = skb->data;\n\n\t\t\t/* Now transfer the data from the card into that area */\n\t\t\tif (lp->mode == 2)\n\t\t\t\tmemcpy_fromio(ptr, lp->mem_ptr_virt,pkt_len);\n	t
30313	766	mmc_sdio_init_card	drivers/mmc/core/sdio.c	mmc_sdio_init_card_$card$obj$259$2$obj	0	13	\N	\N	\tstruct mmc_card *card;\n\tint err;\n\tint retries = 10;\n\tu32 rocr = 0;\n\tu32 ocr_card = ocr;\n\n\tWARN_ON(!host->claimed);\n\n\t/* to query card if 1.8V signalling is supported */\n\tif (mmc_host_uhs(host))\n\t\tocr |= R4_18V_PRESENT;\n\ntry_again:\n\tif (!retries) {\n\t\tpr_warn("%s: Skipping voltage switch\\n", mmc_hostname(host));\n\t\tocr &= ~R4_18V_PRESENT;\n\t}\n\n\t/*\n\t * Inform the card of the voltage\n\t */\n\tif (!powered_resume) {\n\t\terr = mmc_send_io_op_cond(host, ocr, &rocr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * For SPI, enable CRC as appropriate.\n\t */\n\tif (mmc_host_is_spi(host)) {\n\t\terr = mmc_spi_set_crc(host, use_spi_crc);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * Allocate card structure.\n\t */\n\tcard = mmc_alloc_card(host, NULL);\n\tif (IS_ERR(card)) {\n\t\terr = PTR_ERR(card);\n\t\tgoto err;\n\t}\n\n\tif ((rocr & R4_MEMORY_PRESENT) &&\n\t    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {\n\t\tcard->type = MMC_TYPE_SD_COMBO;\n\n\t\tif (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||\n\t\t    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {\n\t\t\tmmc_remove_card(card);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else {\n\t\tcard->type = MMC_TYPE_SDIO;\n\n\t\tif (oldcard && oldcard->type != MMC_TYPE_SDIO) {\n\t\t\tmmc_remove_card(card);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/*\n\t * Call the optional HC's init_card function to handle quirks.\n\t */\n\tif (host->ops->init_card)\n\t\thost->ops->init_card(host, card);\n\n\t/*\n\t * If the host and card support UHS-I mode request the card\n\t * to switch to 1.8V signaling level.  No 1.8v signalling if\n\t * UHS mode is not enabled to maintain compatibility and some\n\t * systems that claim 1.8v signalling in fact do not support\n\t * it. Per SDIO spec v3, section 3.1.2, if the voltage is already\n\t * 1.8v, the card sets S18A to 0 in the R4 response. So it will\n\t * fails to check rocr & R4_18V_PRESENT,  but we still need to\n\t * try to init uhs card. sdio_read_cccr will take over this task\n\t * to make sure which speed mode should work.\n\t */\n\tif (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {\n\t\terr = mmc_set_uhs_voltage(host, ocr_card);\n\t\tif (err == -EAGAIN) {\n\t\t\tmmc_sdio_resend_if_cond(host, card);\n\t\t\tretries--;\n\t\t\tgoto try_again;\n\t\t} else if (err) {\n\t\t\tocr &= ~R4_18V_PRESENT;\n\t\t}\n\t}\n\n\t/*\n\t * For native busses:  set card RCA and quit open drain mode.\n\t */\n\tif (!powered_resume && !mmc_host_is_spi(host)) {\n\t\terr = mmc_send_relative_addr(host, &card->rca);\n\t\tif (err)\n\t\t\tgoto remove;\n\n\t\t/*\n\t\t * Update oldcard with the new RCA received from the SDIO\n\t\t * device -- we're doing this so that it's updated in the\n\t\t * "card" struct when oldcard overwrites that later.\n\t\t */\n\t\tif (oldcard)\n\t\t\toldcard->rca = card->rca;\n\t}\n\n\t/*\n\t * Read CSD, before selecting the card\n\t */\n\tif (!oldcard && card->type == MMC_TYPE_SD_COMBO) {\n\t\terr = mmc_sd_get_csd(host, card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmmc_decode_cid(card);\n\t}\n\n\t/*\n\t * Select card, as all following commands rely on that.\n\t */\n\tif (!powered_resume && !mmc_host_is_spi(host)) {\n\t\terr = mmc_select_card(card);\n\t\tif (err)\n\t\t\tgoto remove;\n\t}\n\n\tif (card->quirks & MMC_QUIRK_NONSTD_SDIO) {\n\t\t/*\n\t\t * This is non-standard SDIO device, meaning it doesn't\n\t\t * have any CIA (Common I/O area) registers present.\n\t\t * It's host's responsibility to fill cccr and cis\n\t\t * structures in init_card().\n\t\t */\n\t\tmmc_set_clock(host, card->cis.max_dtr);\n\n\t\tif (card->cccr.high_speed) {\n\t\t\tmmc_set_timing(card->host, MMC_TIMING_SD_HS);\n\t\t}\n\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Read the common registers. Note that we should try to\n\t * validate whether UHS would work or not.\n\t */\n\terr = sdio_read_cccr(card, ocr);\n\tif (err) {\n\t\tmmc_sdio_resend_if_cond(host, card);\n\t\tif (ocr & R4_18V_PRESENT) {\n\t\t\t/* Retry init sequence, but without R4_18V_PRESENT. */\n\t\t\tretries = 0;\n\t\t\tgoto try_again;\n\t\t} else {\n\t\t\tgoto remove;\n\t\t}\n\t}\n\n\t/*\n\t * Read the common CIS tuples.\n\t */\n\terr = sdio_read_common_cis(card);\n\tif (err)\n\t\tgoto remove;\n\n\tif (oldcard) {\n\t\tint same = (card->cis.vendor == oldcard->cis.vendor &&\n\t\t\t    card->cis.device == oldcard->cis.device);\n\t\tmmc_remove_card(card);\n\t\tif (!same)\n\t\t\treturn -ENOENT;\n\n\t\tcard = oldcard;\n\t}\n\tcard->ocr = ocr_card;\n\tmmc_fixup_device(card, sdio_fixup_methods);\n\n\tif (card->type == MMC_TYPE_SD_COMBO) {\n\t\terr = mmc_sd_setup_card(host, card, oldcard != NULL);\n\t\t/* handle as SDIO-only card if memory init failed */\n\t\tif (err) {\n\t\t\tmmc_go_idle(host);\n\t\t\tif (mmc_host_is_spi(host))\n\t\t\t\t/* should not fail, as it worked previously */\n\t\t\t\tmmc_spi_set_crc(host, use_spi_crc);\n\t\t\tcard->type = MMC_TYPE_SDIO;\n\t\t} else\n\t\t\tcard->dev.type = &sd_type;\n\t}\n\n\t/*\n\t * If needed, disconnect card detection pull-up resistor.\n\t */\n\terr = sdio_disable_cd(card);\n\tif (err)\n\t\tgoto remove;\n\n\t/* Initialization sequence for UHS-I cards */\n\t/* Only if card supports 1.8v and UHS signaling */\n\tif ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {\n	f
55584	225	fanotify_handle_event	fs/notify/fanotify/fanotify.c	fsn_event	0	11	\N	\N	\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\n\tBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\n\tBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\n\tBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\n\tBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\n\n\tif (!fanotify_should_send_event(inode_mark, fanotify_mark, mask, data,\n\t\t\t\t\tdata_type))\n\t\treturn 0;\n\n\tpr_debug("%s: group=%p inode=%p mask=%x\\n", __func__, group, inode,\n\t\t mask);\n\n\tevent = fanotify_alloc_event(inode, mask, data);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tret = fsnotify_add_event(group, fsn_event, fanotify_merge);\n\tif (ret) {\n\t\t/* Permission events shouldn't be merged */\n\t\tBUG_ON(ret == 1 && mask & FAN_ALL_PERM_EVENTS);\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n	f
55997	210	batadv_v_ogm_send	net/batman-adv/bat_v_ogm.c	ogm_packet->ttl	0	11	\N	\N	\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_priv_bat_v *bat_v;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_ogm2_packet *ogm_packet;\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned char *ogm_buff;\n\tint ogm_buff_len;\n\tu16 tvlv_len = 0;\n\tint ret;\n\n\tbat_v = container_of(work, struct batadv_priv_bat_v, ogm_wq.work);\n\tbat_priv = container_of(bat_v, struct batadv_priv, bat_v);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\n\t\tgoto out;\n\n\togm_buff = bat_priv->bat_v.ogm_buff;\n\togm_buff_len = bat_priv->bat_v.ogm_buff_len;\n\t/* tt changes have to be committed before the tvlv data is\n\t * appended as it may alter the tt tvlv container\n\t */\n\tbatadv_tt_local_commit_changes(bat_priv);\n\ttvlv_len = batadv_tvlv_container_ogm_append(bat_priv, &ogm_buff,\n\t\t\t\t\t\t    &ogm_buff_len,\n\t\t\t\t\t\t    BATADV_OGM2_HLEN);\n\n\tbat_priv->bat_v.ogm_buff = ogm_buff;\n\tbat_priv->bat_v.ogm_buff_len = ogm_buff_len;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, ETH_HLEN + ogm_buff_len);\n\tif (!skb)\n\t\tgoto reschedule;\n\n\tskb_reserve(skb, ETH_HLEN);\n\tskb_put_data(skb, ogm_buff, ogm_buff_len);\n\n\togm_packet = (struct batadv_ogm2_packet *)skb->data;\n\togm_packet->seqno = htonl(atomic_read(&bat_priv->bat_v.ogm_seqno));\n\tatomic_inc(&bat_priv->bat_v.ogm_seqno);\n\togm_packet->tvlv_len = htons(tvlv_len);\n\n\t/* broadcast on every interface */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tret = batadv_hardif_no_broadcast(hard_iface, NULL, NULL);\n\t\tif (ret) {\n\t\t\tchar *type;\n\n\t\t\tswitch (ret) {\n\t\t\tcase BATADV_HARDIF_BCAST_NORECIPIENT:\n\t\t\t\ttype = "no neighbor";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPFWD:\n\t\t\t\ttype = "single neighbor is source";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPORIG:\n\t\t\t\ttype = "single neighbor is originator";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttype = "unknown";\n\t\t\t}\n\n\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 from ourselves on %s suppressed: %s\\n",\n\t\t\t\t   hard_iface->net_dev->name, type);\n\n\t\t\tbatadv_hardif_put(hard_iface);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n	f
36844	1516	kcdrwd	drivers/block/pktcdvd.c	pd	1	11	\N	\N	\tstruct pktcdvd_device *pd = foobar;\n\tstruct packet_data *pkt;\n\tlong min_sleep_time, residue;\n\n\tset_user_nice(current, MIN_NICE);\n\tset_freezable();\n\n\tfor (;;) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t/*\n\t\t * Wait until there is something to do\n\t\t */\n\t\tadd_wait_queue(&pd->wqueue, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\t/* Check if we need to run pkt_handle_queue */\n\t\t\tif (atomic_read(&pd->scan_queue) > 0)\n\t\t\t\tgoto work_to_do;\n\n\t\t\t/* Check if we need to run the state machine for some packet */\n\t\t\tlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\n\t\t\t\tif (atomic_read(&pkt->run_sm) > 0)\n\t\t\t\t\tgoto work_to_do;\n\t\t\t}\n\n\t\t\t/* Check if we need to process the iosched queues */\n\t\t\tif (atomic_read(&pd->iosched.attention) != 0)\n\t\t\t\tgoto work_to_do;\n\n\t\t\t/* Otherwise, go to sleep */\n\t\t\tif (PACKET_DEBUG > 1) {\n\t\t\t\tint states[PACKET_NUM_STATES];\n\t\t\t\tpkt_count_states(pd, states);\n\t\t\t\tpkt_dbg(2, pd, "i:%d ow:%d rw:%d ww:%d rec:%d fin:%d\\n",\n\t\t\t\t\tstates[0], states[1], states[2],\n\t\t\t\t\tstates[3], states[4], states[5]);\n\t\t\t}\n\n\t\t\tmin_sleep_time = MAX_SCHEDULE_TIMEOUT;\n\t\t\tlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\n\t\t\t\tif (pkt->sleep_time && pkt->sleep_time < min_sleep_time)\n\t\t\t\t\tmin_sleep_time = pkt->sleep_time;\n\t\t\t}\n\n\t\t\tpkt_dbg(2, pd, "sleeping\\n");\n\t\t\tresidue = schedule_timeout(min_sleep_time);\n\t\t\tpkt_dbg(2, pd, "wake up\\n");\n\n\t\t\t/* make swsusp happy with our thread */\n\t\t\ttry_to_freeze();\n\n\t\t\tlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\n\t\t\t\tif (!pkt->sleep_time)\n\t\t\t\t\tcontinue;\n\t\t\t\tpkt->sleep_time -= min_sleep_time - residue;\n\t\t\t\tif (pkt->sleep_time <= 0) {\n\t\t\t\t\tpkt->sleep_time = 0;\n\t\t\t\t\tatomic_inc(&pkt->run_sm);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t}\nwork_to_do:\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&pd->wqueue, &wait);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if pkt_handle_queue returns true, we can queue\n\t\t * another request.\n\t\t */\n\t\twhile (pkt_handle_queue(pd))\n\t\t\t;\n\n\t\t/*\n\t\t * Handle packet state machine\n\t\t */\n\t\tpkt_handle_packets(pd);\n\n\t\t/*\n\t\t * Handle iosched queues\n\t\t */\n\t\tpkt_iosched_process_queue(pd);\n	t
46832	582	cdv_chip_setup	drivers/gpu/drm/gma500/cdv_device.c	cdv_chip_setup_	1	11	\N	\N	\tstruct drm_psb_private *dev_priv = dev->dev_private;\n\tINIT_WORK(&dev_priv->hotplug_work, cdv_hotplug_work_func);\n\n\tif (pci_enable_msi(dev->pdev))\n	t
2329	153	exynos_ppmu_set_event	drivers/devfreq/event/exynos-ppmu.c	cntens	1	13	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\tu32 pmnc, cntens;\n\n\tif (id < 0)\n\t\treturn id;\n\n\t/* Enable specific counter */\n\tret = regmap_read(info->regmap, PPMU_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_CNTENS, cntens);\n	f
30230	255	befs_btree_find	fs/befs/btree.c	&bt_super) != BEFS_OK	1	13	\N	\N	\tstruct befs_btree_node *this_node;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off;\n\tint res;\n\n\tbefs_debug(sb, "---> %s Key: %s", __func__, key);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n	f
38193	347	expect_t120	net/netfilter/nf_conntrack_h323_main.c	&addr	1	13	\N	\N	\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\ttypeof(nat_t120_hook) nat_t120;\n\n\t/* Read T.120 address */\n\tif (!get_h245_addr(ct, *data, taddr, &addr, &port) ||\n	f
45845	1185	et8ek8_dev_init	drivers/media/i2c/et8ek8/et8ek8_driver.c	sensor->version	1	13	\N	\N	\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint rval, rev_l, rev_h;\n\n\trval = et8ek8_power_on(sensor);\n\tif (rval) {\n\t\tdev_err(&client->dev, "could not power on\\n");\n\t\treturn rval;\n\t}\n\n\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t   REG_REVISION_NUMBER_L, &rev_l);\n\tif (!rval)\n\t\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t\t   REG_REVISION_NUMBER_H, &rev_h);\n\tif (rval) {\n\t\tdev_err(&client->dev, "no et8ek8 sensor detected\\n");\n\t\tgoto out_poweroff;\n\t}\n\n\tsensor->version = (rev_h << 8) + rev_l;\n\tif (sensor->version != ET8EK8_REV_1 && sensor->version != ET8EK8_REV_2)\n	f
53150	220	ch9200_link_reset	drivers/net/usb/ch9200.c	&ecmd	1	13	\N	\N	\tstruct ethtool_cmd ecmd;\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n	f
34927	127	cw1200_request_irq	drivers/net/wireless/st/cw1200/cw1200_sdio.c	ret	1	13	\N	\N	\tint ret;\n\tu8 cccr;\n\n\tcccr = sdio_f0_readb(self->func, SDIO_CCCR_IENx, &ret);\n\tif (WARN_ON(ret))\n	f
51611	295	s5h1420_send_burst	drivers/media/dvb-frontends/s5h1420.c	s5h1420_send_burst_$and$8	0	13	\N	\N	\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint result = 0;\n\tunsigned long timeout;\n\n\t/* setup for tone burst */\n\tval = s5h1420_readreg(state, 0x3b);\n\ts5h1420_writereg(state, 0x3b, (s5h1420_readreg(state, 0x3b) & 0x70) | 0x01);\n\n\t/* set value for B position if requested */\n\tif (minicmd == SEC_MINI_B) {\n\t\ts5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x04);\n\t}\n\tmsleep(15);\n\n\t/* start transmission */\n\ts5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x08);\n\n\t/* wait for transmission to complete */\n\ttimeout = jiffies + ((100*HZ) / 1000);\n\twhile(time_before(jiffies, timeout)) {\n\t\tif (!(s5h1420_readreg(state, 0x3b) & 0x08))\n	f
27042	187	method_vpcw	drivers/platform/x86/ideapad-laptop.c	status	1	11	\N	\N	\tstruct acpi_object_list params;\n\tunion acpi_object in_obj[2];\n\tacpi_status status;\n\n\tparams.count = 2;\n\tparams.pointer = in_obj;\n\tin_obj[0].type = ACPI_TYPE_INTEGER;\n\tin_obj[0].integer.value = cmd;\n\tin_obj[1].type = ACPI_TYPE_INTEGER;\n\tin_obj[1].integer.value = data;\n\n\tstatus = acpi_evaluate_object(handle, "VPCW", &params, NULL);\n\tif (status != AE_OK)\n	t
44922	939	initialize_power_supply_data	drivers/platform/x86/compal-laptop.c	initialize_power_supply_data_	1	11	\N	\N	\tec_read_sequence(BAT_MANUFACTURER_NAME_ADDR,\n\t\t\t\t\tdata->bat_manufacturer_name,\n\t\t\t\t\tBAT_MANUFACTURER_NAME_LEN);\n\tdata->bat_manufacturer_name[BAT_MANUFACTURER_NAME_LEN] = 0;\n\n\tec_read_sequence(BAT_MODEL_NAME_ADDR,\n\t\t\t\t\tdata->bat_model_name,\n\t\t\t\t\tBAT_MODEL_NAME_LEN);\n\tdata->bat_model_name[BAT_MODEL_NAME_LEN] = 0;\n\n\tscnprintf(data->bat_serial_number, BAT_SERIAL_NUMBER_LEN + 1, "%d",\n	t
45432	1707	u132_run	drivers/usb/host/u132-hcd.c	fminterval	1	11	\N	\N	\tint retval;\n\tu32 control;\n\tu32 status;\n\tu32 fminterval;\n\tu32 periodicstart;\n\tu32 cmdstatus;\n\tu32 roothub_a;\n\tint mask = OHCI_INTR_INIT;\n\tint first = u132->hc_fminterval == 0;\n\tint sleep_time = 0;\n\tint reset_timeout = 30;\t/* ... allow extra time */\n\tu132_disable(u132);\n\tif (first) {\n\t\tu32 temp;\n\t\tretval = u132_read_pcimem(u132, fminterval, &temp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tu132->hc_fminterval = temp & 0x3fff;\n\t\tu132->hc_fminterval |= FSMP(u132->hc_fminterval) << 16;\n\t}\n\tretval = u132_read_pcimem(u132, control, &u132->hc_control);\n\tif (retval)\n\t\treturn retval;\n\tdev_info(&u132->platform_dev->dev, "resetting from state '%s', control "\n\t\t"= %08X\\n", hcfs2string(u132->hc_control & OHCI_CTRL_HCFS),\n\t\tu132->hc_control);\n\tswitch (u132->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_OPER:\n\t\tsleep_time = 0;\n\t\tbreak;\n\tcase OHCI_USB_SUSPEND:\n\tcase OHCI_USB_RESUME:\n\t\tu132->hc_control &= OHCI_CTRL_RWC;\n\t\tu132->hc_control |= OHCI_USB_RESUME;\n\t\tsleep_time = 10;\n\t\tbreak;\n\tdefault:\n\t\tu132->hc_control &= OHCI_CTRL_RWC;\n\t\tu132->hc_control |= OHCI_USB_RESET;\n\t\tsleep_time = 50;\n\t\tbreak;\n\t}\n\tretval = u132_write_pcimem(u132, control, u132->hc_control);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_read_pcimem(u132, control, &control);\n\tif (retval)\n\t\treturn retval;\n\tmsleep(sleep_time);\n\tretval = u132_read_pcimem(u132, roothub.a, &roothub_a);\n\tif (retval)\n\t\treturn retval;\n\tif (!(roothub_a & RH_A_NPS)) {\n\t\tint temp;\t/* power down each port */\n\t\tfor (temp = 0; temp < u132->num_ports; temp++) {\n\t\t\tretval = u132_write_pcimem(u132,\n\t\t\t\troothub.portstatus[temp], RH_PS_LSDA);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tretval = u132_read_pcimem(u132, control, &control);\n\tif (retval)\n\t\treturn retval;\nretry:\n\tretval = u132_read_pcimem(u132, cmdstatus, &status);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_write_pcimem(u132, cmdstatus, OHCI_HCR);\n\tif (retval)\n\t\treturn retval;\nextra:\t{\n\t\tretval = u132_read_pcimem(u132, cmdstatus, &status);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (0 != (status & OHCI_HCR)) {\n\t\t\tif (--reset_timeout == 0) {\n\t\t\t\tdev_err(&u132->platform_dev->dev, "USB HC reset"\n\t\t\t\t\t" timed out!\\n");\n\t\t\t\treturn -ENODEV;\n\t\t\t} else {\n\t\t\t\tmsleep(5);\n\t\t\t\tgoto extra;\n\t\t\t}\n\t\t}\n\t}\n\tif (u132->flags & OHCI_QUIRK_INITRESET) {\n\t\tretval = u132_write_pcimem(u132, control, u132->hc_control);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = u132_read_pcimem(u132, control, &control);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tretval = u132_write_pcimem(u132, ed_controlhead, 0x00000000);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_write_pcimem(u132, ed_bulkhead, 0x11000000);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_write_pcimem(u132, hcca, 0x00000000);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_periodic_reinit(u132);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_read_pcimem(u132, fminterval, &fminterval);\n\tif (retval)\n\t\treturn retval;\n\tretval = u132_read_pcimem(u132, periodicstart, &periodicstart);\n\tif (retval)\n\t\treturn retval;\n\tif (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {\n	t
57098	282	trace_event_raw_event_jbd2_checkpoint_stats	fs/jbd2/journal.c	1	1	-11	\N	\N	\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t/*\n\t * Set up an interval timer which can be used to trigger a commit wakeup\n\t * after the commit interval expires\n\t */\n\tsetup_timer(&journal->j_commit_timer, commit_timeout,\n\t\t\t(unsigned long)current);\n\n\tset_freezable();\n\n\t/* Record that the journal thread is running */\n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Make sure that no allocations from this kernel thread will ever\n\t * recurse to the fs layer because we are responsible for the\n\t * transaction commit and any fs involvement might get stuck waiting for\n\t * the trasn. commit.\n\t */\n\tmemalloc_nofs_save();\n\n\t/*\n\t * And now, wait forever for commit wakeup events.\n\t */\n\twrite_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd_debug(1, "commit_sequence=%d, commit_request=%d\\n",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd_debug(1, "OK, requests differ\\n");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjbd2_journal_commit_transaction(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t/*\n\t\t * The simpler the better. Flushing journal isn't a\n\t\t * good idea, because that depends on threads that may\n\t\t * be already stopped.\n\t\t */\n\t\tjbd_debug(1, "Now suspending kjournald2\\n");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\twrite_lock(&journal->j_state_lock);\n\t} else {\n\t\t/*\n\t\t * We assume on resume that commits are already there,\n\t\t * so we don't sleep\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd_debug(1, "kjournald2 wakes\\n");\n\n\t/*\n\t * Were we woken up by a commit wakeup event?\n\t */\n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n	t
46879	1042	msp34xxg_thread	drivers/media/i2c/msp3400-kthreads.c	state->std	1	13	\N	\N	\tstruct i2c_client *client = data;\n\tstruct msp_state *state = to_state(i2c_get_clientdata(client));\n\tint val, i;\n\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, "msp34xxg daemon started\\n");\n\tstate->detected_std = V4L2_STD_ALL;\n\tset_freezable();\n\tfor (;;) {\n\t\tdev_dbg_lvl(&client->dev, 2, msp_debug, "msp34xxg thread: sleep\\n");\n\t\tmsp_sleep(state, -1);\n\t\tdev_dbg_lvl(&client->dev, 2, msp_debug, "msp34xxg thread: wakeup\\n");\n\nrestart:\n\t\tdev_dbg_lvl(&client->dev, 1, msp_debug, "thread: restart scan\\n");\n\t\tstate->restart = 0;\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (state->mode == MSP_MODE_EXTERN) {\n\t\t\t/* no carrier scan needed, just unmute */\n\t\t\tdev_dbg_lvl(&client->dev, 1, msp_debug,\n\t\t\t\t"thread: no carrier scan\\n");\n\t\t\tstate->scan_in_progress = 0;\n\t\t\tmsp_update_volume(state);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* setup the chip*/\n\t\tmsp34xxg_reset(client);\n\t\tstate->std = state->radio ? 0x40 :\n\t\t\t(state->force_btsc && msp_standard == 1) ? 32 : msp_standard;\n\t\tmsp_write_dem(client, 0x20, state->std);\n\t\t/* start autodetect */\n\t\tif (state->std != 1)\n\t\t\tgoto unmute;\n\n\t\t/* watch autodetect */\n\t\tdev_dbg_lvl(&client->dev, 1, msp_debug,\n\t\t\t"started autodetect, waiting for result\\n");\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tif (msp_sleep(state, 100))\n\t\t\t\tgoto restart;\n\n\t\t\t/* check results */\n\t\t\tval = msp_read_dem(client, 0x7e);\n\t\t\tif (val < 0x07ff) {\n\t\t\t\tstate->std = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_dbg_lvl(&client->dev, 2, msp_debug,\n\t\t\t\t"detection still in progress\\n");\n\t\t}\n\t\tif (state->std == 1) {\n	f
60308	6639	ath10k_wmi_op_gen_set_ap_ps	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_set_ap_ps_$cmd$obj$1$0	0	13	\N	\N	\tstruct wmi_ap_ps_peer_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_ap_ps_peer_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(value);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n	f
37142	384	fnic_fcoe_send_vlan_req	drivers/scsi/fnic/fnic_fcs.c	fnic_fcoe_send_vlan_req_$vlan$obj$0$0	0	13	\N	\N	\tstruct fcoe_ctlr *fip = &fnic->ctlr;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tstruct sk_buff *skb;\n\tchar *eth_fr;\n\tint fr_len;\n\tstruct fip_vlan *vlan;\n\tu64 vlan_tov;\n\n\tfnic_fcoe_reset_vlans(fnic);\n\tfnic->set_vlan(fnic, 0);\n\n\tif (printk_ratelimit())\n\t\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t  "Sending VLAN request...\\n");\n\n\tskb = dev_alloc_skb(sizeof(struct fip_vlan));\n\tif (!skb)\n\t\treturn;\n\n\tfr_len = sizeof(*vlan);\n\teth_fr = (char *)skb->data;\n\tvlan = (struct fip_vlan *)eth_fr;\n\n\tmemset(vlan, 0, sizeof(*vlan));\n\tmemcpy(vlan->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\tmemcpy(vlan->eth.h_dest, fcoe_all_fcfs, ETH_ALEN);\n	f
59675	435	netvsc_vf_xmit	drivers/net/hyperv/netvsc_drv.c	skb	0	11	\N	\N	\tstruct net_device_context *ndev_ctx = netdev_priv(net);\n\tunsigned int len = skb->len;\n\tint rc;\n\n\tskb->dev = vf_netdev;\n\tskb->queue_mapping = qdisc_skb_cb(skb)->slave_dev_queue_mapping;\n\n\trc = dev_queue_xmit(skb);\n	f
59938	217	arc_emac_rx	drivers/net/ethernet/arc/emac_main.c	skb	0	11	\N	\N	\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int work_done;\n\n\tfor (work_done = 0; work_done < budget; work_done++) {\n\t\tunsigned int *last_rx_bd = &priv->last_rx_bd;\n\t\tstruct net_device_stats *stats = &ndev->stats;\n\t\tstruct buffer_state *rx_buff = &priv->rx_buff[*last_rx_bd];\n\t\tstruct arc_emac_bd *rxbd = &priv->rxbd[*last_rx_bd];\n\t\tunsigned int pktlen, info = le32_to_cpu(rxbd->info);\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t addr;\n\n\t\tif (unlikely((info & OWN_MASK) == FOR_EMAC))\n\t\t\tbreak;\n\n\t\t/* Make a note that we saw a packet at this BD.\n\t\t * So next time, driver starts from this + 1\n\t\t */\n\t\t*last_rx_bd = (*last_rx_bd + 1) % RX_BD_NUM;\n\n\t\tif (unlikely((info & FIRST_OR_LAST_MASK) !=\n\t\t\t     FIRST_OR_LAST_MASK)) {\n\t\t\t/* We pre-allocate buffers of MTU size so incoming\n\t\t\t * packets won't be split/chained.\n\t\t\t */\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(ndev, "incomplete packet received\\n");\n\n\t\t\t/* Return ownership to EMAC */\n\t\t\trxbd->info = cpu_to_le32(FOR_EMAC | EMAC_BUFFER_SIZE);\n\t\t\tstats->rx_errors++;\n\t\t\tstats->rx_length_errors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpktlen = info & LEN_MASK;\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += pktlen;\n\t\tskb = rx_buff->skb;\n\t\tskb_put(skb, pktlen);\n	f
35451	559	pt_identify	drivers/block/paride/pt.c	pt_identify_	1	11	\N	\N	\tint dt, s;\n\tchar *ms[2] = { "master", "slave" };\n\tchar mf[10], id[18];\n\tchar id_cmd[12] = { ATAPI_IDENTIFY, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\tchar ms_cmd[12] =\n\t    { ATAPI_MODE_SENSE, 0, 0x2a, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\tchar ls_cmd[12] =\n\t    { ATAPI_LOG_SENSE, 0, 0x71, 0, 0, 0, 0, 0, 36, 0, 0, 0 };\n\tchar buf[36];\n\n\ts = pt_atapi(tape, id_cmd, 36, buf, "identify");\n\tif (s)\n\t\treturn -1;\n\n\tdt = buf[0] & 0x1f;\n\tif (dt != 1) {\n\t\tif (verbose)\n\t\t\tprintk("%s: Drive %d, unsupported type %d\\n",\n\t\t\t       tape->name, tape->drive, dt);\n\t\treturn -1;\n\t}\n\n\txs(buf, mf, 8, 8);\n\txs(buf, id, 16, 16);\n\n\ttape->flags = 0;\n\ttape->capacity = 0;\n\ttape->bs = 0;\n\n\tif (!pt_ready_wait(tape, PT_READY_TMO))\n	t
36249	138	gmc_v6_0_init_microcode	drivers/gpu/drm/amd/amdgpu/gmc_v6_0.c	chip_name	1	11	\N	\N	\tconst char *chip_name;\n\tchar fw_name[30];\n\tint err;\n\tbool is_58_fw = false;\n\n\tDRM_DEBUG("\\n");\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TAHITI:\n\t\tchip_name = "tahiti";\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\tchip_name = "pitcairn";\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tchip_name = "verde";\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tchip_name = "oland";\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\tchip_name = "hainan";\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\t/* this memory configuration requires special firmware */\n\tif (((RREG32(mmMC_SEQ_MISC0) & 0xff000000) >> 24) == 0x58)\n\t\tis_58_fw = true;\n\n\tif (is_58_fw)\n\t\tsnprintf(fw_name, sizeof(fw_name), "radeon/si58_mc.bin");\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), "radeon/%s_mc.bin", chip_name);\n	t
36669	2413	ath10k_wmi_tlv_op_gen_pdev_set_wmm	drivers/net/wireless/ath/ath10k/wmi-tlv.c	tlv->tag	1	11	\N	\N	\tstruct wmi_tlv_pdev_set_wmm_cmd *cmd;\n\tstruct wmi_wmm_params *wmm;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (4 * (sizeof(*tlv) + sizeof(*wmm)));\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_WMM_PARAMS_CMD);\n	t
41254	473	uvd_v6_0_start	drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c	r	1	11	\N	\N	\tstruct amdgpu_ring *ring = &adev->uvd.ring;\n\tuint32_t rb_bufsz, tmp;\n\tuint32_t lmi_swap_cntl;\n\tuint32_t mp_swap_cntl;\n\tint i, j, r;\n\n\t/* disable DPG */\n\tWREG32_P(mmUVD_POWER_STATUS, 0, ~UVD_POWER_STATUS__UVD_PG_MODE_MASK);\n\n\t/* disable byte swapping */\n\tlmi_swap_cntl = 0;\n\tmp_swap_cntl = 0;\n\n\tuvd_v6_0_mc_resume(adev);\n\n\t/* disable interupt */\n\tWREG32_FIELD(UVD_MASTINT_EN, VCPU_EN, 0);\n\n\t/* stall UMC and register bus before resetting VCPU */\n\tWREG32_FIELD(UVD_LMI_CTRL2, STALL_ARB_UMC, 1);\n\tmdelay(1);\n\n\t/* put LMI, VCPU, RBC etc... into reset */\n\tWREG32(mmUVD_SOFT_RESET,\n\t\tUVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LBSI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__RBC_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__CSM_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__CXW_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__TAP_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t/* take UVD block out of reset */\n\tWREG32_FIELD(SRBM_SOFT_RESET, SOFT_RESET_UVD, 0);\n\tmdelay(5);\n\n\t/* initialize UVD memory controller */\n\tWREG32(mmUVD_LMI_CTRL,\n\t\t(0x40 << UVD_LMI_CTRL__WRITE_CLEAN_TIMER__SHIFT) |\n\t\tUVD_LMI_CTRL__WRITE_CLEAN_TIMER_EN_MASK |\n\t\tUVD_LMI_CTRL__DATA_COHERENCY_EN_MASK |\n\t\tUVD_LMI_CTRL__VCPU_DATA_COHERENCY_EN_MASK |\n\t\tUVD_LMI_CTRL__REQ_MODE_MASK |\n\t\tUVD_LMI_CTRL__DISABLE_ON_FWV_FAIL_MASK);\n\n#ifdef __BIG_ENDIAN\n\t/* swap (8 in 32) RB and IB */\n\tlmi_swap_cntl = 0xa;\n\tmp_swap_cntl = 0;\n#endif\n\tWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\n\tWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\n\n\tWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\n\tWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\n\tWREG32(mmUVD_MPC_SET_ALU, 0);\n\tWREG32(mmUVD_MPC_SET_MUX, 0x88);\n\n\t/* take all subblocks out of reset, except VCPU */\n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t/* enable VCPU clock */\n\tWREG32(mmUVD_VCPU_CNTL, UVD_VCPU_CNTL__CLK_EN_MASK);\n\n\t/* enable UMC */\n\tWREG32_FIELD(UVD_LMI_CTRL2, STALL_ARB_UMC, 0);\n\n\t/* boot up the VCPU */\n\tWREG32(mmUVD_SOFT_RESET, 0);\n\tmdelay(10);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR("UVD not responding, trying to reset the VCPU!!!\\n");\n\t\tWREG32_FIELD(UVD_SOFT_RESET, VCPU_SOFT_RESET, 1);\n\t\tmdelay(10);\n\t\tWREG32_FIELD(UVD_SOFT_RESET, VCPU_SOFT_RESET, 0);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\tif (r) {\n	t
47430	3066	drbd_adm_invalidate_peer	drivers/block/drbd/drbd_nl.c	device->state.conn	1	11	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tint retcode; /* drbd_ret_code, drbd_state_rv */\n\tstruct drbd_device *device;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\n\tif (!adm_ctx.reply_skb)\n\t\treturn retcode;\n\tif (retcode != NO_ERROR)\n\t\tgoto out;\n\n\tdevice = adm_ctx.device;\n\tif (!get_ldev(device)) {\n\t\tretcode = ERR_NO_DISK;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&adm_ctx.resource->adm_mutex);\n\n\t/* If there is still bitmap IO pending, probably because of a previous\n\t * resync just being finished, wait for it before requesting a new resync.\n\t * Also wait for it's after_state_ch(). */\n\tdrbd_suspend_io(device);\n\twait_event(device->misc_wait, !test_bit(BITMAP_IO, &device->flags));\n\tdrbd_flush_workqueue(&first_peer_device(device)->connection->sender_work);\n\n\t/* If we happen to be C_STANDALONE R_PRIMARY, just set all bits\n\t * in the bitmap.  Otherwise, try to start a resync handshake\n\t * as sync source for full sync.\n\t */\n\tif (device->state.conn == C_STANDALONE && device->state.role == R_PRIMARY) {\n	t
41400	8530	fan_fan2_input_show	drivers/platform/x86/thinkpad_acpi.c	speed	1	13	\N	\N	\tint res;\n\tunsigned int speed;\n\n\tres = fan2_get_speed(&speed);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn snprintf(buf, PAGE_SIZE, "%u\\n", speed);\n	f
46163	46	virtio_gpu_config_changed_work_func	drivers/gpu/drm/virtio/virtgpu_kms.c	events_read	1	11	\N	\N	\tstruct virtio_gpu_device *vgdev =\n\t\tcontainer_of(work, struct virtio_gpu_device,\n\t\t\t     config_changed_work);\n\tu32 events_read, events_clear = 0;\n\n\t/* read the config space */\n\tvirtio_cread(vgdev->vdev, struct virtio_gpu_config,\n\t\t     events_read, &events_read);\n\tif (events_read & VIRTIO_GPU_EVENT_DISPLAY) {\n	t
49727	5621	ext4_insert_range	fs/ext4/extents.c	ext4_insert_range_	1	11	\N	\N	\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *extent;\n\text4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;\n\tunsigned int credits, ee_len;\n\tint ret = 0, depth, split_flag = 0;\n\tloff_t ioffset;\n\n\t/*\n\t * We need to test this early because xfstests assumes that an\n\t * insert range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support insert range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Insert range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t\t\tlen & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_insert_range(inode, offset, len);\n\n\toffset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tlen_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal */\n\tif (ext4_should_journal_data(inode)) {\n	t
53660	412	perf_trace_ext4_da_write_pages	fs/ext4/super.c	sb	1	11	\N	\N	\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n	t
58789	850	acpi_gpio_adr_space_handler	drivers/gpio/gpiolib-acpi.c	pin	1	11	\N	\N	\tstruct acpi_gpio_chip *achip = region_context;\n\tstruct gpio_chip *chip = achip->chip;\n\tstruct acpi_resource_gpio *agpio;\n\tstruct acpi_resource *ares;\n\tint pin_index = (int)address;\n\tacpi_status status;\n\tint length;\n\tint i;\n\n\tstatus = acpi_buffer_to_resource(achip->conn_info.connection,\n\t\t\t\t\t achip->conn_info.length, &ares);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tif (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {\n\t\tACPI_FREE(ares);\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tagpio = &ares->data.gpio;\n\n\tif (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&\n\t    function == ACPI_WRITE)) {\n\t\tACPI_FREE(ares);\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tlength = min(agpio->pin_table_length, (u16)(pin_index + bits));\n\tfor (i = pin_index; i < length; ++i) {\n\t\tint pin = agpio->pin_table[i];\n	t
58930	2247	snd_trident_foldback_pcm	sound/pci/trident/trident_main.c	substream->name	1	11	\N	\N	\tstruct snd_pcm *foldback;\n\tint err;\n\tint num_chan = 3;\n\tstruct snd_pcm_substream *substream;\n\n\tif (trident->device == TRIDENT_DEVICE_ID_NX)\n\t\tnum_chan = 4;\n\tif ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, 0, num_chan, &foldback)) < 0)\n\t\treturn err;\n\n\tfoldback->private_data = trident;\n\tif (trident->tlb.entries)\n\t\tsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_nx_foldback_ops);\n\telse\n\t\tsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_foldback_ops);\n\tfoldback->info_flags = 0;\n\tstrcpy(foldback->name, "Trident 4DWave");\n\tsubstream = foldback->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\tstrcpy(substream->name, "Front Mixer");\n	t
20455	4801	decode_getfattr_generic	fs/nfs/nfs4xdr.c	savep	1	13	\N	\N	\tunsigned int savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_GETATTR);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_bitmap(xdr, bitmap);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_length(xdr, &attrlen, &savep);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_getfattr_attrs(xdr, bitmap, fattr, fh, fs_loc,\n\t\t\t\t\tlabel, server);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\n	f
25835	270	da9063_i2c_probe	drivers/mfd/da9063-i2c.c	da9063	1	13	\N	\N	\tstruct da9063 *da9063;\n\tint ret;\n\n\tda9063 = devm_kzalloc(&i2c->dev, sizeof(struct da9063), GFP_KERNEL);\n\tif (da9063 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, da9063);\n\tda9063->dev = &i2c->dev;\n\tda9063->chip_irq = i2c->irq;\n\n\tif (da9063->variant_code == PMIC_DA9063_AD) {\n\t\tda9063_regmap_config.rd_table = &da9063_ad_readable_table;\n\t\tda9063_regmap_config.wr_table = &da9063_ad_writeable_table;\n\t\tda9063_regmap_config.volatile_table = &da9063_ad_volatile_table;\n\t} else {\n\t\tda9063_regmap_config.rd_table = &da9063_bb_readable_table;\n\t\tda9063_regmap_config.wr_table = &da9063_bb_writeable_table;\n\t\tda9063_regmap_config.volatile_table = &da9063_bb_volatile_table;\n\t}\n\n\tda9063->regmap = devm_regmap_init_i2c(i2c, &da9063_regmap_config);\n\tif (IS_ERR(da9063->regmap)) {\n\t\tret = PTR_ERR(da9063->regmap);\n\t\tdev_err(da9063->dev, "Failed to allocate register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn da9063_device_init(da9063, i2c->irq);\n	f
37487	3126	try_enable_event_buffer	drivers/char/ipmi/ipmi_si_intf.c	resp	1	11	\N	\N	\tunsigned char         msg[3];\n\tunsigned char         *resp;\n\tunsigned long         resp_len;\n\tint                   rv = 0;\n\n\tresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\n\tsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\n\n\trv = wait_for_msg_done(smi_info);\n\tif (rv) {\n\t\tpr_warn(PFX "Error getting response from get global enables command, the event buffer is not enabled.\\n");\n\t\tgoto out;\n\t}\n\n\tresp_len = smi_info->handlers->get_result(smi_info->si_sm,\n\t\t\t\t\t\t  resp, IPMI_MAX_MSG_LENGTH);\n\n\tif (resp_len < 4 ||\n\t\t\tresp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||\n	t
42894	389	pty_common_install	drivers/tty/pty.c	ports	1	11	\N	\N	\tstruct tty_struct *o_tty;\n\tstruct tty_port *ports[2];\n\tint idx = tty->index;\n\tint retval = -ENOMEM;\n\n\t/* Opening the slave first has always returned -EIO */\n\tif (driver->subtype != PTY_TYPE_MASTER)\n\t\treturn -EIO;\n\n\tports[0] = kmalloc(sizeof **ports, GFP_KERNEL);\n\tports[1] = kmalloc(sizeof **ports, GFP_KERNEL);\n\tif (!ports[0] || !ports[1])\n	t
46231	133	__rmnet_map_ingress_handler	drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c	skb	1	11	\N	\N	\tstruct rmnet_endpoint *ep;\n\tu8 mux_id;\n\tu16 len;\n\n\tif (RMNET_MAP_GET_CD_BIT(skb)) {\n\t\tif (port->ingress_data_format\n\t\t    & RMNET_INGRESS_FORMAT_MAP_COMMANDS)\n\t\t\treturn rmnet_map_command(skb, port);\n\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tmux_id = RMNET_MAP_GET_MUX_ID(skb);\n\tlen = RMNET_MAP_GET_LENGTH(skb) - RMNET_MAP_GET_PAD(skb);\n\n\tif (mux_id >= RMNET_MAX_LOGICAL_EP) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tep = &port->muxed_ep[mux_id];\n\n\tif (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)\n\t\tskb->dev = ep->egress_dev;\n\n\t/* Subtract MAP header */\n\tskb_pull(skb, sizeof(struct rmnet_map_header));\n\tskb_trim(skb, len);\n\trmnet_set_skb_proto(skb);\n\treturn rmnet_deliver_skb(skb, ep);\n	t
46582	341	dccp_flush_write_queue	net/dccp/output.c	skb	1	11	\N	\N	\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct sk_buff *skb;\n\tlong delay, rc;\n\n\twhile (*time_budget > 0 && (skb = skb_peek(&sk->sk_write_queue))) {\n\t\trc = ccid_hc_tx_send_packet(dp->dccps_hc_tx_ccid, sk, skb);\n\n\t\tswitch (ccid_packet_dequeue_eval(rc)) {\n\t\tcase CCID_PACKET_WILL_DEQUEUE_LATER:\n\t\t\t/*\n\t\t\t * If the CCID determines when to send, the next sending\n\t\t\t * time is unknown or the CCID may not even send again\n\t\t\t * (e.g. remote host crashes or lost Ack packets).\n\t\t\t */\n\t\t\tDCCP_WARN("CCID did not manage to send all packets\\n");\n\t\t\treturn;\n\t\tcase CCID_PACKET_DELAY:\n\t\t\tdelay = msecs_to_jiffies(rc);\n\t\t\tif (delay > *time_budget)\n\t\t\t\treturn;\n\t\t\trc = dccp_wait_for_ccid(sk, delay);\n\t\t\tif (rc < 0)\n\t\t\t\treturn;\n\t\t\t*time_budget -= (delay - rc);\n\t\t\t/* check again if we can send now */\n\t\t\tbreak;\n\t\tcase CCID_PACKET_SEND_AT_ONCE:\n\t\t\tdccp_xmit_packet(sk);\n\t\t\tbreak;\n\t\tcase CCID_PACKET_ERR:\n\t\t\tskb_dequeue(&sk->sk_write_queue);\n\t\t\tkfree_skb(skb);\n	t
49377	3046	udc_irq	drivers/usb/gadget/udc/snps_udc_core.c	dev	1	11	\N	\N	\tstruct udc *dev = pdev;\n\tu32 reg;\n\tu16 i;\n\tu32 ep_irq;\n\tirqreturn_t ret_val = IRQ_NONE;\n\n\tspin_lock(&dev->lock);\n\n\t/* check for ep irq */\n\treg = readl(&dev->regs->ep_irqsts);\n\tif (reg) {\n\t\tif (reg & AMD_BIT(UDC_EPINT_OUT_EP0))\n\t\t\tret_val |= udc_control_out_isr(dev);\n\t\tif (reg & AMD_BIT(UDC_EPINT_IN_EP0))\n\t\t\tret_val |= udc_control_in_isr(dev);\n\n\t\t/*\n\t\t * data endpoint\n\t\t * iterate ep's\n\t\t */\n\t\tfor (i = 1; i < UDC_EP_NUM; i++) {\n\t\t\tep_irq = 1 << i;\n\t\t\tif (!(reg & ep_irq) || i == UDC_EPINT_OUT_EP0)\n\t\t\t\tcontinue;\n\n\t\t\t/* clear irq status */\n\t\t\twritel(ep_irq, &dev->regs->ep_irqsts);\n\n\t\t\t/* irq for out ep ? */\n\t\t\tif (i > UDC_EPIN_NUM)\n\t\t\t\tret_val |= udc_data_out_isr(dev, i);\n\t\t\telse\n\t\t\t\tret_val |= udc_data_in_isr(dev, i);\n\t\t}\n\n\t}\n\n\n\t/* check for dev irq */\n\treg = readl(&dev->regs->irqsts);\n\tif (reg) {\n\t\t/* clear irq */\n\t\twritel(reg, &dev->regs->irqsts);\n\t\tret_val |= udc_dev_isr(dev, reg);\n	t
53193	490	affs_getemptyblk_ino	fs/affs/file.c	&tmp_bh	1	11	\N	\N	\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n	t
-505	215	efivarfs_fill_super	fs/efivarfs/super.c	inode	1000	3	\N	\N	\tstruct inode *inode = NULL;\n\tstruct dentry *root;\n\tint err;\n\n\tefivarfs_sb = sb;\n\n\tsb->s_maxbytes          = MAX_LFS_FILESIZE;\n\tsb->s_blocksize         = PAGE_SIZE;\n\tsb->s_blocksize_bits    = PAGE_SHIFT;\n\tsb->s_magic             = EFIVARFS_MAGIC;\n\tsb->s_op                = &efivarfs_ops;\n\tsb->s_d_op\t\t= &efivarfs_d_ops;\n\tsb->s_time_gran         = 1;\n\n\tinode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0, true);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode->i_op = &efivarfs_dir_inode_operations;\n\n\troot = d_make_root(inode);\n	f
45986	444	nilfs_prepare_segment_for_recovery	fs/nilfs2/recovery.c	segnum[1]	2	-11	\N	\N	\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t/*\n\t * Releasing the next segment of the latest super root.\n\t * The next segment is invalidated by this recovery.\n\t */\n\terr = nilfs_sufile_free(sufile, segnum[1]);\n	t
63425	145	dsa_rcv	net/dsa/tag_dsa.c	new_header	0	11	\N	\N	\tstruct dsa_switch_tree *dst = dev->dsa_ptr;\n\tstruct dsa_switch *ds;\n\tu8 *dsa_header;\n\tint source_device;\n\tint source_port;\n\n\tif (unlikely(!pskb_may_pull(skb, DSA_HLEN)))\n\t\treturn NULL;\n\n\t/*\n\t * The ethertype field is part of the DSA header.\n\t */\n\tdsa_header = skb->data - 2;\n\n\t/*\n\t * Check that frame type is either TO_CPU or FORWARD.\n\t */\n\tif ((dsa_header[0] & 0xc0) != 0x00 && (dsa_header[0] & 0xc0) != 0xc0)\n\t\treturn NULL;\n\n\t/*\n\t * Determine source device and port.\n\t */\n\tsource_device = dsa_header[0] & 0x1f;\n\tsource_port = (dsa_header[1] >> 3) & 0x1f;\n\n\t/*\n\t * Check that the source device exists and that the source\n\t * port is a registered DSA port.\n\t */\n\tif (source_device >= DSA_MAX_SWITCHES)\n\t\treturn NULL;\n\n\tds = dst->ds[source_device];\n\tif (!ds)\n\t\treturn NULL;\n\n\tif (source_port >= ds->num_ports || !ds->ports[source_port].netdev)\n\t\treturn NULL;\n\n\t/*\n\t * Convert the DSA header to an 802.1q header if the 'tagged'\n\t * bit in the DSA header is set.  If the 'tagged' bit is clear,\n\t * delete the DSA header entirely.\n\t */\n\tif (dsa_header[0] & 0x20) {\n\t\tu8 new_header[4];\n\n\t\t/*\n\t\t * Insert 802.1q ethertype and copy the VLAN-related\n\t\t * fields, but clear the bit that will hold CFI (since\n\t\t * DSA uses that bit location for another purpose).\n\t\t */\n\t\tnew_header[0] = (ETH_P_8021Q >> 8) & 0xff;\n\t\tnew_header[1] = ETH_P_8021Q & 0xff;\n\t\tnew_header[2] = dsa_header[2] & ~0x10;\n\t\tnew_header[3] = dsa_header[3];\n\n\t\t/*\n\t\t * Move CFI bit from its place in the DSA header to\n\t\t * its 802.1q-designated place.\n\t\t */\n\t\tif (dsa_header[1] & 0x01)\n\t\t\tnew_header[2] |= 0x10;\n\n\t\t/*\n\t\t * Update packet checksum if skb is CHECKSUM_COMPLETE.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\t\t__wsum c = skb->csum;\n\t\t\tc = csum_add(c, csum_partial(new_header + 2, 2, 0));\n\t\t\tc = csum_sub(c, csum_partial(dsa_header + 2, 2, 0));\n\t\t\tskb->csum = c;\n\t\t}\n\n\t\tmemcpy(dsa_header, new_header, DSA_HLEN);\n	f
62919	7269	ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config_$cmd$obj	0	13	\N	\N	\tstruct wmi_pdev_get_tpc_config_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_get_tpc_config_cmd *)skb->data;\n\tcmd->param = __cpu_to_le32(param);\n	f
27336	1088	rvt_error_qp	drivers/infiniband/sw/rdmavt/qp.c	&wc	1	11	\N	\N	\tstruct ib_wc wc;\n\tint ret = 0;\n\tstruct rvt_dev_info *rdi = ib_to_rvt(qp->ibqp.device);\n\n\tlockdep_assert_held(&qp->r_lock);\n\tlockdep_assert_held(&qp->s_lock);\n\tif (qp->state == IB_QPS_ERR || qp->state == IB_QPS_RESET)\n\t\tgoto bail;\n\n\tqp->state = IB_QPS_ERR;\n\n\tif (qp->s_flags & (RVT_S_TIMER | RVT_S_WAIT_RNR)) {\n\t\tqp->s_flags &= ~(RVT_S_TIMER | RVT_S_WAIT_RNR);\n\t\tdel_timer(&qp->s_timer);\n\t}\n\n\tif (qp->s_flags & RVT_S_ANY_WAIT_SEND)\n\t\tqp->s_flags &= ~RVT_S_ANY_WAIT_SEND;\n\n\trdi->driver_f.notify_error_qp(qp);\n\n\t/* Schedule the sending tasklet to drain the send work queue. */\n\tif (ACCESS_ONCE(qp->s_last) != qp->s_head)\n\t\trdi->driver_f.schedule_send(qp);\n\n\trvt_clear_mr_refs(qp, 0);\n\n\tmemset(&wc, 0, sizeof(wc));\n\twc.qp = &qp->ibqp;\n\twc.opcode = IB_WC_RECV;\n\n\tif (test_and_clear_bit(RVT_R_WRID_VALID, &qp->r_aflags)) {\n\t\twc.wr_id = qp->r_wr_id;\n\t\twc.status = err;\n\t\trvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc, 1);\n	t
45168	27792	wlc_phy_cal_rxiq_nphy_rev2	drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c	pi	1	11	\N	\N	\tstruct phy_iq_est est[PHY_CORE_MAX];\n\tu8 core_num, rx_core, tx_core;\n\tu16 lna_vals[] = { 0x3, 0x3, 0x1 };\n\tu16 hpf1_vals[] = { 0x7, 0x2, 0x0 };\n\tu16 hpf2_vals[] = { 0x2, 0x0, 0x0 };\n\ts16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;\n\ts16 desired_log2_pwr, actual_log2_pwr, hpf_change;\n\tu16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;\n\tu16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;\n\tu16 num_samps;\n\tu32 i_pwr, q_pwr, tot_pwr[3];\n\tu8 gain_pass, use_hpf_num;\n\tu16 mask, val1, val2;\n\tu16 core_no;\n\tu16 gain_save[2];\n\tu16 cal_gain[2];\n\tstruct nphy_iqcal_params cal_params[2];\n\tu8 phy_bw;\n\tint bcmerror = 0;\n\tbool first_playtone = true;\n\n\twlc_phy_stay_in_carriersearch_nphy(pi, true);\n\n\tif (NREV_LT(pi->pubpi.phy_rev, 2))\n\t\twlc_phy_reapply_txcal_coeffs_nphy(pi);\n\n\twlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);\n\n\tfor (core_no = 0; core_no <= 1; core_no++) {\n\t\twlc_phy_iqcal_gainparams_nphy(pi, core_no, target_gain,\n\t\t\t\t\t      &cal_params[core_no]);\n\t\tcal_gain[core_no] = cal_params[core_no].cal_gain;\n\t}\n\n\twlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, cal_gain);\n\n\tnum_samps = 1024;\n\tdesired_log2_pwr = 13;\n\n\tfor (core_num = 0; core_num < 2; core_num++) {\n\n\t\trx_core = core_num;\n\t\ttx_core = 1 - core_num;\n\n\t\torig_RfseqCoreActv = read_phy_reg(pi, 0xa2);\n\t\torig_AfectrlCore = read_phy_reg(pi, (rx_core == PHY_CORE_0) ?\n\t\t\t\t\t\t0xa6 : 0xa7);\n\t\torig_AfectrlOverride = read_phy_reg(pi, 0xa5);\n\t\torig_RfctrlIntcRx = read_phy_reg(pi, (rx_core == PHY_CORE_0) ?\n\t\t\t\t\t\t 0x91 : 0x92);\n\t\torig_RfctrlIntcTx = read_phy_reg(pi, (tx_core == PHY_CORE_0) ?\n\t\t\t\t\t\t 0x91 : 0x92);\n\n\t\tmod_phy_reg(pi, 0xa2, (0xf << 12), (1 << tx_core) << 12);\n\t\tmod_phy_reg(pi, 0xa2, (0xf << 0), (1 << tx_core) << 0);\n\n\t\tor_phy_reg(pi, ((rx_core == PHY_CORE_0) ? 0xa6 : 0xa7),\n\t\t\t   ((0x1 << 1) | (0x1 << 2)));\n\t\tor_phy_reg(pi, 0xa5, ((0x1 << 1) | (0x1 << 2)));\n\n\t\tif (((pi->nphy_rxcalparams) & 0xff000000))\n\t\t\twrite_phy_reg(pi,\n\t\t\t\t      (rx_core == PHY_CORE_0) ? 0x91 : 0x92,\n\t\t\t\t      (CHSPEC_IS5G(pi->radio_chanspec) ?\n\t\t\t\t\t0x140 : 0x110));\n\t\telse\n\t\t\twrite_phy_reg(pi,\n\t\t\t\t      (rx_core == PHY_CORE_0) ? 0x91 : 0x92,\n\t\t\t\t      (CHSPEC_IS5G(pi->radio_chanspec) ?\n\t\t\t\t       0x180 : 0x120));\n\n\t\twrite_phy_reg(pi, (tx_core == PHY_CORE_0) ? 0x91 : 0x92,\n\t\t\t      (CHSPEC_IS5G(pi->radio_chanspec) ? 0x148 :\n\t\t\t       0x114));\n\n\t\tmask = RADIO_2055_COUPLE_RX_MASK | RADIO_2055_COUPLE_TX_MASK;\n\t\tif (rx_core == PHY_CORE_0) {\n\t\t\tval1 = RADIO_2055_COUPLE_RX_MASK;\n\t\t\tval2 = RADIO_2055_COUPLE_TX_MASK;\n\t\t} else {\n\t\t\tval1 = RADIO_2055_COUPLE_TX_MASK;\n\t\t\tval2 = RADIO_2055_COUPLE_RX_MASK;\n\t\t}\n\n\t\tif ((pi->nphy_rxcalparams & 0x10000)) {\n\t\t\tmod_radio_reg(pi, RADIO_2055_CORE1_GEN_SPARE2, mask,\n\t\t\t\t      val1);\n\t\t\tmod_radio_reg(pi, RADIO_2055_CORE2_GEN_SPARE2, mask,\n\t\t\t\t      val2);\n\t\t}\n\n\t\tfor (gain_pass = 0; gain_pass < 4; gain_pass++) {\n\n\t\t\tif (debug)\n\t\t\t\tmdelay(WAIT_FOR_SCOPE);\n\n\t\t\tif (gain_pass < 3) {\n\t\t\t\tcurr_lna = lna_vals[gain_pass];\n\t\t\t\tcurr_hpf1 = hpf1_vals[gain_pass];\n\t\t\t\tcurr_hpf2 = hpf2_vals[gain_pass];\n\t\t\t} else {\n\n\t\t\t\tif (tot_pwr[1] > 10000) {\n\t\t\t\t\tcurr_lna = lna_vals[2];\n\t\t\t\t\tcurr_hpf1 = hpf1_vals[2];\n\t\t\t\t\tcurr_hpf2 = hpf2_vals[2];\n\t\t\t\t\tuse_hpf_num = 1;\n\t\t\t\t\tcurr_hpf = curr_hpf1;\n\t\t\t\t\tactual_log2_pwr =\n\t\t\t\t\t\twlc_phy_nbits(tot_pwr[2]);\n\t\t\t\t} else {\n\t\t\t\t\tif (tot_pwr[0] > 10000) {\n\t\t\t\t\t\tcurr_lna = lna_vals[1];\n\t\t\t\t\t\tcurr_hpf1 = hpf1_vals[1];\n\t\t\t\t\t\tcurr_hpf2 = hpf2_vals[1];\n\t\t\t\t\t\tuse_hpf_num = 1;\n\t\t\t\t\t\tcurr_hpf = curr_hpf1;\n\t\t\t\t\t\tactual_log2_pwr =\n\t\t\t\t\t\t\twlc_phy_nbits(\n\t\t\t\t\t\t\t\ttot_pwr[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurr_lna = lna_vals[0];\n\t\t\t\t\t\tcurr_hpf1 = hpf1_vals[0];\n\t\t\t\t\t\tcurr_hpf2 = hpf2_vals[0];\n\t\t\t\t\t\tuse_hpf_num = 2;\n\t\t\t\t\t\tcurr_hpf = curr_hpf2;\n\t\t\t\t\t\tactual_log2_pwr =\n\t\t\t\t\t\t\twlc_phy_nbits(\n\t\t\t\t\t\t\t\ttot_pwr[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thpf_change = desired_log2_pwr - actual_log2_pwr;\n\t\t\t\tcurr_hpf += hpf_change;\n\t\t\t\tcurr_hpf = max(min_t(u16, curr_hpf, 10), 0);\n\t\t\t\tif (use_hpf_num == 1)\n\t\t\t\t\tcurr_hpf1 = curr_hpf;\n\t\t\t\telse\n\t\t\t\t\tcurr_hpf2 = curr_hpf;\n\t\t\t}\n\n\t\t\twlc_phy_rfctrl_override_nphy(pi, (0x1 << 10),\n\t\t\t\t\t\t     ((curr_hpf2 << 8) |\n\t\t\t\t\t\t      (curr_hpf1 << 4) |\n\t\t\t\t\t\t      (curr_lna << 2)), 0x3, 0);\n\t\t\twlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);\n\n\t\t\twlc_phy_stopplayback_nphy(pi);\n\n\t\t\tif (first_playtone) {\n\t\t\t\tbcmerror = wlc_phy_tx_tone_nphy(pi, 4000,\n\t\t\t\t\t\t(u16) (pi->nphy_rxcalparams &\n\t\t\t\t\t\t       0xffff), 0, 0, true);\n\t\t\t\tfirst_playtone = false;\n\t\t\t} else {\n\t\t\t\tphy_bw = (CHSPEC_IS40(pi->radio_chanspec)) ?\n\t\t\t\t\t  40 : 20;\n\t\t\t\twlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff,\n\t\t\t\t\t\t\t0, 0, 0, true);\n\t\t\t}\n\n\t\t\tif (bcmerror == 0) {\n\t\t\t\tif (gain_pass < 3) {\n\n\t\t\t\t\twlc_phy_rx_iq_est_nphy(pi, est,\n\t\t\t\t\t\t\t       num_samps, 32,\n\t\t\t\t\t\t\t       0);\n\t\t\t\t\ti_pwr =\t(est[rx_core].i_pwr +\n\t\t\t\t\t\t num_samps / 2) / num_samps;\n\t\t\t\t\tq_pwr =\t(est[rx_core].q_pwr +\n\t\t\t\t\t\t num_samps / 2) / num_samps;\n\t\t\t\t\ttot_pwr[gain_pass] = i_pwr + q_pwr;\n\t\t\t\t} else {\n\n\t\t\t\t\twlc_phy_calc_rx_iq_comp_nphy(pi,\n\t\t\t\t\t\t\t\t     (1 <<\n\t\t\t\t\t\t\t\t      rx_core));\n\t\t\t\t}\n\n\t\t\t\twlc_phy_stopplayback_nphy(pi);\n\t\t\t}\n\n\t\t\tif (bcmerror != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tand_radio_reg(pi, RADIO_2055_CORE1_GEN_SPARE2, ~mask);\n\t\tand_radio_reg(pi, RADIO_2055_CORE2_GEN_SPARE2, ~mask);\n\n\t\twrite_phy_reg(pi, (tx_core == PHY_CORE_0) ? 0x91 :\n	t
52193	951	omap_dma_prep_slave_sg	drivers/dma/omap-dma.c	port_window_bytes	1	11	\N	\N	\tstruct omap_dmadev *od = to_omap_dma_dev(chan->device);\n\tstruct omap_chan *c = to_omap_dma_chan(chan);\n\tenum dma_slave_buswidth dev_width;\n\tstruct scatterlist *sgent;\n\tstruct omap_desc *d;\n\tdma_addr_t dev_addr;\n\tunsigned i, es, en, frame_bytes;\n\tbool ll_failed = false;\n\tu32 burst;\n\tu32 port_window, port_window_bytes;\n\n\tif (dir == DMA_DEV_TO_MEM) {\n\t\tdev_addr = c->cfg.src_addr;\n\t\tdev_width = c->cfg.src_addr_width;\n\t\tburst = c->cfg.src_maxburst;\n\t\tport_window = c->cfg.src_port_window_size;\n\t} else if (dir == DMA_MEM_TO_DEV) {\n\t\tdev_addr = c->cfg.dst_addr;\n\t\tdev_width = c->cfg.dst_addr_width;\n\t\tburst = c->cfg.dst_maxburst;\n\t\tport_window = c->cfg.dst_port_window_size;\n\t} else {\n\t\tdev_err(chan->device->dev, "%s: bad direction?\\n", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* Bus width translates to the element size (ES) */\n\tswitch (dev_width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tes = CSDP_DATA_TYPE_8;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tes = CSDP_DATA_TYPE_16;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tes = CSDP_DATA_TYPE_32;\n\t\tbreak;\n\tdefault: /* not reached */\n\t\treturn NULL;\n\t}\n\n\t/* Now allocate and setup the descriptor. */\n\td = kzalloc(sizeof(*d) + sglen * sizeof(d->sg[0]), GFP_ATOMIC);\n\tif (!d)\n\t\treturn NULL;\n\n\td->dir = dir;\n\td->dev_addr = dev_addr;\n\td->es = es;\n\n\t/* When the port_window is used, one frame must cover the window */\n\tif (port_window) {\n\t\tburst = port_window;\n\t\tport_window_bytes = port_window * es_bytes[es];\n\n\t\td->ei = 1;\n\t\t/*\n\t\t * One frame covers the port_window and by  configure\n\t\t * the source frame index to be -1 * (port_window - 1)\n\t\t * we instruct the sDMA that after a frame is processed\n\t\t * it should move back to the start of the window.\n\t\t */\n\t\td->fi = -(port_window_bytes - 1);\n\t}\n\n\td->ccr = c->ccr | CCR_SYNC_FRAME;\n\tif (dir == DMA_DEV_TO_MEM) {\n\t\td->csdp = CSDP_DST_BURST_64 | CSDP_DST_PACKED;\n\n\t\td->ccr |= CCR_DST_AMODE_POSTINC;\n\t\tif (port_window) {\n\t\t\td->ccr |= CCR_SRC_AMODE_DBLIDX;\n\n\t\t\tif (port_window_bytes >= 64)\n	t
63475	924	mt9t001_probe	drivers/media/i2c/mt9t001.c	mt9t001->ctrls.error	1	-11	\N	\N	\tstruct mt9t001_platform_data *pdata = client->dev.platform_data;\n\tstruct mt9t001 *mt9t001;\n\tunsigned int i;\n\tint ret;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, "No platform data\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_warn(&client->adapter->dev,\n\t\t\t "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\\n");\n\t\treturn -EIO;\n\t}\n\n\tmt9t001 = devm_kzalloc(&client->dev, sizeof(*mt9t001), GFP_KERNEL);\n\tif (!mt9t001)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mt9t001->power_lock);\n\tmt9t001->output_control = MT9T001_OUTPUT_CONTROL_DEF;\n\n\tmt9t001->regulators[0].supply = "vdd";\n\tmt9t001->regulators[1].supply = "vaa";\n\n\tret = devm_regulator_bulk_get(&client->dev, 2, mt9t001->regulators);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, "Unable to get regulators\\n");\n\t\treturn ret;\n\t}\n\n\tmt9t001->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(mt9t001->clk)) {\n\t\tdev_err(&client->dev, "Unable to get clock\\n");\n\t\treturn PTR_ERR(mt9t001->clk);\n\t}\n\n\tv4l2_ctrl_handler_init(&mt9t001->ctrls, ARRAY_SIZE(mt9t001_ctrls) +\n\t\t\t\t\t\tARRAY_SIZE(mt9t001_gains) + 4);\n\n\tv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE, MT9T001_SHUTTER_WIDTH_MIN,\n\t\t\t  MT9T001_SHUTTER_WIDTH_MAX, 1,\n\t\t\t  MT9T001_SHUTTER_WIDTH_DEF);\n\tv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\n\t\t\t  V4L2_CID_BLACK_LEVEL, 1, 1, 1, 1);\n\tv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\n\t\t\t  V4L2_CID_PIXEL_RATE, pdata->ext_clk, pdata->ext_clk,\n\t\t\t  1, pdata->ext_clk);\n\tv4l2_ctrl_new_std_menu_items(&mt9t001->ctrls, &mt9t001_ctrl_ops,\n\t\t\tV4L2_CID_TEST_PATTERN,\n\t\t\tARRAY_SIZE(mt9t001_test_pattern_menu) - 1, 0,\n\t\t\t0, mt9t001_test_pattern_menu);\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9t001_ctrls); ++i)\n\t\tv4l2_ctrl_new_custom(&mt9t001->ctrls, &mt9t001_ctrls[i], NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9t001_gains); ++i)\n\t\tmt9t001->gains[i] = v4l2_ctrl_new_custom(&mt9t001->ctrls,\n\t\t\t&mt9t001_gains[i], NULL);\n\n\tv4l2_ctrl_cluster(ARRAY_SIZE(mt9t001_gains), mt9t001->gains);\n\n\tmt9t001->subdev.ctrl_handler = &mt9t001->ctrls;\n\n\tif (mt9t001->ctrls.error) {\n	t
-504	434	batadv_frag_create	net/batman-adv/fragmentation.c	skb_fragment->data	1000	3	\N	\N	\tstruct sk_buff *skb_fragment;\n\tunsigned int header_size = sizeof(*frag_head);\n\tunsigned int mtu = fragment_size + header_size;\n\n\tskb_fragment = netdev_alloc_skb(NULL, mtu + ETH_HLEN);\n\tif (!skb_fragment)\n\t\tgoto err;\n\n\tskb_fragment->priority = skb->priority;\n\n\t/* Eat the last mtu-bytes of the skb */\n\tskb_reserve(skb_fragment, header_size + ETH_HLEN);\n\tskb_split(skb, skb_fragment, skb->len - fragment_size);\n\n\t/* Add the header */\n\tskb_push(skb_fragment, header_size);\n\tmemcpy(skb_fragment->data, frag_head, header_size);\n	f
54758	1622	rdtgroup_mkdir_mon	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c	rdtgroup_mkdir_mon_$rdtgrp$obj$8	0	13	\N	\N	\tstruct rdtgroup *rdtgrp, *prgrp;\n\tint ret;\n\n\tret = mkdir_rdt_prepare(parent_kn, prgrp_kn, name, mode, RDTMON_GROUP,\n\t\t\t\t&rdtgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tprgrp = rdtgrp->mon.parent;\n	f
8343	714	lpfc_nvmet_xmt_fcp_op	drivers/scsi/lpfc/lpfc_nvmet.c	ctxp	1	11	\N	\N	\tstruct lpfc_nvmet_tgtport *lpfc_nvmep = tgtport->private;\n\tstruct lpfc_nvmet_rcv_ctx *ctxp =\n\t\tcontainer_of(rsp, struct lpfc_nvmet_rcv_ctx, ctx.fcp_req);\n\tstruct lpfc_hba *phba = ctxp->phba;\n\tstruct lpfc_iocbq *nvmewqeq;\n\tint rc;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (phba->ktime_on) {\n\t\tif (rsp->op == NVMET_FCOP_RSP)\n\t\t\tctxp->ts_nvme_status = ktime_get_ns();\n\t\telse\n\t\t\tctxp->ts_nvme_data = ktime_get_ns();\n\t}\n\tif (phba->cpucheck_on & LPFC_CHECK_NVMET_IO) {\n\t\tint id = smp_processor_id();\n\t\tctxp->cpu = id;\n\t\tif (id < LPFC_CHECK_CPU_CNT)\n\t\t\tphba->cpucheck_xmt_io[id]++;\n\t\tif (rsp->hwqid != id) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_NVME_IOERR,\n\t\t\t\t\t"6705 CPU Check OP: "\n\t\t\t\t\t"cpu %d expect %d\\n",\n\t\t\t\t\tid, rsp->hwqid);\n\t\t\tctxp->cpu = rsp->hwqid;\n\t\t}\n\t}\n#endif\n\n\t/* Sanity check */\n\tif ((ctxp->flag & LPFC_NVMET_ABTS_RCV) ||\n\t    (ctxp->state == LPFC_NVMET_STE_ABORT)) {\n\t\tatomic_inc(&lpfc_nvmep->xmt_fcp_drop);\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_NVME_IOERR,\n\t\t\t\t"6102 IO xri x%x aborted\\n",\n\t\t\t\tctxp->oxid);\n\t\trc = -ENXIO;\n\t\tgoto aerr;\n\t}\n\n\tnvmewqeq = lpfc_nvmet_prep_fcp_wqe(phba, ctxp);\n	t
24169	1589	irnet_discovervalue_confirm	drivers/staging/irda/net/irnet/irnet_irda.c	self	1	11	\N	\N	  irnet_socket *\tself = (irnet_socket *) priv;\n  __u8\t\t\tdtsap_sel;\t\t/* TSAP we are looking for */\n\n  DENTER(IRDA_OCB_TRACE, "(self=0x%p)\\n", self);\n  DASSERT(self != NULL, , IRDA_OCB_ERROR, "Self is NULL !!!\\n");\n\n  /* Check if already connected (via irnet_connect_socket())\n   * or socket is closing down (via irda_irnet_destroy()) */\n  if(! test_bit(0, &self->ttp_connect))\n    {\n      DERROR(IRDA_OCB_ERROR, "Socket no longer connecting. Ouch !\\n");\n      return;\n    }\n\n  /* Post process the IAS reply */\n  dtsap_sel = irnet_ias_to_tsap(self, result, value);\n\n  /* Have we got something ? */\n  if(self->errno == 0)\n    {\n      /* We found the requested service */\n      if(self->daddr != DEV_ADDR_ANY)\n\t{\n\t  DERROR(IRDA_OCB_ERROR, "More than one device in range supports IrNET...\\n");\n\t}\n      else\n\t{\n\t  /* First time we found that one, save it ! */\n\t  self->daddr = self->discoveries[self->disco_index].daddr;\n\t  self->dtsap_sel = dtsap_sel;\n\t}\n    }\n\n  /* If no failure */\n  if((self->errno == -EADDRNOTAVAIL) || (self->errno == 0))\n    {\n      int\tret;\n\n      /* Search the next node */\n      ret = irnet_discover_next_daddr(self);\n	t
38384	1651	ef4_probe_nic	drivers/net/ethernet/sfc/falcon/efx.c	efx	1	11	\N	\N	\tint rc;\n\n\tnetif_dbg(efx, probe, efx->net_dev, "creating NIC\\n");\n\n\t/* Carry out hardware-type specific initialisation */\n\trc = efx->type->probe(efx);\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\tif (!efx->max_channels || !efx->max_tx_channels) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  "Insufficient resources to allocate"\n\t\t\t\t  " any channels\\n");\n\t\t\trc = -ENOSPC;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\t/* Determine the number of channels and queues by trying\n\t\t * to hook in MSI-X interrupts.\n\t\t */\n\t\trc = ef4_probe_interrupts(efx);\n\t\tif (rc)\n\t\t\tgoto fail1;\n\n\t\tef4_set_channels(efx);\n	t
51354	5033	ext4_convert_unwritten_extents	fs/ext4/extents.c	ret	1	11	\N	\N	\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\tmax_blocks = EXT4_MAX_BLOCKS(len, offset, blkbits);\n\n\t/*\n\t * This is somewhat ugly but the idea is clear: When transaction is\n\t * reserved, everything goes into it. Otherwise we rather start several\n\t * smaller transactions for conversion of each extent separately.\n\t */\n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tcredits = 0;\n\t} else {\n\t\t/*\n\t\t * credits to insert 1 extent into extent tree\n\t\t */\n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n	t
31451	357	alps_input_configured	drivers/hid/hid-alps.c	alps_input_configured_$devInfo$13$obj	0	13	\N	\N	\tstruct u1_dev *data = hid_get_drvdata(hdev);\n\tstruct input_dev *input = hi->input, *input2;\n\tstruct u1_dev devInfo;\n\tint ret;\n\tint res_x, res_y, i;\n\n\tdata->input = input;\n\n\thid_dbg(hdev, "Opening low level driver\\n");\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Allow incoming hid reports */\n\thid_device_io_start(hdev);\n\n\t/* Device initialization */\n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\n\t\t\t&devInfo.dev_ctrl, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tdevInfo.dev_ctrl &= ~U1_DISABLE_DEV;\n\tdevInfo.dev_ctrl |= U1_TP_ABS_MODE;\n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\n\t\t\tNULL, devInfo.dev_ctrl, false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed to change TP mode (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,\n\t\t\t&devInfo.sen_line_num_x, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,\n\t\t\t&devInfo.sen_line_num_y, 0, true);\n\t\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,\n\t\t\t&devInfo.pitch_x, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,\n\t\t\t&devInfo.pitch_y, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,\n\t\t&devInfo.resolution, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,\n\t\t\t&devInfo.btn_info, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\t/* Check StickPointer device */\n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,\n\t\t\t&devInfo.dev_type, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tdevInfo.x_active_len_mm =\n\t\t(devInfo.pitch_x * (devInfo.sen_line_num_x - 1)) / 10;\n\tdevInfo.y_active_len_mm =\n\t\t(devInfo.pitch_y * (devInfo.sen_line_num_y - 1)) / 10;\n\n\tdevInfo.x_max =\n\t\t(devInfo.resolution << 2) * (devInfo.sen_line_num_x - 1);\n\tdevInfo.y_max =\n\t\t(devInfo.resolution << 2) * (devInfo.sen_line_num_y - 1);\n\n\t__set_bit(EV_ABS, input->evbit);\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 1, devInfo.x_max, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 1, devInfo.y_max, 0, 0);\n\n\tif (devInfo.x_active_len_mm && devInfo.y_active_len_mm) {\n	f
-507	1982	touchpad_store	drivers/platform/x86/toshiba_acpi.c	state	1000	3	\N	\N	\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\t/* Set the TouchPad on/off, 0 - Disable | 1 - Enable */\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n	f
-502	329	asoc_simple_card_parse_aux_devs	sound/soc/generic/simple-card.c	aux_node	1000	3	\N	\N	\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *aux_node;\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tint i, n, len;\n\n\tif (!of_find_property(node, PREFIX "aux-devs", &len))\n\t\treturn 0;\t\t/* Ok to have no aux-devs */\n\n\tn = len / sizeof(__be32);\n\tif (n <= 0)\n\t\treturn -EINVAL;\n\n\tcard->aux_dev = devm_kzalloc(dev,\n\t\t\tn * sizeof(*card->aux_dev), GFP_KERNEL);\n\tif (!card->aux_dev)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++) {\n\t\taux_node = of_parse_phandle(node, PREFIX "aux-devs", i);\n\t\tif (!aux_node)\n	f
7229	77	atombios_overscan_setup	drivers/gpu/drm/radeon/atombios_crtc.c	index	1	11	\N	\N	\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tSET_CRTC_OVERSCAN_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_OverScan);\n\tint a1, a2;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\n\tswitch (radeon_crtc->rmx_type) {\n\tcase RMX_CENTER:\n\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\tbreak;\n\tcase RMX_ASPECT:\n\t\ta1 = mode->crtc_vdisplay * adjusted_mode->crtc_hdisplay;\n\t\ta2 = adjusted_mode->crtc_vdisplay * mode->crtc_hdisplay;\n\n\t\tif (a1 > a2) {\n\t\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t} else if (a2 > a1) {\n\t\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t}\n\t\tbreak;\n\tcase RMX_FULL:\n\tdefault:\n\t\targs.usOverscanRight = cpu_to_le16(radeon_crtc->h_border);\n\t\targs.usOverscanLeft = cpu_to_le16(radeon_crtc->h_border);\n\t\targs.usOverscanBottom = cpu_to_le16(radeon_crtc->v_border);\n\t\targs.usOverscanTop = cpu_to_le16(radeon_crtc->v_border);\n\t\tbreak;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n	t
20566	781	selinux_set_mnt_opts	security/selinux/hooks.c	rootcontext_sid)	1	11	\N	\N	\tconst struct cred *cred = current_cred();\n\tint rc = 0, i;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tconst char *name = sb->s_type->name;\n\tstruct dentry *root = sbsec->sb->s_root;\n\tstruct inode_security_struct *root_isec;\n\tu32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;\n\tu32 defcontext_sid = 0;\n\tchar **mount_options = opts->mnt_opts;\n\tint *flags = opts->mnt_opts_flags;\n\tint num_opts = opts->num_mnt_opts;\n\n\tmutex_lock(&sbsec->lock);\n\n\tif (!ss_initialized) {\n\t\tif (!num_opts) {\n\t\t\t/* Defer initialization until selinux_complete_init,\n\t\t\t   after the initial policy is loaded and the security\n\t\t\t   server is ready to handle calls. */\n\t\t\tgoto out;\n\t\t}\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING "SELinux: Unable to set superblock options "\n\t\t\t"before the security server is initialized\\n");\n\t\tgoto out;\n\t}\n\tif (kern_flags && !set_kern_flags) {\n\t\t/* Specifying internal flags without providing a place to\n\t\t * place the results is not allowed */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Binary mount data FS will come through this function twice.  Once\n\t * from an explicit call and once from the generic calls from the vfs.\n\t * Since the generic VFS calls will not contain any security mount data\n\t * we need to skip the double mount verification.\n\t *\n\t * This does open a hole in which we will not notice if the first\n\t * mount using this sb set explict options and a second mount using\n\t * this sb does not set any security options.  (The first options\n\t * will be used for both mounts)\n\t */\n\tif ((sbsec->flags & SE_SBINITIALIZED) && (sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)\n\t    && (num_opts == 0))\n\t\tgoto out;\n\n\troot_isec = backing_inode_security_novalidate(root);\n\n\t/*\n\t * parse the mount options, check if they are valid sids.\n\t * also check if someone is trying to mount the same sb more\n\t * than once with different security options.\n\t */\n\tfor (i = 0; i < num_opts; i++) {\n\t\tu32 sid;\n\n\t\tif (flags[i] == SBLABEL_MNT)\n\t\t\tcontinue;\n\t\trc = security_context_str_to_sid(mount_options[i], &sid, GFP_KERNEL);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING "SELinux: security_context_str_to_sid"\n\t\t\t       "(%s) failed for (dev %s, type %s) errno=%d\\n",\n\t\t\t       mount_options[i], sb->s_id, name, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (flags[i]) {\n\t\tcase FSCONTEXT_MNT:\n\t\t\tfscontext_sid = sid;\n\n\t\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,\n\t\t\t\t\tfscontext_sid))\n\t\t\t\tgoto out_double_mount;\n\n\t\t\tsbsec->flags |= FSCONTEXT_MNT;\n\t\t\tbreak;\n\t\tcase CONTEXT_MNT:\n\t\t\tcontext_sid = sid;\n\n\t\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,\n\t\t\t\t\tcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\n\t\t\tsbsec->flags |= CONTEXT_MNT;\n\t\t\tbreak;\n\t\tcase ROOTCONTEXT_MNT:\n\t\t\trootcontext_sid = sid;\n\n\t\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,\n	t
-404	666	bcm3510_check_firmware_version	drivers/media/dvb-frontends/bcm3510.c	ver.demod_version	2	3	\N	\N	\tstruct bcm3510_hab_cmd_get_version_info ver;\n\tbcm3510_do_hab_cmd(st,CMD_GET_VERSION_INFO,MSGID_GET_VERSION_INFO,NULL,0,(u8*)&ver,sizeof(ver));\n\n\tdeb_info("Version information: 0x%02x 0x%02x 0x%02x 0x%02x\\n",\n	f
20776	172	acpi_ex_resolve_operands	drivers/acpi/acpica/exresop.c	stack_ptr	1	11	\N	\N	\tunion acpi_operand_object *obj_desc;\n\tacpi_status status = AE_OK;\n\tu8 object_type;\n\tu32 arg_types;\n\tconst struct acpi_opcode_info *op_info;\n\tu32 this_arg_type;\n\tacpi_object_type type_needed;\n\tu16 target_op = 0;\n\n\tACPI_FUNCTION_TRACE_U32(ex_resolve_operands, opcode);\n\n\top_info = acpi_ps_get_opcode_info(opcode);\n\tif (op_info->class == AML_CLASS_UNKNOWN) {\n\t\treturn_ACPI_STATUS(AE_AML_BAD_OPCODE);\n\t}\n\n\targ_types = op_info->runtime_args;\n\tif (arg_types == ARGI_INVALID_OPCODE) {\n\t\tACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X", opcode));\n\n\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  "Opcode %X [%s] RequiredOperandTypes=%8.8X\\n",\n\t\t\t  opcode, op_info->name, arg_types));\n\n\t/*\n\t * Normal exit is with (arg_types == 0) at end of argument list.\n\t * Function will return an exception from within the loop upon\n\t * finding an entry which is not (or cannot be converted\n\t * to) the required type; if stack underflows; or upon\n\t * finding a NULL stack entry (which should not happen).\n\t */\n\twhile (GET_CURRENT_ARG_TYPE(arg_types)) {\n\t\tif (!stack_ptr || !*stack_ptr) {\n	t
27395	3684	cm_event_connected	drivers/infiniband/hw/nes/nes_cm.c	&attr	1	11	\N	\N	\tstruct nes_qp *nesqp;\n\tstruct nes_vnic *nesvnic;\n\tstruct nes_device *nesdev;\n\tstruct nes_cm_node *cm_node;\n\tstruct nes_adapter *nesadapter;\n\tstruct ib_qp_attr attr;\n\tstruct iw_cm_id *cm_id;\n\tstruct iw_cm_event cm_event;\n\tstruct nes_v4_quad nes_quad;\n\tu32 crc_value;\n\tint ret;\n\tstruct sockaddr_in *laddr;\n\tstruct sockaddr_in *raddr;\n\tstruct sockaddr_in *cm_event_laddr;\n\n\t/* get all our handles */\n\tcm_node = event->cm_node;\n\tcm_id = cm_node->cm_id;\n\tnes_debug(NES_DBG_CM, "cm_event_connected - %p - cm_id = %p\\n", cm_node, cm_id);\n\tnesqp = (struct nes_qp *)cm_id->provider_data;\n\tnesvnic = to_nesvnic(nesqp->ibqp.device);\n\tnesdev = nesvnic->nesdev;\n\tnesadapter = nesdev->nesadapter;\n\tladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\n\traddr = (struct sockaddr_in *)&cm_id->m_remote_addr;\n\tcm_event_laddr = (struct sockaddr_in *)&cm_event.local_addr;\n\n\tif (nesqp->destroyed)\n\t\treturn;\n\tatomic_inc(&cm_connecteds);\n\tnes_debug(NES_DBG_CM, "QP%u attempting to connect to  0x%08X:0x%04X on"\n\t\t  " local port 0x%04X. jiffies = %lu.\\n",\n\t\t  nesqp->hwqp.qp_id, ntohl(raddr->sin_addr.s_addr),\n\t\t  ntohs(raddr->sin_port), ntohs(laddr->sin_port), jiffies);\n\n\tnes_cm_init_tsa_conn(nesqp, cm_node);\n\n\t/* set the QP tsa context */\n\tnesqp->nesqp_context->tcpPorts[0] =\n\t\t\tcpu_to_le16(cm_node->loc_port);\n\tnesqp->nesqp_context->tcpPorts[1] =\n\t\t\tcpu_to_le16(cm_node->rem_port);\n\tnesqp->nesqp_context->ip0 = cpu_to_le32(cm_node->rem_addr);\n\n\tnesqp->nesqp_context->misc2 |= cpu_to_le32(\n\t\t\t(u32)PCI_FUNC(nesdev->pcidev->devfn) <<\n\t\t\tNES_QPCONTEXT_MISC2_SRC_IP_SHIFT);\n\tnesqp->nesqp_context->arp_index_vlan |= cpu_to_le32(\n\t\t\tnes_arp_table(nesdev,\n\t\t\tle32_to_cpu(nesqp->nesqp_context->ip0),\n\t\t\tNULL, NES_ARP_RESOLVE) << 16);\n\tnesqp->nesqp_context->ts_val_delta = cpu_to_le32(\n\t\t\tjiffies - nes_read_indexed(nesdev, NES_IDX_TCP_NOW));\n\tnesqp->nesqp_context->ird_index = cpu_to_le32(nesqp->hwqp.qp_id);\n\tnesqp->nesqp_context->ird_ord_sizes |=\n\t\t\tcpu_to_le32((u32)1 <<\n\t\t\tNES_QPCONTEXT_ORDIRD_IWARP_MODE_SHIFT);\n\tnesqp->nesqp_context->ird_ord_sizes |=\n\t\t\tcpu_to_le32((u32)cm_node->ord_size);\n\n\t/* Adjust tail for not having a LSMM */\n\t/*nesqp->hwqp.sq_tail = 1;*/\n\n\tbuild_rdma0_msg(cm_node, &nesqp);\n\n\tnes_write32(nesdev->regs + NES_WQE_ALLOC,\n\t\t    (1 << 24) | 0x00800000 | nesqp->hwqp.qp_id);\n\n\tmemset(&nes_quad, 0, sizeof(nes_quad));\n\n\tnes_quad.DstIpAdrIndex =\n\t\tcpu_to_le32((u32)PCI_FUNC(nesdev->pcidev->devfn) << 24);\n\tnes_quad.SrcIpadr = htonl(cm_node->rem_addr);\n\tnes_quad.TcpPorts[0] = htons(cm_node->rem_port);\n\tnes_quad.TcpPorts[1] = htons(cm_node->loc_port);\n\n\t/* Produce hash key */\n\tcrc_value = get_crc_value(&nes_quad);\n\tnesqp->hte_index = cpu_to_be32(crc_value ^ 0xffffffff);\n\tnes_debug(NES_DBG_CM, "HTE Index = 0x%08X, After CRC = 0x%08X\\n",\n\t\t  nesqp->hte_index, nesqp->hte_index & nesadapter->hte_index_mask);\n\n\tnesqp->hte_index &= nesadapter->hte_index_mask;\n\tnesqp->nesqp_context->hte_index = cpu_to_le32(nesqp->hte_index);\n\n\tnesqp->ietf_frame = &cm_node->mpa_frame;\n\tnesqp->private_data_len = (u8)cm_node->mpa_frame_size;\n\tcm_node->cm_core->api->accelerated(cm_node->cm_core, cm_node);\n\n\t/* notify OF layer we successfully created the requested connection */\n\tcm_event.event = IW_CM_EVENT_CONNECT_REPLY;\n\tcm_event.status = 0;\n\tcm_event.provider_data = cm_id->provider_data;\n\tcm_event_laddr->sin_family = AF_INET;\n\tcm_event_laddr->sin_port = laddr->sin_port;\n\tcm_event.remote_addr = cm_id->m_remote_addr;\n\n\tcm_event.private_data = (void *)event->cm_node->mpa_frame_buf;\n\tcm_event.private_data_len = (u8)event->cm_node->mpa_frame_size;\n\tcm_event.ird = cm_node->ird_size;\n\tcm_event.ord = cm_node->ord_size;\n\n\tcm_event_laddr->sin_addr.s_addr = htonl(event->cm_info.loc_addr);\n\tret = cm_id->event_handler(cm_id, &cm_event);\n\tnes_debug(NES_DBG_CM, "OFA CM event_handler returned, ret=%d\\n", ret);\n\n\tif (ret)\n\t\tprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, "\n\t\t       "ret=%d\\n", __func__, __LINE__, ret);\n\tattr.qp_state = IB_QPS_RTS;\n\tnes_modify_qp(&nesqp->ibqp, &attr, IB_QP_STATE, NULL);\n	t
28247	1127	bnxt_re_create_qp	drivers/infiniband/hw/bnxt_re/ib_verbs.c	&qp->qplib_qp	1	11	\N	\N	\tstruct bnxt_re_pd *pd = container_of(ib_pd, struct bnxt_re_pd, ib_pd);\n\tstruct bnxt_re_dev *rdev = pd->rdev;\n\tstruct bnxt_qplib_dev_attr *dev_attr = &rdev->dev_attr;\n\tstruct bnxt_re_qp *qp;\n\tstruct bnxt_re_cq *cq;\n\tint rc, entries;\n\n\tif ((qp_init_attr->cap.max_send_wr > dev_attr->max_qp_wqes) ||\n\t    (qp_init_attr->cap.max_recv_wr > dev_attr->max_qp_wqes) ||\n\t    (qp_init_attr->cap.max_send_sge > dev_attr->max_qp_sges) ||\n\t    (qp_init_attr->cap.max_recv_sge > dev_attr->max_qp_sges) ||\n\t    (qp_init_attr->cap.max_inline_data > dev_attr->max_inline_data))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->rdev = rdev;\n\tether_addr_copy(qp->qplib_qp.smac, rdev->netdev->dev_addr);\n\tqp->qplib_qp.pd = &pd->qplib_pd;\n\tqp->qplib_qp.qp_handle = (u64)(unsigned long)(&qp->qplib_qp);\n\tqp->qplib_qp.type = __from_ib_qp_type(qp_init_attr->qp_type);\n\tif (qp->qplib_qp.type == IB_QPT_MAX) {\n\t\tdev_err(rdev_to_dev(rdev), "QP type 0x%x not supported",\n\t\t\tqp->qplib_qp.type);\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\tqp->qplib_qp.max_inline_data = qp_init_attr->cap.max_inline_data;\n\tqp->qplib_qp.sig_type = ((qp_init_attr->sq_sig_type ==\n\t\t\t\t  IB_SIGNAL_ALL_WR) ? true : false);\n\n\tqp->qplib_qp.sq.max_sge = qp_init_attr->cap.max_send_sge;\n\tif (qp->qplib_qp.sq.max_sge > dev_attr->max_qp_sges)\n\t\tqp->qplib_qp.sq.max_sge = dev_attr->max_qp_sges;\n\n\tif (qp_init_attr->send_cq) {\n\t\tcq = container_of(qp_init_attr->send_cq, struct bnxt_re_cq,\n\t\t\t\t  ib_cq);\n\t\tif (!cq) {\n\t\t\tdev_err(rdev_to_dev(rdev), "Send CQ not found");\n\t\t\trc = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tqp->qplib_qp.scq = &cq->qplib_cq;\n\t}\n\n\tif (qp_init_attr->recv_cq) {\n\t\tcq = container_of(qp_init_attr->recv_cq, struct bnxt_re_cq,\n\t\t\t\t  ib_cq);\n\t\tif (!cq) {\n\t\t\tdev_err(rdev_to_dev(rdev), "Receive CQ not found");\n\t\t\trc = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tqp->qplib_qp.rcq = &cq->qplib_cq;\n\t}\n\n\tif (qp_init_attr->srq) {\n\t\tdev_err(rdev_to_dev(rdev), "SRQ not supported");\n\t\trc = -ENOTSUPP;\n\t\tgoto fail;\n\t} else {\n\t\t/* Allocate 1 more than what's provided so posting max doesn't\n\t\t * mean empty\n\t\t */\n\t\tentries = roundup_pow_of_two(qp_init_attr->cap.max_recv_wr + 1);\n\t\tqp->qplib_qp.rq.max_wqe = min_t(u32, entries,\n\t\t\t\t\t\tdev_attr->max_qp_wqes + 1);\n\n\t\tqp->qplib_qp.rq.q_full_delta = qp->qplib_qp.rq.max_wqe -\n\t\t\t\t\t\tqp_init_attr->cap.max_recv_wr;\n\n\t\tqp->qplib_qp.rq.max_sge = qp_init_attr->cap.max_recv_sge;\n\t\tif (qp->qplib_qp.rq.max_sge > dev_attr->max_qp_sges)\n\t\t\tqp->qplib_qp.rq.max_sge = dev_attr->max_qp_sges;\n\t}\n\n\tqp->qplib_qp.mtu = ib_mtu_enum_to_int(iboe_get_mtu(rdev->netdev->mtu));\n\n\tif (qp_init_attr->qp_type == IB_QPT_GSI) {\n\t\t/* Allocate 1 more than what's provided */\n\t\tentries = roundup_pow_of_two(qp_init_attr->cap.max_send_wr + 1);\n\t\tqp->qplib_qp.sq.max_wqe = min_t(u32, entries,\n\t\t\t\t\t\tdev_attr->max_qp_wqes + 1);\n\t\tqp->qplib_qp.sq.q_full_delta = qp->qplib_qp.sq.max_wqe -\n\t\t\t\t\t\tqp_init_attr->cap.max_send_wr;\n\t\tqp->qplib_qp.rq.max_sge = dev_attr->max_qp_sges;\n\t\tif (qp->qplib_qp.rq.max_sge > dev_attr->max_qp_sges)\n\t\t\tqp->qplib_qp.rq.max_sge = dev_attr->max_qp_sges;\n\t\tqp->qplib_qp.sq.max_sge++;\n\t\tif (qp->qplib_qp.sq.max_sge > dev_attr->max_qp_sges)\n\t\t\tqp->qplib_qp.sq.max_sge = dev_attr->max_qp_sges;\n\n\t\tqp->qplib_qp.rq_hdr_buf_size =\n\t\t\t\t\tBNXT_QPLIB_MAX_QP1_RQ_HDR_SIZE_V2;\n\n\t\tqp->qplib_qp.sq_hdr_buf_size =\n\t\t\t\t\tBNXT_QPLIB_MAX_QP1_SQ_HDR_SIZE_V2;\n\t\tqp->qplib_qp.dpi = &rdev->dpi_privileged;\n\t\trc = bnxt_qplib_create_qp1(&rdev->qplib_res, &qp->qplib_qp);\n	t
33922	6908	ath10k_wmi_10_2_op_gen_pdev_bss_chan_info	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_10_2_op_gen_pdev_bss_chan_info_$cmd$obj	0	13	\N	\N	\tstruct wmi_pdev_chan_info_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_chan_info_req_cmd *)skb->data;\n\tcmd->type = __cpu_to_le32(type);\n	f
45009	554	f81534_update_mctrl	drivers/usb/serial/f81534.c	status	1	13	\N	\N	\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint status;\n\tu8 tmp;\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0)\n\t\treturn 0;\t/* no change */\n\n\tmutex_lock(&port_priv->mcr_mutex);\n\n\t/* 'Set' takes precedence over 'Clear' */\n\tclear &= ~set;\n\n\t/* Always enable UART_MCR_OUT2 */\n\ttmp = UART_MCR_OUT2 | port_priv->shadow_mcr;\n\n\tif (clear & TIOCM_DTR)\n\t\ttmp &= ~UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\ttmp &= ~UART_MCR_RTS;\n\n\tif (set & TIOCM_DTR)\n\t\ttmp |= UART_MCR_DTR;\n\n\tif (set & TIOCM_RTS)\n\t\ttmp |= UART_MCR_RTS;\n\n\tstatus = f81534_set_port_register(port, F81534_MODEM_CONTROL_REG, tmp);\n\tif (status < 0) {\n	f
46895	208	wm8739_probe	drivers/media/i2c/wm8739.c	&state->hdl	1	13	\N	\N	\tstruct wm8739_state *state;\n\tstruct v4l2_subdev *sd;\n\n\t/* Check if the adapter supports the needed features */\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, "chip found @ 0x%x (%s)\\n",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &wm8739_ops);\n\tv4l2_ctrl_handler_init(&state->hdl, 2);\n	f
52077	4303	ocfs2_reflink	fs/ocfs2/refcounttree.c	ocfs2_reflink_$_st123$obj	0	13	\N	\N	\tint error;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct buffer_head *old_bh = NULL;\n\tstruct inode *new_orphan_inode = NULL;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\n\terror = ocfs2_create_inode_in_orphan(dir, inode->i_mode,\n\t\t\t\t\t     &new_orphan_inode);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_rw_lock(inode, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_inode_lock(inode, &old_bh, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tocfs2_rw_unlock(inode, 1);\n\t\tgoto out;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\terror = __ocfs2_reflink(old_dentry, old_bh,\n\t\t\t\tnew_orphan_inode, preserve);\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 1);\n\tocfs2_rw_unlock(inode, 1);\n\tbrelse(old_bh);\n\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\t/* If the security isn't preserved, we need to re-initialize them. */\n\tif (!preserve) {\n\t\terror = ocfs2_init_security_and_acl(dir, new_orphan_inode,\n\t\t\t\t\t\t    &new_dentry->d_name);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n	f
31522	2336	e1000_set_rx_mode	drivers/net/ethernet/intel/e1000/e1000_main.c	hw	1	11	\N	\N	\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tbool use_uc = false;\n\tu32 rctl;\n\tu32 hash_value;\n\tint i, rar_entries = E1000_RAR_ENTRIES;\n\tint mta_reg_count = E1000_NUM_MTA_REGISTERS;\n\tu32 *mcarray = kcalloc(mta_reg_count, sizeof(u32), GFP_ATOMIC);\n\n\tif (!mcarray)\n\t\treturn;\n\n\t/* Check for Promiscuous and All Multicast modes */\n\n\trctl = er32(RCTL);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);\n\t\trctl &= ~E1000_RCTL_VFE;\n\t} else {\n\t\tif (netdev->flags & IFF_ALLMULTI)\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\telse\n\t\t\trctl &= ~E1000_RCTL_MPE;\n\t\t/* Enable VLAN filter if there is a VLAN */\n\t\tif (e1000_vlan_used(adapter))\n\t\t\trctl |= E1000_RCTL_VFE;\n\t}\n\n\tif (netdev_uc_count(netdev) > rar_entries - 1) {\n\t\trctl |= E1000_RCTL_UPE;\n\t} else if (!(netdev->flags & IFF_PROMISC)) {\n\t\trctl &= ~E1000_RCTL_UPE;\n\t\tuse_uc = true;\n\t}\n\n\tew32(RCTL, rctl);\n\n\t/* 82542 2.0 needs to be in reset to write receive address registers */\n\n\tif (hw->mac_type == e1000_82542_rev2_0)\n\t\te1000_enter_82542_rst(adapter);\n\n\t/* load the first 14 addresses into the exact filters 1-14. Unicast\n\t * addresses take precedence to avoid disabling unicast filtering\n\t * when possible.\n\t *\n\t * RAR 0 is used for the station MAC address\n\t * if there are not 14 addresses, go ahead and clear the filters\n\t */\n\ti = 1;\n\tif (use_uc)\n\t\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\t\tif (i == rar_entries)\n\t\t\t\tbreak;\n\t\t\te1000_rar_set(hw, ha->addr, i++);\n\t\t}\n\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\tif (i == rar_entries) {\n\t\t\t/* load any remaining addresses into the hash table */\n\t\t\tu32 hash_reg, hash_bit, mta;\n\t\t\thash_value = e1000_hash_mc_addr(hw, ha->addr);\n\t\t\thash_reg = (hash_value >> 5) & 0x7F;\n\t\t\thash_bit = hash_value & 0x1F;\n\t\t\tmta = (1 << hash_bit);\n\t\t\tmcarray[hash_reg] |= mta;\n\t\t} else {\n\t\t\te1000_rar_set(hw, ha->addr, i++);\n\t\t}\n\t}\n\n\tfor (; i < rar_entries; i++) {\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, i << 1, 0);\n\t\tE1000_WRITE_FLUSH();\n\t\tE1000_WRITE_REG_ARRAY(hw, RA, (i << 1) + 1, 0);\n\t\tE1000_WRITE_FLUSH();\n\t}\n\n\t/* write the hash table completely, write from bottom to avoid\n\t * both stupid write combining chipsets, and flushing each write\n\t */\n\tfor (i = mta_reg_count - 1; i >= 0 ; i--) {\n\t\t/* If we are on an 82544 has an errata where writing odd\n\t\t * offsets overwrites the previous even offset, but writing\n\t\t * backwards over the range solves the issue by always\n\t\t * writing the odd offset first\n\t\t */\n\t\tE1000_WRITE_REG_ARRAY(hw, MTA, i, mcarray[i]);\n	t
31880	12241	intel_update_crtcs	drivers/gpu/drm/i915/intel_display.c	old_crtc_state	1	11	\N	\N	\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tint i;\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tintel_update_crtc(crtc, state, old_crtc_state,\n	t
33436	871	do_erase_oneblock	drivers/mtd/chips/cfi_cmdset_0020.c	chipstatus	1	11	\N	\N	\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK;\n\tunsigned long timeo;\n\tint retries = 3;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint ret = 0;\n\n\tadr += chip->start;\n\n\t/* Let's determine this according to the interleave only once */\n\tstatus_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\nretry:\n\tmutex_lock(&chip->mutex);\n\n\t/* Check that the chip's ready to talk to us. */\n\tswitch (chip->state) {\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\tcase FL_READY:\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t/* Urgh. Chip not yet ready to talk to us. */\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR "waiting for chip to be ready timed out in erase\\n");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Latency issues. Drop the lock, wait a while and retry */\n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\t\t/* Stick ourselves on a wait queue to be woken when\n\t\t   someone changes the status */\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tENABLE_VPP(map);\n\t/* Clear the status register first */\n\tmap_write(map, CMD(0x50), adr);\n\n\t/* Now erase */\n\tmap_write(map, CMD(0x20), adr);\n\tmap_write(map, CMD(0xD0), adr);\n\tchip->state = FL_ERASING;\n\n\tmutex_unlock(&chip->mutex);\n\tmsleep(1000);\n\tmutex_lock(&chip->mutex);\n\n\t/* FIXME. Use a timer to check this, and return immediately. */\n\t/* Once the state machine's known to be working I'll do that */\n\n\ttimeo = jiffies + (HZ*20);\n\tfor (;;) {\n\t\tif (chip->state != FL_ERASING) {\n\t\t\t/* Someone's suspended the erase. Sleep */\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\ttimeo = jiffies + (HZ*20); /* FIXME */\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t/* OK Still waiting */\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tprintk(KERN_ERR "waiting for erase to complete timed out. Xstatus = %lx, status = %lx.\\n", status.x[0], map_read(map, adr).x[0]);\n\t\t\tDISABLE_VPP(map);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Latency issues. Drop the lock, wait a while and retry */\n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tmutex_lock(&chip->mutex);\n\t}\n\n\tDISABLE_VPP(map);\n\tret = 0;\n\n\t/* We've broken this before. It doesn't hurt to be safe */\n\tmap_write(map, CMD(0x70), adr);\n\tchip->state = FL_STATUS;\n\tstatus = map_read(map, adr);\n\n\t/* check for lock bit */\n\tif (map_word_bitsset(map, status, CMD(0x3a))) {\n\t\tunsigned char chipstatus = status.x[0];\n\t\tif (!map_word_equal(map, status, CMD(chipstatus))) {\n\t\t\tint i, w;\n\t\t\tfor (w=0; w<map_words(map); w++) {\n\t\t\t\tfor (i = 0; i<cfi_interleave(cfi); i++) {\n\t\t\t\t\tchipstatus |= status.x[w] >> (cfi->device_type * 8);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_WARNING "Status is not identical for all chips: 0x%lx. Merging to give 0x%02x\\n",\n\t\t\t       status.x[0], chipstatus);\n\t\t}\n\t\t/* Reset the error bits */\n\t\tmap_write(map, CMD(0x50), adr);\n\t\tmap_write(map, CMD(0x70), adr);\n\n\t\tif ((chipstatus & 0x30) == 0x30) {\n\t\t\tprintk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\\n", chipstatus);\n\t\t\tret = -EIO;\n\t\t} else if (chipstatus & 0x02) {\n\t\t\t/* Protection bit set */\n\t\t\tret = -EROFS;\n\t\t} else if (chipstatus & 0x8) {\n\t\t\t/* Voltage */\n\t\t\tprintk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\\n", chipstatus);\n\t\t\tret = -EIO;\n\t\t} else if (chipstatus & 0x20) {\n	t
33806	1190	qlcnic_load_firmware	drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c	data)	1	11	\N	\N	\t__le64 *ptr64;\n\tu32 i, flashaddr, size;\n\tconst struct firmware *fw = adapter->fw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tdev_info(&pdev->dev, "loading firmware from %s\\n",\n\t\t fw_name[adapter->ahw->fw_type]);\n\n\tif (fw) {\n\t\tu64 data;\n\n\t\tsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\n\n\t\tptr64 = (__le64 *)qlcnic_get_bootld_offs(adapter);\n\t\tflashaddr = QLCNIC_BOOTLD_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter, flashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = qlcnic_get_fw_size(adapter) / 8;\n\n\t\tptr64 = (__le64 *)qlcnic_get_fw_offs(adapter);\n\t\tflashaddr = QLCNIC_IMAGE_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = qlcnic_get_fw_size(adapter) % 8;\n\t\tif (size) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t} else {\n\t\tu64 data;\n\t\tu32 hi, lo;\n\t\tint ret;\n\t\tstruct qlcnic_flt_entry bootld_entry;\n\n\t\tret = qlcnic_get_flt_entry(adapter, QLCNIC_BOOTLD_REGION,\n\t\t\t\t\t&bootld_entry);\n\t\tif (!ret) {\n\t\t\tsize = bootld_entry.size / 8;\n\t\t\tflashaddr = bootld_entry.start_addr;\n\t\t} else {\n\t\t\tsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\n\t\t\tflashaddr = QLCNIC_BOOTLD_START;\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t"using legacy method to get flash fw region");\n\t\t}\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (qlcnic_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr, (int *)&lo) != 0)\n\t\t\t\treturn -EIO;\n\t\t\tif (qlcnic_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr + 4, (int *)&hi) != 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tdata = (((u64)hi << 32) | lo);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n	t
55249	2436	trace_event_raw_event_ocfs2_find_local_alias	fs/ocfs2/super.c	!dirty	1	13	\N	\N	\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL; /* only used if we\n\t\t\t\t\t\t  * recover\n\t\t\t\t\t\t  * ourselves. */\n\n\t/* Init our journal object. */\n\tstatus = ocfs2_journal_init(osb->journal, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, "Could not initialize journal!\\n");\n\t\tgoto finally;\n\t}\n\n\t/* Now that journal has been initialized, check to make sure\n\t   entire volume is addressable. */\n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t/* If the journal was unmounted cleanly then we don't want to\n\t * recover anything. Otherwise, journal_load will do that\n\t * dirty work for us :) */\n	f
39906	856	qlcnic_enable_msi_legacy	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c	qlcnic_enable_msi_legacy_	1	11	\N	\N	\tint err = 0;\n\tu32 offset, mask_reg;\n\tconst struct qlcnic_legacy_intr_set *legacy_intrp;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tif (qlcnic_use_msi && !pci_enable_msi(pdev)) {\n	t
43065	271	rtl8723bs_recv_tasklet	drivers/staging/rtl8723bs/hal/rtl8723bs_recv.c	pkt_copy	1	11	\N	\N	\tstruct adapter *padapter;\n\tstruct hal_com_data *pHalData;\n\tstruct recv_priv *precvpriv;\n\tstruct recv_buf *precvbuf;\n\tunion recv_frame *precvframe;\n\tstruct rx_pkt_attrib *pattrib;\n\tu8 *ptr;\n\tu32 pkt_offset, skb_len, alloc_sz;\n\t_pkt *pkt_copy = NULL;\n\tu8 shift_sz = 0, rx_report_sz = 0;\n\n\n\tpadapter = priv;\n\tpHalData = GET_HAL_DATA(padapter);\n\tprecvpriv = &padapter->recvpriv;\n\n\tdo {\n\t\tprecvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue);\n\t\tif (NULL == precvbuf)\n\t\t\tbreak;\n\n\t\tptr = precvbuf->pdata;\n\n\t\twhile (ptr < precvbuf->ptail) {\n\t\t\tprecvframe = rtw_alloc_recvframe(&precvpriv->free_recv_queue);\n\t\t\tif (precvframe == NULL) {\n\t\t\t\tDBG_8192C("%s: no enough recv frame!\\n", __func__);\n\t\t\t\trtw_enqueue_recvbuf_to_head(precvbuf, &precvpriv->recv_buf_pending_queue);\n\n\t\t\t\t/*  The case of can't allocte recvframe should be temporary, */\n\t\t\t\t/*  schedule again and hope recvframe is available next time. */\n\t\t\t\ttasklet_schedule(&precvpriv->recv_tasklet);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* rx desc parsing */\n\t\t\tupdate_recvframe_attrib(padapter, precvframe, (struct recv_stat *)ptr);\n\n\t\t\tpattrib = &precvframe->u.hdr.attrib;\n\n\t\t\t/*  fix Hardware RX data error, drop whole recv_buffer */\n\t\t\tif ((!(pHalData->ReceiveConfig & RCR_ACRC32)) && pattrib->crc_err) {\n\t\t\t\tDBG_8192C("%s()-%d: RX Warning! rx CRC ERROR !!\\n", __func__, __LINE__);\n\t\t\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trx_report_sz = RXDESC_SIZE + pattrib->drvinfo_sz;\n\t\t\tpkt_offset = rx_report_sz + pattrib->shift_sz + pattrib->pkt_len;\n\n\t\t\tif ((ptr + pkt_offset) > precvbuf->ptail) {\n\t\t\t\tDBG_8192C("%s()-%d: : next pkt len(%p,%d) exceed ptail(%p)!\\n", __func__, __LINE__, ptr, pkt_offset, precvbuf->ptail);\n\t\t\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((pattrib->crc_err) || (pattrib->icv_err)) {\n\t\t\t\t{\n\t\t\t\t\tDBG_8192C("%s: crc_err =%d icv_err =%d, skip!\\n", __func__, pattrib->crc_err, pattrib->icv_err);\n\t\t\t\t}\n\t\t\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\t\t} else {\n\t\t\t\t/* \tModified by Albert 20101213 */\n\t\t\t\t/* \tFor 8 bytes IP header alignment. */\n\t\t\t\tif (pattrib->qos)\t/* \tQos data, wireless lan header length is 26 */\n\t\t\t\t\tshift_sz = 6;\n\t\t\t\telse\n\t\t\t\t\tshift_sz = 0;\n\n\t\t\t\tskb_len = pattrib->pkt_len;\n\n\t\t\t\t/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */\n\t\t\t\t/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */\n\t\t\t\tif ((pattrib->mfrag == 1) && (pattrib->frag_num == 0)) {\n\t\t\t\t\tif (skb_len <= 1650)\n\t\t\t\t\t\talloc_sz = 1664;\n\t\t\t\t\telse\n\t\t\t\t\t\talloc_sz = skb_len + 14;\n\t\t\t\t} else {\n\t\t\t\t\talloc_sz = skb_len;\n\t\t\t\t\t/* \t6 is for IP header 8 bytes alignment in QoS packet case. */\n\t\t\t\t\t/* \t8 is for skb->data 4 bytes alignment. */\n\t\t\t\t\talloc_sz += 14;\n\t\t\t\t}\n\n\t\t\t\tpkt_copy = rtw_skb_alloc(alloc_sz);\n\n\t\t\t\tif (pkt_copy) {\n\t\t\t\t\tpkt_copy->dev = padapter->pnetdev;\n\t\t\t\t\tprecvframe->u.hdr.pkt = pkt_copy;\n\t\t\t\t\tskb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */\n	t
46342	2590	ips_next	drivers/scsi/ips.c	scb->scsi_cmd	1	11	\N	\N	\tips_scb_t *scb;\n\tstruct scsi_cmnd *SC;\n\tstruct scsi_cmnd *p;\n\tstruct scsi_cmnd *q;\n\tips_copp_wait_item_t *item;\n\tint ret;\n\tstruct Scsi_Host *host;\n\tMETHOD_TRACE("ips_next", 1);\n\n\tif (!ha)\n\t\treturn;\n\thost = ips_sh[ha->host_num];\n\t/*\n\t * Block access to the queue function so\n\t * this command won't time out\n\t */\n\tif (intr == IPS_INTR_ON)\n\t\tspin_lock(host->host_lock);\n\n\tif ((ha->subsys->param[3] & 0x300000)\n\t    && (ha->scb_activelist.count == 0)) {\n\t\tstruct timeval tv;\n\n\t\tdo_gettimeofday(&tv);\n\n\t\tif (tv.tv_sec - ha->last_ffdc > IPS_SECS_8HOURS) {\n\t\t\tha->last_ffdc = tv.tv_sec;\n\t\t\tips_ffdc_time(ha);\n\t\t}\n\t}\n\n\t/*\n\t * Send passthru commands\n\t * These have priority over normal I/O\n\t * but shouldn't affect performance too much\n\t * since we limit the number that can be active\n\t * on the card at any one time\n\t */\n\twhile ((ha->num_ioctl < IPS_MAX_IOCTL) &&\n\t       (ha->copp_waitlist.head) && (scb = ips_getscb(ha))) {\n\n\t\titem = ips_removeq_copp_head(&ha->copp_waitlist);\n\t\tha->num_ioctl++;\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_unlock(host->host_lock);\n\t\tscb->scsi_cmd = item->scsi_cmd;\n\t\tkfree(item);\n\n\t\tret = ips_make_passthru(ha, scb->scsi_cmd, scb, intr);\n\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_lock(host->host_lock);\n\t\tswitch (ret) {\n\t\tcase IPS_FAILURE:\n\t\t\tif (scb->scsi_cmd) {\n\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t\tscb->scsi_cmd->scsi_done(scb->scsi_cmd);\n	t
-522	673	bgpio_pdev_probe	drivers/gpio/gpio-mmio.c	pdata->label	1000	3	\N	\N	\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tvoid __iomem *dat;\n\tvoid __iomem *set;\n\tvoid __iomem *clr;\n\tvoid __iomem *dirout;\n\tvoid __iomem *dirin;\n\tunsigned long sz;\n\tunsigned long flags = 0;\n\tint err;\n\tstruct gpio_chip *gc;\n\tstruct bgpio_pdata *pdata;\n\n\tpdata = bgpio_parse_dt(pdev, &flags);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tif (!pdata) {\n\t\tpdata = dev_get_platdata(dev);\n\t\tflags = pdev->id_entry->driver_data;\n\t}\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");\n\tif (!r)\n\t\treturn -EINVAL;\n\n\tsz = resource_size(r);\n\n\tdat = bgpio_map(pdev, "dat", sz);\n\tif (IS_ERR(dat))\n\t\treturn PTR_ERR(dat);\n\n\tset = bgpio_map(pdev, "set", sz);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tclr = bgpio_map(pdev, "clr", sz);\n\tif (IS_ERR(clr))\n\t\treturn PTR_ERR(clr);\n\n\tdirout = bgpio_map(pdev, "dirout", sz);\n\tif (IS_ERR(dirout))\n\t\treturn PTR_ERR(dirout);\n\n\tdirin = bgpio_map(pdev, "dirin", sz);\n\tif (IS_ERR(dirin))\n\t\treturn PTR_ERR(dirin);\n\n\tgc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\terr = bgpio_init(gc, dev, sz, dat, set, clr, dirout, dirin, flags);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata) {\n\t\tif (pdata->label)\n	f
60437	1617	hci_logging_frame	net/bluetooth/hci_sock.c	skb->data	1	13	\N	\N	\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\tstruct hci_dev *hdev;\n\tu16 index;\n\tint err;\n\n\t/* The logging frame consists at minimum of the standard header,\n\t * the priority byte, the ident length byte and at least one string\n\t * terminator NUL byte. Anything shorter are invalid packets.\n\t */\n\tif (len < sizeof(*hdr) + 3)\n\t\treturn -EINVAL;\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\thdr = (void *)skb->data;\n\n\tif (__le16_to_cpu(hdr->len) != len - sizeof(*hdr)) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\n\tif (__le16_to_cpu(hdr->opcode) == 0x0000) {\n\t\t__u8 priority = skb->data[sizeof(*hdr)];\n	f
24	2477	i40iw_poll_cq	drivers/infiniband/hw/i40iw/i40iw_verbs.c	iwqp->rq_drained	1	11	\N	\N	\tstruct i40iw_cq *iwcq;\n\tint cqe_count = 0;\n\tstruct i40iw_cq_poll_info cq_poll_info;\n\tenum i40iw_status_code ret;\n\tstruct i40iw_cq_uk *ukcq;\n\tstruct i40iw_sc_qp *qp;\n\tstruct i40iw_qp *iwqp;\n\tunsigned long flags;\n\n\tiwcq = (struct i40iw_cq *)ibcq;\n\tukcq = &iwcq->sc_cq.cq_uk;\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\twhile (cqe_count < num_entries) {\n\t\tret = ukcq->ops.iw_cq_poll_completion(ukcq, &cq_poll_info);\n\t\tif (ret == I40IW_ERR_QUEUE_EMPTY) {\n\t\t\tbreak;\n\t\t} else if (ret == I40IW_ERR_QUEUE_DESTROYED) {\n\t\t\tcontinue;\n\t\t} else if (ret) {\n\t\t\tif (!cqe_count)\n\t\t\t\tcqe_count = -1;\n\t\t\tbreak;\n\t\t}\n\t\tentry->wc_flags = 0;\n\t\tentry->wr_id = cq_poll_info.wr_id;\n\t\tif (cq_poll_info.error) {\n\t\t\tentry->status = IB_WC_WR_FLUSH_ERR;\n\t\t\tentry->vendor_err = cq_poll_info.major_err << 16 | cq_poll_info.minor_err;\n\t\t} else {\n\t\t\tentry->status = IB_WC_SUCCESS;\n\t\t}\n\n\t\tswitch (cq_poll_info.op_type) {\n\t\tcase I40IW_OP_TYPE_RDMA_WRITE:\n\t\t\tentry->opcode = IB_WC_RDMA_WRITE;\n\t\t\tbreak;\n\t\tcase I40IW_OP_TYPE_RDMA_READ_INV_STAG:\n\t\tcase I40IW_OP_TYPE_RDMA_READ:\n\t\t\tentry->opcode = IB_WC_RDMA_READ;\n\t\t\tbreak;\n\t\tcase I40IW_OP_TYPE_SEND_SOL:\n\t\tcase I40IW_OP_TYPE_SEND_SOL_INV:\n\t\tcase I40IW_OP_TYPE_SEND_INV:\n\t\tcase I40IW_OP_TYPE_SEND:\n\t\t\tentry->opcode = IB_WC_SEND;\n\t\t\tbreak;\n\t\tcase I40IW_OP_TYPE_REC:\n\t\t\tentry->opcode = IB_WC_RECV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->opcode = IB_WC_RECV;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry->ex.imm_data = 0;\n\t\tqp = (struct i40iw_sc_qp *)cq_poll_info.qp_handle;\n\t\tentry->qp = (struct ib_qp *)qp->back_qp;\n\t\tentry->src_qp = cq_poll_info.qp_id;\n\t\tiwqp = (struct i40iw_qp *)qp->back_qp;\n\t\tif (iwqp->iwarp_state > I40IW_QP_STATE_RTS) {\n\t\t\tif (!I40IW_RING_MORE_WORK(qp->qp_uk.sq_ring))\n\t\t\t\tcomplete(&iwqp->sq_drained);\n\t\t\tif (!I40IW_RING_MORE_WORK(qp->qp_uk.rq_ring))\n\t\t\t\tcomplete(&iwqp->rq_drained);\n	t
46539	790	ch_ioctl	drivers/scsi/ch.c	buffer	1	11	\N	\N	\tscsi_changer *ch = file->private_data;\n\tint retval;\n\tvoid __user *argp = (void __user *)arg;\n\n\tretval = scsi_ioctl_block_when_processing_errors(ch->device, cmd,\n\t\t\tfile->f_flags & O_NDELAY);\n\tif (retval)\n\t\treturn retval;\n\n\tswitch (cmd) {\n\tcase CHIOGPARAMS:\n\t{\n\t\tstruct changer_params params;\n\n\t\tparams.cp_curpicker = 0;\n\t\tparams.cp_npickers  = ch->counts[CHET_MT];\n\t\tparams.cp_nslots    = ch->counts[CHET_ST];\n\t\tparams.cp_nportals  = ch->counts[CHET_IE];\n\t\tparams.cp_ndrives   = ch->counts[CHET_DT];\n\n\t\tif (copy_to_user(argp, &params, sizeof(params)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase CHIOGVPARAMS:\n\t{\n\t\tstruct changer_vendor_params vparams;\n\n\t\tmemset(&vparams,0,sizeof(vparams));\n\t\tif (ch->counts[CHET_V1]) {\n\t\t\tvparams.cvp_n1  = ch->counts[CHET_V1];\n\t\t\tstrncpy(vparams.cvp_label1,vendor_labels[0],16);\n\t\t}\n\t\tif (ch->counts[CHET_V2]) {\n\t\t\tvparams.cvp_n2  = ch->counts[CHET_V2];\n\t\t\tstrncpy(vparams.cvp_label2,vendor_labels[1],16);\n\t\t}\n\t\tif (ch->counts[CHET_V3]) {\n\t\t\tvparams.cvp_n3  = ch->counts[CHET_V3];\n\t\t\tstrncpy(vparams.cvp_label3,vendor_labels[2],16);\n\t\t}\n\t\tif (ch->counts[CHET_V4]) {\n\t\t\tvparams.cvp_n4  = ch->counts[CHET_V4];\n\t\t\tstrncpy(vparams.cvp_label4,vendor_labels[3],16);\n\t\t}\n\t\tif (copy_to_user(argp, &vparams, sizeof(vparams)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase CHIOPOSITION:\n\t{\n\t\tstruct changer_position pos;\n\n\t\tif (copy_from_user(&pos, argp, sizeof (pos)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, pos.cp_type, pos.cp_unit)) {\n\t\t\tDPRINTK("CHIOPOSITION: invalid parameter\\n");\n\t\t\treturn -EBADSLT;\n\t\t}\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_position(ch,0,\n\t\t\t\t     ch->firsts[pos.cp_type] + pos.cp_unit,\n\t\t\t\t     pos.cp_flags & CP_INVERT);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOMOVE:\n\t{\n\t\tstruct changer_move mv;\n\n\t\tif (copy_from_user(&mv, argp, sizeof (mv)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, mv.cm_fromtype, mv.cm_fromunit) ||\n\t\t    0 != ch_checkrange(ch, mv.cm_totype,   mv.cm_tounit  )) {\n\t\t\tDPRINTK("CHIOMOVE: invalid parameter\\n");\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_move(ch,0,\n\t\t\t\t ch->firsts[mv.cm_fromtype] + mv.cm_fromunit,\n\t\t\t\t ch->firsts[mv.cm_totype]   + mv.cm_tounit,\n\t\t\t\t mv.cm_flags & CM_INVERT);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOEXCHANGE:\n\t{\n\t\tstruct changer_exchange mv;\n\n\t\tif (copy_from_user(&mv, argp, sizeof (mv)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, mv.ce_srctype,  mv.ce_srcunit ) ||\n\t\t    0 != ch_checkrange(ch, mv.ce_fdsttype, mv.ce_fdstunit) ||\n\t\t    0 != ch_checkrange(ch, mv.ce_sdsttype, mv.ce_sdstunit)) {\n\t\t\tDPRINTK("CHIOEXCHANGE: invalid parameter\\n");\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_exchange\n\t\t\t(ch,0,\n\t\t\t ch->firsts[mv.ce_srctype]  + mv.ce_srcunit,\n\t\t\t ch->firsts[mv.ce_fdsttype] + mv.ce_fdstunit,\n\t\t\t ch->firsts[mv.ce_sdsttype] + mv.ce_sdstunit,\n\t\t\t mv.ce_flags & CE_INVERT1, mv.ce_flags & CE_INVERT2);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOGSTATUS:\n\t{\n\t\tstruct changer_element_status ces;\n\n\t\tif (copy_from_user(&ces, argp, sizeof (ces)))\n\t\t\treturn -EFAULT;\n\t\tif (ces.ces_type < 0 || ces.ces_type >= CH_TYPES)\n\t\t\treturn -EINVAL;\n\n\t\treturn ch_gstatus(ch, ces.ces_type, ces.ces_data);\n\t}\n\n\tcase CHIOGELEM:\n\t{\n\t\tstruct changer_get_element cge;\n\t\tu_char ch_cmd[12];\n\t\tu_char *buffer;\n\t\tunsigned int elem;\n\t\tint     result,i;\n\n\t\tif (copy_from_user(&cge, argp, sizeof (cge)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, cge.cge_type, cge.cge_unit))\n\t\t\treturn -EINVAL;\n\t\telem = ch->firsts[cge.cge_type] + cge.cge_unit;\n\n\t\tbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t\tmutex_lock(&ch->lock);\n\n\tvoltag_retry:\n\t\tmemset(ch_cmd, 0, sizeof(ch_cmd));\n\t\tch_cmd[0] = READ_ELEMENT_STATUS;\n\t\tch_cmd[1] = ((ch->device->lun & 0x7) << 5) |\n\t\t\t(ch->voltags ? 0x10 : 0) |\n\t\t\tch_elem_to_typecode(ch,elem);\n\t\tch_cmd[2] = (elem >> 8) & 0xff;\n\t\tch_cmd[3] = elem        & 0xff;\n\t\tch_cmd[5] = 1;\n\t\tch_cmd[9] = 255;\n\n\t\tresult = ch_do_scsi(ch, ch_cmd, 12,\n\t\t\t\t    buffer, 256, DMA_FROM_DEVICE);\n\t\tif (!result) {\n\t\t\tcge.cge_status = buffer[18];\n\t\t\tcge.cge_flags = 0;\n\t\t\tif (buffer[18] & CESTATUS_EXCEPT) {\n\t\t\t\tcge.cge_errno = EIO;\n\t\t\t}\n\t\t\tif (buffer[25] & 0x80) {\n\t\t\t\tcge.cge_flags |= CGE_SRC;\n\t\t\t\tif (buffer[25] & 0x40)\n	t
46552	789	trace_event_raw_event_ext4_allocate_blocks	fs/ext4/super.c	dev_t dev	1	11	\N	\N	\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     "updating to rev %d because of new feature flag, "\n\t\t     "running e2fsck is recommended",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n\n/*\n * Open the external journal device\n */\nstatic struct block_device *ext4_blkdev_get(dev_t dev, struct super_block *sb)\n	t
48971	641	be_get_link_ksettings	drivers/net/ethernet/emulex/benet/be_ethtool.c	adapter	1	11	\N	\N	\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu8 link_status;\n\tu16 link_speed = 0;\n\tint status;\n\tu32 auto_speeds;\n\tu32 fixed_speeds;\n\tu32 supported = 0, advertising = 0;\n\n\tif (adapter->phy.link_speed < 0) {\n\t\tstatus = be_cmd_link_status_query(adapter, &link_speed,\n\t\t\t\t\t\t  &link_status, 0);\n\t\tif (!status)\n\t\t\tbe_link_status_update(adapter, link_status);\n\t\tcmd->base.speed = link_speed;\n\n\t\tstatus = be_cmd_get_phy_info(adapter);\n\t\tif (!status) {\n\t\t\tauto_speeds = adapter->phy.auto_speeds_supported;\n\t\t\tfixed_speeds = adapter->phy.fixed_speeds_supported;\n\n\t\t\tbe_cmd_query_cable_type(adapter);\n\n\t\t\tsupported =\n\t\t\t\tconvert_to_et_setting(adapter,\n\t\t\t\t\t\t      auto_speeds |\n\t\t\t\t\t\t      fixed_speeds);\n\t\t\tadvertising =\n\t\t\t\tconvert_to_et_setting(adapter, auto_speeds);\n\n\t\t\tcmd->base.port = be_get_port_type(adapter);\n	t
24847	4102	regulator_register	drivers/regulator/core.c	regulator_register_$init_data$obj$34$obj$0$1	0	13	\N	\N	\tconst struct regulation_constraints *constraints = NULL;\n\tconst struct regulator_init_data *init_data;\n\tstruct regulator_config *config = NULL;\n\tstatic atomic_t regulator_no = ATOMIC_INIT(-1);\n\tstruct regulator_dev *rdev;\n\tstruct device *dev;\n\tint ret, i;\n\n\tif (regulator_desc == NULL || cfg == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = cfg->dev;\n\tWARN_ON(!dev);\n\n\tif (regulator_desc->name == NULL || regulator_desc->ops == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (regulator_desc->type != REGULATOR_VOLTAGE &&\n\t    regulator_desc->type != REGULATOR_CURRENT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Only one of each should be implemented */\n\tWARN_ON(regulator_desc->ops->get_voltage &&\n\t\tregulator_desc->ops->get_voltage_sel);\n\tWARN_ON(regulator_desc->ops->set_voltage &&\n\t\tregulator_desc->ops->set_voltage_sel);\n\n\t/* If we're using selectors we must implement list_voltage. */\n\tif (regulator_desc->ops->get_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (regulator_desc->ops->set_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);\n\tif (rdev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Duplicate the config so the driver could override it after\n\t * parsing init data.\n\t */\n\tconfig = kmemdup(cfg, sizeof(*cfg), GFP_KERNEL);\n\tif (config == NULL) {\n\t\tkfree(rdev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit_data = regulator_of_get_init_data(dev, regulator_desc, config,\n\t\t\t\t\t       &rdev->dev.of_node);\n\tif (!init_data) {\n\t\tinit_data = config->init_data;\n\t\trdev->dev.of_node = of_node_get(config->of_node);\n\t}\n\n\tmutex_init(&rdev->mutex);\n\trdev->reg_data = config->driver_data;\n\trdev->owner = regulator_desc->owner;\n\trdev->desc = regulator_desc;\n\tif (config->regmap)\n\t\trdev->regmap = config->regmap;\n\telse if (dev_get_regmap(dev, NULL))\n\t\trdev->regmap = dev_get_regmap(dev, NULL);\n\telse if (dev->parent)\n\t\trdev->regmap = dev_get_regmap(dev->parent, NULL);\n\tINIT_LIST_HEAD(&rdev->consumer_list);\n\tINIT_LIST_HEAD(&rdev->list);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);\n\tINIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);\n\n\t/* preform any regulator specific init */\n\tif (init_data && init_data->regulator_init) {\n\t\tret = init_data->regulator_init(rdev->reg_data);\n\t\tif (ret < 0)\n\t\t\tgoto clean;\n\t}\n\n\tif ((config->ena_gpio || config->ena_gpio_initialized) &&\n\t    gpio_is_valid(config->ena_gpio)) {\n\t\tmutex_lock(&regulator_list_mutex);\n\t\tret = regulator_ena_gpio_request(rdev, config);\n\t\tmutex_unlock(&regulator_list_mutex);\n\t\tif (ret != 0) {\n\t\t\trdev_err(rdev, "Failed to request enable GPIO%d: %d\\n",\n\t\t\t\t config->ena_gpio, ret);\n\t\t\tgoto clean;\n\t\t}\n\t}\n\n\t/* register with sysfs */\n\trdev->dev.class = &regulator_class;\n\trdev->dev.parent = dev;\n\tdev_set_name(&rdev->dev, "regulator.%lu",\n\t\t    (unsigned long) atomic_inc_return(&regulator_no));\n\n\t/* set regulator constraints */\n\tif (init_data)\n\t\tconstraints = &init_data->constraints;\n\n\tif (init_data && init_data->supply_regulator)\n\t\trdev->supply_name = init_data->supply_regulator;\n\telse if (regulator_desc->supply_name)\n\t\trdev->supply_name = regulator_desc->supply_name;\n\n\t/*\n\t * Attempt to resolve the regulator supply, if specified,\n\t * but don't return an error if we fail because we will try\n\t * to resolve it again later as more regulators are added.\n\t */\n\tif (regulator_resolve_supply(rdev))\n\t\trdev_dbg(rdev, "unable to resolve supply\\n");\n\n\tret = set_machine_constraints(rdev, constraints);\n\tif (ret < 0)\n\t\tgoto wash;\n\n\t/* add consumers devices */\n\tif (init_data) {\n\t\tmutex_lock(&regulator_list_mutex);\n\t\tfor (i = 0; i < init_data->num_consumer_supplies; i++) {\n\t\t\tret = set_consumer_device_supply(rdev,\n\t\t\t\tinit_data->consumer_supplies[i].dev_name,\n\t\t\t\tinit_data->consumer_supplies[i].supply);\n	f
4566	140	temp1_input_show	drivers/hwmon/shtc1.c	temp1_input_show_$data$obj$18$obj	0	13	\N	\N	\tstruct shtc1_data *data = shtc1_update_client(dev);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, "%d\\n", data->temperature);\n	f
32958	759	ubifs_jnl_write_data	fs/ubifs/journal.c	err	1	13	\N	\N	\tstruct ubifs_data_node *data;\n\tint err, lnum, offs, compr_type, out_len, compr_len;\n\tint dlen = COMPRESSED_DATA_NODE_BUF_SZ, allocated = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tbool encrypted = ubifs_crypt_is_encrypted(inode);\n\n\tdbg_jnlk(key, "ino %lu, blk %u, len %d, key ",\n\t\t(unsigned long)key_inum(c, key), key_block(c, key), len);\n\tubifs_assert(len <= UBIFS_BLOCK_SIZE);\n\n\tif (encrypted)\n\t\tdlen += UBIFS_CIPHER_BLOCK_SIZE;\n\n\tdata = kmalloc(dlen, GFP_NOFS | __GFP_NOWARN);\n\tif (!data) {\n\t\t/*\n\t\t * Fall-back to the write reserve buffer. Note, we might be\n\t\t * currently on the memory reclaim path, when the kernel is\n\t\t * trying to free some memory by writing out dirty pages. The\n\t\t * write reserve buffer helps us to guarantee that we are\n\t\t * always able to write the data.\n\t\t */\n\t\tallocated = 0;\n\t\tmutex_lock(&c->write_reserve_mutex);\n\t\tdata = c->write_reserve_buf;\n\t}\n\n\tdata->ch.node_type = UBIFS_DATA_NODE;\n\tkey_write(c, key, &data->key);\n\tdata->size = cpu_to_le32(len);\n\n\tif (!(ui->flags & UBIFS_COMPR_FL))\n\t\t/* Compression is disabled for this inode */\n\t\tcompr_type = UBIFS_COMPR_NONE;\n\telse\n\t\tcompr_type = ui->compr_type;\n\n\tout_len = compr_len = dlen - UBIFS_DATA_NODE_SZ;\n\tubifs_compress(c, buf, len, &data->data, &compr_len, &compr_type);\n\tubifs_assert(compr_len <= UBIFS_BLOCK_SIZE);\n\n\tif (encrypted) {\n\t\terr = ubifs_encrypt(inode, data, compr_len, &out_len, key_block(c, key));\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t} else {\n\t\tdata->compr_size = 0;\n\t\tout_len = compr_len;\n\t}\n\n\tdlen = UBIFS_DATA_NODE_SZ + out_len;\n\tdata->compr_type = cpu_to_le16(compr_type);\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, DATAHD, dlen);\n\tif (err)\n	f
35944	127	mixart_set_pipe_state	sound/pci/mixart/mixart.c	group_state_resp.txx_status	1	13	\N	\N	\tstruct mixart_group_state_req group_state;\n\tstruct mixart_group_state_resp group_state_resp;\n\tstruct mixart_msg request;\n\tint err;\n\tu32 system_msg_uid;\n\n\tswitch(pipe->status) {\n\tcase PIPE_RUNNING:\n\tcase PIPE_CLOCK_SET:\n\t\tif(start) return 0; /* already started */\n\t\tbreak;\n\tcase PIPE_STOPPED:\n\t\tif(!start) return 0; /* already stopped */\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t"error mixart_set_pipe_state called with wrong pipe->status!\\n");\n\t\treturn -EINVAL;      /* function called with wrong pipe status */\n\t}\n\n\tsystem_msg_uid = 0x12345678; /* the event ! (take care: the MSB and two LSB's have to be 0) */\n\n\t/* wait on the last MSG_SYSTEM_SEND_SYNCHRO_CMD command to be really finished */\n\n\trequest.message_id = MSG_SYSTEM_WAIT_SYNCHRO_CMD;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &system_msg_uid;\n\trequest.size = sizeof(system_msg_uid);\n\n\terr = snd_mixart_send_msg_wait_notif(mgr, &request, system_msg_uid);\n\tif(err) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t"error : MSG_SYSTEM_WAIT_SYNCHRO_CMD was not notified !\\n");\n\t\treturn err;\n\t}\n\n\t/* start or stop the pipe (1 pipe) */\n\n\tmemset(&group_state, 0, sizeof(group_state));\n\tgroup_state.pipe_count = 1;\n\tgroup_state.pipe_uid[0] = pipe->group_uid;\n\n\tif(start)\n\t\trequest.message_id = MSG_STREAM_START_STREAM_GRP_PACKET;\n\telse\n\t\trequest.message_id = MSG_STREAM_STOP_STREAM_GRP_PACKET;\n\n\trequest.uid = pipe->group_uid; /*(struct mixart_uid){0,0};*/\n\trequest.data = &group_state;\n\trequest.size = sizeof(group_state);\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(group_state_resp), &group_state_resp);\n\tif (err < 0 || group_state_resp.txx_status != 0) {\n	f
47045	491	ef4_rx_mk_skb	drivers/net/ethernet/sfc/falcon/rx.c	skb->data + efx->rx_ip_align	1	13	\N	\N	\tstruct ef4_nic *efx = channel->efx;\n\tstruct sk_buff *skb;\n\n\t/* Allocate an SKB to store the headers */\n\tskb = netdev_alloc_skb(efx->net_dev,\n\t\t\t       efx->rx_ip_align + efx->rx_prefix_size +\n\t\t\t       hdr_len);\n\tif (unlikely(skb == NULL)) {\n\t\tatomic_inc(&efx->n_rx_noskb_drops);\n\t\treturn NULL;\n\t}\n\n\tEF4_BUG_ON_PARANOID(rx_buf->len < hdr_len);\n\n\tmemcpy(skb->data + efx->rx_ip_align, eh - efx->rx_prefix_size,\n	f
55749	830	exofs_writepages	fs/exofs/inode.c	pcol.pages	1	13	\N	\N	\tstruct page_collect pcol;\n\tlong start, end, expected_pages;\n\tint ret;\n\n\tstart = wbc->range_start >> PAGE_SHIFT;\n\tend = (wbc->range_end == LLONG_MAX) ?\n\t\t\tstart + mapping->nrpages :\n\t\t\twbc->range_end >> PAGE_SHIFT;\n\n\tif (start || end)\n\t\texpected_pages = end - start + 1;\n\telse\n\t\texpected_pages = mapping->nrpages;\n\n\tif (expected_pages < 32L)\n\t\texpected_pages = 32L;\n\n\tEXOFS_DBGMSG2("inode(0x%lx) wbc->start=0x%llx wbc->end=0x%llx "\n\t\t     "nrpages=%lu start=0x%lx end=0x%lx expected_pages=%ld\\n",\n\t\t     mapping->host->i_ino, wbc->range_start, wbc->range_end,\n\t\t     mapping->nrpages, start, end, expected_pages);\n\n\t_pcol_init(&pcol, expected_pages, mapping->host);\n\n\tret = write_cache_pages(mapping, wbc, writepage_strip, &pcol);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR("write_cache_pages => %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret = write_exec(&pcol);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\treturn write_exec(&pcol); /* pump the last reminder */\n\t} else if (pcol.nr_pages) {\n\t\t/* not SYNC let the reminder join the next writeout */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < pcol.nr_pages; i++) {\n\t\t\tstruct page *page = pcol.pages[i];\n	f
55827	1060	capinc_tty_write	drivers/isdn/capi/capi.c	skb	1	13	\N	\N	\tstruct capiminor *mp = tty->driver_data;\n\tstruct sk_buff *skb;\n\n\tpr_debug("capinc_tty_write(count=%d)\\n", count);\n\n\tspin_lock_bh(&mp->outlock);\n\tskb = mp->outskb;\n\tif (skb) {\n\t\tmp->outskb = NULL;\n\t\t__skb_queue_tail(&mp->outqueue, skb);\n\t\tmp->outbytes += skb->len;\n\t}\n\n\tskb = alloc_skb(CAPI_DATA_B3_REQ_LEN + count, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR "capinc_tty_write: alloc_skb failed\\n");\n\t\tspin_unlock_bh(&mp->outlock);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, CAPI_DATA_B3_REQ_LEN);\n	f
61980	4106	drbd_adm_start_ov	drivers/block/drbd/drbd_nl.c	adm_ctx.resource->adm_mutex	1	13	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tstruct drbd_device *device;\n\tenum drbd_ret_code retcode;\n\tstruct start_ov_parms parms;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\n\tif (!adm_ctx.reply_skb)\n\t\treturn retcode;\n\tif (retcode != NO_ERROR)\n\t\tgoto out;\n\n\tdevice = adm_ctx.device;\n\n\t/* resume from last known position, if possible */\n\tparms.ov_start_sector = device->ov_start_sector;\n\tparms.ov_stop_sector = ULLONG_MAX;\n\tif (info->attrs[DRBD_NLA_START_OV_PARMS]) {\n\t\tint err = start_ov_parms_from_attrs(&parms, info);\n\t\tif (err) {\n\t\t\tretcode = ERR_MANDATORY_TAG;\n\t\t\tdrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_lock(&adm_ctx.resource->adm_mutex);\n	f
36111	888	ieee80211_tdls_build_mgmt_packet_data	net/mac80211/tdls.c	skb	1	13	\N	\N	\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = netdev_alloc_skb(sdata->dev,\n\t\t\t       local->hw.extra_tx_headroom +\n\t\t\t       max(sizeof(struct ieee80211_mgmt),\n\t\t\t\t   sizeof(struct ieee80211_tdls_data)) +\n\t\t\t       50 + /* supported rates */\n\t\t\t       10 + /* ext capab */\n\t\t\t       26 + /* max(WMM-info, WMM-param) */\n\t\t\t       2 + max(sizeof(struct ieee80211_ht_cap),\n\t\t\t\t       sizeof(struct ieee80211_ht_operation)) +\n\t\t\t       2 + max(sizeof(struct ieee80211_vht_cap),\n\t\t\t\t       sizeof(struct ieee80211_vht_operation)) +\n\t\t\t       50 + /* supported channels */\n\t\t\t       3 + /* 40/20 BSS coex */\n\t\t\t       4 + /* AID */\n\t\t\t       4 + /* oper classes */\n\t\t\t       extra_ies_len +\n\t\t\t       sizeof(struct ieee80211_tdls_lnkie));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n	f
36391	439	sid_to_id	fs/cifs/cifsacl.c	id	1	13	\N	\N	\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, "%s: %u subauthorities is too many!\\n",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL) {\n\t\tuint32_t unix_id;\n\t\tbool is_group;\n\n\t\tif (sidtype != SIDOWNER)\n\t\t\tis_group = true;\n\t\telse\n\t\t\tis_group = false;\n\n\t\tif (is_well_known_sid(psid, &unix_id, is_group) == false)\n\t\t\tgoto try_upcall_to_get_id;\n\n\t\tif (is_group) {\n\t\t\tkgid_t gid;\n\t\t\tgid_t id;\n\n\t\t\tid = (gid_t)unix_id;\n\t\t\tgid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid)) {\n\t\t\t\tfgid = gid;\n\t\t\t\tgoto got_valid_id;\n\t\t\t}\n\t\t} else {\n\t\t\tkuid_t uid;\n\t\t\tuid_t id;\n\n\t\t\tid = (uid_t)unix_id;\n\t\t\tuid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid)) {\n\t\t\t\tfuid = uid;\n\t\t\t\tgoto got_valid_id;\n\t\t\t}\n\t\t}\n\t\t/* If unable to find uid/gid easily from SID try via upcall */\n\t}\n\ntry_upcall_to_get_id:\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, "");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, "%s: Can't map SID %s to a %cid\\n",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, "%s: Downcall contained malformed key (datalen=%hu)\\n",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.data[0], sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.data[0], sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n	f
8681	72	nft_bitwise_init	net/netfilter/nft_bitwise.c	priv->len	1	13	\N	\N	\tstruct nft_bitwise *priv = nft_expr_priv(expr);\n\tstruct nft_data_desc d1, d2;\n\tu32 len;\n\tint err;\n\n\tif (tb[NFTA_BITWISE_SREG] == NULL ||\n\t    tb[NFTA_BITWISE_DREG] == NULL ||\n\t    tb[NFTA_BITWISE_LEN] == NULL ||\n\t    tb[NFTA_BITWISE_MASK] == NULL ||\n\t    tb[NFTA_BITWISE_XOR] == NULL)\n\t\treturn -EINVAL;\n\n\terr = nft_parse_u32_check(tb[NFTA_BITWISE_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->len = len;\n\n\tpriv->sreg = nft_parse_register(tb[NFTA_BITWISE_SREG]);\n\terr = nft_validate_register_load(priv->sreg, priv->len);\n	f
9120	2159	nv_gear_backoff_reseed	drivers/net/ethernet/nvidia/forcedeth.c	combinedSeed	1	13	\N	\N	\tu8 __iomem *base = get_hwbase(dev);\n\tu32 miniseed1, miniseed2, miniseed2_reversed, miniseed3, miniseed3_reversed;\n\tu32 temp, seedset, combinedSeed;\n\tint i;\n\n\t/* Setup seed for free running LFSR */\n\t/* We are going to read the time stamp counter 3 times\n\t   and swizzle bits around to increase randomness */\n\tget_random_bytes(&miniseed1, sizeof(miniseed1));\n\tminiseed1 &= 0x0fff;\n\tif (miniseed1 == 0)\n\t\tminiseed1 = 0xabc;\n\n\tget_random_bytes(&miniseed2, sizeof(miniseed2));\n\tminiseed2 &= 0x0fff;\n\tif (miniseed2 == 0)\n\t\tminiseed2 = 0xabc;\n\tminiseed2_reversed =\n\t\t((miniseed2 & 0xF00) >> 8) |\n\t\t (miniseed2 & 0x0F0) |\n\t\t ((miniseed2 & 0x00F) << 8);\n\n\tget_random_bytes(&miniseed3, sizeof(miniseed3));\n\tminiseed3 &= 0x0fff;\n\tif (miniseed3 == 0)\n\t\tminiseed3 = 0xabc;\n\tminiseed3_reversed =\n\t\t((miniseed3 & 0xF00) >> 8) |\n\t\t (miniseed3 & 0x0F0) |\n\t\t ((miniseed3 & 0x00F) << 8);\n\n\tcombinedSeed = ((miniseed1 ^ miniseed2_reversed) << 12) |\n\t\t       (miniseed2 ^ miniseed3_reversed);\n\n\t/* Seeds can not be zero */\n\tif ((combinedSeed & NVREG_BKOFFCTRL_SEED_MASK) == 0)\n\t\tcombinedSeed |= 0x08;\n\tif ((combinedSeed & (NVREG_BKOFFCTRL_SEED_MASK << NVREG_BKOFFCTRL_GEAR)) == 0)\n	f
20952	902	hip04_mac_probe	drivers/net/ethernet/hisilicon/hip04_eth.c	priv	1	13	\N	\N	\tstruct device *d = &pdev->dev;\n\tstruct device_node *node = d->of_node;\n\tstruct of_phandle_args arg;\n\tstruct net_device *ndev;\n\tstruct hip04_priv *priv;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(struct hip04_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->base = devm_ioremap_resource(d, res);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto init_fail;\n\t}\n\n\tret = of_parse_phandle_with_fixed_args(node, "port-handle", 2, 0, &arg);\n\tif (ret < 0) {\n\t\tdev_warn(d, "no port-handle\\n");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->port = arg.args[0];\n\tpriv->chan = arg.args[1] * RX_DESC_NUM;\n\n\thrtimer_init(&priv->tx_coalesce_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\n\t/* BQL will try to keep the TX queue as short as possible, but it can't\n\t * be faster than tx_coalesce_usecs, so we need a fast timeout here,\n\t * but also long enough to gather up enough frames to ensure we don't\n\t * get more interrupts than necessary.\n\t * 200us is enough for 16 frames of 1500 bytes at gigabit ethernet rate\n\t */\n\tpriv->tx_coalesce_frames = TX_DESC_NUM * 3 / 4;\n\tpriv->tx_coalesce_usecs = 200;\n\tpriv->tx_coalesce_timer.function = tx_done;\n\n\tpriv->map = syscon_node_to_regmap(arg.np);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_warn(d, "no syscon hisilicon,hip04-ppe\\n");\n\t\tret = PTR_ERR(priv->map);\n\t\tgoto init_fail;\n\t}\n\n\tpriv->phy_mode = of_get_phy_mode(node);\n\tif (priv->phy_mode < 0) {\n\t\tdev_warn(d, "not find phy-mode\\n");\n\t\tret = -EINVAL;\n\t\tgoto init_fail;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto init_fail;\n\t}\n\n\tret = devm_request_irq(d, irq, hip04_mac_interrupt,\n\t\t\t       0, pdev->name, ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, "devm_request_irq failed\\n");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->phy_node = of_parse_phandle(node, "phy-handle", 0);\n\tif (priv->phy_node) {\n\t\tpriv->phy = of_phy_connect(ndev, priv->phy_node,\n\t\t\t\t\t   &hip04_adjust_link,\n\t\t\t\t\t   0, priv->phy_mode);\n\t\tif (!priv->phy) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto init_fail;\n\t\t}\n\t}\n\n\tINIT_WORK(&priv->tx_timeout_task, hip04_tx_timeout_task);\n\n\tndev->netdev_ops = &hip04_netdev_ops;\n\tndev->ethtool_ops = &hip04_ethtool_ops;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\tndev->irq = irq;\n\tnetif_napi_add(ndev, &priv->napi, hip04_rx_poll, NAPI_POLL_WEIGHT);\n\n\thip04_reset_ppe(priv);\n	f
25678	1787	do_cmdtest_ioctl	drivers/staging/comedi/comedi_fops.c	&cmd	1	13	\N	\N	\tstruct comedi_cmd cmd;\n\tstruct comedi_subdevice *s;\n\tunsigned int __user *user_chanlist;\n\tint ret;\n\n\t/* get the user's cmd and do some simple validation */\n\tret = __comedi_get_user_cmd(dev, arg, &cmd);\n	f
6816	339	set_temp_max1	drivers/hwmon/gl518sm.c	set_temp_max1_$__UNIQUE_ID_min1_133$obj	0	13	\N	\N	\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, "%d\\n", DIV_FROM_REG(data->fan_div[nr]));\n}\n\n#define set(type, suffix, value, reg)\t\t\t\t\t\\\nstatic ssize_t set_##suffix(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gl518_data *data = dev_get_drvdata(dev);\t\t\t\\\n\tstruct i2c_client *client = data->client;\t\t\t\\\n\tlong val;\t\t\t\t\t\t\t\\\n\tint err = kstrtol(buf, 10, &val);\t\t\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&data->update_lock);\t\t\t\t\t\\\n\tdata->value = type##_TO_REG(val);\t\t\t\t\\\n\tgl518_write_value(client, reg, data->value);\t\t\t\\\n\tmutex_unlock(&data->update_lock);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define set_bits(type, suffix, value, reg, mask, shift)\t\t\t\\\nstatic ssize_t set_##suffix(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gl518_data *data = dev_get_drvdata(dev);\t\t\t\\\n\tstruct i2c_client *client = data->client;\t\t\t\\\n\tint regvalue;\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint err = kstrtoul(buf, 10, &val);\t\t\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&data->update_lock);\t\t\t\t\t\\\n\tregvalue = gl518_read_value(client, reg);\t\t\t\\\n\tdata->value = type##_TO_REG(val);\t\t\t\t\\\n\tregvalue = (regvalue & ~mask) | (data->value << shift);\t\t\\\n\tgl518_write_value(client, reg, regvalue);\t\t\t\\\n\tmutex_unlock(&data->update_lock);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define set_low(type, suffix, value, reg)\t\t\t\t\\\n\tset_bits(type, suffix, value, reg, 0x00ff, 0)\n#define set_high(type, suffix, value, reg)\t\t\t\t\\\n\tset_bits(type, suffix, value, reg, 0xff00, 8)\n\nset(TEMP, temp_max1, temp_max, GL518_REG_TEMP_MAX);\n	f
27446	304	qed_iwarp_modify_fw	drivers/net/ethernet/qlogic/qed/qed_iwarp.c	p_ramrod->flags	1	13	\N	\N	\tstruct iwarp_modify_qp_ramrod_data *p_ramrod;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tint rc;\n\n\t/* Get SPQ entry */\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qp->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_MODIFY_QP,\n\t\t\t\t p_hwfn->p_rdma_info->proto, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iwarp_modify_qp;\n\tSET_FIELD(p_ramrod->flags, IWARP_MODIFY_QP_RAMROD_DATA_STATE_TRANS_EN,\n	f
33844	574	add_new_ctl	sound/usb/mixer_scarlett.c	kctl->id.name	1	13	\N	\N	\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\telem->head.mixer = mixer;\n\telem->head.resume = resume;\n\telem->control = offset;\n\telem->idx_off = num;\n\telem->head.id = index;\n\telem->val_type = val_type;\n\n\telem->channels = channels;\n\n\t/* add scarlett_mixer_elem_enum_info struct */\n\telem->private_data = (void *)opt;\n\n\tkctl = snd_ctl_new1(ncontrol, elem);\n\tif (!kctl) {\n\t\tkfree(elem);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n	f
36412	2518	CIFSSMBPosixLock	fs/cifs/cifssmb.c	data_count	1	13	\N	\N	\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\n\tcifs_dbg(FYI, "Posix Lock\\n");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout, &rsp_iov);\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)rsp_iov.iov_base;\n\t}\n\tcifs_small_buf_release(pSMB);\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, "Send error in Posix Lock = %d\\n", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n	f
45427	571	cbaf_wusb_ck_store	drivers/usb/wusbcore/cbaf.c	result	1	13	\N	\N	\tssize_t result;\n\tstruct usb_interface *iface = to_usb_interface(dev);\n\tstruct cbaf *cbaf = usb_get_intfdata(iface);\n\n\tresult = sscanf(buf,\n\t\t\t"%02hhx %02hhx %02hhx %02hhx "\n\t\t\t"%02hhx %02hhx %02hhx %02hhx "\n\t\t\t"%02hhx %02hhx %02hhx %02hhx "\n\t\t\t"%02hhx %02hhx %02hhx %02hhx",\n\t\t\t&cbaf->ck.data[0] , &cbaf->ck.data[1],\n\t\t\t&cbaf->ck.data[2] , &cbaf->ck.data[3],\n\t\t\t&cbaf->ck.data[4] , &cbaf->ck.data[5],\n\t\t\t&cbaf->ck.data[6] , &cbaf->ck.data[7],\n\t\t\t&cbaf->ck.data[8] , &cbaf->ck.data[9],\n\t\t\t&cbaf->ck.data[10], &cbaf->ck.data[11],\n\t\t\t&cbaf->ck.data[12], &cbaf->ck.data[13],\n\t\t\t&cbaf->ck.data[14], &cbaf->ck.data[15]);\n\tif (result != 16)\n\t\treturn -EINVAL;\n\n\tresult = cbaf_cc_upload(cbaf);\n\tif (result < 0)\n	f
60501	396	irlan_provider_open_ctrl_tsap	drivers/staging/irda/net/irlan/irlan_provider.c	&notify	1	13	\N	\N	\tstruct tsap_cb *tsap;\n\tnotify_t notify;\n\n\tIRDA_ASSERT(self != NULL, return -1;);\n\tIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\n\n\t/* Check if already open */\n\tif (self->provider.tsap_ctrl)\n\t\treturn -1;\n\n\t/*\n\t *  First register well known control TSAP\n\t */\n\tirda_notify_init(&notify);\n\tnotify.data_indication       = irlan_provider_data_indication;\n\tnotify.connect_indication    = irlan_provider_connect_indication;\n\tnotify.disconnect_indication = irlan_provider_disconnect_indication;\n\tnotify.instance = self;\n\tstrlcpy(notify.name, "IrLAN ctrl (p)", sizeof(notify.name));\n\n\ttsap = irttp_open_tsap(LSAP_ANY, 1, &notify);\n	f
36090	1059	collapse_huge_page	mm/khugepaged.c	collapse_huge_page_$vma$obj$9	0	13	\N	\N	\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *pmd_ptl, *pte_ptl;\n\tint isolated = 0, result = 0;\n\tstruct mem_cgroup *memcg;\n\tstruct vm_area_struct *vma;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t gfp;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\t/*\n\t * Before allocating the hugepage, release the mmap_sem read lock.\n\t * The allocation can take potentially a long time if it involves\n\t * sync compaction, and we do not need to hold the mmap_sem during\n\t * that. We will recheck the vma after taking it again in write mode.\n\t */\n\tup_read(&mm->mmap_sem);\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\t/*\n\t * __collapse_huge_page_swapin always returns with mmap_sem locked.\n\t * If it fails, we release mmap_sem and jump out_nolock.\n\t * Continuing to collapse causes inconsistency.\n\t */\n\tif (!__collapse_huge_page_swapin(mm, vma, address, pmd, referenced)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later handled by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result)\n\t\tgoto out;\n\t/* check if the pmd is still valid */\n\tif (mm_find_pmd(mm, address) != pmd)\n\t\tgoto out;\n\n\tanon_vma_lock_write(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tpte_ptl = pte_lockptr(mm, pmd);\n\n\tmmun_start = address;\n\tmmun_end   = address + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\tpmd_ptl = pmd_lock(mm, pmd); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_collapse_flush(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\n\tspin_lock(pte_ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(pte_ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(pmd_ptl);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\t/*\n\t\t * We can only use set_pmd_at when establishing\n\t\t * hugepmds and never for establishing regular pmds that\n\t\t * points to regular pagetables. Use pmd_populate for that\n\t\t */\n\t\tpmd_populate(mm, pmd, pmd_pgtable(_pmd));\n\t\tspin_unlock(pmd_ptl);\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\t\tresult = SCAN_FAIL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock_write(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, pte_ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\n\t_pmd = mk_huge_pmd(new_page, vma->vm_page_prot);\n	f
27864	869	mmc_test_nonblock_transfer	drivers/mmc/core/mmc_test.c	status	1	13	\N	\N	\tstruct mmc_test_req *rq1, *rq2;\n\tstruct mmc_test_async_req test_areq[2];\n\tstruct mmc_async_req *done_areq;\n\tstruct mmc_async_req *cur_areq = &test_areq[0].areq;\n\tstruct mmc_async_req *other_areq = &test_areq[1].areq;\n\tenum mmc_blk_status status;\n\tint i;\n\tint ret = RESULT_OK;\n\n\ttest_areq[0].test = test;\n\ttest_areq[1].test = test;\n\n\trq1 = mmc_test_req_alloc();\n\trq2 = mmc_test_req_alloc();\n\tif (!rq1 || !rq2) {\n\t\tret = RESULT_FAIL;\n\t\tgoto err;\n\t}\n\n\tcur_areq->mrq = &rq1->mrq;\n\tcur_areq->err_check = mmc_test_check_result_async;\n\tother_areq->mrq = &rq2->mrq;\n\tother_areq->err_check = mmc_test_check_result_async;\n\n\tfor (i = 0; i < count; i++) {\n\t\tmmc_test_prepare_mrq(test, cur_areq->mrq, sg, sg_len, dev_addr,\n\t\t\t\t     blocks, blksz, write);\n\t\tdone_areq = mmc_start_areq(test->card->host, cur_areq, &status);\n\n\t\tif (status != MMC_BLK_SUCCESS || (!done_areq && i > 0)) {\n	f
32966	2982	r600_copy_cpdma	drivers/gpu/drm/radeon/r600.c	&sync	1	13	\N	\N	\tstruct radeon_fence *fence;\n\tstruct radeon_sync sync;\n\tint ring_index = rdev->asic->copy.blit_ring_index;\n\tstruct radeon_ring *ring = &rdev->ring[ring_index];\n\tu32 size_in_bytes, cur_size_in_bytes, tmp;\n\tint i, num_loops;\n\tint r = 0;\n\n\tradeon_sync_create(&sync);\n\n\tsize_in_bytes = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT);\n\tnum_loops = DIV_ROUND_UP(size_in_bytes, 0x1fffff);\n\tr = radeon_ring_lock(rdev, ring, num_loops * 6 + 24);\n\tif (r) {\n\t\tDRM_ERROR("radeon: moving bo (%d).\\n", r);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_sync_resv(rdev, &sync, resv, false);\n\tradeon_sync_rings(rdev, &sync, ring->idx);\n	f
57115	130	bert_init	drivers/acpi/apei/bert.c	bert_init_$bert_tab$obj$9	0	13	\N	\N	\tstruct apei_resources bert_resources;\n\tstruct acpi_bert_region *boot_error_region;\n\tstruct acpi_table_bert *bert_tab;\n\tunsigned int region_len;\n\tacpi_status status;\n\tint rc = 0;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tif (bert_disable) {\n\t\tpr_info("Boot Error Record Table support is disabled.\\n");\n\t\treturn 0;\n\t}\n\n\tstatus = acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab);\n\tif (status == AE_NOT_FOUND)\n\t\treturn 0;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err("get table failed, %s.\\n", acpi_format_exception(status));\n\t\treturn -EINVAL;\n\t}\n\n\trc = bert_check_table(bert_tab);\n\tif (rc) {\n\t\tpr_err(FW_BUG "table invalid.\\n");\n\t\treturn rc;\n\t}\n\n\tregion_len = bert_tab->region_length;\n	f
36489	421	xfs_attr_remove	fs/xfs/libxfs/xfs_attr.c	error	1	13	\N	\N	\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(mp, xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n	f
39096	857	esd_usb2_close	drivers/net/can/usb/esd_usb2.c	esd_usb2_close_	1	13	\N	\N	\tstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\n\tstruct esd_usb2_msg *msg;\n\tint i;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t/* Disable all IDs (see esd_usb2_start()) */\n\tmsg->msg.hdr.cmd = CMD_IDADD;\n\tmsg->msg.hdr.len = 2 + ESD_MAX_ID_SEGMENT;\n\tmsg->msg.filter.net = priv->index;\n\tmsg->msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */\n\tfor (i = 0; i <= ESD_MAX_ID_SEGMENT; i++)\n\t\tmsg->msg.filter.mask[i] = 0;\n\tif (esd_usb2_send_msg(priv->usb2, msg) < 0)\n	f
44763	1205	genwqe_ioctl	drivers/misc/genwqe/card_dev.c	&m	1	13	\N	\N	\tint rc = 0;\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct genwqe_reg_io __user *io;\n\tu64 val;\n\tu32 reg_offs;\n\n\t/* Return -EIO if card hit EEH */\n\tif (pci_channel_offline(pci_dev))\n\t\treturn -EIO;\n\n\tif (_IOC_TYPE(cmd) != GENWQE_IOC_CODE)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\n\tcase GENWQE_GET_CARD_STATE:\n\t\tput_user(cd->card_state, (enum genwqe_card_state __user *)arg);\n\t\treturn 0;\n\n\t\t/* Register access */\n\tcase GENWQE_READ_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readq(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writeq(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_READ_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readl(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writel(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\t\t/* Flash update/reading */\n\tcase GENWQE_SLU_UPDATE: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&load, (void __user *)arg,\n\t\t\t\t   sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_update(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\tcase GENWQE_SLU_READ: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif (genwqe_flash_readback_fails(cd))\n\t\t\treturn -ENOSPC;\t /* known to fail for old versions */\n\n\t\tif (copy_from_user(&load, (void __user *)arg, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_read(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\t\t/* memory pinning and unpinning */\n\tcase GENWQE_PIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_pin_mem(cfile, &m);\n\t}\n\n\tcase GENWQE_UNPIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_unpin_mem(cfile, &m);\n	f
60806	3598	kiblnd_scheduler	drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c	kiblnd_scheduler_$wc$3$obj	0	13	\N	\N	\tlong id = (long)arg;\n\tstruct kib_sched_info *sched;\n\tstruct kib_conn *conn;\n\twait_queue_entry_t wait;\n\tunsigned long flags;\n\tstruct ib_wc wc;\n\tint did_something;\n\tint busy_loops = 0;\n\tint rc;\n\n\tcfs_block_allsigs();\n\n\tinit_waitqueue_entry(&wait, current);\n\n\tsched = kiblnd_data.kib_scheds[KIB_THREAD_CPT(id)];\n\n\trc = cfs_cpt_bind(lnet_cpt_table(), sched->ibs_cpt);\n\tif (rc) {\n\t\tCWARN("Unable to bind on CPU partition %d, please verify whether all CPUs are healthy and reload modules if necessary, otherwise your system might under risk of low performance\\n",\n\t\t      sched->ibs_cpt);\n\t}\n\n\tspin_lock_irqsave(&sched->ibs_lock, flags);\n\n\twhile (!kiblnd_data.kib_shutdown) {\n\t\tif (busy_loops++ >= IBLND_RESCHED) {\n\t\t\tspin_unlock_irqrestore(&sched->ibs_lock, flags);\n\n\t\t\tcond_resched();\n\t\t\tbusy_loops = 0;\n\n\t\t\tspin_lock_irqsave(&sched->ibs_lock, flags);\n\t\t}\n\n\t\tdid_something = 0;\n\n\t\tif (!list_empty(&sched->ibs_conns)) {\n\t\t\tconn = list_entry(sched->ibs_conns.next, struct kib_conn,\n\t\t\t\t\t  ibc_sched_list);\n\t\t\t/* take over kib_sched_conns' ref on conn... */\n\t\t\tLASSERT(conn->ibc_scheduled);\n\t\t\tlist_del(&conn->ibc_sched_list);\n\t\t\tconn->ibc_ready = 0;\n\n\t\t\tspin_unlock_irqrestore(&sched->ibs_lock, flags);\n\n\t\t\twc.wr_id = IBLND_WID_INVAL;\n\n\t\t\trc = ib_poll_cq(conn->ibc_cq, 1, &wc);\n\t\t\tif (!rc) {\n\t\t\t\trc = ib_req_notify_cq(conn->ibc_cq,\n\t\t\t\t\t\t      IB_CQ_NEXT_COMP);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tCWARN("%s: ib_req_notify_cq failed: %d, closing connection\\n",\n\t\t\t\t\t      libcfs_nid2str(conn->ibc_peer->ibp_nid), rc);\n\t\t\t\t\tkiblnd_close_conn(conn, -EIO);\n\t\t\t\t\tkiblnd_conn_decref(conn);\n\t\t\t\t\tspin_lock_irqsave(&sched->ibs_lock,\n\t\t\t\t\t\t\t  flags);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trc = ib_poll_cq(conn->ibc_cq, 1, &wc);\n\t\t\t}\n\n\t\t\tif (unlikely(rc > 0 && wc.wr_id == IBLND_WID_INVAL)) {\n\t\t\t\tLCONSOLE_ERROR("ib_poll_cq (rc: %d) returned invalid wr_id, opcode %d, status: %d, vendor_err: %d, conn: %s status: %d\\nplease upgrade firmware and OFED or contact vendor.\\n",\n	f
35477	754	ath_tx_process_buffer	drivers/net/wireless/ath/ath9k/xmit.c	struct	1	13	\N	\N	\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath_atx_tid *tid = NULL;\n\tbool txok, flush;\n\n\ttxok = !(ts->ts_status & ATH9K_TXERR_MASK);\n\tflush = !!(ts->ts_status & ATH9K_TX_FLUSH);\n\ttxq->axq_tx_inprogress = false;\n\n\ttxq->axq_depth--;\n\tif (bf_is_ampdu_not_probing(bf))\n\t\ttxq->axq_ampdu_depth--;\n\n\tts->duration = ath9k_hw_get_duration(sc->sc_ah, bf->bf_desc,\n\t\t\t\t\t     ts->ts_rateindex);\n\n\thdr = (struct ieee80211_hdr *) bf->bf_mpdu->data;\n\tsta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr1, hdr->addr2);\n\tif (sta) {\n\t\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n	f
23147	738	xfs_refcount_merge_extents	fs/xfs/libxfs/xfs_refcount.c	xfs_refcount_merge_extents_$cleft$0$obj	0	13	\N	\N	\tstruct xfs_refcount_irec\tleft = {0}, cleft = {0};\n\tstruct xfs_refcount_irec\tcright = {0}, right = {0};\n\tint\t\t\t\terror;\n\tunsigned long long\t\tulen;\n\tbool\t\t\t\tcequal;\n\n\t*shape_changed = false;\n\t/*\n\t * Find the extent just below agbno [left], just above agbno [cleft],\n\t * just below (agbno + aglen) [cright], and just above (agbno + aglen)\n\t * [right].\n\t */\n\terror = xfs_refcount_find_left_extents(cur, &left, &cleft, *agbno,\n\t\t\t*aglen, flags);\n\tif (error)\n\t\treturn error;\n\terror = xfs_refcount_find_right_extents(cur, &right, &cright, *agbno,\n\t\t\t*aglen, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* No left or right extent to merge; exit. */\n\tif (!xfs_refc_valid(&left) && !xfs_refc_valid(&right))\n\t\treturn 0;\n\n\tcequal = (cleft.rc_startblock == cright.rc_startblock) &&\n	f
46890	305	vf50_ts_probe	drivers/input/touchscreen/colibri-vf50-ts.c	error	1	13	\N	\N	\tstruct input_dev *input;\n\tstruct iio_channel *channels;\n\tstruct device *dev = &pdev->dev;\n\tstruct vf50_touch_device *touchdev;\n\tint num_adc_channels;\n\tint error;\n\n\tchannels = iio_channel_get_all(dev);\n\tif (IS_ERR(channels))\n\t\treturn PTR_ERR(channels);\n\n\terror = devm_add_action(dev, vf50_ts_channel_release, channels);\n\tif (error) {\n\t\tiio_channel_release_all(channels);\n\t\tdev_err(dev, "Failed to register iio channel release action");\n\t\treturn error;\n\t}\n\n\tnum_adc_channels = 0;\n\twhile (channels[num_adc_channels].indio_dev)\n\t\tnum_adc_channels++;\n\n\tif (num_adc_channels != COLI_TOUCH_REQ_ADC_CHAN) {\n\t\tdev_err(dev, "Inadequate ADC channels specified\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ttouchdev = devm_kzalloc(dev, sizeof(*touchdev), GFP_KERNEL);\n\tif (!touchdev)\n\t\treturn -ENOMEM;\n\n\ttouchdev->pdev = pdev;\n\ttouchdev->channels = channels;\n\n\terror = of_property_read_u32(dev->of_node, "vf50-ts-min-pressure",\n\t\t\t\t &touchdev->min_pressure);\n\tif (error)\n	f
25510	4168	i915_wedged_set	drivers/gpu/drm/i915/i915_debugfs.c	engine	1	13	\N	\N	\tstruct drm_i915_private *i915 = data;\n\tstruct intel_engine_cs *engine;\n\tunsigned int tmp;\n\n\t/*\n\t * There is no safeguard against this debugfs entry colliding\n\t * with the hangcheck calling same i915_handle_error() in\n\t * parallel, causing an explosion. For now we assume that the\n\t * test harness is responsible enough not to inject gpu hangs\n\t * while it is writing to 'i915_wedged'\n\t */\n\n\tif (i915_reset_backoff(&i915->gpu_error))\n\t\treturn -EAGAIN;\n\n\tfor_each_engine_masked(engine, i915, val, tmp) {\n\t\tengine->hangcheck.seqno = intel_engine_get_seqno(engine);\n	f
57307	437	dln2_update_scan_mode	drivers/iio/adc/dln2-adc.c	ret	1	13	\N	\N	\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\tint chan_count = indio_dev->num_channels - 1;\n\tint ret, i, j;\n\n\tmutex_lock(&dln2->mutex);\n\n\tfor (i = 0; i < chan_count; ++i) {\n\t\tret = dln2_adc_set_chan_enabled(dln2, i,\n\t\t\t\t\t\ttest_bit(i, scan_mask));\n\t\tif (ret < 0) {\n	f
-605	180	pm8xxx_rtc_read_time	drivers/rtc/rtc-pm8xxx.c	reg	2	3	\N	\N	\tint rc;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tunsigned long secs;\n\tunsigned int reg;\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\n\trc = regmap_bulk_read(rtc_dd->regmap, regs->read, value, sizeof(value));\n\tif (rc) {\n\t\tdev_err(dev, "RTC read data register failed\\n");\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Read the LSB again and check if there has been a carry over.\n\t * If there is, redo the read operation.\n\t */\n\trc = regmap_read(rtc_dd->regmap, regs->read, &reg);\n\tif (rc < 0) {\n\t\tdev_err(dev, "RTC read data register failed\\n");\n\t\treturn rc;\n\t}\n\n\tif (unlikely(reg < value[0])) {\n	f
20282	280	__sbi_read_stats	fs/exofs/super.c	__sbi_read_stats_$ios$obj	0	13	\N	\N	\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR("%s: ore_get_io_state failed.\\n", __func__);\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n	f
35268	3865	setup_card	drivers/net/wireless/cisco/airo.c	cap_rid.softCap	1	13	\N	\N	\tCmd cmd;\n\tResp rsp;\n\tint status;\n\tSsidRid mySsid;\n\t__le16 lastindex;\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset( &mySsid, 0, sizeof( mySsid ) );\n\tkfree (ai->flash);\n\tai->flash = NULL;\n\n\t/* The NOP is the first step in getting the card going */\n\tcmd.cmd = NOP;\n\tcmd.parm0 = cmd.parm1 = cmd.parm2 = 0;\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif ( issuecommand( ai, &cmd, &rsp ) != SUCCESS ) {\n\t\tif (lock)\n\t\t\tup(&ai->sem);\n\t\treturn ERROR;\n\t}\n\tdisable_MAC( ai, 0);\n\n\t// Let's figure out if we need to use the AUX port\n\tif (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tcmd.cmd = CMD_ENABLEAUX;\n\t\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\n\t\t\tif (lock)\n\t\t\t\tup(&ai->sem);\n\t\t\tairo_print_err(ai->dev->name, "Error checking for AUX port");\n\t\t\treturn ERROR;\n\t\t}\n\t\tif (!aux_bap || rsp.status & 0xff00) {\n\t\t\tai->bap_read = fast_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, "Doing fast bap_reads");\n\t\t} else {\n\t\t\tai->bap_read = aux_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, "Doing AUX bap_reads");\n\t\t}\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n\tif (ai->config.len == 0) {\n\t\tint i;\n\t\ttdsRssiRid rssi_rid;\n\t\tCapabilityRid cap_rid;\n\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t\t// general configuration (read/modify/write)\n\t\tstatus = readConfigRid(ai, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = readCapabilityRid(ai, &cap_rid, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = PC4500_readrid(ai,RID_RSSI,&rssi_rid,sizeof(rssi_rid),lock);\n\t\tif ( status == SUCCESS ) {\n\t\t\tif (ai->rssi || (ai->rssi = kmalloc(512, GFP_KERNEL)) != NULL)\n\t\t\t\tmemcpy(ai->rssi, (u8*)&rssi_rid + 2, 512); /* Skip RID length member */\n\t\t}\n\t\telse {\n\t\t\tkfree(ai->rssi);\n\t\t\tai->rssi = NULL;\n\t\t\tif (cap_rid.softCap & cpu_to_le16(8))\n	f
36906	1026	ax88179_check_efuse	drivers/net/usb/ax88179_178a.c	efuse	1	13	\N	\N	\tu8\ti;\n\tu8\tefuse[64];\n\tu16\tcsum = 0;\n\n\tif (ax88179_read_cmd(dev, AX_ACCESS_EFUS, 0, 64, 64, efuse) < 0)\n\t\treturn -EINVAL;\n\n\tif (*efuse == 0xFF)\n	f
7400	276	find_next_position	drivers/mtd/mtdoops.c	maxcount	1	13	\N	\N	\tstruct mtd_info *mtd = cxt->mtd;\n\tint ret, page, maxpos = 0;\n\tu32 count[2], maxcount = 0xffffffff;\n\tsize_t retlen;\n\n\tfor (page = 0; page < cxt->oops_pages; page++) {\n\t\tif (mtd_block_isbad(mtd, page * record_size))\n\t\t\tcontinue;\n\t\t/* Assume the page is used */\n\t\tmark_page_used(cxt, page);\n\t\tret = mtd_read(mtd, page * record_size, MTDOOPS_HEADER_SIZE,\n\t\t\t       &retlen, (u_char *)&count[0]);\n\t\tif (retlen != MTDOOPS_HEADER_SIZE ||\n\t\t\t\t(ret < 0 && !mtd_is_bitflip(ret))) {\n\t\t\tprintk(KERN_ERR "mtdoops: read failure at %ld (%td of %d read), err %d\\n",\n\t\t\t       page * record_size, retlen,\n\t\t\t       MTDOOPS_HEADER_SIZE, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (count[0] == 0xffffffff && count[1] == 0xffffffff)\n\t\t\tmark_page_unused(cxt, page);\n\t\tif (count[0] == 0xffffffff || count[1] != MTDOOPS_KERNMSG_MAGIC)\n\t\t\tcontinue;\n\t\tif (maxcount == 0xffffffff) {\n	f
9418	2083	do_panic_write_oneword	drivers/mtd/chips/cfi_cmdset_0002.c	oldd	1	13	\N	\N	\tconst unsigned long uWriteTimeout = (HZ / 1000) + 1;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint retry_cnt = 0;\n\tmap_word oldd;\n\tint ret = 0;\n\tint i;\n\n\tadr += chip->start;\n\n\tret = cfi_amdstd_panic_wait(map, chip, adr);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_debug("MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)\\n",\n\t\t\t__func__, adr, datum.x[0]);\n\n\t/*\n\t * Check for a NOP for the case when the datum to write is already\n\t * present - it saves time and works around buggy chips that corrupt\n\t * data at other locations when 0xff is written to a location that\n\t * already contains 0xff.\n\t */\n\toldd = map_read(map, adr);\n\tif (map_word_equal(map, oldd, datum)) {\n	f
26979	391	sci_open	drivers/platform/x86/toshiba_acpi.c	status	1	13	\N	\N	\tu32 in[TCI_WORDS] = { SCI_OPEN, 0, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif  (ACPI_FAILURE(status)) {\n	f
37517	227	fix_up_ptrs	fs/hpfs/dnode.c	&qbh	1	13	\N	\N	\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n	f
51698	218	dlmfs_file_setattr	fs/ocfs2/dlmfs/dlmfs.c	inode	1	13	\N	\N	\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tattr->ia_valid &= ~ATTR_SIZE;\n\terror = setattr_prepare(dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n	f
54462	682	load_ucode_intel_bsp	arch/x86/kernel/cpu/microcode/intel.c	patch	1	13	\N	\N	\tstruct microcode_intel *patch;\n\tstruct ucode_cpu_info uci;\n\n\tpatch = __load_ucode_intel(&uci);\n\tif (!patch)\n	f
-407	1814	adm8211_probe	drivers/net/wireless/admtek/adm8211.c	reg	11	3	\N	\N	\tstruct ieee80211_hw *dev;\n\tstruct adm8211_priv *priv;\n\tunsigned long mem_addr, mem_len;\n\tunsigned int io_addr, io_len;\n\tint err;\n\tu32 reg;\n\tu8 perm_addr[ETH_ALEN];\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR "%s (adm8211): Cannot enable new PCI device\\n",\n\t\t       pci_name(pdev));\n\t\treturn err;\n\t}\n\n\tio_addr = pci_resource_start(pdev, 0);\n\tio_len = pci_resource_len(pdev, 0);\n\tmem_addr = pci_resource_start(pdev, 1);\n\tmem_len = pci_resource_len(pdev, 1);\n\tif (io_len < 256 || mem_len < 1024) {\n\t\tprintk(KERN_ERR "%s (adm8211): Too short PCI resources\\n",\n\t\t       pci_name(pdev));\n\t\tgoto err_disable_pdev;\n\t}\n\n\n\t/* check signature */\n\tpci_read_config_dword(pdev, 0x80 /* CR32 */, &reg);\n\tif (reg != ADM8211_SIG1 && reg != ADM8211_SIG2) {\n	f
28366	916	ipv6_setsockopt	net/ipv6/ipv6_sockglue.c	err	1	13	\N	\N	\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n	f
24333	921	ieee80211_auth_resp	drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c	ieee80211_auth_resp_$auth$obj$0$4	0	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct ieee80211_authentication *auth;\n\tint len = ieee->tx_headroom + sizeof(struct ieee80211_authentication)+1;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->len = sizeof(struct ieee80211_authentication);\n\n\tauth = (struct ieee80211_authentication *)skb->data;\n\n\tauth->status = cpu_to_le16(status);\n\tauth->transaction = cpu_to_le16(2);\n\tauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\n\n\tmemcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\n	f
519	101	lm3533_read	drivers/mfd/lm3533-core.c	val	1	13	\N	\N	\tint tmp;\n\tint ret;\n\n\tret = regmap_read(lm3533->regmap, reg, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(lm3533->dev, "failed to read register %02x: %d\\n",\n\t\t\t\t\t\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\t*val = tmp;\n\n\tdev_dbg(lm3533->dev, "read [%02x]: %02x\\n", reg, *val);\n	f
30992	2419	bch_refill_keybuf	drivers/md/bcache/btree.c	&refill.op	1	13	\N	\N	\tstruct bkey start = buf->last_scanned;\n\tstruct refill refill;\n\n\tcond_resched();\n\n\tbch_btree_op_init(&refill.op, -1);\n\trefill.nr_found\t= 0;\n\trefill.buf\t= buf;\n\trefill.end\t= end;\n\trefill.pred\t= pred;\n\n\tbch_btree_map_keys(&refill.op, c, &buf->last_scanned,\n	f
31114	184	usbduxfast_send_cmd	drivers/staging/comedi/drivers/usbduxfast.c	ret	1	13	\N	\N	\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tint nsent;\n\tint ret;\n\n\tdevpriv->duxbuf[0] = cmd_type;\n\n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),\n\t\t\t   devpriv->duxbuf, SIZEOFDUXBUF,\n\t\t\t   &nsent, 10000);\n\tif (ret < 0)\n	f
37454	429	da9052_bat_check_health	drivers/power/supply/da9052-battery.c	capacity	1	13	\N	\N	\tint ret;\n\tint bat_illegal;\n\tint capacity;\n\n\tret = da9052_bat_check_presence(bat, &bat_illegal);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bat_illegal) {\n\t\tbat->health = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tif (bat->health != POWER_SUPPLY_HEALTH_OVERHEAT) {\n\t\tret = da9052_bat_read_capacity(bat, &capacity);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (capacity < DA9052_BAT_LOW_CAP)\n	f
44879	424	pwm_enable_store	drivers/platform/x86/compal-laptop.c	val	1	13	\N	\N	\tstruct compal_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val < 0)\n	f
49804	334	recover_bitmaps	drivers/md/md-cluster.c	hi	1	13	\N	\N	\tstruct mddev *mddev = thread->mddev;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct dlm_lock_resource *bm_lockres;\n\tchar str[64];\n\tint slot, ret;\n\tstruct suspend_info *s, *tmp;\n\tsector_t lo, hi;\n\n\twhile (cinfo->recovery_map) {\n\t\tslot = fls64((u64)cinfo->recovery_map) - 1;\n\n\t\t/* Clear suspend_area associated with the bitmap */\n\t\tspin_lock_irq(&cinfo->suspend_lock);\n\t\tlist_for_each_entry_safe(s, tmp, &cinfo->suspend_list, list)\n\t\t\tif (slot == s->slot) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\tspin_unlock_irq(&cinfo->suspend_lock);\n\n\t\tsnprintf(str, 64, "bitmap%04d", slot);\n\t\tbm_lockres = lockres_init(mddev, str, NULL, 1);\n\t\tif (!bm_lockres) {\n\t\t\tpr_err("md-cluster: Cannot initialize bitmaps\\n");\n\t\t\tgoto clear_bit;\n\t\t}\n\n\t\tret = dlm_lock_sync_interruptible(bm_lockres, DLM_LOCK_PW, mddev);\n\t\tif (ret) {\n\t\t\tpr_err("md-cluster: Could not DLM lock %s: %d\\n",\n\t\t\t\t\tstr, ret);\n\t\t\tgoto clear_bit;\n\t\t}\n\t\tret = bitmap_copy_from_slot(mddev, slot, &lo, &hi, true);\n\t\tif (ret) {\n\t\t\tpr_err("md-cluster: Could not copy data from bitmap %d\\n", slot);\n\t\t\tgoto clear_bit;\n\t\t}\n\t\tif (hi > 0) {\n	f
54777	762	da7213_dai_event	sound/soc/codecs/da7213.c	pll_ctrl	1	13	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\n\tstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\n\tu8 pll_ctrl, pll_status;\n\tint i = 0;\n\tbool srm_lock = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t/* Enable DAI clks for master mode */\n\t\tif (da7213->master)\n\t\t\tsnd_soc_update_bits(codec, DA7213_DAI_CLK_MODE,\n\t\t\t\t\t    DA7213_DAI_CLK_EN_MASK,\n\t\t\t\t\t    DA7213_DAI_CLK_EN_MASK);\n\n\t\t/* PC synchronised to DAI */\n\t\tsnd_soc_update_bits(codec, DA7213_PC_COUNT,\n\t\t\t\t    DA7213_PC_FREERUN_MASK, 0);\n\n\t\t/* If SRM not enabled then nothing more to do */\n\t\tpll_ctrl = snd_soc_read(codec, DA7213_PLL_CTRL);\n\t\tif (!(pll_ctrl & DA7213_PLL_SRM_EN))\n\t\t\treturn 0;\n\n\t\t/* Assist 32KHz mode PLL lock */\n\t\tif (pll_ctrl & DA7213_PLL_32K_MODE) {\n	f
21644	731	cx25821_audio_initdev	drivers/media/pci/cx25821/cx25821-alsa.c	cx25821_audio_initdev_$card$obj$9	0	13	\N	\N	\tstruct snd_card *card;\n\tstruct cx25821_audio_dev *chip;\n\tint err;\n\n\tif (devno >= SNDRV_CARDS) {\n\t\tpr_info("DEBUG ERROR: devno >= SNDRV_CARDS %s\\n", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!enable[devno]) {\n\t\t++devno;\n\t\tpr_info("DEBUG ERROR: !enable[devno] %s\\n", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&dev->pci->dev, index[devno], id[devno],\n\t\t\t   THIS_MODULE,\n\t\t\t   sizeof(struct cx25821_audio_dev), &card);\n\tif (err < 0) {\n\t\tpr_info("DEBUG ERROR: cannot create snd_card_new in %s\\n",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, "cx25821");\n\n\t/* Card "creation" */\n\tchip = card->private_data;\n	f
36500	665	xfs_setattr_nonsize	fs/xfs/xfs_iops.c	error	1	13	\N	\N	\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n	f
39719	435	snd_tea575x_s_hw_freq_seek	drivers/media/radio/tea575x.c	freq	1	13	\N	\N	\tunsigned long timeout;\n\tint i, spacing;\n\n\tif (tea->cannot_read_data)\n\t\treturn -ENOTTY;\n\tif (a->tuner || a->wrap_around)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tif (a->rangelow || a->rangehigh) {\n\t\tfor (i = 0; i < ARRAY_SIZE(bands); i++) {\n\t\t\tif ((i == BAND_FM && tea->tea5759) ||\n\t\t\t    (i == BAND_FM_JAPAN && !tea->tea5759) ||\n\t\t\t    (i == BAND_AM && !tea->has_am))\n\t\t\t\tcontinue;\n\t\t\tif (bands[i].rangelow  == a->rangelow &&\n\t\t\t    bands[i].rangehigh == a->rangehigh)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(bands))\n\t\t\treturn -EINVAL; /* No matching band found */\n\t\tif (i != tea->band) {\n\t\t\ttea->band = i;\n\t\t\ttea->freq = clamp(tea->freq, bands[i].rangelow,\n\t\t\t\t\t\t     bands[i].rangehigh);\n\t\t\tsnd_tea575x_set_freq(tea);\n\t\t}\n\t}\n\n\tspacing = (tea->band == BAND_AM) ? 5 : 50; /* kHz */\n\n\t/* clear the frequency, HW will fill it in */\n\ttea->val &= ~TEA575X_BIT_FREQ_MASK;\n\ttea->val |= TEA575X_BIT_SEARCH;\n\tif (a->seek_upward)\n\t\ttea->val |= TEA575X_BIT_UPDOWN;\n\telse\n\t\ttea->val &= ~TEA575X_BIT_UPDOWN;\n\tsnd_tea575x_write(tea, tea->val);\n\ttimeout = jiffies + msecs_to_jiffies(10000);\n\tfor (;;) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(msecs_to_jiffies(10))) {\n\t\t\t/* some signal arrived, stop search */\n\t\t\ttea->val &= ~TEA575X_BIT_SEARCH;\n\t\t\tsnd_tea575x_set_freq(tea);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tif (!(snd_tea575x_read(tea) & TEA575X_BIT_SEARCH)) {\n\t\t\tu32 freq;\n\n\t\t\t/* Found a frequency, wait until it can be read */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tmsleep(10);\n\t\t\t\tfreq = snd_tea575x_get_freq(tea);\n\t\t\t\tif (freq) /* available */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (freq == 0) /* shouldn't happen */\n	f
6992	7101	bnx2x_ext_phy_10G_an_resolve	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	val	1	13	\N	\N	\tu16 val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tif (val & (1<<5))\n	f
8820	3136	raw_cmd_copyin	drivers/block/floppy.c	ptr->cmd_count	1	13	\N	\N	\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n	f
40230	414	sja1000_err	drivers/net/can/sja1000/sja1000.c	cf->can_id	1	13	\N	\N	\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state state = priv->can.state;\n\tenum can_state rx_state, tx_state;\n\tunsigned int rxerr, txerr;\n\tuint8_t ecc, alc;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\ttxerr = priv->read_reg(priv, SJA1000_TXERR);\n\trxerr = priv->read_reg(priv, SJA1000_RXERR);\n\n\tcf->data[6] = txerr;\n\tcf->data[7] = rxerr;\n\n\tif (isrc & IRQ_DOI) {\n\t\t/* data overrun interrupt */\n\t\tnetdev_dbg(dev, "data overrun interrupt\\n");\n\t\tcf->can_id |= CAN_ERR_CRTL;\n	f
28859	2607	stv090x_get_sig_params	drivers/media/dvb-frontends/stv090x.c	tmg	1	13	\N	\N	\tstruct dvb_frontend *fe = &state->frontend;\n\n\tu8 tmg;\n\tu32 reg;\n\ts32 i = 0, offst_freq;\n\n\tmsleep(5);\n\n\tif (state->algo == STV090x_BLIND_SEARCH) {\n\t\ttmg = STV090x_READ_DEMOD(state, TMGREG2);\n\t\tSTV090x_WRITE_DEMOD(state, SFRSTEP, 0x5c);\n\t\twhile ((i <= 50) && (tmg != 0) && (tmg != 0xff)) {\n	f
31841	2549	intel_dp_sink_dpms	drivers/gpu/drm/i915/intel_dp.c	ret	1	13	\N	\N	\tint ret, i;\n\n\t/* Should have a valid DPCD by this point */\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (mode != DRM_MODE_DPMS_ON) {\n\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER,\n\t\t\t\t\t DP_SET_POWER_D3);\n\t} else {\n\t\tstruct intel_lspcon *lspcon = dp_to_lspcon(intel_dp);\n\n\t\t/*\n\t\t * When turning on, we need to retry for 1ms to give the sink\n\t\t * time to wake up.\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER,\n\t\t\t\t\t\t DP_SET_POWER_D0);\n\t\t\tif (ret == 1)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (ret == 1 && lspcon->active)\n	f
59380	51	i915_vma_retire	drivers/gpu/drm/i915/i915_vma.c	i915_vma_retire_$__ret_warn_on$obj	0	13	\N	\N	\tconst unsigned int idx = rq->engine->id;\n\tstruct i915_vma *vma =\n\t\tcontainer_of(active, struct i915_vma, last_read[idx]);\n\tstruct drm_i915_gem_object *obj = vma->obj;\n\n\tGEM_BUG_ON(!i915_vma_has_active_engine(vma, idx));\n\n\ti915_vma_clear_active(vma, idx);\n\tif (i915_vma_is_active(vma))\n\t\treturn;\n\n\tGEM_BUG_ON(!drm_mm_node_allocated(&vma->node));\n\tlist_move_tail(&vma->vm_link, &vma->vm->inactive_list);\n\tif (unlikely(i915_vma_is_closed(vma) && !i915_vma_is_pinned(vma)))\n\t\tWARN_ON(i915_vma_unbind(vma));\n	f
9503	1217	ccp_run_xts_aes_cmd	drivers/crypto/ccp/ccp-ops.c	&key	1	13	\N	\N	\tstruct ccp_xts_aes_engine *xts = &cmd->u.xts;\n\tstruct ccp_dm_workarea key, ctx;\n\tstruct ccp_data src, dst;\n\tstruct ccp_op op;\n\tunsigned int unit_size, dm_offset;\n\tbool in_place = false;\n\tunsigned int sb_count;\n\tenum ccp_aes_type aestype;\n\tint ret;\n\n\tswitch (xts->unit_size) {\n\tcase CCP_XTS_AES_UNIT_SIZE_16:\n\t\tunit_size = 16;\n\t\tbreak;\n\tcase CCP_XTS_AES_UNIT_SIZE_512:\n\t\tunit_size = 512;\n\t\tbreak;\n\tcase CCP_XTS_AES_UNIT_SIZE_1024:\n\t\tunit_size = 1024;\n\t\tbreak;\n\tcase CCP_XTS_AES_UNIT_SIZE_2048:\n\t\tunit_size = 2048;\n\t\tbreak;\n\tcase CCP_XTS_AES_UNIT_SIZE_4096:\n\t\tunit_size = 4096;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (xts->key_len == AES_KEYSIZE_128)\n\t\taestype = CCP_AES_TYPE_128;\n\telse if (xts->key_len == AES_KEYSIZE_256)\n\t\taestype = CCP_AES_TYPE_256;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!xts->final && (xts->src_len & (AES_BLOCK_SIZE - 1)))\n\t\treturn -EINVAL;\n\n\tif (xts->iv_len != AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!xts->key || !xts->iv || !xts->src || !xts->dst)\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(CCP_XTS_AES_KEY_SB_COUNT != 1);\n\tBUILD_BUG_ON(CCP_XTS_AES_CTX_SB_COUNT != 1);\n\n\tret = -EIO;\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = CCP_NEW_JOBID(cmd_q->ccp);\n\top.sb_key = cmd_q->sb_key;\n\top.sb_ctx = cmd_q->sb_ctx;\n\top.init = 1;\n\top.u.xts.type = aestype;\n\top.u.xts.action = xts->action;\n\top.u.xts.unit_size = xts->unit_size;\n\n\t/* A version 3 device only supports 128-bit keys, which fits into a\n\t * single SB entry. A version 5 device uses a 512-bit vector, so two\n\t * SB entries.\n\t */\n\tif (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0))\n\t\tsb_count = CCP_XTS_AES_KEY_SB_COUNT;\n\telse\n\t\tsb_count = CCP5_XTS_AES_KEY_SB_COUNT;\n\tret = ccp_init_dm_workarea(&key, cmd_q,\n\t\t\t\t   sb_count * CCP_SB_BYTES,\n\t\t\t\t   DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0)) {\n\t\t/* All supported key sizes must be in little endian format.\n\t\t * Use the 256-bit byte swap passthru option to convert from\n\t\t * big endian to little endian.\n\t\t */\n\t\tdm_offset = CCP_SB_BYTES - AES_KEYSIZE_128;\n\t\tccp_set_dm_area(&key, dm_offset, xts->key, 0, xts->key_len);\n\t\tccp_set_dm_area(&key, 0, xts->key, xts->key_len, xts->key_len);\n\t} else {\n\t\t/* Version 5 CCPs use a 512-bit space for the key: each portion\n\t\t * occupies 256 bits, or one entire slot, and is zero-padded.\n\t\t */\n\t\tunsigned int pad;\n\n\t\tdm_offset = CCP_SB_BYTES;\n\t\tpad = dm_offset - xts->key_len;\n\t\tccp_set_dm_area(&key, pad, xts->key, 0, xts->key_len);\n\t\tccp_set_dm_area(&key, dm_offset + pad, xts->key, xts->key_len,\n\t\t\t\txts->key_len);\n\t}\n\tret = ccp_copy_to_sb(cmd_q, &key, op.jobid, op.sb_key,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_key;\n\t}\n\n\t/* The AES context fits in a single (32-byte) SB entry and\n\t * for XTS is already in little endian format so no byte swapping\n\t * is needed.\n\t */\n\tret = ccp_init_dm_workarea(&ctx, cmd_q,\n\t\t\t\t   CCP_XTS_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto e_key;\n\n\tccp_set_dm_area(&ctx, 0, xts->iv, 0, xts->iv_len);\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_NOOP);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_ctx;\n\t}\n\n\t/* Prepare the input and output data workareas. For in-place\n\t * operations we need to set the dma direction to BIDIRECTIONAL\n\t * and copy the src workarea to the dst workarea.\n\t */\n\tif (sg_virt(xts->src) == sg_virt(xts->dst))\n\t\tin_place = true;\n\n\tret = ccp_init_data(&src, cmd_q, xts->src, xts->src_len,\n\t\t\t    unit_size,\n\t\t\t    in_place ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\n\tif (ret)\n\t\tgoto e_ctx;\n\n\tif (in_place) {\n\t\tdst = src;\n\t} else {\n\t\tret = ccp_init_data(&dst, cmd_q, xts->dst, xts->src_len,\n\t\t\t\t    unit_size, DMA_FROM_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_src;\n\t}\n\n\t/* Send data to the CCP AES engine */\n\twhile (src.sg_wa.bytes_left) {\n\t\tccp_prepare_data(&src, &dst, &op, unit_size, true);\n\t\tif (!src.sg_wa.bytes_left)\n\t\t\top.eom = 1;\n\n\t\tret = cmd_q->ccp->vdata->perform->xts_aes(&op);\n\t\tif (ret) {\n\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\tgoto e_dst;\n\t\t}\n\n\t\tccp_process_data(&src, &dst, &op);\n\t}\n\n\t/* Retrieve the AES context - convert from LE to BE using\n\t * 32-byte (256-bit) byteswapping\n\t */\n\tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_dst;\n\t}\n\n\t/* ...but we only need AES_BLOCK_SIZE bytes */\n\tdm_offset = CCP_SB_BYTES - AES_BLOCK_SIZE;\n\tccp_get_dm_area(&ctx, dm_offset, xts->iv, 0, xts->iv_len);\n\ne_dst:\n\tif (!in_place)\n\t\tccp_free_data(&dst, cmd_q);\n\ne_src:\n\tccp_free_data(&src, cmd_q);\n\ne_ctx:\n\tccp_dm_free(&ctx);\n\ne_key:\n\tccp_dm_free(&key);\n	f
22346	1519	xfs_dialloc_ag_update_inobt	fs/xfs/libxfs/xfs_ialloc.c	i	1	13	\N	\N	\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(cur->bc_mp, i == 1);\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(cur->bc_mp, i == 1);\n	f
25878	1368	mtk_pctrl_init	drivers/pinctrl/mediatek/pinctrl-mtk-common.c	node	1	13	\N	\N	\tstruct pinctrl_pin_desc *pins;\n\tstruct mtk_pinctrl *pctl;\n\tstruct device_node *np = pdev->dev.of_node, *node;\n\tstruct property *prop;\n\tstruct resource *res;\n\tint i, ret, irq, ports_buf;\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\tprop = of_find_property(np, "pins-are-numbered", NULL);\n\tif (!prop) {\n\t\tdev_err(&pdev->dev, "only support pins-are-numbered format\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tnode = of_parse_phandle(np, "mediatek,pctl-regmap", 0);\n\tif (node) {\n	f
33382	198	userio_char_write	drivers/input/serio/userio.c	cmd.type	1	13	\N	\N	\tstruct userio_device *userio = file->private_data;\n\tstruct userio_cmd cmd;\n\tint error;\n\n\tif (count != sizeof(cmd)) {\n\t\tdev_warn(userio_misc.this_device, "Invalid payload size\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cmd, buffer, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\terror = mutex_lock_interruptible(&userio->mutex);\n\tif (error)\n\t\treturn error;\n\n\tswitch (cmd.type) {\n	f
36516	860	mtdchar_ioctl	drivers/mtd/mtdchar.c	einfo.length	1	13	\N	\N	\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret = 0;\n\tu_long size;\n\tstruct mtd_info_user info;\n\n\tpr_debug("MTD_ioctl\\n");\n\n\tsize = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;\n\tif (cmd & IOC_IN) {\n\t\tif (!access_ok(VERIFY_READ, argp, size))\n\t\t\treturn -EFAULT;\n\t}\n\tif (cmd & IOC_OUT) {\n\t\tif (!access_ok(VERIFY_WRITE, argp, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase MEMGETREGIONCOUNT:\n\t\tif (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase MEMGETREGIONINFO:\n\t{\n\t\tuint32_t ur_idx;\n\t\tstruct mtd_erase_region_info *kr;\n\t\tstruct region_info_user __user *ur = argp;\n\n\t\tif (get_user(ur_idx, &(ur->regionindex)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ur_idx >= mtd->numeraseregions)\n\t\t\treturn -EINVAL;\n\n\t\tkr = &(mtd->eraseregions[ur_idx]);\n\n\t\tif (put_user(kr->offset, &(ur->offset))\n\t\t    || put_user(kr->erasesize, &(ur->erasesize))\n\t\t    || put_user(kr->numblocks, &(ur->numblocks)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase MEMGETINFO:\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.type\t= mtd->type;\n\t\tinfo.flags\t= mtd->flags;\n\t\tinfo.size\t= mtd->size;\n\t\tinfo.erasesize\t= mtd->erasesize;\n\t\tinfo.writesize\t= mtd->writesize;\n\t\tinfo.oobsize\t= mtd->oobsize;\n\t\t/* The below field is obsolete */\n\t\tinfo.padding\t= 0;\n\t\tif (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase MEMERASE:\n\tcase MEMERASE64:\n\t{\n\t\tstruct erase_info *erase;\n\n\t\tif(!(file->f_mode & FMODE_WRITE))\n\t\t\treturn -EPERM;\n\n\t\terase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);\n\t\tif (!erase)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\twait_queue_head_t waitq;\n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\tinit_waitqueue_head(&waitq);\n\n\t\t\tif (cmd == MEMERASE64) {\n\t\t\t\tstruct erase_info_user64 einfo64;\n\n\t\t\t\tif (copy_from_user(&einfo64, argp,\n\t\t\t\t\t    sizeof(struct erase_info_user64))) {\n\t\t\t\t\tkfree(erase);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\terase->addr = einfo64.start;\n\t\t\t\terase->len = einfo64.length;\n\t\t\t} else {\n\t\t\t\tstruct erase_info_user einfo32;\n\n\t\t\t\tif (copy_from_user(&einfo32, argp,\n\t\t\t\t\t    sizeof(struct erase_info_user))) {\n\t\t\t\t\tkfree(erase);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\terase->addr = einfo32.start;\n\t\t\t\terase->len = einfo32.length;\n\t\t\t}\n\t\t\terase->mtd = mtd;\n\t\t\terase->callback = mtdchar_erase_callback;\n\t\t\terase->priv = (unsigned long)&waitq;\n\n\t\t\t/*\n\t\t\t  FIXME: Allow INTERRUPTIBLE. Which means\n\t\t\t  not having the wait_queue head on the stack.\n\n\t\t\t  If the wq_head is on the stack, and we\n\t\t\t  leave because we got interrupted, then the\n\t\t\t  wq_head is no longer there when the\n\t\t\t  callback routine tries to wake us up.\n\t\t\t*/\n\t\t\tret = mtd_erase(mtd, erase);\n\t\t\tif (!ret) {\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tadd_wait_queue(&waitq, &wait);\n\t\t\t\tif (erase->state != MTD_ERASE_DONE &&\n\t\t\t\t    erase->state != MTD_ERASE_FAILED)\n\t\t\t\t\tschedule();\n\t\t\t\tremove_wait_queue(&waitq, &wait);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\n\t\t\t\tret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;\n\t\t\t}\n\t\t\tkfree(erase);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase MEMWRITEOOB:\n\t{\n\t\tstruct mtd_oob_buf buf;\n\t\tstruct mtd_oob_buf __user *buf_user = argp;\n\n\t\t/* NOTE: writes return length to buf_user->length */\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\n\t\t\t\tbuf.ptr, &buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMREADOOB:\n\t{\n\t\tstruct mtd_oob_buf buf;\n\t\tstruct mtd_oob_buf __user *buf_user = argp;\n\n\t\t/* NOTE: writes return length to buf_user->start */\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_readoob(file, mtd, buf.start, buf.length,\n\t\t\t\tbuf.ptr, &buf_user->start);\n\t\tbreak;\n\t}\n\n\tcase MEMWRITEOOB64:\n\t{\n\t\tstruct mtd_oob_buf64 buf;\n\t\tstruct mtd_oob_buf64 __user *buf_user = argp;\n\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\n\t\t\t\t(void __user *)(uintptr_t)buf.usr_ptr,\n\t\t\t\t&buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMREADOOB64:\n\t{\n\t\tstruct mtd_oob_buf64 buf;\n\t\tstruct mtd_oob_buf64 __user *buf_user = argp;\n\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_readoob(file, mtd, buf.start, buf.length,\n\t\t\t\t(void __user *)(uintptr_t)buf.usr_ptr,\n\t\t\t\t&buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMWRITE:\n\t{\n\t\tret = mtdchar_write_ioctl(mtd,\n\t\t      (struct mtd_write_req __user *)arg);\n\t\tbreak;\n\t}\n\n\tcase MEMLOCK:\n\t{\n\t\tstruct erase_info_user einfo;\n\n\t\tif (copy_from_user(&einfo, argp, sizeof(einfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = mtd_lock(mtd, einfo.start, einfo.length);\n	f
44848	2741	ath_tx_edma_tasklet	drivers/net/wireless/ath/ath9k/xmit.c	ts.qid	1	13	\N	\N	\tstruct ath_tx_status ts;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_txq *txq;\n\tstruct ath_buf *bf, *lastbf;\n\tstruct list_head bf_head;\n\tstruct list_head *fifo_list;\n\tint status;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\n\t\t\tbreak;\n\n\t\tstatus = ath9k_hw_txprocdesc(ah, NULL, (void *)&ts);\n\t\tif (status == -EINPROGRESS)\n\t\t\tbreak;\n\t\tif (status == -EIO) {\n\t\t\tath_dbg(common, XMIT, "Error processing tx status\\n");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Process beacon completions separately */\n\t\tif (ts.qid == sc->beacon.beaconq) {\n	f
55860	1464	debugfs_u64_set	drivers/edac/pnd2_edac.c	&daddr	1	13	\N	\N	\tstruct dram_addr daddr;\n\tstruct mce m;\n\n\t*(u64 *)data = val;\n\tm.mcgstatus = 0;\n\t/* ADDRV + MemRd + Unknown channel */\n\tm.status = MCI_STATUS_ADDRV + 0x9f;\n\tm.addr = val;\n\tpnd2_mce_output_error(pnd2_mci, &m, &daddr);\n	f
37663	1033	if_spi_init_card	drivers/net/wireless/marvell/libertas/if_spi.c	scratch	1	13	\N	\N	\tstruct lbs_private *priv = card->priv;\n\tint err, i;\n\tu32 scratch;\n\tconst struct firmware *helper = NULL;\n\tconst struct firmware *mainfw = NULL;\n\n\terr = spu_init(card, card->pdata->use_dummy_writes);\n\tif (err)\n\t\tgoto out;\n\terr = spu_get_chip_revision(card, &card->card_id, &card->card_rev);\n\tif (err)\n\t\tgoto out;\n\n\terr = spu_read_u32(card, IF_SPI_SCRATCH_4_REG, &scratch);\n\tif (err)\n\t\tgoto out;\n\tif (scratch == SUCCESSFUL_FW_DOWNLOAD_MAGIC)\n	f
41430	2902	efx_ef10_rx_fini	drivers/net/ethernet/sfc/ef10.c	outlen	1	13	\N	\N	\tMCDI_DECLARE_BUF(inbuf, MC_CMD_FINI_RXQ_IN_LEN);\n\tMCDI_DECLARE_BUF_ERR(outbuf);\n\tstruct efx_nic *efx = rx_queue->efx;\n\tsize_t outlen;\n\tint rc;\n\n\tMCDI_SET_DWORD(inbuf, FINI_RXQ_IN_INSTANCE,\n\t\t       efx_rx_queue_index(rx_queue));\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_FINI_RXQ, inbuf, sizeof(inbuf),\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\n\tif (rc && rc != -EALREADY)\n\t\tgoto fail;\n\n\treturn;\n\nfail:\n\tefx_mcdi_display_error(efx, MC_CMD_FINI_RXQ, MC_CMD_FINI_RXQ_IN_LEN,\n	f
45726	71	v9fs_fid_readpage	fs/9p/vfs_addr.c	err	1	13	\N	\N	\tstruct inode *inode = page->mapping->host;\n\tstruct bio_vec bvec = {.bv_page = page, .bv_len = PAGE_SIZE};\n\tstruct iov_iter to;\n\tint retval, err;\n\n\tp9_debug(P9_DEBUG_VFS, "\\n");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tiov_iter_bvec(&to, ITER_BVEC | READ, &bvec, 1, PAGE_SIZE);\n\n\tretval = p9_client_read(fid, page_offset(page), &to, &err);\n\tif (err) {\n	f
47252	1107	snd_lx6464es_probe	sound/pci/lx6464es/lx6464es.c	chip->irq	1	13	\N	\N	\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct lx6464es *chip;\n\tint err;\n\n\tdev_dbg(&pci->dev, "->snd_lx6464es_probe\\n");\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_lx6464es_create(card, pci, &chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, "error during snd_lx6464es_create\\n");\n\t\tgoto out_free;\n\t}\n\n\tstrcpy(card->driver, "LX6464ES");\n\tsprintf(card->id, "LX6464ES_%02X%02X%02X",\n\t\tchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\n\n\tsprintf(card->shortname, "LX6464ES %02X.%02X.%02X.%02X.%02X.%02X",\n\t\tchip->mac_address[0], chip->mac_address[1], chip->mac_address[2],\n\t\tchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\n\n\tsprintf(card->longname, "%s at 0x%lx, 0x%p, irq %i",\n\t\tcard->shortname, chip->port_plx,\n\t\tchip->port_dsp_bar, chip->irq);\n	f
48137	1038	ttusb_dec_start_ts_feed	drivers/media/usb/ttusb-dec/ttusb_dec.c	result	1	13	\N	\N	\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ttusb_dec *dec = dvbdmx->priv;\n\tu8 b0[] = { 0x05 };\n\tint result = 0;\n\n\tdprintk("%s\\n", __func__);\n\n\tdprintk("  ts_type:");\n\n\tif (dvbdmxfeed->ts_type & TS_DECODER)\n\t\tdprintk(" TS_DECODER");\n\n\tif (dvbdmxfeed->ts_type & TS_PACKET)\n\t\tdprintk(" TS_PACKET");\n\n\tif (dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)\n\t\tdprintk(" TS_PAYLOAD_ONLY");\n\n\tdprintk("\\n");\n\n\tswitch (dvbdmxfeed->pes_type) {\n\n\tcase DMX_PES_VIDEO:\n\t\tdprintk("  pes_type: DMX_PES_VIDEO\\n");\n\t\tdec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\n\t\tdec->pid[DMX_PES_VIDEO] = dvbdmxfeed->pid;\n\t\tdec->video_filter = dvbdmxfeed->filter;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_AUDIO:\n\t\tdprintk("  pes_type: DMX_PES_AUDIO\\n");\n\t\tdec->pid[DMX_PES_AUDIO] = dvbdmxfeed->pid;\n\t\tdec->audio_filter = dvbdmxfeed->filter;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_TELETEXT:\n\t\tdec->pid[DMX_PES_TELETEXT] = dvbdmxfeed->pid;\n\t\tdprintk("  pes_type: DMX_PES_TELETEXT(not supported)\\n");\n\t\treturn -ENOSYS;\n\n\tcase DMX_PES_PCR:\n\t\tdprintk("  pes_type: DMX_PES_PCR\\n");\n\t\tdec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_OTHER:\n\t\tdprintk("  pes_type: DMX_PES_OTHER(not supported)\\n");\n\t\treturn -ENOSYS;\n\n\tdefault:\n\t\tdprintk("  pes_type: unknown (%d)\\n", dvbdmxfeed->pes_type);\n\t\treturn -EINVAL;\n\n\t}\n\n\tresult = ttusb_dec_send_command(dec, 0x80, sizeof(b0), b0, NULL, NULL);\n\tif (result)\n	f
50943	302	add_beep_ctls	sound/pci/hda/patch_via.c	kctl	1	13	\N	\N	\tstruct via_spec *spec = codec->spec;\n\tint err;\n\n\tif (spec->beep_amp) {\n\t\tconst struct snd_kcontrol_new *knew;\n\t\tfor (knew = cxt_beep_mixer; knew->name; knew++) {\n\t\t\tstruct snd_kcontrol *kctl;\n\t\t\tkctl = snd_ctl_new1(knew, codec);\n\t\t\tif (!kctl)\n	f
55812	528	assume_stream_formats	sound/firewire/oxfw/oxfw-stream.c	formation.rate	1	13	\N	\N	\tstruct snd_oxfw_stream_formation formation;\n\tunsigned int i, eid;\n\tint err;\n\n\t/* get format at current sampling rate */\n\terr = avc_stream_get_format_single(oxfw->unit, dir, pid, buf, len);\n\tif (err < 0) {\n\t\tdev_err(&oxfw->unit->device,\n\t\t"fail to get current stream format for isoc %s plug %d:%d\\n",\n\t\t\t(dir == AVC_GENERAL_PLUG_DIR_IN) ? "in" : "out",\n\t\t\tpid, err);\n\t\tgoto end;\n\t}\n\n\t/* parse and set stream format */\n\teid = 0;\n\terr = snd_oxfw_stream_parse_format(buf, &formation);\n\tif (err < 0)\n\t\tgoto end;\n\n\tformats[eid] = kmemdup(buf, *len, GFP_KERNEL);\n\tif (formats[eid] == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t/* apply the format for each available sampling rate */\n\tfor (i = 0; i < ARRAY_SIZE(oxfw_rate_table); i++) {\n\t\tif (formation.rate == oxfw_rate_table[i])\n	f
62359	878	at76_set_preamble	drivers/net/wireless/atmel/at76c50x-usb.c	ret	1	13	\N	\N	\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_LOCAL;\n\tpriv->mib_buf.size = 1;\n\tpriv->mib_buf.index = offsetof(struct mib_local, preamble_type);\n\tpriv->mib_buf.data.byte = type;\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n	f
36800	505	sun4i_can_rx	drivers/net/can/sun4i_can.c	skb	1	13	\N	\N	\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu8 fi;\n\tu32 dreg;\n\tcanid_t id;\n\tint i;\n\n\t/* create zero'ed CAN frame buffer */\n\tskb = alloc_can_skb(dev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tfi = readl(priv->base + SUN4I_REG_BUF0_ADDR);\n\tcf->can_dlc = get_can_dlc(fi & 0x0F);\n\tif (fi & SUN4I_MSG_EFF_FLAG) {\n\t\tdreg = SUN4I_REG_BUF5_ADDR;\n\t\tid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 21) |\n\t\t     (readl(priv->base + SUN4I_REG_BUF2_ADDR) << 13) |\n\t\t     (readl(priv->base + SUN4I_REG_BUF3_ADDR) << 5)  |\n\t\t    ((readl(priv->base + SUN4I_REG_BUF4_ADDR) >> 3)  & 0x1f);\n\t\tid |= CAN_EFF_FLAG;\n\t} else {\n\t\tdreg = SUN4I_REG_BUF3_ADDR;\n\t\tid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 3) |\n\t\t    ((readl(priv->base + SUN4I_REG_BUF2_ADDR) >> 5) & 0x7);\n\t}\n\n\t/* remote frame ? */\n\tif (fi & SUN4I_MSG_RTR_FLAG)\n\t\tid |= CAN_RTR_FLAG;\n\telse\n\t\tfor (i = 0; i < cf->can_dlc; i++)\n\t\t\tcf->data[i] = readl(priv->base + dreg + i * 4);\n\n\tcf->can_id = id;\n\n\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_RELEASE_RBUF);\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n\tnetif_rx(skb);\n	f
8095	118	memory_bm_clear_bit	kernel/power/snapshot.c	memory_bm_clear_bit_$nr.addr.i$obj	0	13	\N	\N	\timage_size = ((totalram_pages * 2) / 5) * PAGE_SIZE;\n}\n\n/*\n * List of PBEs needed for restoring the pages that were allocated before\n * the suspend and included in the suspend image, but have also been\n * allocated by the "resume" kernel, so their contents cannot be written\n * directly to their "original" page frames.\n */\nstruct pbe *restore_pblist;\n\n/* struct linked_page is used to build chains of pages */\n\n	f
48939	379	mv88e6xxx_g1_irq_setup	drivers/net/dsa/mv88e6xxx/chip.c	mask	1	13	\N	\N	\tint err, irq, virq;\n\tu16 reg, mask;\n\n\tchip->g1_irq.nirqs = chip->info->g1_irqs;\n\tchip->g1_irq.domain = irq_domain_add_simple(\n\t\tNULL, chip->g1_irq.nirqs, 0,\n\t\t&mv88e6xxx_g1_irq_domain_ops, chip);\n\tif (!chip->g1_irq.domain)\n\t\treturn -ENOMEM;\n\n\tfor (irq = 0; irq < chip->g1_irq.nirqs; irq++)\n\t\tirq_create_mapping(chip->g1_irq.domain, irq);\n\n\tchip->g1_irq.chip = mv88e6xxx_g1_irq_chip;\n\tchip->g1_irq.masked = ~0;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_CTL1, &mask);\n\tif (err)\n\t\tgoto out_mapping;\n\n\tmask &= ~GENMASK(chip->g1_irq.nirqs, 0);\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);\n	f
49280	3934	intel_dp_sink_crc_start	drivers/gpu/drm/i915/intel_dp.c	buf	1	13	\N	\N	\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(dig_port->base.base.crtc);\n\tu8 buf;\n\tint ret;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK_MISC, &buf) < 0)\n\t\treturn -EIO;\n\n\tif (!(buf & DP_TEST_CRC_SUPPORTED))\n\t\treturn -ENOTTY;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK, &buf) < 0)\n\t\treturn -EIO;\n\n\tif (buf & DP_TEST_SINK_START) {\n	f
52100	100	dtt200u_fe_read_signal_strength	drivers/media/usb/dvb-usb/dtt200u-fe.c	ret	1	13	\N	\N	\tstruct dtt200u_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tmutex_lock(&state->data_mutex);\n\tstate->data[0] = GET_AGC;\n\n\tret = dvb_usb_generic_rw(state->d, state->data, 1, state->data, 1, 0);\n\tif (ret >= 0)\n	f
54137	205	ext4_mpage_readpages	fs/ext4/readpage.c	map.m_len	1	13	\N	\N	\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tint length;\n\tunsigned relative_block = 0;\n\tstruct ext4_map_blocks map;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tint fully_mapped = 1;\n\t\tunsigned first_hole = blocks_per_page;\n\n\t\tprefetchw(&page->flags);\n\t\tif (pages) {\n\t\t\tpage = list_entry(pages->prev, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping, page->index,\n\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (page_has_buffers(page))\n\t\t\tgoto confused;\n\n\t\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\t\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\t\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\t\tif (last_block > last_block_in_file)\n\t\t\tlast_block = last_block_in_file;\n\t\tpage_block = 0;\n\n\t\t/*\n\t\t * Map blocks using the previous result first.\n\t\t */\n\t\tif ((map.m_flags & EXT4_MAP_MAPPED) &&\n\t\t    block_in_file > map.m_lblk &&\n\t\t    block_in_file < (map.m_lblk + map.m_len)) {\n\t\t\tunsigned map_offset = block_in_file - map.m_lblk;\n\t\t\tunsigned last = map.m_len - map_offset;\n\n\t\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\t\tif (relative_block == last) {\n\t\t\t\t\t/* needed? */\n\t\t\t\t\tmap.m_flags &= ~EXT4_MAP_MAPPED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (page_block == blocks_per_page)\n\t\t\t\t\tbreak;\n\t\t\t\tblocks[page_block] = map.m_pblk + map_offset +\n\t\t\t\t\trelative_block;\n\t\t\t\tpage_block++;\n\t\t\t\tblock_in_file++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Then do more ext4_map_blocks() calls until we are\n\t\t * done with this page.\n\t\t */\n\t\twhile (page_block < blocks_per_page) {\n\t\t\tif (block_in_file < last_block) {\n\t\t\t\tmap.m_lblk = block_in_file;\n\t\t\t\tmap.m_len = last_block - block_in_file;\n\n\t\t\t\tif (ext4_map_blocks(NULL, inode, &map, 0) < 0) {\n\t\t\t\tset_error_page:\n\t\t\t\t\tSetPageError(page);\n\t\t\t\t\tzero_user_segment(page, 0,\n\t\t\t\t\t\t\t  PAGE_SIZE);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto next_page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((map.m_flags & EXT4_MAP_MAPPED) == 0) {\n\t\t\t\tfully_mapped = 0;\n\t\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\t\tfirst_hole = page_block;\n\t\t\t\tpage_block++;\n\t\t\t\tblock_in_file++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (first_hole != blocks_per_page)\n\t\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t\t/* Contiguous blocks? */\n\t\t\tif (page_block && blocks[page_block-1] != map.m_pblk-1)\n\t\t\t\tgoto confused;\n\t\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\t\tif (relative_block == map.m_len) {\n	f
48660	501	radeon_dp_mode_valid_helper	drivers/gpu/drm/radeon/atombios_dp.c	dp_clock	1	13	\N	\N	\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *dig_connector;\n\tunsigned dp_clock, dp_lanes;\n\tint ret;\n\n\tif ((mode->clock > 340000) &&\n\t    (!radeon_connector_is_dp12_capable(connector)))\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (!radeon_connector->con_priv)\n\t\treturn MODE_CLOCK_HIGH;\n\tdig_connector = radeon_connector->con_priv;\n\n\tret = radeon_dp_get_dp_link_config(connector, dig_connector->dpcd,\n\t\t\t\t\t   mode->clock,\n\t\t\t\t\t   &dp_lanes,\n\t\t\t\t\t   &dp_clock);\n\tif (ret)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif ((dp_clock == 540000) &&\n	f
53603	1759	snd_es1938_mixer	sound/pci/es1938.c	kctl->private_free	1	13	\N	\N	\tstruct snd_card *card;\n\tunsigned int idx;\n\tint err;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, "ESS Solo-1");\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_es1938_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(&snd_es1938_controls[idx], chip);\n\t\tswitch (idx) {\n\t\t\tcase 0:\n\t\t\t\tchip->master_volume = kctl;\n\t\t\t\tkctl->private_free = snd_es1938_hwv_free;\n	f
-1017	206	bmg160_get_filter	drivers/iio/gyro/bmg160_core.c	bw_bits	2	3	\N	\N	\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint i;\n\tunsigned int bw_bits;\n\n\tret = regmap_read(data->regmap, BMG160_REG_PMU_BW, &bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, "Error reading reg_pmu_bw\\n");\n\t\treturn ret;\n\t}\n\n\t/* Ignore the readonly reserved bit. */\n\tbw_bits &= ~BMG160_REG_PMU_BW_RES;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].bw_bits == bw_bits)\n	f
2379	72	as3722_rtc_read_time	drivers/rtc/rtc-as3722.c	ret	1	13	\N	\N	\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\tstruct as3722 *as3722 = as3722_rtc->as3722;\n\tu8 as_time_array[6];\n\tint ret;\n\n\tret = as3722_block_read(as3722, AS3722_RTC_SECOND_REG,\n\t\t\t6, as_time_array);\n\tif (ret < 0) {\n	f
9467	839	wl128x_is_tcxo_valid	drivers/net/wireless/ti/wl12xx/main.c	tcxo_detection	1	13	\N	\N	\tu16 tcxo_detection;\n\tint ret;\n\n\tret = wl12xx_top_reg_read(wl, TCXO_CLK_DETECT_REG, &tcxo_detection);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (tcxo_detection & TCXO_DET_FAILED)\n	f
24746	6595	load_advanced_binaries	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css.c	&pre_gdc_descr	1	13	\N	\N	\tstruct ia_css_frame_info pre_in_info, gdc_in_info,\n\t\t\t\t post_in_info, post_out_info,\n\t\t\t\t vf_info, *vf_pp_in_info, *pipe_out_info,\n\t\t\t\t *pipe_vf_out_info;\n\tbool need_pp;\n\tbool need_isp_copy = true;\n\tenum ia_css_err err = IA_CSS_SUCCESS;\n\n\tIA_CSS_ENTER_PRIVATE("");\n\n\tassert(pipe != NULL);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE || pipe->mode == IA_CSS_PIPE_ID_COPY);\n\tif (pipe->pipe_settings.capture.pre_isp_binary.info)\n\t\treturn IA_CSS_SUCCESS;\n\tpipe_out_info = &pipe->output_info[0];\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\n\tvf_info = *pipe_vf_out_info;\n\terr = ia_css_util_check_vf_out_info(pipe_out_info, &vf_info);\n\tif (err != IA_CSS_SUCCESS)\n\t\treturn err;\n\tneed_pp = need_capture_pp(pipe);\n\n\tia_css_frame_info_set_format(&vf_info,\n\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_pp) {\n\t\tstruct ia_css_binary_descr capture_pp_descr;\n\n\t\tia_css_pipe_get_capturepp_binarydesc(pipe,\n\t\t\t&capture_pp_descr, &post_out_info, pipe_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&capture_pp_descr,\n\t\t\t\t&pipe->pipe_settings.capture.capture_pp_binary);\n\t\tif (err != IA_CSS_SUCCESS)\n\t\t\treturn err;\n\t} else {\n\t\tpost_out_info = *pipe_out_info;\n\t}\n\n\t/* Post-gdc */\n\t{\n\t\tstruct ia_css_binary_descr post_gdc_descr;\n\n\t\tia_css_pipe_get_post_gdc_binarydesc(pipe,\n\t\t\t&post_gdc_descr, &post_in_info, &post_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&post_gdc_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.post_isp_binary);\n\t\tif (err != IA_CSS_SUCCESS)\n\t\t\treturn err;\n\t}\n\n\t/* Gdc */\n\t{\n\t\tstruct ia_css_binary_descr gdc_descr;\n\n\t\tia_css_pipe_get_gdc_binarydesc(pipe, &gdc_descr, &gdc_in_info,\n\t\t\t       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&gdc_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.anr_gdc_binary);\n\t\tif (err != IA_CSS_SUCCESS)\n\t\t\treturn err;\n\t}\n\tpipe->pipe_settings.capture.anr_gdc_binary.left_padding =\n\t\tpipe->pipe_settings.capture.post_isp_binary.left_padding;\n\n\t/* Pre-gdc */\n\t{\n\t\tstruct ia_css_binary_descr pre_gdc_descr;\n\n\t\tia_css_pipe_get_pre_gdc_binarydesc(pipe, &pre_gdc_descr, &pre_in_info,\n\t\t\t\t   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&pre_gdc_descr,\n	f
60499	676	proc_setattr	fs/proc/base.c	inode	1	13	\N	\N	\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = setattr_prepare(dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n	f
61578	1980	ll_file_ioctl	drivers/staging/lustre/lustre/llite/file.c	lsl.sl_fd	1	13	\N	\N	\tstruct inode\t\t*inode = file_inode(file);\n\tstruct ll_file_data\t*fd = LUSTRE_FPRIVATE(file);\n\tint\t\t\t flags, rc;\n\n\tCDEBUG(D_VFSTRACE, "VFS Op:inode=" DFID "(%p),cmd=%x\\n",\n\t       PFID(ll_inode2fid(inode)), inode, cmd);\n\tll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_IOCTL, 1);\n\n\t/* asm-ppc{,64} declares TCGETS, et. al. as type 't' not 'T' */\n\tif (_IOC_TYPE(cmd) == 'T' || _IOC_TYPE(cmd) == 't') /* tty ioctls */\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase LL_IOC_GETFLAGS:\n\t\t/* Get the current value of the file flags */\n\t\treturn put_user(fd->fd_flags, (int __user *)arg);\n\tcase LL_IOC_SETFLAGS:\n\tcase LL_IOC_CLRFLAGS:\n\t\t/* Set or clear specific file flags */\n\t\t/* XXX This probably needs checks to ensure the flags are\n\t\t *     not abused, and to handle any flag side effects.\n\t\t */\n\t\tif (get_user(flags, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tif (cmd == LL_IOC_SETFLAGS) {\n\t\t\tif ((flags & LL_FILE_IGNORE_LOCK) &&\n\t\t\t    !(file->f_flags & O_DIRECT)) {\n\t\t\t\tCERROR("%s: unable to disable locking on non-O_DIRECT file\\n",\n\t\t\t\t       current->comm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfd->fd_flags |= flags;\n\t\t} else {\n\t\t\tfd->fd_flags &= ~flags;\n\t\t}\n\t\treturn 0;\n\tcase LL_IOC_LOV_SETSTRIPE:\n\t\treturn ll_lov_setstripe(inode, file, arg);\n\tcase LL_IOC_LOV_SETEA:\n\t\treturn ll_lov_setea(inode, file, arg);\n\tcase LL_IOC_LOV_SWAP_LAYOUTS: {\n\t\tstruct file *file2;\n\t\tstruct lustre_swap_layouts lsl;\n\n\t\tif (copy_from_user(&lsl, (char __user *)arg,\n\t\t\t\t   sizeof(struct lustre_swap_layouts)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tfile2 = fget(lsl.sl_fd);\n	f
-1015	160	gfs2_mount_args	fs/gfs2/super.c	&tmp[0]	2	3	\N	\N	\tchar *o;\n\tint token;\n\tsubstring_t tmp[MAX_OPT_ARGS];\n\tint rv;\n\n\t/* Split the options into tokens with the "," character and\n\t   process them */\n\n\twhile (1) {\n\t\to = strsep(&options, ",");\n\t\tif (o == NULL)\n\t\t\tbreak;\n\t\tif (*o == '\\0')\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_lockproto:\n\t\t\tmatch_strlcpy(args->ar_lockproto, &tmp[0],\n	f
-1013	386	pm8xxx_rtc_enable	drivers/rtc/rtc-pm8xxx.c	ctrl_reg	2	3	\N	\N	\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tunsigned int ctrl_reg;\n\tint rc;\n\n\t/* Check if the RTC is on, else turn it on */\n\trc = regmap_read(rtc_dd->regmap, regs->ctrl, &ctrl_reg);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(ctrl_reg & PM8xxx_RTC_ENABLE)) {\n	f
33067	1610	psb_intel_sdvo_get_lvds_modes	drivers/gpu/drm/gma500/psb_intel_sdvo.c	psb_intel_sdvo->sdvo_lvds_fixed_mode	1	13	\N	\N	\tstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\n\tstruct drm_psb_private *dev_priv = connector->dev->dev_private;\n\tstruct drm_display_mode *newmode;\n\n\t/*\n\t * Attempt to get the mode list from DDC.\n\t * Assume that the preferred modes are\n\t * arranged in priority order.\n\t */\n\tpsb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);\n\tif (list_empty(&connector->probed_modes) == false)\n\t\tgoto end;\n\n\t/* Fetch modes from VBT */\n\tif (dev_priv->sdvo_lvds_vbt_mode != NULL) {\n\t\tnewmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t     dev_priv->sdvo_lvds_vbt_mode);\n\t\tif (newmode != NULL) {\n\t\t\t/* Guarantee the mode is preferred */\n\t\t\tnewmode->type = (DRM_MODE_TYPE_PREFERRED |\n\t\t\t\t\t DRM_MODE_TYPE_DRIVER);\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t}\n\t}\n\nend:\n\tlist_for_each_entry(newmode, &connector->probed_modes, head) {\n\t\tif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tpsb_intel_sdvo->sdvo_lvds_fixed_mode =\n\t\t\t\tdrm_mode_duplicate(connector->dev, newmode);\n\n\t\t\tdrm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode,\n	f
46611	2420	do_move_mount	fs/namespace.c	&parent_path	1	13	\N	\N	\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n	f
48115	1606	refill_rx_ring	drivers/net/ethernet/adaptec/starfire.c	skb->data	1	13	\N	\N	\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint entry = -1;\n\n\t/* Refill the Rx ring buffers. */\n\tfor (; np->cur_rx - np->dirty_rx > 0; np->dirty_rx++) {\n\t\tentry = np->dirty_rx % RX_RING_SIZE;\n\t\tif (np->rx_info[entry].skb == NULL) {\n\t\t\tskb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\t\tnp->rx_info[entry].skb = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t/* Better luck next round. */\n\t\t\tnp->rx_info[entry].mapping =\n\t\t\t\tpci_map_single(np->pci_dev, skb->data, np->rx_buf_sz, PCI_DMA_FROMDEVICE);\n	f
535	241	lp5521_update_program_memory	drivers/leds/leds-lp5521.c	offset	1	13	\N	\N	\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tu8 pattern[LP5521_PROGRAM_LENGTH] = {0};\n\tstatic const u8 addr[] = {\n\t\t[LP55XX_ENGINE_1] = LP5521_REG_R_PROG_MEM,\n\t\t[LP55XX_ENGINE_2] = LP5521_REG_G_PROG_MEM,\n\t\t[LP55XX_ENGINE_3] = LP5521_REG_B_PROG_MEM,\n\t};\n\tunsigned cmd;\n\tchar c[3];\n\tint nrchars;\n\tint ret;\n\tint offset = 0;\n\tint i = 0;\n\n\twhile ((offset < size - 1) && (i < LP5521_PROGRAM_LENGTH)) {\n	f
924	1015	find_media_headers	drivers/mtd/nand/diskonchip.c	retlen	1	13	\N	\N	\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned offs;\n\tint ret;\n\tsize_t retlen;\n\n\tfor (offs = 0; offs < mtd->size; offs += mtd->erasesize) {\n\t\tret = mtd_read(mtd, offs, mtd->writesize, &retlen, buf);\n\t\tif (retlen != mtd->writesize)\n	f
4642	305	set_fan_pulses	drivers/hwmon/tc654.c	val	1	13	\N	\N	\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 config;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n	f
4699	258	nct7802_read_fan_min	drivers/hwmon/nct7802.c	ret	1	13	\N	\N	\tunsigned int f1, f2;\n\tint ret;\n\n\tmutex_lock(&data->access_lock);\n\tret = regmap_read(data->regmap, reg_fan_low, &f1);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = regmap_read(data->regmap, reg_fan_high, &f2);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = f1 | ((f2 & 0xf8) << 5);\n\t/* convert fan count to rpm */\n\tif (ret == 0x1fff)\t/* maximum value, assume no limit */\n	f
22041	57	rt2x00usb_vendor_request	drivers/net/wireless/ralink/rt2x00/rt2x00usb.c	status	1	13	\N	\N	\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tint status;\n\tunsigned int pipe =\n\t    (requesttype == USB_VENDOR_REQUEST_IN) ?\n\t    usb_rcvctrlpipe(usb_dev, 0) : usb_sndctrlpipe(usb_dev, 0);\n\tunsigned long expire = jiffies + msecs_to_jiffies(timeout);\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn -ENODEV;\n\n\tdo {\n\t\tstatus = usb_control_msg(usb_dev, pipe, request, requesttype,\n\t\t\t\t\t value, offset, buffer, buffer_length,\n\t\t\t\t\t timeout / 2);\n\t\tif (status >= 0)\n	f
26323	88	opp_debug_create_one	drivers/base/power/opp/debugfs.c	d	1	13	\N	\N	\tstruct dentry *pdentry = opp_table->dentry;\n\tstruct dentry *d;\n\tchar name[25];\t/* 20 chars for 64 bit value + 5 (opp:\\0) */\n\n\t/* Rate is unique to each OPP, use it to give opp-name */\n\tsnprintf(name, sizeof(name), "opp:%lu", opp->rate);\n\n\t/* Create per-opp directory */\n\td = debugfs_create_dir(name, pdentry);\n\tif (!d)\n	f
30694	635	C_SYSC_newlstat	fs/stat.c	&stat	1	13	\N	\N	\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_lstat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\treturn cp_compat_stat(&stat, statbuf);\n	f
36883	802	pt3_probe	drivers/media/pci/pt3/pt3.c	ret	1	13	\N	\N	\tu8 rev;\n\tu32 ver;\n\tint i, ret;\n\tstruct pt3_board *pt3;\n\tstruct i2c_adapter *i2c;\n\n\tif (pci_read_config_byte(pdev, PCI_REVISION_ID, &rev) || rev != 1)\n\t\treturn -ENODEV;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, DRV_NAME);\n\tif (ret < 0)\n\t\tgoto err_disable_device;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret == 0)\n\t\tdma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\n\telse {\n\t\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret == 0)\n\t\t\tdma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\telse {\n\t\t\tdev_err(&pdev->dev, "Failed to set DMA mask\\n");\n\t\t\tgoto err_release_regions;\n\t\t}\n\t\tdev_info(&pdev->dev, "Use 32bit DMA\\n");\n\t}\n\n\tpt3 = kzalloc(sizeof(*pt3), GFP_KERNEL);\n\tif (!pt3) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\tpci_set_drvdata(pdev, pt3);\n\tpt3->pdev = pdev;\n\tmutex_init(&pt3->lock);\n\tpt3->regs[0] = pci_ioremap_bar(pdev, 0);\n\tpt3->regs[1] = pci_ioremap_bar(pdev, 2);\n\tif (pt3->regs[0] == NULL || pt3->regs[1] == NULL) {\n\t\tdev_err(&pdev->dev, "Failed to ioremap\\n");\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\n\tver = ioread32(pt3->regs[0] + REG_VERSION);\n\tif ((ver >> 16) != 0x0301) {\n\t\tdev_warn(&pdev->dev, "PT%d, I/F-ver.:%d not supported\\n",\n\t\t\t ver >> 24, (ver & 0x00ff0000) >> 16);\n\t\tret = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\tpt3->num_bufs = clamp_val(num_bufs, MIN_DATA_BUFS, MAX_DATA_BUFS);\n\n\tpt3->i2c_buf = kmalloc(sizeof(*pt3->i2c_buf), GFP_KERNEL);\n\tif (pt3->i2c_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\ti2c = &pt3->i2c_adap;\n\ti2c->owner = THIS_MODULE;\n\ti2c->algo = &pt3_i2c_algo;\n\ti2c->algo_data = NULL;\n\ti2c->dev.parent = &pdev->dev;\n\tstrlcpy(i2c->name, DRV_NAME, sizeof(i2c->name));\n\ti2c_set_adapdata(i2c, pt3);\n\tret = i2c_add_adapter(i2c);\n\tif (ret < 0)\n\t\tgoto err_i2cbuf;\n\n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tret = pt3_alloc_adapter(pt3, i);\n\t\tif (ret < 0)\n	f
8876	845	ethtool_set_settings	net/core/ethtool.c	&cmd)	1	13	\N	\N	\tstruct ethtool_cmd cmd;\n\n\tASSERT_RTNL();\n\n\tif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* first, try new %ethtool_link_ksettings API. */\n\tif (dev->ethtool_ops->set_link_ksettings) {\n\t\tstruct ethtool_link_ksettings link_ksettings;\n\n\t\tif (!convert_legacy_settings_to_link_ksettings(&link_ksettings,\n	f
21830	118	hsdk_reset_probe	drivers/reset/reset-hsdk.c	&rst->rcdev	1	13	\N	\N	\tstruct hsdk_rst *rst;\n\tstruct resource *mem;\n\n\trst = devm_kzalloc(&pdev->dev, sizeof(*rst), GFP_KERNEL);\n\tif (!rst)\n\t\treturn -ENOMEM;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trst->regs_ctl = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(rst->regs_ctl))\n\t\treturn PTR_ERR(rst->regs_ctl);\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\trst->regs_rst = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(rst->regs_rst))\n\t\treturn PTR_ERR(rst->regs_rst);\n\n\tspin_lock_init(&rst->lock);\n\n\trst->rcdev.owner = THIS_MODULE;\n\trst->rcdev.ops = &hsdk_reset_ops;\n\trst->rcdev.of_node = pdev->dev.of_node;\n\trst->rcdev.nr_resets = HSDK_MAX_RESETS;\n\trst->rcdev.of_reset_n_cells = 1;\n\n\treturn reset_controller_register(&rst->rcdev);\n	f
27075	1146	display_store	drivers/platform/x86/asus-laptop.c	value	1	13	\N	\N	\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tasus_set_display(asus, value);\n	f
36934	301	ax88172a_reset	drivers/net/usb/ax88172a.c	rx_ctl	1	13	\N	\N	\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\tint ret;\n\tu16 rx_ctl;\n\n\tax88172a_reset_phy(dev, priv->use_embdphy);\n\n\tmsleep(150);\n\trx_ctl = asix_read_rx_ctl(dev, 0);\n\tnetdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\\n", rx_ctl);\n	f
37522	233	ms_power_off	drivers/memstick/host/rtsx_usb_ms.c	err	1	13	\N	\N	\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\n\tdev_dbg(ms_dev(host), "%s\\n", __func__);\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (err < 0)\n	f
37584	3407	r600_ib_test	drivers/gpu/drm/radeon/r600.c	&ib	1	13	\N	\N	\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR("radeon: failed to get scratch reg (%d).\\n", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\n	f
45978	168	dlm_rcom_status	fs/dlm/rcom.c	mh	1	13	\N	\N	\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n	f
49372	691	__f2fs_tmpfile	fs/f2fs/namei.c	inode->i_ino	1	13	\N	\N	\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (whiteout) {\n\t\tinit_special_inode(inode, inode->i_mode, WHITEOUT_DEV);\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t} else {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t}\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_do_tmpfile(inode, dir);\n\tif (err)\n\t\tgoto release_out;\n\n\t/*\n\t * add this non-linked tmpfile to orphan list, in this way we could\n\t * remove all unused data of tmpfile after abnormal power-off.\n\t */\n\tadd_orphan_inode(inode);\n\talloc_nid_done(sbi, inode->i_ino);\n	f
56732	390	perf_trace_hfi1_sdma_progress	drivers/infiniband/hw/hfi1/trace.c	RCVCTRL	1	13	\N	\N	\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0; i < len ; i++)\n\t\ttrace_seq_printf(p, "%s%#x", i == 0 ? "" : " ", arr[i]);\n\ttrace_seq_putc(p, 0);\n\treturn ret;\n}\n\n__hfi1_trace_fn(PKT);\n__hfi1_trace_fn(PROC);\n__hfi1_trace_fn(SDMA);\n__hfi1_trace_fn(LINKVERB);\n__hfi1_trace_fn(DEBUG);\n__hfi1_trace_fn(SNOOP);\n__hfi1_trace_fn(CNTR);\n__hfi1_trace_fn(PIO);\n__hfi1_trace_fn(DC8051);\n__hfi1_trace_fn(FIRMWARE);\n__hfi1_trace_fn(RCVCTRL);\n	f
55135	245	nf_nat_sip	net/netfilter/nf_nat_sip.c	nf_nat_sip_phi$$n$obj$and$255$shl$8$or$%n$obj$and$65280$ashr$8$	0	13	\N	\N	\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tunsigned int coff, matchoff, matchlen;\n\tenum sip_header_types hdr;\n\tunion nf_inet_addr addr;\n\t__be16 port;\n\tint request, in_header;\n\n\t/* Basic rules: requests and responses. */\n\tif (strncasecmp(*dptr, "SIP/2.0", strlen("SIP/2.0")) != 0) {\n\t\tif (ct_sip_parse_request(ct, *dptr, *datalen,\n\t\t\t\t\t &matchoff, &matchlen,\n\t\t\t\t\t &addr, &port) > 0 &&\n\t\t    !map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      matchoff, matchlen, &addr, port)) {\n\t\t\tnf_ct_helper_log(skb, ct, "cannot mangle SIP message");\n\t\t\treturn NF_DROP;\n\t\t}\n\t\trequest = 1;\n\t} else\n\t\trequest = 0;\n\n\tif (nf_ct_protonum(ct) == IPPROTO_TCP)\n\t\thdr = SIP_HDR_VIA_TCP;\n\telse\n\t\thdr = SIP_HDR_VIA_UDP;\n\n\t/* Translate topmost Via header and parameters */\n\tif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\n\t\t\t\t    hdr, NULL, &matchoff, &matchlen,\n\t\t\t\t    &addr, &port) > 0) {\n\t\tunsigned int olen, matchend, poff, plen, buflen, n;\n\t\tchar buffer[INET6_ADDRSTRLEN + sizeof("[]:nnnnn")];\n\n\t\t/* We're only interested in headers related to this\n\t\t * connection */\n\t\tif (request) {\n\t\t\tif (!nf_inet_addr_cmp(&addr,\n\t\t\t\t\t&ct->tuplehash[dir].tuple.src.u3) ||\n\t\t\t    port != ct->tuplehash[dir].tuple.src.u.udp.port)\n\t\t\t\tgoto next;\n\t\t} else {\n\t\t\tif (!nf_inet_addr_cmp(&addr,\n\t\t\t\t\t&ct->tuplehash[dir].tuple.dst.u3) ||\n\t\t\t    port != ct->tuplehash[dir].tuple.dst.u.udp.port)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tolen = *datalen;\n\t\tif (!map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      matchoff, matchlen, &addr, port)) {\n\t\t\tnf_ct_helper_log(skb, ct, "cannot mangle Via header");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tmatchend = matchoff + matchlen + *datalen - olen;\n\n\t\t/* The maddr= parameter (RFC 2361) specifies where to send\n\t\t * the reply. */\n\t\tif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t       "maddr=", &poff, &plen,\n\t\t\t\t\t       &addr, true) > 0 &&\n\t\t    nf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.src.u3) &&\n\t\t    !nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.dst.u3)) {\n\t\t\tbuflen = sip_sprintf_addr(ct, buffer,\n\t\t\t\t\t&ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t\t\ttrue);\n\t\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t   poff, plen, buffer, buflen)) {\n\t\t\t\tnf_ct_helper_log(skb, ct, "cannot mangle maddr");\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\t/* The received= parameter (RFC 2361) contains the address\n\t\t * from which the server received the request. */\n\t\tif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t       "received=", &poff, &plen,\n\t\t\t\t\t       &addr, false) > 0 &&\n\t\t    nf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.dst.u3) &&\n\t\t    !nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.src.u3)) {\n\t\t\tbuflen = sip_sprintf_addr(ct, buffer,\n\t\t\t\t\t&ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t\t\tfalse);\n\t\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t   poff, plen, buffer, buflen)) {\n\t\t\t\tnf_ct_helper_log(skb, ct, "cannot mangle received");\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\t/* The rport= parameter (RFC 3581) contains the port number\n\t\t * from which the server received the request. */\n\t\tif (ct_sip_parse_numerical_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t\t "rport=", &poff, &plen,\n\t\t\t\t\t\t &n) > 0 &&\n\t\t    htons(n) == ct->tuplehash[dir].tuple.dst.u.udp.port &&\n	f
37620	6004	btrfs_real_readdir	fs/btrfs/inode.c	found_key.type	1	13	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_file_private *private = file->private_data;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tvoid *addr;\n\tstruct list_head ins_list;\n\tstruct list_head del_list;\n\tint ret;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tchar *name_ptr;\n\tint name_len;\n\tint entries = 0;\n\tint total_len = 0;\n\tbool put = false;\n\tstruct btrfs_key location;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\taddr = private->filldir_buf;\n\tpath->reada = READA_FORWARD;\n\n\tINIT_LIST_HEAD(&ins_list);\n\tINIT_LIST_HEAD(&del_list);\n\tput = btrfs_readdir_get_delayed_items(inode, &ins_list, &del_list);\n\nagain:\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = ctx->pos;\n\tkey.objectid = btrfs_ino(BTRFS_I(inode));\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\twhile (1) {\n\t\tstruct dir_entry *entry;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_DIR_INDEX_KEY)\n	f
4073	711	tda8295_probe	drivers/media/tuners/tda8290.c	id	1	13	\N	\N	#define TDA8295_ID 0x8a\n#define TDA8295C2_ID 0x8b\n\tu8 reg = 0x2f, id;\n\tstruct i2c_msg msg_read[] = {\n\t\t{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\n\t};\n\n\t/* detect tda8295 */\n\tif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\n\t\tprintk(KERN_WARNING "%s: couldn't read register 0x%02x\\n",\n\t\t\t       __func__, reg);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((id & 0xfe) == TDA8295_ID) {\n	f
10024	155	proc_ioctl	drivers/usb/core/devio.c	&usbfs_memory_usage	1	13	\N	\N	\tu64 lim;\n\n\tlim = ACCESS_ONCE(usbfs_memory_mb);\n\tlim <<= 20;\n\n	f
62479	1072	pcxhr_open	sound/pci/pcxhr/pcxhr.c	external_rate	1	13	\N	\N	\tstruct snd_pcxhr       *chip = snd_pcm_substream_chip(subs);\n\tstruct pcxhr_mgr       *mgr = chip->mgr;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct pcxhr_stream    *stream;\n\tint err;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\t/* copy the struct snd_pcm_hardware struct */\n\truntime->hw = pcxhr_caps;\n\n\tif( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {\n\t\tdev_dbg(chip->card->dev, "pcxhr_open playback chip%d subs%d\\n",\n\t\t\t    chip->chip_idx, subs->number);\n\t\tstream = &chip->playback_stream[subs->number];\n\t} else {\n\t\tdev_dbg(chip->card->dev, "pcxhr_open capture chip%d subs%d\\n",\n\t\t\t    chip->chip_idx, subs->number);\n\t\tif (mgr->mono_capture)\n\t\t\truntime->hw.channels_max = 1;\n\t\telse\n\t\t\truntime->hw.channels_min = 2;\n\t\tstream = &chip->capture_stream[subs->number];\n\t}\n\tif (stream->status != PCXHR_STREAM_STATUS_FREE){\n\t\t/* streams in use */\n\t\tdev_err(chip->card->dev, "pcxhr_open chip%d subs%d in use\\n",\n\t\t\t   chip->chip_idx, subs->number);\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\t/* float format support is in some cases buggy on stereo cards */\n\tif (mgr->is_hr_stereo)\n\t\truntime->hw.formats &= ~SNDRV_PCM_FMTBIT_FLOAT_LE;\n\n\t/* buffer-size should better be multiple of period-size */\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\treturn err;\n\t}\n\n\t/* if a sample rate is already used or fixed by external clock,\n\t * the stream cannot change\n\t */\n\tif (mgr->sample_rate)\n\t\truntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\n\telse {\n\t\tif (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {\n\t\t\tint external_rate;\n\t\t\tif (pcxhr_get_external_clock(mgr, mgr->use_clock_type,\n\t\t\t\t\t\t     &external_rate) ||\n\t\t\t    external_rate == 0) {\n	f
-1033	1727	ext4_mb_check_limits	fs/ext4/mballoc.c	max	2	3	\N	\N	\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n	f
27936	453	mlx4_ib_query_device	drivers/infiniband/hw/mlx4/main.c	cmd.reserved	1	13	\N	\N	\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tstruct ib_smp *in_mad  = NULL;\n\tstruct ib_smp *out_mad = NULL;\n\tint err;\n\tint have_ib_ports;\n\tstruct mlx4_uverbs_ex_query_device cmd;\n\tstruct mlx4_uverbs_ex_query_device_resp resp = {.comp_mask = 0};\n\tstruct mlx4_clock_params clock_params;\n\n\tif (uhw->inlen) {\n\t\tif (uhw->inlen < sizeof(cmd))\n\t\t\treturn -EINVAL;\n\n\t\terr = ib_copy_from_udata(&cmd, uhw, sizeof(cmd));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (cmd.comp_mask)\n\t\t\treturn -EINVAL;\n\n\t\tif (cmd.reserved)\n	f
31222	251	usbtv_setup_capture	drivers/media/usb/usbtv/usbtv-video.c	ret	1	13	\N	\N	\tint ret;\n\tstatic const u16 setup[][2] = {\n\t\t/* These seem to enable the device. */\n\t\t{ USBTV_BASE + 0x0008, 0x0001 },\n\t\t{ USBTV_BASE + 0x01d0, 0x00ff },\n\t\t{ USBTV_BASE + 0x01d9, 0x0002 },\n\n\t\t/* These seem to influence color parameters, such as\n\t\t * brightness, etc. */\n\t\t{ USBTV_BASE + 0x0239, 0x0040 },\n\t\t{ USBTV_BASE + 0x0240, 0x0000 },\n\t\t{ USBTV_BASE + 0x0241, 0x0000 },\n\t\t{ USBTV_BASE + 0x0242, 0x0002 },\n\t\t{ USBTV_BASE + 0x0243, 0x0080 },\n\t\t{ USBTV_BASE + 0x0244, 0x0012 },\n\t\t{ USBTV_BASE + 0x0245, 0x0090 },\n\t\t{ USBTV_BASE + 0x0246, 0x0000 },\n\n\t\t{ USBTV_BASE + 0x0278, 0x002d },\n\t\t{ USBTV_BASE + 0x0279, 0x000a },\n\t\t{ USBTV_BASE + 0x027a, 0x0032 },\n\t\t{ 0xf890, 0x000c },\n\t\t{ 0xf894, 0x0086 },\n\n\t\t{ USBTV_BASE + 0x00ac, 0x00c0 },\n\t\t{ USBTV_BASE + 0x00ad, 0x0000 },\n\t\t{ USBTV_BASE + 0x00a2, 0x0012 },\n\t\t{ USBTV_BASE + 0x00a3, 0x00e0 },\n\t\t{ USBTV_BASE + 0x00a4, 0x0028 },\n\t\t{ USBTV_BASE + 0x00a5, 0x0082 },\n\t\t{ USBTV_BASE + 0x00a7, 0x0080 },\n\t\t{ USBTV_BASE + 0x0000, 0x0014 },\n\t\t{ USBTV_BASE + 0x0006, 0x0003 },\n\t\t{ USBTV_BASE + 0x0090, 0x0099 },\n\t\t{ USBTV_BASE + 0x0091, 0x0090 },\n\t\t{ USBTV_BASE + 0x0094, 0x0068 },\n\t\t{ USBTV_BASE + 0x0095, 0x0070 },\n\t\t{ USBTV_BASE + 0x009c, 0x0030 },\n\t\t{ USBTV_BASE + 0x009d, 0x00c0 },\n\t\t{ USBTV_BASE + 0x009e, 0x00e0 },\n\t\t{ USBTV_BASE + 0x0019, 0x0006 },\n\t\t{ USBTV_BASE + 0x008c, 0x00ba },\n\t\t{ USBTV_BASE + 0x0101, 0x00ff },\n\t\t{ USBTV_BASE + 0x010c, 0x00b3 },\n\t\t{ USBTV_BASE + 0x01b2, 0x0080 },\n\t\t{ USBTV_BASE + 0x01b4, 0x00a0 },\n\t\t{ USBTV_BASE + 0x014c, 0x00ff },\n\t\t{ USBTV_BASE + 0x014d, 0x00ca },\n\t\t{ USBTV_BASE + 0x0113, 0x0053 },\n\t\t{ USBTV_BASE + 0x0119, 0x008a },\n\t\t{ USBTV_BASE + 0x013c, 0x0003 },\n\t\t{ USBTV_BASE + 0x0150, 0x009c },\n\t\t{ USBTV_BASE + 0x0151, 0x0071 },\n\t\t{ USBTV_BASE + 0x0152, 0x00c6 },\n\t\t{ USBTV_BASE + 0x0153, 0x0084 },\n\t\t{ USBTV_BASE + 0x0154, 0x00bc },\n\t\t{ USBTV_BASE + 0x0155, 0x00a0 },\n\t\t{ USBTV_BASE + 0x0156, 0x00a0 },\n\t\t{ USBTV_BASE + 0x0157, 0x009c },\n\t\t{ USBTV_BASE + 0x0158, 0x001f },\n\t\t{ USBTV_BASE + 0x0159, 0x0006 },\n\t\t{ USBTV_BASE + 0x015d, 0x0000 },\n\n\t\t{ USBTV_BASE + 0x0003, 0x0004 },\n\t\t{ USBTV_BASE + 0x0100, 0x00d3 },\n\t\t{ USBTV_BASE + 0x0115, 0x0015 },\n\t\t{ USBTV_BASE + 0x0220, 0x002e },\n\t\t{ USBTV_BASE + 0x0225, 0x0008 },\n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t};\n\n\tret = usbtv_set_regs(usbtv, setup, ARRAY_SIZE(setup));\n\tif (ret)\n	f
7748	419	bq2415x_detect_chip	drivers/power/supply/bq2415x_charger.c	ret	1	13	\N	\N	\tstruct i2c_client *client = to_i2c_client(bq->dev);\n\tint ret = bq2415x_exec_command(bq, BQ2415X_PART_NUMBER);\n\n\tif (ret < 0)\n	f
37702	6000	xfs_bmse_shift_one	fs/xfs/libxfs/xfs_bmap.c	adj_irec.br_startoff	1	13	\N	\N	\tstruct xfs_ifork\t\t*ifp;\n\tstruct xfs_mount\t\t*mp;\n\txfs_fileoff_t\t\t\tstartoff;\n\tstruct xfs_bmbt_irec\t\tadj_irec, new;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\ttotal_extents;\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\ttotal_extents = xfs_iext_count(ifp);\n\n\t/* delalloc extents should be prevented by caller */\n\tXFS_WANT_CORRUPTED_RETURN(mp, !isnullstartblock(got->br_startblock));\n\n\tif (direction == SHIFT_LEFT) {\n\t\tstartoff = got->br_startoff - offset_shift_fsb;\n\n\t\t/*\n\t\t * Check for merge if we've got an extent to the left,\n\t\t * otherwise make sure there's enough room at the start\n\t\t * of the file for the shift.\n\t\t */\n\t\tif (!*current_ext) {\n\t\t\tif (got->br_startoff < offset_shift_fsb)\n\t\t\t\treturn -EINVAL;\n\t\t\tgoto update_current_ext;\n\t\t}\n\n\t\t/*\n\t\t * grab the left extent and check for a large enough hole.\n\t\t */\n\t\txfs_iext_get_extent(ifp, *current_ext - 1, &adj_irec);\n\t\tif (startoff < adj_irec.br_startoff + adj_irec.br_blockcount)\n	f
42929	1180	e1000_nonintegrated_phy_loopback	drivers/net/ethernet/intel/e1000/e1000_ethtool.c	phy_reg	1	13	\N	\N	\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_reg;\n\tu16 phy_reg;\n\n\t/* Setup the Device Control Register for PHY loopback test. */\n\n\tctrl_reg = er32(CTRL);\n\tctrl_reg |= (E1000_CTRL_ILOS |\t\t/* Invert Loss-Of-Signal */\n\t\t     E1000_CTRL_FRCSPD |\t/* Set the Force Speed Bit */\n\t\t     E1000_CTRL_FRCDPX |\t/* Set the Force Duplex Bit */\n\t\t     E1000_CTRL_SPD_1000 |\t/* Force Speed to 1000 */\n\t\t     E1000_CTRL_FD);\t\t/* Force Duplex to FULL */\n\n\tew32(CTRL, ctrl_reg);\n\n\t/* Read the PHY Specific Control Register (0x10) */\n\te1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);\n\n\t/* Clear Auto-Crossover bits in PHY Specific Control Register\n\t * (bits 6:5).\n\t */\n\tphy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;\n\te1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);\n	f
46136	1166	isdn_ppp_push_higher	drivers/isdn/i4l/isdn_ppp.c	skb->data	1	13	\N	\N	\tstruct net_device *dev = net_dev->dev;\n\tstruct ippp_struct *is, *mis;\n\tisdn_net_local *mlp = NULL;\n\tint slot;\n\n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR "isdn_ppp_push_higher: lp->ppp_slot(%d)\\n",\n\t\t       lp->ppp_slot);\n\t\tgoto drop_packet;\n\t}\n\tis = ippp_table[slot];\n\n\tif (lp->master) { // FIXME?\n\t\tmlp = ISDN_MASTER_PRIV(lp);\n\t\tslot = mlp->ppp_slot;\n\t\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\t\tprintk(KERN_ERR "isdn_ppp_push_higher: master->ppp_slot(%d)\\n",\n\t\t\t       lp->ppp_slot);\n\t\t\tgoto drop_packet;\n\t\t}\n\t}\n\tmis = ippp_table[slot];\n\n\tif (is->debug & 0x10) {\n\t\tprintk(KERN_DEBUG "push, skb %d %04x\\n", (int) skb->len, proto);\n\t\tisdn_ppp_frame_log("rpush", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t}\n\tif (mis->compflags & SC_DECOMP_ON) {\n\t\tskb = isdn_ppp_decompress(skb, is, mis, &proto);\n\t\tif (!skb) // decompression error\n\t\t\treturn;\n\t}\n\tswitch (proto) {\n\tcase PPP_IPX:  /* untested */\n\t\tif (is->debug & 0x20)\n\t\t\tprintk(KERN_DEBUG "isdn_ppp: IPX\\n");\n\t\tskb->protocol = htons(ETH_P_IPX);\n\t\tbreak;\n\tcase PPP_IP:\n\t\tif (is->debug & 0x20)\n\t\t\tprintk(KERN_DEBUG "isdn_ppp: IP\\n");\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tbreak;\n\tcase PPP_COMP:\n\tcase PPP_COMPFRAG:\n\t\tprintk(KERN_INFO "isdn_ppp: unexpected compressed frame dropped\\n");\n\t\tgoto drop_packet;\n#ifdef CONFIG_ISDN_PPP_VJ\n\tcase PPP_VJC_UNCOMP:\n\t\tif (is->debug & 0x20)\n\t\t\tprintk(KERN_DEBUG "isdn_ppp: VJC_UNCOMP\\n");\n\t\tif (net_dev->local->ppp_slot < 0) {\n\t\t\tprintk(KERN_ERR "%s: net_dev->local->ppp_slot(%d) out of range\\n",\n\t\t\t       __func__, net_dev->local->ppp_slot);\n\t\t\tgoto drop_packet;\n\t\t}\n\t\tif (slhc_remember(ippp_table[net_dev->local->ppp_slot]->slcomp, skb->data, skb->len) <= 0) {\n\t\t\tprintk(KERN_WARNING "isdn_ppp: received illegal VJC_UNCOMP frame!\\n");\n\t\t\tgoto drop_packet;\n\t\t}\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tbreak;\n\tcase PPP_VJC_COMP:\n\t\tif (is->debug & 0x20)\n\t\t\tprintk(KERN_DEBUG "isdn_ppp: VJC_COMP\\n");\n\t\t{\n\t\t\tstruct sk_buff *skb_old = skb;\n\t\t\tint pkt_len;\n\t\t\tskb = dev_alloc_skb(skb_old->len + 128);\n\n\t\t\tif (!skb) {\n\t\t\t\tprintk(KERN_WARNING "%s: Memory squeeze, dropping packet.\\n", dev->name);\n\t\t\t\tskb = skb_old;\n\t\t\t\tgoto drop_packet;\n\t\t\t}\n\t\t\tskb_put(skb, skb_old->len + 128);\n\t\t\tskb_copy_from_linear_data(skb_old, skb->data,\n\t\t\t\t\t\t  skb_old->len);\n\t\t\tif (net_dev->local->ppp_slot < 0) {\n\t\t\t\tprintk(KERN_ERR "%s: net_dev->local->ppp_slot(%d) out of range\\n",\n\t\t\t\t       __func__, net_dev->local->ppp_slot);\n\t\t\t\tgoto drop_packet;\n\t\t\t}\n\t\t\tpkt_len = slhc_uncompress(ippp_table[net_dev->local->ppp_slot]->slcomp,\n\t\t\t\t\t\t  skb->data, skb_old->len);\n\t\t\tkfree_skb(skb_old);\n\t\t\tif (pkt_len < 0)\n\t\t\t\tgoto drop_packet;\n\n\t\t\tskb_trim(skb, pkt_len);\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t}\n\t\tbreak;\n#endif\n\tcase PPP_CCP:\n\tcase PPP_CCPFRAG:\n\t\tisdn_ppp_receive_ccp(net_dev, lp, skb, proto);\n\t\t/* Dont pop up ResetReq/Ack stuff to the daemon any\n\t\t   longer - the job is done already */\n\t\tif (skb->data[0] == CCP_RESETREQ ||\n	f
46266	131	vcnl4000_read_raw	drivers/iio/light/vcnl4000.c	ret	1	13	\N	\N	\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = vcnl4000_measure(data,\n\t\t\t\tVCNL4000_AL_OD, VCNL4000_AL_RDY,\n\t\t\t\tVCNL4000_AL_RESULT_HI, val);\n\t\t\tif (ret < 0)\n	f
-622	3008	nfp_net_ring_reconfig	drivers/net/ethernet/netronome/nfp/nfp_net_common.c	nn	2	3	\N	\N	\tint r, err;\n\n\tdp->fl_bufsz = nfp_net_calc_fl_bufsz(dp);\n\n\tdp->num_stack_tx_rings = dp->num_tx_rings;\n\tif (dp->xdp_prog)\n\t\tdp->num_stack_tx_rings -= dp->num_rx_rings;\n\n\tdp->num_r_vecs = max(dp->num_rx_rings, dp->num_stack_tx_rings);\n\n\terr = nfp_net_check_config(nn, dp, extack);\n\tif (err)\n\t\tgoto exit_free_dp;\n\n\tif (!netif_running(dp->netdev)) {\n\t\tnfp_net_dp_swap(nn, dp);\n\t\terr = 0;\n\t\tgoto exit_free_dp;\n\t}\n\n\t/* Prepare new rings */\n\tfor (r = nn->dp.num_r_vecs; r < dp->num_r_vecs; r++) {\n\t\terr = nfp_net_prepare_vector(nn, &nn->r_vecs[r], r);\n\t\tif (err) {\n\t\t\tdp->num_r_vecs = r;\n\t\t\tgoto err_cleanup_vecs;\n\t\t}\n\t}\n\n\terr = nfp_net_rx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_cleanup_vecs;\n\n\terr = nfp_net_tx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_free_rx;\n\n\t/* Stop device, swap in new rings, try to start the firmware */\n\tnfp_net_close_stack(nn);\n\tnfp_net_clear_config_and_disable(nn);\n\n\terr = nfp_net_dp_swap_enable(nn, dp);\n\tif (err) {\n\t\tint err2;\n\n\t\tnfp_net_clear_config_and_disable(nn);\n	f
28922	1502	SetDeviceTypeId	drivers/media/dvb-frontends/drxd_hard.c	status	1	13	\N	\N	\tint status = 0;\n\tu16 deviceId = 0;\n\n\tdo {\n\t\tstatus = Read16(state, CC_REG_JTAGID_L__A, &deviceId, 0);\n\t\tif (status < 0)\n	f
50192	330	lowpan_debugfs_init	net/6lowpan/debugfs.c	lowpan_debugfs_init_@lowpan_debugfs $obj	0	13	\N	\N	\tlowpan_debugfs = debugfs_create_dir("6lowpan", NULL);\n\tif (!lowpan_debugfs)\n	f
4101	1243	xps_cpus_show	net/core/net-sysfs.c	mask	1	13	\N	\N	\tstruct net_device *dev = queue->dev;\n\tint cpu, len, num_tc = 1, tc = 0;\n\tstruct xps_dev_maps *dev_maps;\n\tcpumask_var_t mask;\n\tunsigned long index;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tindex = get_netdev_queue_index(queue);\n\n\tif (dev->num_tc) {\n\t\tnum_tc = dev->num_tc;\n\t\ttc = netdev_txq_to_tc(dev, index);\n\t\tif (tc < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tdev_maps = rcu_dereference(dev->xps_maps);\n\tif (dev_maps) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tint i, tci = cpu * num_tc + tc;\n\t\t\tstruct xps_map *map;\n\n\t\t\tmap = rcu_dereference(dev_maps->cpu_map[tci]);\n\t\t\tif (!map)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = map->len; i--;) {\n\t\t\t\tif (map->queues[i] == index) {\n\t\t\t\t\tcpumask_set_cpu(cpu, mask);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tlen = snprintf(buf, PAGE_SIZE, "%*pb\\n", cpumask_pr_args(mask));\n	f
29307	408	__igt_reserve	drivers/gpu/drm/selftests/test-drm_mm.c	nodes	1	13	\N	\N	\tDRM_RND_STATE(prng, random_seed);\n\tstruct drm_mm mm;\n\tstruct drm_mm_node tmp, *nodes, *node, *next;\n\tunsigned int *order, n, m, o = 0;\n\tint ret, err;\n\n\t/* For exercising drm_mm_reserve_node(), we want to check that\n\t * reservations outside of the drm_mm range are rejected, and to\n\t * overlapping and otherwise already occupied ranges. Afterwards,\n\t * the tree and nodes should be intact.\n\t */\n\n\tDRM_MM_BUG_ON(!count);\n\tDRM_MM_BUG_ON(!size);\n\n\tret = -ENOMEM;\n\torder = drm_random_order(count, &prng);\n\tif (!order)\n\t\tgoto err;\n\n\tnodes = vzalloc(sizeof(*nodes) * count);\n\tif (!nodes)\n\t\tgoto err_order;\n\n\tret = -EINVAL;\n\tdrm_mm_init(&mm, 0, count * size);\n\n\tif (!check_reserve_boundaries(&mm, count, size))\n\t\tgoto out;\n\n\tfor (n = 0; n < count; n++) {\n\t\tnodes[n].start = order[n] * size;\n\t\tnodes[n].size = size;\n\n\t\terr = drm_mm_reserve_node(&mm, &nodes[n]);\n\t\tif (err) {\n\t\t\tpr_err("reserve failed, step %d, start %llu\\n",\n	f
37734	6340	xfs_bmap_split_extent_at	fs/xfs/libxfs/xfs_bmap.c	error	1	13	\N	\N	\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tnew; /* split extent */\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_fsblock_t\t\t\tgotblkcnt; /* new block count for got */\n\txfs_extnum_t\t\t\tcurrent_ext;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ti = 0;\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT("xfs_bmap_split_extent_at",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\t/* Read in all the extents */\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If there are not extents, or split_fsb lies in a hole we are done.\n\t */\n\tif (!xfs_iext_lookup_extent(ip, ifp, split_fsb, &current_ext, &got) ||\n\t    got.br_startoff >= split_fsb)\n\t\treturn 0;\n\n\tgotblkcnt = split_fsb - got.br_startoff;\n\tnew.br_startoff = split_fsb;\n\tnew.br_startblock = got.br_startblock + gotblkcnt;\n\tnew.br_blockcount = got.br_blockcount - gotblkcnt;\n\tnew.br_state = got.br_state;\n\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstfsb;\n\t\tcur->bc_private.b.dfops = dfops;\n\t\tcur->bc_private.b.flags = 0;\n\t\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount,\n\t\t\t\t&i);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);\n\t}\n\n\tgot.br_blockcount = gotblkcnt;\n\txfs_iext_update_extent(ifp, current_ext, &got);\n\n\tlogflags = XFS_ILOG_CORE;\n\tif (cur) {\n\t\terror = xfs_bmbt_update(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount,\n\t\t\t\tgot.br_state);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t} else\n\t\tlogflags |= XFS_ILOG_DEXT;\n\n\t/* Add new extent */\n\tcurrent_ext++;\n\txfs_iext_insert(ip, current_ext, 1, &new, 0);\n\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t   XFS_IFORK_NEXTENTS(ip, whichfork) + 1);\n\n\tif (cur) {\n\t\terror = xfs_bmbt_lookup_eq(cur, new.br_startoff,\n\t\t\t\tnew.br_startblock, new.br_blockcount,\n\t\t\t\t&i);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(mp, i == 0, del_cursor);\n\t\tcur->bc_rec.b.br_state = new.br_state;\n\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n	f
43234	238	rt298_jack_detect	sound/soc/codecs/rt298.c	hp	1	13	\N	\N	\tstruct snd_soc_dapm_context *dapm;\n\tunsigned int val, buf;\n\n\t*hp = false;\n\t*mic = false;\n\n\tif (!rt298->codec)\n\t\treturn -EINVAL;\n\n\tdapm = snd_soc_codec_get_dapm(rt298->codec);\n\n\tif (rt298->pdata.cbj_en) {\n\t\tregmap_read(rt298->regmap, RT298_GET_HP_SENSE, &buf);\n\t\t*hp = buf & 0x80000000;\n\t\tif (*hp == rt298->is_hp_in)\n	f
53254	8585	perf_event_set_addr_filter	kernel/events/core.c	ret	1	13	\N	\N	\tLIST_HEAD(filters);\n\tint ret;\n\n\t/*\n\t * Since this is called in perf_ioctl() path, we're already holding\n\t * ctx::mutex.\n\t */\n\tlockdep_assert_held(&event->ctx->mutex);\n\n\tif (WARN_ON_ONCE(event->parent))\n\t\treturn -EINVAL;\n\n\tret = perf_event_parse_addr_filter(event, filter_str, &filters);\n\tif (ret)\n	f
62718	2781	et131x_handle_send_pkts	drivers/net/ethernet/agere/et131x.c	adapter	1	13	\N	\N	\tunsigned long flags;\n\tu32 serviced;\n\tstruct tcb *tcb;\n\tu32 index;\n\tstruct tx_ring *tx_ring = &adapter->tx_ring;\n\n\tserviced = readl(&adapter->regs->txdma.new_service_complete);\n\tindex = INDEX10(serviced);\n\n\t/* Has the ring wrapped?  Process any descriptors that do not have\n\t * the same "wrap" indicator as the current completion indicator\n\t */\n\tspin_lock_irqsave(&adapter->tcb_send_qlock, flags);\n\n\ttcb = tx_ring->send_head;\n\n\twhile (tcb &&\n\t       ((serviced ^ tcb->index) & ET_DMA10_WRAP) &&\n\t       index < INDEX10(tcb->index)) {\n\t\ttx_ring->used--;\n\t\ttx_ring->send_head = tcb->next;\n\t\tif (tcb->next == NULL)\n\t\t\ttx_ring->send_tail = NULL;\n\n\t\tspin_unlock_irqrestore(&adapter->tcb_send_qlock, flags);\n\t\tfree_send_packet(adapter, tcb);\n\t\tspin_lock_irqsave(&adapter->tcb_send_qlock, flags);\n\n\t\t/* Goto the next packet */\n\t\ttcb = tx_ring->send_head;\n\t}\n\twhile (tcb &&\n\t       !((serviced ^ tcb->index) & ET_DMA10_WRAP) &&\n\t       index > (tcb->index & ET_DMA10_MASK)) {\n\t\ttx_ring->used--;\n\t\ttx_ring->send_head = tcb->next;\n\t\tif (tcb->next == NULL)\n\t\t\ttx_ring->send_tail = NULL;\n\n\t\tspin_unlock_irqrestore(&adapter->tcb_send_qlock, flags);\n\t\tfree_send_packet(adapter, tcb);\n	f
28143	2682	ib_uverbs_attach_mcast	drivers/infiniband/core/uverbs_cmd.c	&mcast->gid	1	13	\N	\N	\tstruct ib_uverbs_attach_mcast cmd;\n\tstruct ib_qp                 *qp;\n\tstruct ib_uqp_object         *obj;\n\tstruct ib_uverbs_mcast_entry *mcast;\n\tint                           ret;\n\n\tif (copy_from_user(&cmd, buf, sizeof cmd))\n\t\treturn -EFAULT;\n\n\tqp = uobj_get_obj_read(qp, cmd.qp_handle, file->ucontext);\n\tif (!qp)\n\t\treturn -EINVAL;\n\n\tobj = container_of(qp->uobject, struct ib_uqp_object, uevent.uobject);\n\n\tmutex_lock(&obj->mcast_lock);\n\tlist_for_each_entry(mcast, &obj->mcast_list, list)\n\t\tif (cmd.mlid == mcast->lid &&\n\t\t    !memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\n\t\t\tret = 0;\n\t\t\tgoto out_put;\n\t\t}\n\n\tmcast = kmalloc(sizeof *mcast, GFP_KERNEL);\n\tif (!mcast) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tmcast->lid = cmd.mlid;\n\tmemcpy(mcast->gid.raw, cmd.gid, sizeof mcast->gid.raw);\n\n\tret = ib_attach_mcast(qp, &mcast->gid, cmd.mlid);\n	f
20109	736	snd_usb_parse_audio_interface	sound/usb/stream.c	fp->rate_max	1	13	\N	\N	\tstruct usb_device *dev;\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tint i, altno, err, stream;\n\tunsigned int format = 0, num_channels = 0;\n\tstruct audioformat *fp = NULL;\n\tint num, protocol, clock = 0;\n\tstruct uac_format_type_i_continuous_descriptor *fmt;\n\tunsigned int chconfig;\n\n\tdev = chip->dev;\n\n\t/* parse the interface's altsettings */\n\tiface = usb_ifnum_to_if(dev, iface_no);\n\n\tnum = iface->num_altsetting;\n\n\t/*\n\t * Dallas DS4201 workaround: It presents 5 altsettings, but the last\n\t * one misses syncpipe, and does not produce any sound.\n\t */\n\tif (chip->usb_id == USB_ID(0x04fa, 0x4201))\n\t\tnum = 4;\n\n\tfor (i = 0; i < num; i++) {\n\t\talts = &iface->altsetting[i];\n\t\taltsd = get_iface_desc(alts);\n\t\tprotocol = altsd->bInterfaceProtocol;\n\t\t/* skip invalid one */\n\t\tif (((altsd->bInterfaceClass != USB_CLASS_AUDIO ||\n\t\t      (altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING &&\n\t\t       altsd->bInterfaceSubClass != USB_SUBCLASS_VENDOR_SPEC)) &&\n\t\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t\t    altsd->bNumEndpoints < 1 ||\n\t\t    le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) == 0)\n\t\t\tcontinue;\n\t\t/* must be isochronous */\n\t\tif ((get_endpoint(alts, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=\n\t\t    USB_ENDPOINT_XFER_ISOC)\n\t\t\tcontinue;\n\t\t/* check direction */\n\t\tstream = (get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN) ?\n\t\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\t\taltno = altsd->bAlternateSetting;\n\n\t\tif (snd_usb_apply_interface_quirk(chip, iface_no, altno))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Roland audio streaming interfaces are marked with protocols\n\t\t * 0/1/2, but are UAC 1 compatible.\n\t\t */\n\t\tif (USB_ID_VENDOR(chip->usb_id) == 0x0582 &&\n\t\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t\t    protocol <= 2)\n\t\t\tprotocol = UAC_VERSION_1;\n\n\t\tchconfig = 0;\n\t\t/* get audio formats */\n\t\tswitch (protocol) {\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, "%u:%d: unknown interface protocol %#02x, assuming v1\\n",\n\t\t\t\tiface_no, altno, protocol);\n\t\t\tprotocol = UAC_VERSION_1;\n\t\t\t/* fall through */\n\n\t\tcase UAC_VERSION_1: {\n\t\t\tstruct uac1_as_header_descriptor *as =\n\t\t\t\tsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\n\t\t\tstruct uac_input_terminal_descriptor *iterm;\n\n\t\t\tif (!as) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t"%u:%d : UAC_AS_GENERAL descriptor not found\\n",\n\t\t\t\t\tiface_no, altno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (as->bLength < sizeof(*as)) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t"%u:%d : invalid UAC_AS_GENERAL desc\\n",\n\t\t\t\t\tiface_no, altno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tformat = le16_to_cpu(as->wFormatTag); /* remember the format value */\n\n\t\t\titerm = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t\t       as->bTerminalLink);\n\t\t\tif (iterm) {\n\t\t\t\tnum_channels = iterm->bNrChannels;\n\t\t\t\tchconfig = le16_to_cpu(iterm->wChannelConfig);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase UAC_VERSION_2: {\n\t\t\tstruct uac2_input_terminal_descriptor *input_term;\n\t\t\tstruct uac2_output_terminal_descriptor *output_term;\n\t\t\tstruct uac2_as_header_descriptor *as =\n\t\t\t\tsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\n\n\t\t\tif (!as) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t"%u:%d : UAC_AS_GENERAL descriptor not found\\n",\n\t\t\t\t\tiface_no, altno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (as->bLength < sizeof(*as)) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t"%u:%d : invalid UAC_AS_GENERAL desc\\n",\n\t\t\t\t\tiface_no, altno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnum_channels = as->bNrChannels;\n\t\t\tformat = le32_to_cpu(as->bmFormats);\n\t\t\tchconfig = le32_to_cpu(as->bmChannelConfig);\n\n\t\t\t/* lookup the terminal associated to this interface\n\t\t\t * to extract the clock */\n\t\t\tinput_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t\t\t    as->bTerminalLink);\n\t\t\tif (input_term) {\n\t\t\t\tclock = input_term->bCSourceID;\n\t\t\t\tif (!chconfig && (num_channels == input_term->bNrChannels))\n\t\t\t\t\tchconfig = le32_to_cpu(input_term->bmChannelConfig);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toutput_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t\t\t      as->bTerminalLink);\n\t\t\tif (output_term) {\n\t\t\t\tclock = output_term->bCSourceID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t"%u:%d : bogus bTerminalLink %d\\n",\n\t\t\t\tiface_no, altno, as->bTerminalLink);\n\t\t\tcontinue;\n\t\t}\n\t\t}\n\n\t\t/* get format type */\n\t\tfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_FORMAT_TYPE);\n\t\tif (!fmt) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t"%u:%d : no UAC_FORMAT_TYPE desc\\n",\n\t\t\t\tiface_no, altno);\n\t\t\tcontinue;\n\t\t}\n\t\tif (((protocol == UAC_VERSION_1) && (fmt->bLength < 8)) ||\n\t\t    ((protocol == UAC_VERSION_2) && (fmt->bLength < 6))) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t"%u:%d : invalid UAC_FORMAT_TYPE desc\\n",\n\t\t\t\tiface_no, altno);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Blue Microphones workaround: The last altsetting is identical\n\t\t * with the previous one, except for a larger packet size, but\n\t\t * is actually a mislabeled two-channel setting; ignore it.\n\t\t */\n\t\tif (fmt->bNrChannels == 1 &&\n\t\t    fmt->bSubframeSize == 2 &&\n\t\t    altno == 2 && num == 3 &&\n\t\t    fp && fp->altsetting == 1 && fp->channels == 1 &&\n\t\t    fp->formats == SNDRV_PCM_FMTBIT_S16_LE &&\n\t\t    protocol == UAC_VERSION_1 &&\n\t\t    le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) ==\n\t\t\t\t\t\t\tfp->maxpacksize * 2)\n\t\t\tcontinue;\n\n\t\tfp = kzalloc(sizeof(*fp), GFP_KERNEL);\n\t\tif (!fp)\n\t\t\treturn -ENOMEM;\n\n\t\tfp->iface = iface_no;\n\t\tfp->altsetting = altno;\n\t\tfp->altset_idx = i;\n\t\tfp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;\n\t\tfp->ep_attr = get_endpoint(alts, 0)->bmAttributes;\n\t\tfp->datainterval = snd_usb_parse_datainterval(chip, alts);\n\t\tfp->protocol = protocol;\n\t\tfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\t\tfp->channels = num_channels;\n\t\tif (snd_usb_get_speed(dev) == USB_SPEED_HIGH)\n\t\t\tfp->maxpacksize = (((fp->maxpacksize >> 11) & 3) + 1)\n\t\t\t\t\t* (fp->maxpacksize & 0x7ff);\n\t\tfp->attributes = parse_uac_endpoint_attributes(chip, alts, protocol, iface_no);\n\t\tfp->clock = clock;\n\t\tINIT_LIST_HEAD(&fp->list);\n\n\t\t/* some quirks for attributes here */\n\n\t\tswitch (chip->usb_id) {\n\t\tcase USB_ID(0x0a92, 0x0053): /* AudioTrak Optoplay */\n\t\t\t/* Optoplay sets the sample rate attribute although\n\t\t\t * it seems not supporting it in fact.\n\t\t\t */\n\t\t\tfp->attributes &= ~UAC_EP_CS_ATTR_SAMPLE_RATE;\n\t\t\tbreak;\n\t\tcase USB_ID(0x041e, 0x3020): /* Creative SB Audigy 2 NX */\n\t\tcase USB_ID(0x0763, 0x2003): /* M-Audio Audiophile USB */\n\t\t\t/* doesn't set the sample rate attribute, but supports it */\n\t\t\tfp->attributes |= UAC_EP_CS_ATTR_SAMPLE_RATE;\n\t\t\tbreak;\n\t\tcase USB_ID(0x0763, 0x2001):  /* M-Audio Quattro USB */\n\t\tcase USB_ID(0x0763, 0x2012):  /* M-Audio Fast Track Pro USB */\n\t\tcase USB_ID(0x047f, 0x0ca1): /* plantronics headset */\n\t\tcase USB_ID(0x077d, 0x07af): /* Griffin iMic (note that there is\n\t\t\t\t\t\tan older model 77d:223) */\n\t\t/*\n\t\t * plantronics headset and Griffin iMic have set adaptive-in\n\t\t * although it's really not...\n\t\t */\n\t\t\tfp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;\n\t\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tfp->ep_attr |= USB_ENDPOINT_SYNC_ADAPTIVE;\n\t\t\telse\n\t\t\t\tfp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ok, let's parse further... */\n\t\tif (snd_usb_parse_audio_format(chip, fp, format, fmt, stream) < 0) {\n\t\t\tkfree(fp->rate_table);\n\t\t\tkfree(fp);\n\t\t\tfp = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Create chmap */\n\t\tif (fp->channels != num_channels)\n\t\t\tchconfig = 0;\n\t\tfp->chmap = convert_chmap(fp->channels, chconfig, protocol);\n\n\t\tdev_dbg(&dev->dev, "%u:%d: add audio endpoint %#x\\n", iface_no, altno, fp->endpoint);\n\t\terr = snd_usb_add_audio_stream(chip, stream, fp);\n\t\tif (err < 0) {\n\t\t\tlist_del(&fp->list); /* unlink for avoiding double-free */\n\t\t\tkfree(fp->rate_table);\n\t\t\tkfree(fp->chmap);\n\t\t\tkfree(fp);\n\t\t\treturn err;\n\t\t}\n\t\t/* try to set the interface... */\n\t\tusb_set_interface(chip->dev, iface_no, altno);\n\t\tsnd_usb_init_pitch(chip, iface_no, alts, fp);\n\t\tsnd_usb_init_sample_rate(chip, iface_no, alts, fp, fp->rate_max);\n	f
29821	245	friio_initialize	drivers/media/usb/dvb-usb/friio.c	ret	1	13	\N	\N	\tint ret;\n\tint i;\n\tint retry = 0;\n\tu8 *rbuf, *wbuf;\n\n\tdeb_info("%s called.\\n", __func__);\n\n\twbuf = kmalloc(3, GFP_KERNEL);\n\tif (!wbuf)\n\t\treturn -ENOMEM;\n\n\trbuf = kmalloc(2, GFP_KERNEL);\n\tif (!rbuf) {\n\t\tkfree(wbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* use gl861_i2c_msg instead of gl861_i2c_xfer(), */\n\t/* because the i2c device is not set up yet. */\n\twbuf[0] = 0x11;\n\twbuf[1] = 0x02;\n\tret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\n\tif (ret < 0)\n	f
38359	5569	lpfc_sli4_alloc_extent	drivers/scsi/lpfc/lpfc_sli.c	rsrc_cnt	1	13	\N	\N	\tbool emb = false;\n\tuint16_t rsrc_id_cnt, rsrc_cnt, rsrc_size;\n\tuint16_t rsrc_id, rsrc_start, j, k;\n\tuint16_t *ids;\n\tint i, rc;\n\tunsigned long longs;\n\tunsigned long *bmask;\n\tstruct lpfc_rsrc_blks *rsrc_blks;\n\tLPFC_MBOXQ_t *mbox;\n\tuint32_t length;\n\tstruct lpfc_id_range *id_array = NULL;\n\tvoid *virtaddr = NULL;\n\tstruct lpfc_mbx_nembed_rsrc_extent *n_rsrc;\n\tstruct lpfc_mbx_alloc_rsrc_extents *rsrc_ext;\n\tstruct list_head *ext_blk_list;\n\n\trc = lpfc_sli4_get_avail_extnt_rsrc(phba, type,\n\t\t\t\t\t    &rsrc_cnt,\n\t\t\t\t\t    &rsrc_size);\n\tif (unlikely(rc))\n\t\treturn -EIO;\n\n\tif ((rsrc_cnt == 0) || (rsrc_size == 0)) {\n	f
41767	678	goodix_configure_dev	drivers/input/touchscreen/goodix.c	ts	1	13	\N	\N	\tint error;\n\n\tts->swapped_x_y = device_property_read_bool(&ts->client->dev,\n\t\t\t\t\t\t    "touchscreen-swapped-x-y");\n\tts->inverted_x = device_property_read_bool(&ts->client->dev,\n\t\t\t\t\t\t   "touchscreen-inverted-x");\n\tts->inverted_y = device_property_read_bool(&ts->client->dev,\n\t\t\t\t\t\t   "touchscreen-inverted-y");\n\n\tgoodix_read_config(ts);\n\n\terror = goodix_request_input_dev(ts);\n	f
44407	697	acerhdf_register_platform	drivers/platform/x86/acerhdf.c	err	1	13	\N	\N	\tint err = 0;\n\n\terr = platform_driver_register(&acerhdf_driver);\n\tif (err)\n\t\treturn err;\n\n\tacerhdf_dev = platform_device_alloc("acerhdf", -1);\n\tif (!acerhdf_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_device_alloc;\n\t}\n\terr = platform_device_add(acerhdf_dev);\n\tif (err)\n	f
50797	160	nilfs_symlink	fs/nilfs2/namei.c	inode	1	13	\N	\N	\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned int l = strlen(symname) + 1;\n\tstruct inode *inode;\n\tint err;\n\n\tif (l > sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\n\tinode = nilfs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\t/* slow symlink */\n\tinode->i_op = &nilfs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n	f
28637	1116	isicom_set_serial_info	drivers/tty/isicom.c	newinfo.flags	1	13	\N	\N	\tstruct isi_port *port = tty->driver_data;\n\tstruct serial_struct newinfo;\n\tint reconfig_port;\n\n\tif (copy_from_user(&newinfo, info, sizeof(newinfo)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&port->port.mutex);\n\treconfig_port = ((port->port.flags & ASYNC_SPD_MASK) !=\n\t\t(newinfo.flags & ASYNC_SPD_MASK));\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((newinfo.close_delay != port->port.close_delay) ||\n	f
28873	385	cxd2820r_search	drivers/media/dvb-frontends/cxd2820r_core.c	ret	1	13	\N	\N	\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tenum fe_status status = 0;\n\n\tdev_dbg(&client->dev, "delivery_system=%d\\n", c->delivery_system);\n\n\t/* switch between DVB-T and DVB-T2 when tune fails */\n\tif (priv->last_tune_failed) {\n\t\tif (priv->delivery_system == SYS_DVBT) {\n\t\t\tret = cxd2820r_sleep_t(fe);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tc->delivery_system = SYS_DVBT2;\n\t\t} else if (priv->delivery_system == SYS_DVBT2) {\n\t\t\tret = cxd2820r_sleep_t2(fe);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tc->delivery_system = SYS_DVBT;\n\t\t}\n\t}\n\n\t/* set frontend */\n\tret = cxd2820r_set_frontend(fe);\n\tif (ret)\n\t\tgoto error;\n\n\t/* frontend lock wait loop count */\n\tswitch (priv->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBC_ANNEX_A:\n\t\ti = 20;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\ti = 40;\n\t\tbreak;\n\tcase SYS_UNDEFINED:\n\tdefault:\n\t\ti = 0;\n\t\tbreak;\n\t}\n\n\t/* wait frontend lock */\n\tfor (; i > 0; i--) {\n\t\tdev_dbg(&client->dev, "loop=%d\\n", i);\n\t\tmsleep(50);\n\t\tret = cxd2820r_read_status(fe, &status);\n\t\tif (ret)\n	f
24773	7296	load_yuvpp_binaries	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css.c	&yuv_scaler_descr	1	13	\N	\N	\tenum ia_css_err err = IA_CSS_SUCCESS;\n\tbool need_scaler = false;\n\tstruct ia_css_frame_info *vf_pp_in_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_yuvpp_settings *mycs;\n\tstruct ia_css_binary *next_binary;\n\tstruct ia_css_cas_binary_descr cas_scaler_descr = IA_CSS_DEFAULT_CAS_BINARY_DESCR;\n\tunsigned int i, j;\n\tbool need_isp_copy_binary = false;\n\n\tIA_CSS_ENTER_PRIVATE("");\n\tassert(pipe != NULL);\n\tassert(pipe->stream != NULL);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);\n\n\tif (pipe->pipe_settings.yuvpp.copy_binary.info)\n\t\tgoto ERR;\n\n        /* Set both must_be_raw and must_be_yuv to false then yuvpp can take rgb inputs */\n\terr = ia_css_util_check_input(&pipe->stream->config, false, false);\n\tif (err != IA_CSS_SUCCESS)\n\t\tgoto ERR;\n\n\tmycs = &pipe->pipe_settings.yuvpp;\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tif (pipe->vf_output_info[i].res.width != 0) {\n\t\t\terr = ia_css_util_check_vf_out_info(&pipe->output_info[i],\n\t\t\t\t\t&pipe->vf_output_info[i]);\n\t\t\tif (err != IA_CSS_SUCCESS)\n\t\t\t\tgoto ERR;\n\t\t}\n\t\tvf_pp_in_info[i] = NULL;\n\t}\n\n\tneed_scaler = need_yuv_scaler_stage(pipe);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_scaler) {\n\t\tstruct ia_css_binary_descr yuv_scaler_descr;\n\n\t\terr = ia_css_pipe_create_cas_scaler_desc(pipe,\n\t\t\t&cas_scaler_descr);\n\t\tif (err != IA_CSS_SUCCESS)\n\t\t\tgoto ERR;\n\t\tmycs->num_output = cas_scaler_descr.num_output_stage;\n\t\tmycs->num_yuv_scaler = cas_scaler_descr.num_stage;\n\t\tmycs->yuv_scaler_binary = kzalloc(cas_scaler_descr.num_stage *\n\t\t\tsizeof(struct ia_css_binary), GFP_KERNEL);\n\t\tif (mycs->yuv_scaler_binary == NULL) {\n\t\t\terr = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;\n\t\t\tgoto ERR;\n\t\t}\n\t\tmycs->is_output_stage = kzalloc(cas_scaler_descr.num_stage *\n\t\t\tsizeof(bool), GFP_KERNEL);\n\t\tif (mycs->is_output_stage == NULL) {\n\t\t\terr = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;\n\t\t\tgoto ERR;\n\t\t}\n\t\tfor (i = 0; i < cas_scaler_descr.num_stage; i++) {\n\t\t\tmycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe,\n\t\t\t\t&yuv_scaler_descr, &cas_scaler_descr.in_info[i],\n\t\t\t\t&cas_scaler_descr.out_info[i],\n\t\t\t\t&cas_scaler_descr.internal_out_info[i],\n\t\t\t\t&cas_scaler_descr.vf_info[i]);\n\t\t\terr = ia_css_binary_find(&yuv_scaler_descr,\n	f
35878	593	ntc_thermistor_probe	drivers/hwmon/ntc_thermistor.c	pdata->connect	1	13	\N	\N	\tstruct thermal_zone_device *tz;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(of_match_ptr(ntc_match), dev);\n\tconst struct platform_device_id *pdev_id;\n\tstruct ntc_thermistor_platform_data *pdata;\n\tstruct device *hwmon_dev;\n\tstruct ntc_data *data;\n\n\tpdata = ntc_thermistor_parse_dt(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\telse if (pdata == NULL)\n\t\tpdata = dev_get_platdata(dev);\n\n\tif (!pdata) {\n\t\tdev_err(dev, "No platform init data supplied.\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Either one of the two is required. */\n\tif (!pdata->read_uv && !pdata->read_ohm) {\n\t\tdev_err(dev,\n\t\t\t"Both read_uv and read_ohm missing. Need either one of the two.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->read_uv && pdata->read_ohm) {\n\t\tdev_warn(dev,\n\t\t\t "Only one of read_uv and read_ohm is needed; ignoring read_uv.\\n");\n\t\tpdata->read_uv = NULL;\n\t}\n\n\tif (pdata->read_uv && (pdata->pullup_uv == 0 ||\n\t\t\t\t(pdata->pullup_ohm == 0 && pdata->connect ==\n\t\t\t\t NTC_CONNECTED_GROUND) ||\n\t\t\t\t(pdata->pulldown_ohm == 0 && pdata->connect ==\n	f
38543	224	sb1000_probe_one	drivers/net/sb1000.c	16	1	13	\N	\N	\tstruct net_device *dev;\n\tunsigned short ioaddr[2], irq;\n\tunsigned int serial_number;\n\tint error = -ENODEV;\n\n\tif (pnp_device_attach(pdev) < 0)\n\t\treturn -ENODEV;\n\tif (pnp_activate_dev(pdev) < 0)\n\t\tgoto out_detach;\n\n\tif (!pnp_port_valid(pdev, 0) || !pnp_port_valid(pdev, 1))\n\t\tgoto out_disable;\n\tif (!pnp_irq_valid(pdev, 0))\n\t\tgoto out_disable;\n\n\tserial_number = pdev->card->serial;\n\n\tioaddr[0] = pnp_port_start(pdev, 0);\n\tioaddr[1] = pnp_port_start(pdev, 0);\n\n\tirq = pnp_irq(pdev, 0);\n\n\tif (!request_region(ioaddr[0], 16, "sb1000"))\n\t\tgoto out_disable;\n\tif (!request_region(ioaddr[1], 16, "sb1000"))\n\t\tgoto out_release_region0;\n\n\tdev = alloc_etherdev(sizeof(struct sb1000_private));\n\tif (!dev) {\n\t\terror = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\n\tdev->base_addr = ioaddr[0];\n\t/* mem_start holds the second I/O address */\n\tdev->mem_start = ioaddr[1];\n\tdev->irq = irq;\n\n\tif (sb1000_debug > 0)\n\t\tprintk(KERN_NOTICE "%s: sb1000 at (%#3.3lx,%#3.3lx), "\n\t\t\t"S/N %#8.8x, IRQ %d.\\n", dev->name, dev->base_addr,\n\t\t\tdev->mem_start, serial_number, dev->irq);\n\n\t/*\n\t * The SB1000 is an rx-only cable modem device.  The uplink is a modem\n\t * and we do not want to arp on it.\n\t */\n\tdev->flags = IFF_POINTOPOINT|IFF_NOARP;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (sb1000_debug > 0)\n\t\tprintk(KERN_NOTICE "%s", version);\n\n\tdev->netdev_ops\t= &sb1000_netdev_ops;\n\n\t/* hardware address is 0:0:serial_number */\n\tdev->dev_addr[2]\t= serial_number >> 24 & 0xff;\n\tdev->dev_addr[3]\t= serial_number >> 16 & 0xff;\n\tdev->dev_addr[4]\t= serial_number >>  8 & 0xff;\n\tdev->dev_addr[5]\t= serial_number >>  0 & 0xff;\n\n\tpnp_set_drvdata(pdev, dev);\n\n\terror = register_netdev(dev);\n\tif (error)\n\t\tgoto out_free_netdev;\n\treturn 0;\n\n out_free_netdev:\n\tfree_netdev(dev);\n out_release_regions:\n\trelease_region(ioaddr[1], 16);\n	f
5176	54	wm831x_unique_id_show	drivers/mfd/wm831x-otp.c	rval	1	13	\N	\N	\tstruct wm831x *wm831x = dev_get_drvdata(dev);\n\tint rval;\n\tchar id[WM831X_UNIQUE_ID_LEN];\n\n\trval = wm831x_unique_id_read(wm831x, id);\n\tif (rval < 0)\n	f
42202	964	edt_ft5x06_ts_probe	drivers/input/touchscreen/edt-ft5x06.c	tsdata->name	1	13	\N	\N	\tconst struct edt_i2c_chip_data *chip_data;\n\tstruct edt_ft5x06_ts_data *tsdata;\n\tstruct input_dev *input;\n\tunsigned long irq_flags;\n\tint error;\n\tchar fw_version[EDT_NAME_LEN];\n\n\tdev_dbg(&client->dev, "probing for EDT FT5x06 I2C\\n");\n\n\ttsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);\n\tif (!tsdata) {\n\t\tdev_err(&client->dev, "failed to allocate driver data.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tchip_data = of_device_get_match_data(&client->dev);\n\tif (!chip_data)\n\t\tchip_data = (const struct edt_i2c_chip_data *)id->driver_data;\n\tif (!chip_data || !chip_data->max_support_points) {\n\t\tdev_err(&client->dev, "invalid or missing chip data\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ttsdata->max_support_points = chip_data->max_support_points;\n\n\ttsdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t     "reset", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tsdata->reset_gpio)) {\n\t\terror = PTR_ERR(tsdata->reset_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t"Failed to request GPIO reset pin, error %d\\n", error);\n\t\treturn error;\n\t}\n\n\ttsdata->wake_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t    "wake", GPIOD_OUT_LOW);\n\tif (IS_ERR(tsdata->wake_gpio)) {\n\t\terror = PTR_ERR(tsdata->wake_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t"Failed to request GPIO wake pin, error %d\\n", error);\n\t\treturn error;\n\t}\n\n\tif (tsdata->wake_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->wake_gpio, 1);\n\t}\n\n\tif (tsdata->reset_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->reset_gpio, 0);\n\t\tmsleep(300);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input) {\n\t\tdev_err(&client->dev, "failed to allocate input device.\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tsdata->mutex);\n\ttsdata->client = client;\n\ttsdata->input = input;\n\ttsdata->factory_mode = false;\n\n\terror = edt_ft5x06_ts_identify(client, tsdata, fw_version);\n\tif (error) {\n\t\tdev_err(&client->dev, "touchscreen probe failed\\n");\n\t\treturn error;\n\t}\n\n\tedt_ft5x06_ts_set_regs(tsdata);\n\tedt_ft5x06_ts_get_defaults(&client->dev, tsdata);\n\tedt_ft5x06_ts_get_parameters(tsdata);\n\n\tdev_dbg(&client->dev,\n	f
46326	319	__inet_lookup	net/ipv4/tcp_ipv4.c	sk	1	13	\N	\N	\tstruct dst_entry *dst = __sk_dst_check(sk, 0);\n\n	f
50359	248	tlc591xx_probe	drivers/leds/leds-tlc591xx.c	priv	1	13	\N	\N	\tstruct device_node *np = client->dev.of_node, *child;\n\tstruct device *dev = &client->dev;\n\tconst struct of_device_id *match;\n\tconst struct tlc591xx *tlc591xx;\n\tstruct tlc591xx_priv *priv;\n\tint err, count, reg;\n\n\tmatch = of_match_device(of_tlc591xx_leds_match, dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\ttlc591xx = match->data;\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tcount = of_get_child_count(np);\n\tif (!count || count > tlc591xx->max_leds)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &tlc591xx_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\terr = PTR_ERR(priv->regmap);\n\t\tdev_err(dev, "Failed to allocate register map: %d\\n", err);\n\t\treturn err;\n\t}\n\tpriv->reg_ledout_offset = tlc591xx->reg_ledout_offset;\n\n\ti2c_set_clientdata(client, priv);\n\n\tfor_each_child_of_node(np, child) {\n\t\terr = of_property_read_u32(child, "reg", &reg);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t\tif (reg < 0 || reg >= tlc591xx->max_leds ||\n\t\t    priv->leds[reg].active) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->leds[reg].active = true;\n\t\tpriv->leds[reg].ldev.name =\n\t\t\tof_get_property(child, "label", NULL) ? : child->name;\n\t\tpriv->leds[reg].ldev.default_trigger =\n\t\t\tof_get_property(child, "linux,default-trigger", NULL);\n\t}\n\treturn tlc591xx_configure(dev, priv, tlc591xx);\n	f
56029	435	ila_nl_cmd_get_mapping	net/ipv6/ila/ila_xlat.c	&xp	1	13	\N	\N	\tstruct net *net = genl_info_net(info);\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct sk_buff *msg;\n\tstruct ila_xlat_params xp;\n\tstruct ila_map *ila;\n\tint ret;\n\n\tret = parse_nl_config(info, &xp);\n	f
58672	180	twl4030_pwm_request	drivers/pwm/pwm-twl.c	ret	1	13	\N	\N	\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val, mask, bits;\n\n\tif (pwm->hwpwm == 1) {\n\t\tmask = TWL4030_GPIO7_VIBRASYNC_PWM1_MASK;\n\t\tbits = TWL4030_GPIO7_VIBRASYNC_PWM1_PWM1;\n\t} else {\n\t\tmask = TWL4030_GPIO6_PWM0_MUTE_MASK;\n\t\tbits = TWL4030_GPIO6_PWM0_MUTE_PWM0;\n\t}\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &val, TWL4030_PMBR1_REG);\n\tif (ret < 0) {\n	f
59613	1583	mlx4_ib_multiplex_mad	drivers/infiniband/hw/mlx4/mad.c	&ah_attr	1	13	\N	\N	\tstruct mlx4_ib_dev *dev = to_mdev(ctx->ib_dev);\n\tstruct mlx4_ib_demux_pv_qp *tun_qp = &ctx->qp[MLX4_TUN_WRID_QPN(wc->wr_id)];\n\tint wr_ix = wc->wr_id & (MLX4_NUM_TUNNEL_BUFS - 1);\n\tstruct mlx4_tunnel_mad *tunnel = tun_qp->ring[wr_ix].addr;\n\tstruct mlx4_ib_ah ah;\n\tstruct rdma_ah_attr ah_attr;\n\tu8 *slave_id;\n\tint slave;\n\tint port;\n\tu16 vlan_id;\n\tu8 qos;\n\tu8 *dmac;\n\n\t/* Get slave that sent this packet */\n\tif (wc->src_qp < dev->dev->phys_caps.base_proxy_sqpn ||\n\t    wc->src_qp >= dev->dev->phys_caps.base_proxy_sqpn + 8 * MLX4_MFUNC_MAX ||\n\t    (wc->src_qp & 0x1) != ctx->port - 1 ||\n\t    wc->src_qp & 0x4) {\n\t\tmlx4_ib_warn(ctx->ib_dev, "can't multiplex bad sqp:%d\\n", wc->src_qp);\n\t\treturn;\n\t}\n\tslave = ((wc->src_qp & ~0x7) - dev->dev->phys_caps.base_proxy_sqpn) / 8;\n\tif (slave != ctx->slave) {\n\t\tmlx4_ib_warn(ctx->ib_dev, "can't multiplex bad sqp:%d: "\n\t\t\t     "belongs to another slave\\n", wc->src_qp);\n\t\treturn;\n\t}\n\n\t/* Map transaction ID */\n\tib_dma_sync_single_for_cpu(ctx->ib_dev, tun_qp->ring[wr_ix].map,\n\t\t\t\t   sizeof (struct mlx4_tunnel_mad),\n\t\t\t\t   DMA_FROM_DEVICE);\n\tswitch (tunnel->mad.mad_hdr.method) {\n\tcase IB_MGMT_METHOD_SET:\n\tcase IB_MGMT_METHOD_GET:\n\tcase IB_MGMT_METHOD_REPORT:\n\tcase IB_SA_METHOD_GET_TABLE:\n\tcase IB_SA_METHOD_DELETE:\n\tcase IB_SA_METHOD_GET_MULTI:\n\tcase IB_SA_METHOD_GET_TRACE_TBL:\n\t\tslave_id = (u8 *) &tunnel->mad.mad_hdr.tid;\n\t\tif (*slave_id) {\n\t\t\tmlx4_ib_warn(ctx->ib_dev, "egress mad has non-null tid msb:%d "\n\t\t\t\t     "class:%d slave:%d\\n", *slave_id,\n\t\t\t\t     tunnel->mad.mad_hdr.mgmt_class, slave);\n\t\t\treturn;\n\t\t} else\n\t\t\t*slave_id = slave;\n\tdefault:\n\t\t/* nothing */;\n\t}\n\n\t/* Class-specific handling */\n\tswitch (tunnel->mad.mad_hdr.mgmt_class) {\n\tcase IB_MGMT_CLASS_SUBN_LID_ROUTED:\n\tcase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\n\t\tif (slave != mlx4_master_func_num(dev->dev) &&\n\t\t    !mlx4_vf_smi_enabled(dev->dev, slave, ctx->port))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_SUBN_ADM:\n\t\tif (mlx4_ib_multiplex_sa_handler(ctx->ib_dev, ctx->port, slave,\n\t\t\t      (struct ib_sa_mad *) &tunnel->mad))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_CM:\n\t\tif (mlx4_ib_multiplex_cm_handler(ctx->ib_dev, ctx->port, slave,\n\t\t\t      (struct ib_mad *) &tunnel->mad))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_DEVICE_MGMT:\n\t\tif (tunnel->mad.mad_hdr.method != IB_MGMT_METHOD_GET &&\n\t\t    tunnel->mad.mad_hdr.method != IB_MGMT_METHOD_SET)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\t/* Drop unsupported classes for slaves in tunnel mode */\n\t\tif (slave != mlx4_master_func_num(dev->dev)) {\n\t\t\tmlx4_ib_warn(ctx->ib_dev, "dropping unsupported egress mad from class:%d "\n\t\t\t\t     "for slave:%d\\n", tunnel->mad.mad_hdr.mgmt_class, slave);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* We are using standard ib_core services to send the mad, so generate a\n\t * stadard address handle by decoding the tunnelled mlx4_ah fields */\n\tmemcpy(&ah.av, &tunnel->hdr.av, sizeof (struct mlx4_av));\n\tah.ibah.device = ctx->ib_dev;\n\n\tport = be32_to_cpu(ah.av.ib.port_pd) >> 24;\n\tport = mlx4_slave_convert_port(dev->dev, slave, port);\n\tif (port < 0)\n\t\treturn;\n\tah.av.ib.port_pd = cpu_to_be32(port << 24 | (be32_to_cpu(ah.av.ib.port_pd) & 0xffffff));\n\tah.ibah.type = rdma_ah_find_type(&dev->ib_dev, port);\n\n\tmlx4_ib_query_ah(&ah.ibah, &ah_attr);\n	f
37474	11584	bnx2x_sfx7101_sp_sw_reset	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	val	1	13	\N	\N	\tu16 val, cnt;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tmsleep(50);\n\t\t/* Writes a self-clearing reset */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_7101_RESET,\n\t\t\t\t (val | (1<<15)));\n\t\t/* Wait for clear */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\t\tif ((val & (1<<15)) == 0)\n	f
40380	186	i2c_gpio_probe	drivers/i2c/busses/i2c-gpio.c	pdata->scl_is_open_drain	1	13	\N	\N	\tstruct i2c_gpio_private_data *priv;\n\tstruct i2c_gpio_platform_data *pdata;\n\tstruct i2c_algo_bit_data *bit_data;\n\tstruct i2c_adapter *adap;\n\tunsigned int sda_pin, scl_pin;\n\tint ret;\n\n\t/* First get the GPIO pins; if it fails, we'll defer the probe. */\n\tif (pdev->dev.of_node) {\n\t\tret = of_i2c_gpio_get_pins(pdev->dev.of_node,\n\t\t\t\t\t   &sda_pin, &scl_pin);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (!dev_get_platdata(&pdev->dev))\n\t\t\treturn -ENXIO;\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tsda_pin = pdata->sda_pin;\n\t\tscl_pin = pdata->scl_pin;\n\t}\n\n\tret = devm_gpio_request(&pdev->dev, sda_pin, "sda");\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tret = -EPROBE_DEFER;\t/* Try again later */\n\t\treturn ret;\n\t}\n\tret = devm_gpio_request(&pdev->dev, scl_pin, "scl");\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tret = -EPROBE_DEFER;\t/* Try again later */\n\t\treturn ret;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tadap = &priv->adap;\n\tbit_data = &priv->bit_data;\n\tpdata = &priv->pdata;\n\n\tif (pdev->dev.of_node) {\n\t\tpdata->sda_pin = sda_pin;\n\t\tpdata->scl_pin = scl_pin;\n\t\tof_i2c_gpio_get_props(pdev->dev.of_node, pdata);\n\t} else {\n\t\tmemcpy(pdata, dev_get_platdata(&pdev->dev), sizeof(*pdata));\n\t}\n\n\tif (pdata->sda_is_open_drain) {\n\t\tgpio_direction_output(pdata->sda_pin, 1);\n\t\tbit_data->setsda = i2c_gpio_setsda_val;\n\t} else {\n\t\tgpio_direction_input(pdata->sda_pin);\n\t\tbit_data->setsda = i2c_gpio_setsda_dir;\n\t}\n\n\tif (pdata->scl_is_open_drain || pdata->scl_is_output_only) {\n	f
45677	1294	__download_offload_pseudocode	drivers/mmc/host/vub300.c	retval	1	13	\N	\N	\tu8 register_count = 0;\n\tu16 ts = 0;\n\tu16 interrupt_size = 0;\n\tconst u8 *data = fw->data;\n\tint size = fw->size;\n\tu8 c;\n\tdev_info(&vub300->udev->dev, "using %s for SDIO offload processing\\n",\n\t\t vub300->vub_name);\n\tdo {\n\t\tc = *data++;\n\t} while (size-- && c); /* skip comment */\n\tdev_info(&vub300->udev->dev, "using offload firmware %s %s\\n", fw->data,\n\t\t vub300->vub_name);\n\tif (size < 4) {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t"corrupt offload pseudocode in firmware %s\\n",\n\t\t\tvub300->vub_name);\n\t\tstrncpy(vub300->vub_name, "corrupt offload pseudocode",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\tinterrupt_size += *data++;\n\tsize -= 1;\n\tinterrupt_size <<= 8;\n\tinterrupt_size += *data++;\n\tsize -= 1;\n\tif (interrupt_size < size) {\n\t\tu16 xfer_length = roundup_to_multiple_of_64(interrupt_size);\n\t\tu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\n\t\tif (xfer_buffer) {\n\t\t\tint retval;\n\t\t\tmemcpy(xfer_buffer, data, interrupt_size);\n\t\t\tmemset(xfer_buffer + interrupt_size, 0,\n\t\t\t       xfer_length - interrupt_size);\n\t\t\tsize -= interrupt_size;\n\t\t\tdata += interrupt_size;\n\t\t\tretval =\n\t\t\t\tusb_control_msg(vub300->udev,\n\t\t\t\t\t\tusb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\t\t\tSET_INTERRUPT_PSEUDOCODE,\n\t\t\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\t\tUSB_RECIP_DEVICE, 0x0000, 0x0000,\n\t\t\t\t\t\txfer_buffer, xfer_length, HZ);\n\t\t\tkfree(xfer_buffer);\n\t\t\tif (retval < 0) {\n\t\t\t\tstrncpy(vub300->vub_name,\n\t\t\t\t\t"SDIO pseudocode download failed",\n\t\t\t\t\tsizeof(vub300->vub_name));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(&vub300->udev->dev,\n\t\t\t\t"not enough memory for xfer buffer to send"\n\t\t\t\t" INTERRUPT_PSEUDOCODE for %s %s\\n", fw->data,\n\t\t\t\tvub300->vub_name);\n\t\t\tstrncpy(vub300->vub_name,\n\t\t\t\t"SDIO interrupt pseudocode download failed",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t"corrupt interrupt pseudocode in firmware %s %s\\n",\n\t\t\tfw->data, vub300->vub_name);\n\t\tstrncpy(vub300->vub_name, "corrupt interrupt pseudocode",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\tts += *data++;\n\tsize -= 1;\n\tts <<= 8;\n\tts += *data++;\n\tsize -= 1;\n\tif (ts < size) {\n\t\tu16 xfer_length = roundup_to_multiple_of_64(ts);\n\t\tu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\n\t\tif (xfer_buffer) {\n\t\t\tint retval;\n\t\t\tmemcpy(xfer_buffer, data, ts);\n\t\t\tmemset(xfer_buffer + ts, 0,\n\t\t\t       xfer_length - ts);\n\t\t\tsize -= ts;\n\t\t\tdata += ts;\n\t\t\tretval =\n\t\t\t\tusb_control_msg(vub300->udev,\n\t\t\t\t\t\tusb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\t\t\tSET_TRANSFER_PSEUDOCODE,\n\t\t\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\t\tUSB_RECIP_DEVICE, 0x0000, 0x0000,\n\t\t\t\t\t\txfer_buffer, xfer_length, HZ);\n\t\t\tkfree(xfer_buffer);\n\t\t\tif (retval < 0) {\n	f
47906	510	lmc_ioctl	drivers/net/wan/lmc/lmc_main.c	xc.len	1	13	\N	\N	    lmc_softc_t *sc = dev_to_sc(dev);\n    lmc_ctl_t ctl;\n    int ret = -EOPNOTSUPP;\n    u16 regVal;\n    unsigned long flags;\n\n    lmc_trace(dev, "lmc_ioctl in");\n\n    /*\n     * Most functions mess with the structure\n     * Disable interrupts while we do the polling\n     */\n\n    switch (cmd) {\n        /*\n         * Return current driver state.  Since we keep this up\n         * To date internally, just copy this out to the user.\n         */\n    case LMCIOCGINFO: /*fold01*/\n\tif (copy_to_user(ifr->ifr_data, &sc->ictl, sizeof(lmc_ctl_t)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n        break;\n\n    case LMCIOCSINFO: /*fold01*/\n        if (!capable(CAP_NET_ADMIN)) {\n            ret = -EPERM;\n            break;\n        }\n\n        if(dev->flags & IFF_UP){\n            ret = -EBUSY;\n            break;\n        }\n\n\tif (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {\n\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&sc->lmc_lock, flags);\n        sc->lmc_media->set_status (sc, &ctl);\n\n        if(ctl.crc_length != sc->ictl.crc_length) {\n            sc->lmc_media->set_crc_length(sc, ctl.crc_length);\n\t    if (sc->ictl.crc_length == LMC_CTL_CRC_LENGTH_16)\n\t\tsc->TxDescriptControlInit |=  LMC_TDES_ADD_CRC_DISABLE;\n\t    else\n\t\tsc->TxDescriptControlInit &= ~LMC_TDES_ADD_CRC_DISABLE;\n        }\n\tspin_unlock_irqrestore(&sc->lmc_lock, flags);\n\n        ret = 0;\n        break;\n\n    case LMCIOCIFTYPE: /*fold01*/\n        {\n\t    u16 old_type = sc->if_type;\n\t    u16\tnew_type;\n\n\t    if (!capable(CAP_NET_ADMIN)) {\n\t\tret = -EPERM;\n\t\tbreak;\n\t    }\n\n\t    if (copy_from_user(&new_type, ifr->ifr_data, sizeof(u16))) {\n\t\tret = -EFAULT;\n\t\tbreak;\n\t    }\n\n            \n\t    if (new_type == old_type)\n\t    {\n\t\tret = 0 ;\n\t\tbreak;\t\t\t\t/* no change */\n            }\n            \n\t    spin_lock_irqsave(&sc->lmc_lock, flags);\n            lmc_proto_close(sc);\n\n            sc->if_type = new_type;\n            lmc_proto_attach(sc);\n\t    ret = lmc_proto_open(sc);\n\t    spin_unlock_irqrestore(&sc->lmc_lock, flags);\n\t    break;\n\t}\n\n    case LMCIOCGETXINFO: /*fold01*/\n\tspin_lock_irqsave(&sc->lmc_lock, flags);\n        sc->lmc_xinfo.Magic0 = 0xBEEFCAFE;\n\n        sc->lmc_xinfo.PciCardType = sc->lmc_cardtype;\n        sc->lmc_xinfo.PciSlotNumber = 0;\n        sc->lmc_xinfo.DriverMajorVersion = DRIVER_MAJOR_VERSION;\n        sc->lmc_xinfo.DriverMinorVersion = DRIVER_MINOR_VERSION;\n        sc->lmc_xinfo.DriverSubVersion = DRIVER_SUB_VERSION;\n        sc->lmc_xinfo.XilinxRevisionNumber =\n            lmc_mii_readreg (sc, 0, 3) & 0xf;\n        sc->lmc_xinfo.MaxFrameSize = LMC_PKT_BUF_SZ;\n        sc->lmc_xinfo.link_status = sc->lmc_media->get_link_status (sc);\n        sc->lmc_xinfo.mii_reg16 = lmc_mii_readreg (sc, 0, 16);\n\tspin_unlock_irqrestore(&sc->lmc_lock, flags);\n\n        sc->lmc_xinfo.Magic1 = 0xDEADBEEF;\n\n        if (copy_to_user(ifr->ifr_data, &sc->lmc_xinfo,\n\t\t\t sizeof(struct lmc_xinfo)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n\n        break;\n\n    case LMCIOCGETLMCSTATS:\n\t    spin_lock_irqsave(&sc->lmc_lock, flags);\n\t    if (sc->lmc_cardtype == LMC_CARDTYPE_T1) {\n\t\t    lmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_LSB);\n\t\t    sc->extra_stats.framingBitErrorCount +=\n\t\t\t    lmc_mii_readreg(sc, 0, 18) & 0xff;\n\t\t    lmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_MSB);\n\t\t    sc->extra_stats.framingBitErrorCount +=\n\t\t\t    (lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;\n\t\t    lmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_LSB);\n\t\t    sc->extra_stats.lineCodeViolationCount +=\n\t\t\t    lmc_mii_readreg(sc, 0, 18) & 0xff;\n\t\t    lmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_MSB);\n\t\t    sc->extra_stats.lineCodeViolationCount +=\n\t\t\t    (lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;\n\t\t    lmc_mii_writereg(sc, 0, 17, T1FRAMER_AERR);\n\t\t    regVal = lmc_mii_readreg(sc, 0, 18) & 0xff;\n\n\t\t    sc->extra_stats.lossOfFrameCount +=\n\t\t\t    (regVal & T1FRAMER_LOF_MASK) >> 4;\n\t\t    sc->extra_stats.changeOfFrameAlignmentCount +=\n\t\t\t    (regVal & T1FRAMER_COFA_MASK) >> 2;\n\t\t    sc->extra_stats.severelyErroredFrameCount +=\n\t\t\t    regVal & T1FRAMER_SEF_MASK;\n\t    }\n\t    spin_unlock_irqrestore(&sc->lmc_lock, flags);\n\t    if (copy_to_user(ifr->ifr_data, &sc->lmc_device->stats,\n\t\t\t     sizeof(sc->lmc_device->stats)) ||\n\t\tcopy_to_user(ifr->ifr_data + sizeof(sc->lmc_device->stats),\n\t\t\t     &sc->extra_stats, sizeof(sc->extra_stats)))\n\t\t    ret = -EFAULT;\n\t    else\n\t\t    ret = 0;\n\t    break;\n\n    case LMCIOCCLEARLMCSTATS:\n\t    if (!capable(CAP_NET_ADMIN)) {\n\t\t    ret = -EPERM;\n\t\t    break;\n\t    }\n\n\t    spin_lock_irqsave(&sc->lmc_lock, flags);\n\t    memset(&sc->lmc_device->stats, 0, sizeof(sc->lmc_device->stats));\n\t    memset(&sc->extra_stats, 0, sizeof(sc->extra_stats));\n\t    sc->extra_stats.check = STATCHECK;\n\t    sc->extra_stats.version_size = (DRIVER_VERSION << 16) +\n\t\t    sizeof(sc->lmc_device->stats) + sizeof(sc->extra_stats);\n\t    sc->extra_stats.lmc_cardtype = sc->lmc_cardtype;\n\t    spin_unlock_irqrestore(&sc->lmc_lock, flags);\n\t    ret = 0;\n\t    break;\n\n    case LMCIOCSETCIRCUIT: /*fold01*/\n        if (!capable(CAP_NET_ADMIN)){\n            ret = -EPERM;\n            break;\n        }\n\n        if(dev->flags & IFF_UP){\n            ret = -EBUSY;\n            break;\n        }\n\n\tif (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {\n\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&sc->lmc_lock, flags);\n        sc->lmc_media->set_circuit_type(sc, ctl.circuit_type);\n        sc->ictl.circuit_type = ctl.circuit_type;\n\tspin_unlock_irqrestore(&sc->lmc_lock, flags);\n        ret = 0;\n\n        break;\n\n    case LMCIOCRESET: /*fold01*/\n        if (!capable(CAP_NET_ADMIN)){\n            ret = -EPERM;\n            break;\n        }\n\n\tspin_lock_irqsave(&sc->lmc_lock, flags);\n        /* Reset driver and bring back to current state */\n        printk (" REG16 before reset +%04x\\n", lmc_mii_readreg (sc, 0, 16));\n        lmc_running_reset (dev);\n        printk (" REG16 after reset +%04x\\n", lmc_mii_readreg (sc, 0, 16));\n\n        LMC_EVENT_LOG(LMC_EVENT_FORCEDRESET, LMC_CSR_READ (sc, csr_status), lmc_mii_readreg (sc, 0, 16));\n\tspin_unlock_irqrestore(&sc->lmc_lock, flags);\n\n        ret = 0;\n        break;\n\n#ifdef DEBUG\n    case LMCIOCDUMPEVENTLOG:\n\tif (copy_to_user(ifr->ifr_data, &lmcEventLogIndex, sizeof(u32))) {\n\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\tif (copy_to_user(ifr->ifr_data + sizeof(u32), lmcEventLogBuf,\n\t\t\t sizeof(lmcEventLogBuf)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n\n        break;\n#endif /* end ifdef _DBG_EVENTLOG */\n    case LMCIOCT1CONTROL: /*fold01*/\n        if (sc->lmc_cardtype != LMC_CARDTYPE_T1){\n            ret = -EOPNOTSUPP;\n            break;\n        }\n        break;\n    case LMCIOCXILINX: /*fold01*/\n        {\n            struct lmc_xilinx_control xc; /*fold02*/\n\n            if (!capable(CAP_NET_ADMIN)){\n                ret = -EPERM;\n                break;\n            }\n\n            /*\n             * Stop the xwitter whlie we restart the hardware\n             */\n            netif_stop_queue(dev);\n\n\t    if (copy_from_user(&xc, ifr->ifr_data, sizeof(struct lmc_xilinx_control))) {\n\t\tret = -EFAULT;\n\t\tbreak;\n\t    }\n            switch(xc.command){\n            case lmc_xilinx_reset: /*fold02*/\n                {\n                    u16 mii;\n\t\t    spin_lock_irqsave(&sc->lmc_lock, flags);\n                    mii = lmc_mii_readreg (sc, 0, 16);\n\n                    /*\n                     * Make all of them 0 and make input\n                     */\n                    lmc_gpio_mkinput(sc, 0xff);\n\n                    /*\n                     * make the reset output\n                     */\n                    lmc_gpio_mkoutput(sc, LMC_GEP_RESET);\n\n                    /*\n                     * RESET low to force configuration.  This also forces\n                     * the transmitter clock to be internal, but we expect to reset\n                     * that later anyway.\n                     */\n\n                    sc->lmc_gpio &= ~LMC_GEP_RESET;\n                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\n                    /*\n                     * hold for more than 10 microseconds\n                     */\n                    udelay(50);\n\n                    sc->lmc_gpio |= LMC_GEP_RESET;\n                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\n                    /*\n                     * stop driving Xilinx-related signals\n                     */\n                    lmc_gpio_mkinput(sc, 0xff);\n\n                    /* Reset the frammer hardware */\n                    sc->lmc_media->set_link_status (sc, 1);\n                    sc->lmc_media->set_status (sc, NULL);\n//                    lmc_softreset(sc);\n\n                    {\n                        int i;\n                        for(i = 0; i < 5; i++){\n                            lmc_led_on(sc, LMC_DS3_LED0);\n                            mdelay(100);\n                            lmc_led_off(sc, LMC_DS3_LED0);\n                            lmc_led_on(sc, LMC_DS3_LED1);\n                            mdelay(100);\n                            lmc_led_off(sc, LMC_DS3_LED1);\n                            lmc_led_on(sc, LMC_DS3_LED3);\n                            mdelay(100);\n                            lmc_led_off(sc, LMC_DS3_LED3);\n                            lmc_led_on(sc, LMC_DS3_LED2);\n                            mdelay(100);\n                            lmc_led_off(sc, LMC_DS3_LED2);\n                        }\n                    }\n\t\t    spin_unlock_irqrestore(&sc->lmc_lock, flags);\n                    \n                    \n\n                    ret = 0x0;\n\n                }\n\n                break;\n            case lmc_xilinx_load_prom: /*fold02*/\n                {\n                    u16 mii;\n                    int timeout = 500000;\n\t\t    spin_lock_irqsave(&sc->lmc_lock, flags);\n                    mii = lmc_mii_readreg (sc, 0, 16);\n\n                    /*\n                     * Make all of them 0 and make input\n                     */\n                    lmc_gpio_mkinput(sc, 0xff);\n\n                    /*\n                     * make the reset output\n                     */\n                    lmc_gpio_mkoutput(sc,  LMC_GEP_DP | LMC_GEP_RESET);\n\n                    /*\n                     * RESET low to force configuration.  This also forces\n                     * the transmitter clock to be internal, but we expect to reset\n                     * that later anyway.\n                     */\n\n                    sc->lmc_gpio &= ~(LMC_GEP_RESET | LMC_GEP_DP);\n                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\n                    /*\n                     * hold for more than 10 microseconds\n                     */\n                    udelay(50);\n\n                    sc->lmc_gpio |= LMC_GEP_DP | LMC_GEP_RESET;\n                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n                    /*\n                     * busy wait for the chip to reset\n                     */\n                    while( (LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0 &&\n                           (timeout-- > 0))\n                        cpu_relax();\n\n\n                    /*\n                     * stop driving Xilinx-related signals\n                     */\n                    lmc_gpio_mkinput(sc, 0xff);\n\t\t    spin_unlock_irqrestore(&sc->lmc_lock, flags);\n\n                    ret = 0x0;\n                    \n\n                    break;\n\n                }\n\n            case lmc_xilinx_load: /*fold02*/\n                {\n                    char *data;\n                    int pos;\n                    int timeout = 500000;\n\n                    if (!xc.data) {\n                            ret = -EINVAL;\n                            break;\n                    }\n\n                    data = kmalloc(xc.len, GFP_KERNEL);\n                    if (!data) {\n                            ret = -ENOMEM;\n                            break;\n                    }\n                    \n                    if(copy_from_user(data, xc.data, xc.len))\n                    {\n                    \tkfree(data);\n                    \tret = -ENOMEM;\n                    \tbreak;\n                    }\n\n                    printk("%s: Starting load of data Len: %d at 0x%p == 0x%p\\n", dev->name, xc.len, xc.data, data);\n	f
-1029	631	irlan_get_provider_info	drivers/staging/irda/net/irlan/irlan_common.c	skb	2	3	\N	\N	\tstruct sk_buff *skb;\n\t__u8 *frame;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\n\n\tskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER,\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t/* Reserve space for TTP, LMP, and LAP header */\n\tskb_reserve(skb, self->client.max_header_size);\n	f
-1003	404	clk_dyn_rcg_recalc_rate	drivers/clk/qcom/clk-rcg.c	mode	2	3	\N	\N	\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tu32 m, n, pre_div, ns, md, mode, reg;\n\tint bank;\n\tstruct mn *mn;\n\tbool banked_p = !!rcg->p[1].pre_div_width;\n\tbool banked_mn = !!rcg->mn[1].width;\n\n\tregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tbank = reg_to_bank(rcg, reg);\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\n\tm = n = pre_div = mode = 0;\n\n\tif (banked_mn) {\n\t\tmn = &rcg->mn[bank];\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\n\t\tm = md_to_m(mn, md);\n\t\tn = ns_m_to_n(mn, ns, m);\n\t\t/* Two NS registers means mode control is in NS register */\n\t\tif (rcg->ns_reg[0] != rcg->ns_reg[1])\n\t\t\treg = ns;\n\t\tmode = reg_to_mnctr_mode(mn, reg);\n\t}\n\n\tif (banked_p)\n\t\tpre_div = ns_to_pre_div(&rcg->p[bank], ns);\n\n\treturn calc_rate(parent_rate, m, n, mode, pre_div);\n	f
39158	1632	drbd_adm_disk_opts	drivers/block/drbd/drbd_nl.c	peer_device	1	13	\N	\N	\tstruct drbd_config_context adm_ctx;\n\tenum drbd_ret_code retcode;\n\tstruct drbd_device *device;\n\tstruct disk_conf *new_disk_conf, *old_disk_conf;\n\tstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\n\tint err, fifo_size;\n\n\tretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\n\tif (!adm_ctx.reply_skb)\n\t\treturn retcode;\n\tif (retcode != NO_ERROR)\n\t\tgoto finish;\n\n\tdevice = adm_ctx.device;\n\tmutex_lock(&adm_ctx.resource->adm_mutex);\n\n\t/* we also need a disk\n\t * to change the options on */\n\tif (!get_ldev(device)) {\n\t\tretcode = ERR_NO_DISK;\n\t\tgoto out;\n\t}\n\n\tnew_disk_conf = kmalloc(sizeof(struct disk_conf), GFP_KERNEL);\n\tif (!new_disk_conf) {\n\t\tretcode = ERR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\tmutex_lock(&device->resource->conf_update);\n\told_disk_conf = device->ldev->disk_conf;\n\t*new_disk_conf = *old_disk_conf;\n\tif (should_set_defaults(info))\n\t\tset_disk_conf_defaults(new_disk_conf);\n\n\terr = disk_conf_from_attrs_for_change(new_disk_conf, info);\n\tif (err && err != -ENOMSG) {\n\t\tretcode = ERR_MANDATORY_TAG;\n\t\tdrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\n\t\tgoto fail_unlock;\n\t}\n\n\tif (!expect(new_disk_conf->resync_rate >= 1))\n\t\tnew_disk_conf->resync_rate = 1;\n\n\tsanitize_disk_conf(device, new_disk_conf, device->ldev);\n\n\tif (new_disk_conf->c_plan_ahead > DRBD_C_PLAN_AHEAD_MAX)\n\t\tnew_disk_conf->c_plan_ahead = DRBD_C_PLAN_AHEAD_MAX;\n\n\tfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\n\tif (fifo_size != device->rs_plan_s->size) {\n\t\tnew_plan = fifo_alloc(fifo_size);\n\t\tif (!new_plan) {\n\t\t\tdrbd_err(device, "kmalloc of fifo_buffer failed");\n\t\t\tretcode = ERR_NOMEM;\n\t\t\tgoto fail_unlock;\n\t\t}\n\t}\n\n\tdrbd_suspend_io(device);\n\twait_event(device->al_wait, lc_try_lock(device->act_log));\n\tdrbd_al_shrink(device);\n\terr = drbd_check_al_size(device, new_disk_conf);\n\tlc_unlock(device->act_log);\n\twake_up(&device->al_wait);\n\tdrbd_resume_io(device);\n\n\tif (err) {\n\t\tretcode = ERR_NOMEM;\n\t\tgoto fail_unlock;\n\t}\n\n\tlock_all_resources();\n\tretcode = drbd_resync_after_valid(device, new_disk_conf->resync_after);\n\tif (retcode == NO_ERROR) {\n\t\trcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\n\t\tdrbd_resync_after_changed(device);\n\t}\n\tunlock_all_resources();\n\n\tif (retcode != NO_ERROR)\n\t\tgoto fail_unlock;\n\n\tif (new_plan) {\n\t\told_plan = device->rs_plan_s;\n\t\trcu_assign_pointer(device->rs_plan_s, new_plan);\n\t}\n\n\tmutex_unlock(&device->resource->conf_update);\n\n\tif (new_disk_conf->al_updates)\n\t\tdevice->ldev->md.flags &= ~MDF_AL_DISABLED;\n\telse\n\t\tdevice->ldev->md.flags |= MDF_AL_DISABLED;\n\n\tif (new_disk_conf->md_flushes)\n\t\tclear_bit(MD_NO_FUA, &device->flags);\n\telse\n\t\tset_bit(MD_NO_FUA, &device->flags);\n\n\tif (write_ordering_changed(old_disk_conf, new_disk_conf))\n\t\tdrbd_bump_write_ordering(device->resource, NULL, WO_BDEV_FLUSH);\n\n\tif (old_disk_conf->discard_zeroes_if_aligned != new_disk_conf->discard_zeroes_if_aligned\n\t||  old_disk_conf->disable_write_same != new_disk_conf->disable_write_same)\n\t\tdrbd_reconsider_queue_parameters(device, device->ldev, NULL);\n\n\tdrbd_md_sync(device);\n\n\tif (device->state.conn >= C_CONNECTED) {\n\t\tstruct drbd_peer_device *peer_device;\n\n\t\tfor_each_peer_device(peer_device, device)\n	f
39320	3188	btrfs_del_dir_entries_in_log	fs/btrfs/tree-log.c	i_size	1	13	\N	\N	\tstruct btrfs_root *log;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint err = 0;\n\tint bytes_del = 0;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tif (dir->logged_trans < trans->transid)\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\n\tmutex_lock(&dir->log_mutex);\n\n\tlog = root->log_root;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, log, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tdi = btrfs_lookup_dir_index_item(trans, log, path, dir_ino,\n\t\t\t\t\t index, name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* update the directory size in the log to reflect the names\n\t * we have removed\n\t */\n\tif (bytes_del) {\n\t\tstruct btrfs_key key;\n\n\t\tkey.objectid = dir_ino;\n\t\tkey.offset = 0;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_search_slot(trans, log, &key, path, 0, 1);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 i_size;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\ti_size = btrfs_inode_size(path->nodes[0], item);\n\t\t\tif (i_size > bytes_del)\n	f
39387	526	esp6_input_done2	net/ipv6/esp6.c	err	1	13	\N	\N	\tstruct xfrm_state *x = xfrm_input_state(skb);\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct crypto_aead *aead = x->data;\n\tint hlen = sizeof(struct ip_esp_hdr) + crypto_aead_ivsize(aead);\n\tint hdr_len = skb_network_header_len(skb);\n\n\tif (!xo || (xo && !(xo->flags & CRYPTO_DONE)))\n\t\tkfree(ESP_SKB_CB(skb)->tmp);\n\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = esp_remove_trailer(skb);\n\tif (unlikely(err < 0))\n	f
39417	105	sys32_stat64	arch/x86/ia32/sys_ia32.c	ret	1	13	\N	\N	\tstruct kstat stat;\n\tint ret = vfs_stat(filename, &stat);\n\n\tif (!ret)\n	f
39418	1800	smp_cmd_pairing_req	net/bluetooth/smp.c	&rsp	1	13	\N	\N	\tstruct smp_cmd_pairing rsp, *req = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct smp_chan *smp;\n\tu8 key_size, auth, sec_level;\n\tint ret;\n\n\tBT_DBG("conn %p", conn);\n\n\tif (skb->len < sizeof(*req))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tif (conn->hcon->role != HCI_ROLE_SLAVE)\n\t\treturn SMP_CMD_NOTSUPP;\n\n\tif (!chan->data)\n\t\tsmp = smp_chan_create(conn);\n\telse\n\t\tsmp = chan->data;\n\n\tif (!smp)\n\t\treturn SMP_UNSPECIFIED;\n\n\t/* We didn't start the pairing, so match remote */\n\tauth = req->auth_req & AUTH_REQ_MASK(hdev);\n\n\tif (!hci_dev_test_flag(hdev, HCI_BONDABLE) &&\n\t    (auth & SMP_AUTH_BONDING))\n\t\treturn SMP_PAIRING_NOTSUPP;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY) && !(auth & SMP_AUTH_SC))\n\t\treturn SMP_AUTH_REQUIREMENTS;\n\n\tsmp->preq[0] = SMP_CMD_PAIRING_REQ;\n\tmemcpy(&smp->preq[1], req, sizeof(*req));\n\tskb_pull(skb, sizeof(*req));\n\n\t/* If the remote side's OOB flag is set it means it has\n\t * successfully received our local OOB data - therefore set the\n\t * flag to indicate that local OOB is in use.\n\t */\n\tif (req->oob_flag == SMP_OOB_PRESENT)\n\t\tset_bit(SMP_FLAG_LOCAL_OOB, &smp->flags);\n\n\t/* SMP over BR/EDR requires special treatment */\n\tif (conn->hcon->type == ACL_LINK) {\n\t\t/* We must have a BR/EDR SC link */\n\t\tif (!test_bit(HCI_CONN_AES_CCM, &conn->hcon->flags) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP))\n\t\t\treturn SMP_CROSS_TRANSP_NOT_ALLOWED;\n\n\t\tset_bit(SMP_FLAG_SC, &smp->flags);\n\n\t\tbuild_bredr_pairing_cmd(smp, req, &rsp);\n\n\t\tif (req->auth_req & SMP_AUTH_CT2)\n\t\t\tset_bit(SMP_FLAG_CT2, &smp->flags);\n\n\t\tkey_size = min(req->max_key_size, rsp.max_key_size);\n\t\tif (check_enc_key_size(conn, key_size))\n\t\t\treturn SMP_ENC_KEY_SIZE;\n\n\t\t/* Clear bits which are generated but not distributed */\n\t\tsmp->remote_key_dist &= ~SMP_SC_NO_DIST;\n\n\t\tsmp->prsp[0] = SMP_CMD_PAIRING_RSP;\n\t\tmemcpy(&smp->prsp[1], &rsp, sizeof(rsp));\n	f
39487	3059	qla24xx_abort_command	drivers/scsi/qla2xxx/qla_mbx.c	abt_dma	1	13	\N	\N	\tint\t\trval;\n\tunsigned long   flags = 0;\n\n\tstruct abort_entry_24xx *abt;\n\tdma_addr_t\tabt_dma;\n\tuint32_t\thandle;\n\tfc_port_t\t*fcport = sp->fcport;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = vha->req;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x108c,\n\t    "Entered %s.\\n", __func__);\n\n\tif (vha->flags.qpairs_available && sp->qpair)\n\t\treq = sp->qpair->req;\n\n\tif (ql2xasynctmfenable)\n\t\treturn qla24xx_async_abort_command(sp);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\n\t\tif (req->outstanding_cmds[handle] == sp)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\tif (handle == req->num_outstanding_cmds) {\n\t\t/* Command not found. */\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tabt = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &abt_dma);\n\tif (abt == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x108d,\n\t\t    "Failed to allocate abort IOCB.\\n");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\tmemset(abt, 0, sizeof(struct abort_entry_24xx));\n\n\tabt->entry_type = ABORT_IOCB_TYPE;\n\tabt->entry_count = 1;\n\tabt->handle = MAKE_HANDLE(req->id, abt->handle);\n\tabt->nport_handle = cpu_to_le16(fcport->loop_id);\n\tabt->handle_to_abort = MAKE_HANDLE(req->id, handle);\n\tabt->port_id[0] = fcport->d_id.b.al_pa;\n\tabt->port_id[1] = fcport->d_id.b.area;\n\tabt->port_id[2] = fcport->d_id.b.domain;\n\tabt->vp_index = fcport->vha->vp_idx;\n\n\tabt->req_que_no = cpu_to_le16(req->id);\n\n\trval = qla2x00_issue_iocb(vha, abt, abt_dma, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x108e,\n\t\t    "Failed to issue IOCB (%x).\\n", rval);\n\t} else if (abt->entry_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x108f,\n\t\t    "Failed to complete IOCB -- error status (%x).\\n",\n\t\t    abt->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (abt->nport_handle != cpu_to_le16(0)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1090,\n\t\t    "Failed to complete IOCB -- completion status (%x).\\n",\n\t\t    le16_to_cpu(abt->nport_handle));\n\t\tif (abt->nport_handle == CS_IOCB_ERROR)\n\t\t\trval = QLA_FUNCTION_PARAMETER_ERROR;\n\t\telse\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1091,\n\t\t    "Done %s.\\n", __func__);\n\t}\n\n\tdma_pool_free(ha->s_dma_pool, abt, abt_dma);\n	f
39577	589	btrfs_parse_options	fs/btrfs/super.c	intarg	1	13	\N	\N	\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\tenum btrfs_compression_type saved_compress_type;\n\tbool saved_compress_force;\n\tint no_compress = 0;\n\n\tcache_gen = btrfs_super_cache_generation(info->super_copy);\n\tif (btrfs_fs_compat_ro(info, FREE_SPACE_TREE))\n\t\tbtrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);\n\telse if (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\t/*\n\t * Even the options are empty, we still need to do extra check\n\t * against new flags\n\t */\n\tif (!options)\n\t\tgoto check;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, ",")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(info, "allowing degraded mounts");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(info, NODATASUM,\n\t\t\t\t\t   "setting nodatasum");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(info, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(info, NODATACOW))\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   "setting datasum, datacow enabled");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(info, "setting datasum");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(info, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(info, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(info, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   "setting nodatacow, compression disabled");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(info, "setting nodatacow");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(info, NODATACOW,\n\t\t\t\t\t     "setting datacow");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tsaved_compress_type = btrfs_test_opt(info,\n\t\t\t\t\t\t\t     COMPRESS) ?\n\t\t\t\tinfo->compress_type : BTRFS_COMPRESS_NONE;\n\t\t\tsaved_compress_force =\n\t\t\t\tbtrfs_test_opt(info, FORCE_COMPRESS);\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strncmp(args[0].from, "zlib", 4) == 0) {\n\t\t\t\tcompress_type = "zlib";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strncmp(args[0].from, "lzo", 3) == 0) {\n\t\t\t\tcompress_type = "lzo";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strcmp(args[0].from, "zstd") == 0) {\n\t\t\t\tcompress_type = "zstd";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZSTD;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_ZSTD);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strncmp(args[0].from, "no", 2) == 0) {\n\t\t\t\tcompress_type = "no";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t\tno_compress++;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tif ((btrfs_test_opt(info, COMPRESS) &&\n\t\t\t     (info->compress_type != saved_compress_type ||\n\t\t\t      compress_force != saved_compress_force)) ||\n\t\t\t    (!btrfs_test_opt(info, COMPRESS) &&\n\t\t\t     no_compress == 1)) {\n\t\t\t\tbtrfs_info(info, "%s %s compression",\n\t\t\t\t\t   (compress_force) ? "force" : "use",\n\t\t\t\t\t   compress_type);\n\t\t\t}\n\t\t\tcompress_force = false;\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(info, SSD,\n\t\t\t\t\t   "enabling ssd optimizations");\n\t\t\tbtrfs_clear_opt(info->mount_opt, NOSSD);\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(info, SSD,\n\t\t\t\t\t   "enabling ssd optimizations");\n\t\t\tbtrfs_set_and_info(info, SSD_SPREAD,\n\t\t\t\t\t   "using spread ssd allocation scheme");\n\t\t\tbtrfs_clear_opt(info->mount_opt, NOSSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_opt(info->mount_opt, NOSSD);\n\t\t\tbtrfs_clear_and_info(info, SSD,\n\t\t\t\t\t     "not using ssd optimizations");\n\t\t\tbtrfs_clear_and_info(info, SSD_SPREAD,\n\t\t\t\t\t     "not using spread ssd allocation scheme");\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(info, NOBARRIER,\n\t\t\t\t\t     "turning on barriers");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(info, NOBARRIER,\n\t\t\t\t\t   "turning off barriers");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n	f
39610	338	btrfs_read_qgroup_config	fs/btrfs/qgroup.c	found_key.offset	1	13	\N	\N	\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *l;\n\tint slot;\n\tint ret = 0;\n\tu64 flags = 0;\n\tu64 rescan_progress = 0;\n\n\tif (!test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\treturn 0;\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_KERNEL);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* default this to quota off, in case no status key is found */\n\tfs_info->qgroup_flags = 0;\n\n\t/*\n\t * pass 1: read status, all qgroup infos and limits\n\t */\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct btrfs_qgroup *qgroup;\n\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\n\t\t\tstruct btrfs_qgroup_status_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_status_item);\n\n\t\t\tif (btrfs_qgroup_status_version(l, ptr) !=\n\t\t\t    BTRFS_QGROUP_STATUS_VERSION) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t "old qgroup version, quota disabled");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (btrfs_qgroup_status_generation(l, ptr) !=\n\t\t\t    fs_info->generation) {\n\t\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t"qgroup generation mismatch, marked as inconsistent");\n\t\t\t}\n\t\t\tfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\n\t\t\t\t\t\t\t\t\t  ptr);\n\t\t\trescan_progress = btrfs_qgroup_status_rescan(l, ptr);\n\t\t\tgoto next1;\n\t\t}\n\n\t\tif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\n\t\t    found_key.type != BTRFS_QGROUP_LIMIT_KEY)\n\t\t\tgoto next1;\n\n\t\tqgroup = find_qgroup_rb(fs_info, found_key.offset);\n	f
39749	1434	get_a_ctxt	drivers/infiniband/hw/qib/qib_file_ops.c	npresent	1	13	\N	\N	\tstruct qib_devdata *udd = NULL;\n\tint ret = 0, devmax, npresent, nup, ndev, dusable = 0, i;\n\tu32 port = uinfo->spu_port, ctxt;\n\n\tdevmax = qib_count_units(&npresent, &nup);\n\tif (!npresent) {\n	f
40023	1084	lpfc_hba_down_post_s4	drivers/scsi/lpfc/lpfc_init.c	psb	1	13	\N	\N	\tstruct lpfc_scsi_buf *psb, *psb_next;\n\tstruct lpfc_nvmet_rcv_ctx *ctxp, *ctxp_next;\n\tLIST_HEAD(aborts);\n\tLIST_HEAD(nvme_aborts);\n\tLIST_HEAD(nvmet_aborts);\n\tunsigned long iflag = 0;\n\tstruct lpfc_sglq *sglq_entry = NULL;\n\n\n\tlpfc_sli_hbqbuf_free_all(phba);\n\tlpfc_hba_clean_txcmplq(phba);\n\n\t/* At this point in time the HBA is either reset or DOA. Either\n\t * way, nothing should be on lpfc_abts_els_sgl_list, it needs to be\n\t * on the lpfc_els_sgl_list so that it can either be freed if the\n\t * driver is unloading or reposted if the driver is restarting\n\t * the port.\n\t */\n\tspin_lock_irq(&phba->hbalock);  /* required for lpfc_els_sgl_list and */\n\t\t\t\t\t/* scsl_buf_list */\n\t/* sgl_list_lock required because worker thread uses this\n\t * list.\n\t */\n\tspin_lock(&phba->sli4_hba.sgl_list_lock);\n\tlist_for_each_entry(sglq_entry,\n\t\t&phba->sli4_hba.lpfc_abts_els_sgl_list, list)\n\t\tsglq_entry->state = SGL_FREED;\n\n\tlist_splice_init(&phba->sli4_hba.lpfc_abts_els_sgl_list,\n\t\t\t&phba->sli4_hba.lpfc_els_sgl_list);\n\n\n\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\t/* abts_scsi_buf_list_lock required because worker thread uses this\n\t * list.\n\t */\n\tif (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP) {\n\t\tspin_lock(&phba->sli4_hba.abts_scsi_buf_list_lock);\n\t\tlist_splice_init(&phba->sli4_hba.lpfc_abts_scsi_buf_list,\n\t\t\t\t &aborts);\n\t\tspin_unlock(&phba->sli4_hba.abts_scsi_buf_list_lock);\n\t}\n\n\tif (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) {\n\t\tspin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);\n\t\tlist_splice_init(&phba->sli4_hba.lpfc_abts_nvme_buf_list,\n\t\t\t\t &nvme_aborts);\n\t\tlist_splice_init(&phba->sli4_hba.lpfc_abts_nvmet_ctx_list,\n\t\t\t\t &nvmet_aborts);\n\t\tspin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);\n\t}\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlist_for_each_entry_safe(psb, psb_next, &aborts, list) {\n	f
40046	479	agp_via_probe	drivers/char/agp/via-agp.c	bridge->capndx+PCI_AGP_STATUS	1	13	\N	\N	\tstruct agp_device_ids *devs = via_agp_device_ids;\n\tstruct agp_bridge_data *bridge;\n\tint j = 0;\n\tu8 cap_ptr;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\tj = ent - agp_via_pci_table;\n\tprintk (KERN_INFO PFX "Detected VIA %s chipset\\n", devs[j].chipset_name);\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\tbridge->driver = &via_driver;\n\n\t/*\n\t * Garg, there are KT400s with KT266 IDs.\n\t */\n\tif (pdev->device == PCI_DEVICE_ID_VIA_8367_0) {\n\t\t/* Is there a KT400 subsystem ? */\n\t\tif (pdev->subsystem_device == PCI_DEVICE_ID_VIA_8377_0) {\n\t\t\tprintk(KERN_INFO PFX "Found KT400 in disguise as a KT266.\\n");\n\t\t\tcheck_via_agp3(bridge);\n\t\t}\n\t}\n\n\t/* If this is an AGP3 bridge, check which mode its in and adjust. */\n\tget_agp_version(bridge);\n\tif (bridge->major_version >= 3)\n\t\tcheck_via_agp3(bridge);\n\n\t/* Fill in the mode register */\n\tpci_read_config_dword(pdev,\n	f
40295	468	ie31200_probe1	drivers/edac/ie31200_edac.c	dimm_info	1	13	\N	\N	\tint i, j, ret;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tstruct dimm_data dimm_info[IE31200_CHANNELS][IE31200_DIMMS_PER_CHANNEL];\n\tvoid __iomem *window;\n\tstruct ie31200_priv *priv;\n\tu32 addr_decode, mad_offset;\n\n\t/*\n\t * Kaby Lake seems to work like Skylake. Please re-visit this logic\n\t * when adding new CPU support.\n\t */\n\tbool skl = (pdev->device >= PCI_DEVICE_ID_INTEL_IE31200_HB_8);\n\n\tedac_dbg(0, "MC:\\n");\n\n\tif (!ecc_capable(pdev)) {\n\t\tie31200_printk(KERN_INFO, "No ECC support\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tnr_channels = how_many_channels(pdev);\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = IE31200_DIMMS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = nr_channels;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct ie31200_priv));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\twindow = ie31200_map_mchbar(pdev);\n\tif (!window) {\n\t\tret = -ENODEV;\n\t\tgoto fail_free;\n\t}\n\n\tedac_dbg(3, "MC: init mci\\n");\n\tmci->pdev = &pdev->dev;\n\tif (skl)\n\t\tmci->mtype_cap = MEM_FLAG_DDR4;\n\telse\n\t\tmci->mtype_cap = MEM_FLAG_DDR3;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = ie31200_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = ie31200_check;\n\tmci->ctl_page_to_phys = NULL;\n\tpriv = mci->pvt_info;\n\tpriv->window = window;\n\tif (skl) {\n\t\tpriv->c0errlog = window + IE31200_C0ECCERRLOG_SKL;\n\t\tpriv->c1errlog = window + IE31200_C1ECCERRLOG_SKL;\n\t\tmad_offset = IE31200_MAD_DIMM_0_OFFSET_SKL;\n\t} else {\n\t\tpriv->c0errlog = window + IE31200_C0ECCERRLOG;\n\t\tpriv->c1errlog = window + IE31200_C1ECCERRLOG;\n\t\tmad_offset = IE31200_MAD_DIMM_0_OFFSET;\n\t}\n\n\t/* populate DIMM info */\n\tfor (i = 0; i < IE31200_CHANNELS; i++) {\n\t\taddr_decode = readl(window + mad_offset +\n\t\t\t\t\t(i * 4));\n\t\tedac_dbg(0, "addr_decode: 0x%x\\n", addr_decode);\n\t\tfor (j = 0; j < IE31200_DIMMS_PER_CHANNEL; j++) {\n\t\t\tpopulate_dimm_info(&dimm_info[i][j], addr_decode, j,\n\t\t\t\t\t   skl);\n\t\t\tedac_dbg(0, "size: 0x%x, rank: %d, width: %d\\n",\n\t\t\t\t dimm_info[i][j].size,\n\t\t\t\t dimm_info[i][j].dual_rank,\n\t\t\t\t dimm_info[i][j].x16_width);\n\t\t}\n\t}\n\n\t/*\n\t * The dram rank boundary (DRB) reg values are boundary addresses\n\t * for each DRAM rank with a granularity of 64MB.  DRB regs are\n\t * cumulative; the last one will contain the total memory\n\t * contained in all ranks.\n\t */\n\tfor (i = 0; i < IE31200_DIMMS_PER_CHANNEL; i++) {\n\t\tfor (j = 0; j < IE31200_CHANNELS; j++) {\n\t\t\tstruct dimm_info *dimm;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tnr_pages = IE31200_PAGES(dimm_info[j][i].size, skl);\n\t\t\tif (nr_pages == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dimm_info[j][i].dual_rank) {\n	f
40304	1767	smsc75xx_suspend	drivers/net/usb/smsc75xx.c	ret	1	13	\N	\N	\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val, link_up;\n\tint ret;\n\n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, "usbnet_suspend error\\n");\n\t\treturn ret;\n\t}\n\n\tif (pdata->suspend_flags) {\n\t\tnetdev_warn(dev->net, "error during last resume\\n");\n\t\tpdata->suspend_flags = 0;\n\t}\n\n\t/* determine if link is up using only _nopm functions */\n\tlink_up = smsc75xx_link_ok_nopm(dev);\n\n\tif (message.event == PM_EVENT_AUTO_SUSPEND) {\n\t\tret = smsc75xx_autosuspend(dev, link_up);\n\t\tgoto done;\n\t}\n\n\t/* if we get this far we're not autosuspending */\n\t/* if no wol options set, or if link is down and we're not waking on\n\t * PHY activity, enter lowest power SUSPEND2 mode\n\t */\n\tif (!(pdata->wolopts & SUPPORTED_WAKE) ||\n\t\t!(link_up || (pdata->wolopts & WAKE_PHY))) {\n\t\tnetdev_info(dev->net, "entering SUSPEND2 mode\\n");\n\n\t\t/* disable energy detect (link up) & wake up events */\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n	f
40314	141	gru_dump_context	drivers/misc/sgi-gru/grukdump.c	cch_locked	1	13	\N	\N	\tstruct gru_dump_context_header hdr;\n\tstruct gru_dump_context_header __user *uhdr = ubuf;\n\tstruct gru_context_configuration_handle *cch, *ubufcch;\n\tstruct gru_thread_state *gts;\n\tint try, cch_locked, cbrcnt = 0, dsrcnt = 0, bytes = 0, ret = 0;\n\tvoid *grubase;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\tgrubase = gru->gs_gru_base_vaddr;\n\tcch = get_cch(grubase, ctxnum);\n\tfor (try = 0; try < CCH_LOCK_ATTEMPTS; try++) {\n\t\tcch_locked =  trylock_cch_handle(cch);\n\t\tif (cch_locked)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tubuf += sizeof(hdr);\n\tubufcch = ubuf;\n\tif (gru_user_copy_handle(&ubuf, cch)) {\n\t\tif (cch_locked)\n	f
40415	392	tps65090_parse_dt_reg_data	drivers/regulator/tps65090-regulator.c	tps65090_parse_dt_reg_data_	1	13	\N	\N	\tstruct tps65090_platform_data *tps65090_pdata;\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tstruct device_node *regulators;\n\tint idx = 0, ret;\n\tstruct tps65090_regulator_plat_data *reg_pdata;\n\n\ttps65090_pdata = devm_kzalloc(&pdev->dev, sizeof(*tps65090_pdata),\n\t\t\t\tGFP_KERNEL);\n\tif (!tps65090_pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treg_pdata = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX *\n\t\t\t\tsizeof(*reg_pdata), GFP_KERNEL);\n\tif (!reg_pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregulators = of_get_child_by_name(np, "regulators");\n\tif (!regulators) {\n\t\tdev_err(&pdev->dev, "regulator node not found\\n");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tret = of_regulator_match(&pdev->dev, regulators, tps65090_matches,\n\t\t\tARRAY_SIZE(tps65090_matches));\n\tof_node_put(regulators);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t"Error parsing regulator init data: %d\\n", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t*tps65090_reg_matches = tps65090_matches;\n\tfor (idx = 0; idx < ARRAY_SIZE(tps65090_matches); idx++) {\n\t\tstruct regulator_init_data *ri_data;\n\t\tstruct tps65090_regulator_plat_data *rpdata;\n\n\t\trpdata = &reg_pdata[idx];\n\t\tri_data = tps65090_matches[idx].init_data;\n\t\tif (!ri_data || !tps65090_matches[idx].of_node)\n\t\t\tcontinue;\n\n\t\trpdata->reg_init_data = ri_data;\n\t\trpdata->enable_ext_control = of_property_read_bool(\n\t\t\t\t\ttps65090_matches[idx].of_node,\n\t\t\t\t\t"ti,enable-ext-control");\n\t\tif (rpdata->enable_ext_control)\n\t\t\trpdata->gpio = of_get_named_gpio(np,\n\t\t\t\t\t"dcdc-ext-control-gpios", 0);\n\n\t\tif (of_property_read_u32(tps65090_matches[idx].of_node,\n	f
40440	349	nxt200x_writetuner	drivers/media/dvb-frontends/nxt200x.c	buf	1	13	\N	\N	\tu8 buf, count = 0;\n\n\tdprintk("%s\\n", __func__);\n\n\tdprintk("Tuner Bytes: %*ph\\n", 4, data + 1);\n\n\t/* if NXT2004, write directly to tuner. if NXT2002, write through NXT chip.\n\t * direct write is required for Philips TUV1236D and ALPS TDHU2 */\n\tswitch (state->demod_chip) {\n\t\tcase NXT2004:\n\t\t\tif (i2c_writebytes(state, data[0], data+1, 4))\n\t\t\t\tpr_warn("error writing to tuner\\n");\n\t\t\t/* wait until we have a lock */\n\t\t\twhile (count < 20) {\n\t\t\t\ti2c_readbytes(state, data[0], &buf, 1);\n\t\t\t\tif (buf & 0x40)\n	f
40684	913	packetizeRx	drivers/net/usb/hso.c	odev->skb_rx_buf	1	13	\N	\N	\tunsigned short temp_bytes;\n\tunsigned short buffer_offset = 0;\n\tunsigned short frame_len;\n\n\t/* log if needed */\n\thso_dbg(0x1, "Rx %d bytes\\n", count);\n\tDUMP(ip_pkt, min(128, (int)count));\n\n\twhile (count) {\n\t\tswitch (odev->rx_parse_state) {\n\t\tcase WAIT_IP:\n\t\t\t/* waiting for IP header. */\n\t\t\t/* wanted bytes - size of ip header */\n\t\t\ttemp_bytes =\n\t\t\t    (count <\n\t\t\t     odev->rx_buf_missing) ? count : odev->\n\t\t\t    rx_buf_missing;\n\n\t\t\tmemcpy(((unsigned char *)(&odev->rx_ip_hdr)) +\n\t\t\t       odev->rx_buf_size, ip_pkt + buffer_offset,\n\t\t\t       temp_bytes);\n\n\t\t\todev->rx_buf_size += temp_bytes;\n\t\t\tbuffer_offset += temp_bytes;\n\t\t\todev->rx_buf_missing -= temp_bytes;\n\t\t\tcount -= temp_bytes;\n\n\t\t\tif (!odev->rx_buf_missing) {\n\t\t\t\t/* header is complete allocate an sk_buffer and\n\t\t\t\t * continue to WAIT_DATA */\n\t\t\t\tframe_len = ntohs(odev->rx_ip_hdr.tot_len);\n\n\t\t\t\tif ((frame_len > DEFAULT_MRU) ||\n\t\t\t\t    (frame_len < sizeof(struct iphdr))) {\n\t\t\t\t\tdev_err(&odev->net->dev,\n\t\t\t\t\t\t"Invalid frame (%d) length\\n",\n\t\t\t\t\t\tframe_len);\n\t\t\t\t\todev->rx_parse_state = WAIT_SYNC;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Allocate an sk_buff */\n\t\t\t\todev->skb_rx_buf = netdev_alloc_skb(odev->net,\n\t\t\t\t\t\t\t\t    frame_len);\n\t\t\t\tif (!odev->skb_rx_buf) {\n\t\t\t\t\t/* We got no receive buffer. */\n\t\t\t\t\thso_dbg(0x1, "could not allocate memory\\n");\n\t\t\t\t\todev->rx_parse_state = WAIT_SYNC;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Copy what we got so far. make room for iphdr\n\t\t\t\t * after tail. */\n\t\t\t\tskb_put_data(odev->skb_rx_buf,\n	f
40767	320	write_unlock_fs	fs/nfsd/nfsctl.c	path.dentry->d_sb	1	13	\N	\N	\tstruct path path;\n\tchar *fo_path;\n\tint error;\n\n\t/* sanity check */\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\terror = kern_path(fo_path, 0, &path);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX: Needs better sanity checking.  Otherwise we could end up\n\t * releasing locks on the wrong file system.\n\t *\n\t * For example:\n\t * 1.  Does the path refer to a directory?\n\t * 2.  Is that directory a mount point, or\n\t * 3.  Is that directory the root of an exported file system?\n\t */\n\terror = nlmsvc_unlock_all_by_sb(path.dentry->d_sb);\n	f
41074	1940	fc_rport_recv_plogi_req	drivers/scsi/libfc/fc_rport.c	fp	1	13	\N	\N	\tstruct fc_disc *disc;\n\tstruct fc_rport_priv *rdata;\n\tstruct fc_frame *fp = rx_fp;\n\tstruct fc_els_flogi *pl;\n\tstruct fc_seq_els_data rjt_data;\n\tu32 sid;\n\n\tsid = fc_frame_sid(fp);\n\n\tFC_RPORT_ID_DBG(lport, sid, "Received PLOGI request\\n");\n\n\tpl = fc_frame_payload_get(fp, sizeof(*pl));\n\tif (!pl) {\n\t\tFC_RPORT_ID_DBG(lport, sid, "Received PLOGI too short\\n");\n\t\trjt_data.reason = ELS_RJT_PROT;\n\t\trjt_data.explan = ELS_EXPL_INV_LEN;\n\t\tgoto reject;\n\t}\n\n\tdisc = &lport->disc;\n\tmutex_lock(&disc->disc_mutex);\n\trdata = fc_rport_create(lport, sid);\n\tif (!rdata) {\n\t\tmutex_unlock(&disc->disc_mutex);\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tgoto reject;\n\t}\n\n\tmutex_lock(&rdata->rp_mutex);\n\tmutex_unlock(&disc->disc_mutex);\n\n\trdata->ids.port_name = get_unaligned_be64(&pl->fl_wwpn);\n\trdata->ids.node_name = get_unaligned_be64(&pl->fl_wwnn);\n\n\t/*\n\t * If the rport was just created, possibly due to the incoming PLOGI,\n\t * set the state appropriately and accept the PLOGI.\n\t *\n\t * If we had also sent a PLOGI, and if the received PLOGI is from a\n\t * higher WWPN, we accept it, otherwise an LS_RJT is sent with reason\n\t * "command already in progress".\n\t *\n\t * XXX TBD: If the session was ready before, the PLOGI should result in\n\t * all outstanding exchanges being reset.\n\t */\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_INIT:\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI in INIT state\\n");\n\t\tbreak;\n\tcase RPORT_ST_PLOGI_WAIT:\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI in PLOGI_WAIT state\\n");\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI in PLOGI state\\n");\n\t\tif (rdata->ids.port_name < lport->wwpn) {\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\trjt_data.reason = ELS_RJT_INPROG;\n\t\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_RTV:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_ADISC:\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI in logged-in state %d "\n\t\t\t     "- ignored for now\\n", rdata->rp_state);\n\t\t/* XXX TBD - should reset */\n\t\tbreak;\n\tcase RPORT_ST_FLOGI:\n\tcase RPORT_ST_DELETE:\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI in state %s - send busy\\n",\n\t\t\t     fc_rport_state(rdata));\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_BUSY;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject;\n\t}\n\tif (!fc_rport_compatible_roles(lport, rdata)) {\n\t\tFC_RPORT_DBG(rdata, "Received PLOGI for incompatible role\\n");\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_LOGIC;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject;\n\t}\n\n\t/*\n\t * Get session payload size from incoming PLOGI.\n\t */\n\trdata->maxframe_size = fc_plogi_get_maxframe(pl, lport->mfs);\n\n\t/*\n\t * Send LS_ACC.\t If this fails, the originator should retry.\n\t */\n\tfp = fc_frame_alloc(lport, sizeof(*pl));\n\tif (!fp)\n\t\tgoto out;\n\n\tfc_plogi_fill(lport, fp, ELS_LS_ACC);\n	f
41086	776	dln2_spi_probe	drivers/spi/spi-dln2.c	dln2_spi_probe_	1	13	\N	\N	\tstruct spi_master *master;\n\tstruct dln2_spi *dln2;\n\tstruct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*dln2));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tdln2 = spi_master_get_devdata(master);\n\n\tdln2->buf = devm_kmalloc(&pdev->dev, DLN2_SPI_BUF_SIZE, GFP_KERNEL);\n\tif (!dln2->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_free_master;\n\t}\n\n\tdln2->master = master;\n\tdln2->master->dev.of_node = dev->of_node;\n\tdln2->pdev = pdev;\n\tdln2->port = pdata->port;\n\t/* cs/mode can never be 0xff, so the first transfer will set them */\n\tdln2->cs = 0xff;\n\tdln2->mode = 0xff;\n\n\t/* disable SPI module before continuing with the setup */\n\tret = dln2_spi_enable(dln2, false);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to disable SPI module\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tret = dln2_spi_get_cs_num(dln2, &master->num_chipselect);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to get number of CS pins\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tret = dln2_spi_get_speed_range(dln2,\n\t\t\t\t       &master->min_speed_hz,\n\t\t\t\t       &master->max_speed_hz);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to read bus min/max freqs\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tret = dln2_spi_get_supported_frame_sizes(dln2,\n\t\t\t\t\t\t &master->bits_per_word_mask);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to read supported frame sizes\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tret = dln2_spi_cs_enable_all(dln2, true);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to enable CS pins\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tmaster->bus_num = -1;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA;\n\tmaster->prepare_message = dln2_spi_prepare_message;\n\tmaster->transfer_one = dln2_spi_transfer_one;\n\tmaster->auto_runtime_pm = true;\n\n\t/* enable SPI module, we're good to go */\n\tret = dln2_spi_enable(dln2, true);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to enable SPI module\\n");\n\t\tgoto exit_free_master;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t DLN2_RPM_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "Failed to register master\\n");\n\t\tgoto exit_register;\n\t}\n\n\treturn ret;\n\nexit_register:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tif (dln2_spi_enable(dln2, false) < 0)\n	f
41114	752	rfcomm_session_create	net/bluetooth/rfcomm/core.c	sock->sk	1	13	\N	\N	\tstruct rfcomm_session *s = NULL;\n\tstruct sockaddr_l2 addr;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\n\tBT_DBG("%pMR -> %pMR", src, dst);\n\n\t*err = rfcomm_l2sock_create(&sock);\n\tif (*err < 0)\n\t\treturn NULL;\n\n\tbacpy(&addr.l2_bdaddr, src);\n\taddr.l2_family = AF_BLUETOOTH;\n\taddr.l2_psm    = 0;\n\taddr.l2_cid    = 0;\n\taddr.l2_bdaddr_type = BDADDR_BREDR;\n\t*err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (*err < 0)\n\t\tgoto failed;\n\n\t/* Set L2CAP options */\n\tsk = sock->sk;\n	f
41198	549	br_nf_forward_finish	net/bridge/br_netfilter_hooks.c	skb	1	13	\N	\N	\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct net_device *in;\n\n\tif (!IS_ARP(skb) && !IS_VLAN_ARP(skb)) {\n\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tnf_bridge->frag_max_size = IPCB(skb)->frag_max_size;\n\n\t\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tnf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;\n\n\t\tin = nf_bridge->physindev;\n\t\tif (nf_bridge->pkt_otherhost) {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tnf_bridge->pkt_otherhost = false;\n\t\t}\n\t\tnf_bridge_update_protocol(skb);\n\t} else {\n\t\tin = *((struct net_device **)(skb->cb));\n\t}\n\tnf_bridge_push_encap_header(skb);\n\n\tbr_nf_hook_thresh(NF_BR_FORWARD, net, sk, skb, in, skb->dev,\n	f
42167	2042	__falcon_reset_hw	drivers/net/ethernet/sfc/falcon/falcon.c	glb_ctl_reg_ker	1	13	\N	\N	\tstruct falcon_nic_data *nic_data = efx->nic_data;\n\tef4_oword_t glb_ctl_reg_ker;\n\tint rc;\n\n\tnetif_dbg(efx, hw, efx->net_dev, "performing %s hardware reset\\n",\n\t\t  RESET_TYPE(method));\n\n\t/* Initiate device reset */\n\tif (method == RESET_TYPE_WORLD) {\n\t\trc = pci_save_state(efx->pci_dev);\n\t\tif (rc) {\n\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t  "failed to backup PCI state of primary "\n\t\t\t\t  "function prior to hardware reset\\n");\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (ef4_nic_is_dual_func(efx)) {\n\t\t\trc = pci_save_state(nic_data->pci_dev2);\n\t\t\tif (rc) {\n\t\t\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t\t\t  "failed to backup PCI state of "\n\t\t\t\t\t  "secondary function prior to "\n\t\t\t\t\t  "hardware reset\\n");\n\t\t\t\tgoto fail2;\n\t\t\t}\n\t\t}\n\n\t\tEF4_POPULATE_OWORD_2(glb_ctl_reg_ker,\n\t\t\t\t     FRF_AB_EXT_PHY_RST_DUR,\n\t\t\t\t     FFE_AB_EXT_PHY_RST_DUR_10240US,\n\t\t\t\t     FRF_AB_SWRST, 1);\n\t} else {\n\t\tEF4_POPULATE_OWORD_7(glb_ctl_reg_ker,\n\t\t\t\t     /* exclude PHY from "invisible" reset */\n\t\t\t\t     FRF_AB_EXT_PHY_RST_CTL,\n\t\t\t\t     method == RESET_TYPE_INVISIBLE,\n\t\t\t\t     /* exclude EEPROM/flash and PCIe */\n\t\t\t\t     FRF_AB_PCIE_CORE_RST_CTL, 1,\n\t\t\t\t     FRF_AB_PCIE_NSTKY_RST_CTL, 1,\n\t\t\t\t     FRF_AB_PCIE_SD_RST_CTL, 1,\n\t\t\t\t     FRF_AB_EE_RST_CTL, 1,\n\t\t\t\t     FRF_AB_EXT_PHY_RST_DUR,\n\t\t\t\t     FFE_AB_EXT_PHY_RST_DUR_10240US,\n\t\t\t\t     FRF_AB_SWRST, 1);\n\t}\n\tef4_writeo(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\n\n\tnetif_dbg(efx, hw, efx->net_dev, "waiting for hardware reset\\n");\n\tschedule_timeout_uninterruptible(HZ / 20);\n\n\t/* Restore PCI configuration if needed */\n\tif (method == RESET_TYPE_WORLD) {\n\t\tif (ef4_nic_is_dual_func(efx))\n\t\t\tpci_restore_state(nic_data->pci_dev2);\n\t\tpci_restore_state(efx->pci_dev);\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  "successfully restored PCI config\\n");\n\t}\n\n\t/* Assert that reset complete */\n\tef4_reado(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\n\tif (EF4_OWORD_FIELD(glb_ctl_reg_ker, FRF_AB_SWRST) != 0) {\n	f
42232	623	handle_loop	net/caif/cfctrl.c	linktype	1	13	\N	\N	\tstatic int last_linkid;\n\tstatic int dec;\n\tu8 linkid, linktype, tmp;\n\tswitch (cmd) {\n\tcase CFCTRL_CMD_LINK_SETUP:\n\t\tspin_lock_bh(&ctrl->loop_linkid_lock);\n\t\tif (!dec) {\n\t\t\tfor (linkid = last_linkid + 1; linkid < 254; linkid++)\n\t\t\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\t\t\tgoto found;\n\t\t}\n\t\tdec = 1;\n\t\tfor (linkid = last_linkid - 1; linkid > 1; linkid--)\n\t\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\t\tgoto found;\n\t\tspin_unlock_bh(&ctrl->loop_linkid_lock);\n\t\treturn -1;\nfound:\n\t\tif (linkid < 10)\n\t\t\tdec = 0;\n\n\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\tctrl->loop_linkused[linkid] = 1;\n\n\t\tlast_linkid = linkid;\n\n\t\tcfpkt_add_trail(pkt, &linkid, 1);\n\t\tspin_unlock_bh(&ctrl->loop_linkid_lock);\n\t\tcfpkt_peek_head(pkt, &linktype, 1);\n\t\tif (linktype ==  CFCTRL_SRV_UTIL) {\n	f
42325	1749	spacc_probe	drivers/crypto/picoxcell_crypto.c	&engine->aeads[i].alg	1	13	\N	\N	\tint i, err, ret = -EINVAL;\n\tstruct resource *mem, *irq;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spacc_engine *engine = devm_kzalloc(&pdev->dev, sizeof(*engine),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!engine)\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(np, "picochip,spacc-ipsec")) {\n\t\tengine->max_ctxs\t= SPACC_CRYPTO_IPSEC_MAX_CTXS;\n\t\tengine->cipher_pg_sz\t= SPACC_CRYPTO_IPSEC_CIPHER_PG_SZ;\n\t\tengine->hash_pg_sz\t= SPACC_CRYPTO_IPSEC_HASH_PG_SZ;\n\t\tengine->fifo_sz\t\t= SPACC_CRYPTO_IPSEC_FIFO_SZ;\n\t\tengine->algs\t\t= ipsec_engine_algs;\n\t\tengine->num_algs\t= ARRAY_SIZE(ipsec_engine_algs);\n\t\tengine->aeads\t\t= ipsec_engine_aeads;\n\t\tengine->num_aeads\t= ARRAY_SIZE(ipsec_engine_aeads);\n\t} else if (of_device_is_compatible(np, "picochip,spacc-l2")) {\n\t\tengine->max_ctxs\t= SPACC_CRYPTO_L2_MAX_CTXS;\n\t\tengine->cipher_pg_sz\t= SPACC_CRYPTO_L2_CIPHER_PG_SZ;\n\t\tengine->hash_pg_sz\t= SPACC_CRYPTO_L2_HASH_PG_SZ;\n\t\tengine->fifo_sz\t\t= SPACC_CRYPTO_L2_FIFO_SZ;\n\t\tengine->algs\t\t= l2_engine_algs;\n\t\tengine->num_algs\t= ARRAY_SIZE(l2_engine_algs);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tengine->name = dev_name(&pdev->dev);\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tengine->regs = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(engine->regs))\n\t\treturn PTR_ERR(engine->regs);\n\n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!irq) {\n\t\tdev_err(&pdev->dev, "no memory/irq resource for engine\\n");\n\t\treturn -ENXIO;\n\t}\n\n\tif (devm_request_irq(&pdev->dev, irq->start, spacc_spacc_irq, 0,\n\t\t\t     engine->name, engine)) {\n\t\tdev_err(engine->dev, "failed to request IRQ\\n");\n\t\treturn -EBUSY;\n\t}\n\n\tengine->dev\t\t= &pdev->dev;\n\tengine->cipher_ctx_base = engine->regs + SPA_CIPH_KEY_BASE_REG_OFFSET;\n\tengine->hash_key_base\t= engine->regs + SPA_HASH_KEY_BASE_REG_OFFSET;\n\n\tengine->req_pool = dmam_pool_create(engine->name, engine->dev,\n\t\tMAX_DDT_LEN * sizeof(struct spacc_ddt), 8, SZ_64K);\n\tif (!engine->req_pool)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&engine->hw_lock);\n\n\tengine->clk = clk_get(&pdev->dev, "ref");\n\tif (IS_ERR(engine->clk)) {\n\t\tdev_info(&pdev->dev, "clk unavailable\\n");\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);\n\t\treturn PTR_ERR(engine->clk);\n\t}\n\n\tif (clk_prepare_enable(engine->clk)) {\n\t\tdev_info(&pdev->dev, "unable to prepare/enable clk\\n");\n\t\tclk_put(engine->clk);\n\t\treturn -EIO;\n\t}\n\n\terr = device_create_file(&pdev->dev, &dev_attr_stat_irq_thresh);\n\tif (err) {\n\t\tclk_disable_unprepare(engine->clk);\n\t\tclk_put(engine->clk);\n\t\treturn err;\n\t}\n\n\n\t/*\n\t * Use an IRQ threshold of 50% as a default. This seems to be a\n\t * reasonable trade off of latency against throughput but can be\n\t * changed at runtime.\n\t */\n\tengine->stat_irq_thresh = (engine->fifo_sz / 2);\n\n\t/*\n\t * Configure the interrupts. We only use the STAT_CNT interrupt as we\n\t * only submit a new packet for processing when we complete another in\n\t * the queue. This minimizes time spent in the interrupt handler.\n\t */\n\twritel(engine->stat_irq_thresh << SPA_IRQ_CTRL_STAT_CNT_OFFSET,\n\t       engine->regs + SPA_IRQ_CTRL_REG_OFFSET);\n\twritel(SPA_IRQ_EN_STAT_EN | SPA_IRQ_EN_GLBL_EN,\n\t       engine->regs + SPA_IRQ_EN_REG_OFFSET);\n\n\tsetup_timer(&engine->packet_timeout, spacc_packet_timeout,\n\t\t    (unsigned long)engine);\n\n\tINIT_LIST_HEAD(&engine->pending);\n\tINIT_LIST_HEAD(&engine->completed);\n\tINIT_LIST_HEAD(&engine->in_progress);\n\tengine->in_flight = 0;\n\ttasklet_init(&engine->complete, spacc_spacc_complete,\n\t\t     (unsigned long)engine);\n\n\tplatform_set_drvdata(pdev, engine);\n\n\tINIT_LIST_HEAD(&engine->registered_algs);\n\tfor (i = 0; i < engine->num_algs; ++i) {\n\t\tengine->algs[i].engine = engine;\n\t\terr = crypto_register_alg(&engine->algs[i].alg);\n\t\tif (!err) {\n\t\t\tlist_add_tail(&engine->algs[i].entry,\n\t\t\t\t      &engine->registered_algs);\n\t\t\tret = 0;\n\t\t}\n\t\tif (err)\n\t\t\tdev_err(engine->dev, "failed to register alg \\"%s\\"\\n",\n\t\t\t\tengine->algs[i].alg.cra_name);\n\t\telse\n\t\t\tdev_dbg(engine->dev, "registered alg \\"%s\\"\\n",\n\t\t\t\tengine->algs[i].alg.cra_name);\n\t}\n\n\tINIT_LIST_HEAD(&engine->registered_aeads);\n\tfor (i = 0; i < engine->num_aeads; ++i) {\n\t\tengine->aeads[i].engine = engine;\n\t\terr = crypto_register_aead(&engine->aeads[i].alg);\n	f
42427	3668	brcmf_report_wowl_wakeind	drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c	wakeup	1	13	\N	\N	\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_wowl_wakeind_le wake_ind_le;\n\tstruct cfg80211_wowlan_wakeup wakeup_data;\n\tstruct cfg80211_wowlan_wakeup *wakeup;\n\tu32 wakeind;\n\ts32 err;\n\tint timeout;\n\n\terr = brcmf_fil_iovar_data_get(ifp, "wowl_wakeind", &wake_ind_le,\n\t\t\t\t       sizeof(wake_ind_le));\n\tif (err) {\n\t\tbrcmf_err("Get wowl_wakeind failed, err = %d\\n", err);\n\t\treturn;\n\t}\n\n\twakeind = le32_to_cpu(wake_ind_le.ucode_wakeind);\n\tif (wakeind & (BRCMF_WOWL_MAGIC | BRCMF_WOWL_DIS | BRCMF_WOWL_BCN |\n\t\t       BRCMF_WOWL_RETR | BRCMF_WOWL_NET |\n\t\t       BRCMF_WOWL_PFN_FOUND)) {\n\t\twakeup = &wakeup_data;\n\t\tmemset(&wakeup_data, 0, sizeof(wakeup_data));\n\t\twakeup_data.pattern_idx = -1;\n\n\t\tif (wakeind & BRCMF_WOWL_MAGIC) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_MAGIC\\n");\n\t\t\twakeup_data.magic_pkt = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_DIS) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_DIS\\n");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_BCN) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_BCN\\n");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_RETR) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_RETR\\n");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_NET) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_NET\\n");\n\t\t\t/* For now always map to pattern 0, no API to get\n\t\t\t * correct information available at the moment.\n\t\t\t */\n\t\t\twakeup_data.pattern_idx = 0;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_PFN_FOUND) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_PFN_FOUND\\n");\n\t\t\ttimeout = wait_event_timeout(cfg->wowl.nd_data_wait,\n\t\t\t\tcfg->wowl.nd_data_completed,\n\t\t\t\tBRCMF_ND_INFO_TIMEOUT);\n\t\t\tif (!timeout)\n\t\t\t\tbrcmf_err("No result for wowl net detect\\n");\n\t\t\telse\n\t\t\t\twakeup_data.net_detect = cfg->wowl.nd_info;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_GTK_FAILURE) {\n\t\t\tbrcmf_dbg(INFO, "WOWL Wake indicator: BRCMF_WOWL_GTK_FAILURE\\n");\n\t\t\twakeup_data.gtk_rekey_failure = true;\n\t\t}\n\t} else {\n\t\twakeup = NULL;\n\t}\n\tcfg80211_report_wowlan_wakeup(&ifp->vif->wdev, wakeup, GFP_KERNEL);\n	f
42613	1219	ixgbe_rcv_msg_from_vf	drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c	msgbuf	1	13	\N	\N	\tu32 mbx_size = IXGBE_VFMAILBOX_SIZE;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 retval;\n\n\tretval = ixgbe_read_mbx(hw, msgbuf, mbx_size, vf);\n\n\tif (retval) {\n\t\tpr_err("Error receiving message from VF\\n");\n\t\treturn retval;\n\t}\n\n\t/* this is a message we already processed, do nothing */\n\tif (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))\n	f
42664	7204	bnx2x_8073_8727_external_rom_boot	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	fw_msgout	1	13	\N	\N	\tu32 count = 0;\n\tu16 fw_ver1, fw_msgout;\n\tint rc = 0;\n\n\t/* Boot port from external ROM  */\n\t/* EDC grst */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x0001);\n\n\t/* Ucode reboot and rst */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x008c);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0001);\n\n\t/* Reset internal microprocessor */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\n\n\t/* Release srst bit */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\n\n\t/* Delay 100ms per the PHY specifications */\n\tmsleep(100);\n\n\t/* 8073 sometimes taking longer to download */\n\tdo {\n\t\tcount++;\n\t\tif (count > 300) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t "bnx2x_8073_8727_external_rom_boot port %x:"\n\t\t\t\t "Download failed. fw version = 0x%x\\n",\n\t\t\t\t port, fw_ver1);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_ROM_VER1, &fw_ver1);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_M8051_MSGOUT_REG, &fw_msgout);\n\n\t\tusleep_range(1000, 2000);\n\t} while (fw_ver1 == 0 || fw_ver1 == 0x4321 ||\n\t\t\t((fw_msgout & 0xff) != 0x03 && (phy->type ==\n	f
39652	6979	btrfs_init_dev_stats	fs/btrfs/volumes.c	item_size	1	13	\N	\N	\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\n\t\tkey.objectid = BTRFS_DEV_STATS_OBJECTID;\n\t\tkey.type = BTRFS_PERSISTENT_ITEM_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n	f
42878	1214	w_e_end_csum_rs_req	drivers/block/drbd/drbd_worker.c	digest_size	1	13	\N	\N	\tstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tstruct drbd_device *device = peer_device->device;\n\tstruct digest_info *di;\n\tint digest_size;\n\tvoid *digest = NULL;\n\tint err, eq = 0;\n\n\tif (unlikely(cancel)) {\n\t\tdrbd_free_peer_req(device, peer_req);\n\t\tdec_unacked(device);\n\t\treturn 0;\n\t}\n\n\tif (get_ldev(device)) {\n\t\tdrbd_rs_complete_io(device, peer_req->i.sector);\n\t\tput_ldev(device);\n\t}\n\n\tdi = peer_req->digest;\n\n\tif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\n\t\t/* quick hack to try to avoid a race against reconfiguration.\n\t\t * a real fix would be much more involved,\n\t\t * introducing more locking mechanisms */\n\t\tif (peer_device->connection->csums_tfm) {\n\t\t\tdigest_size = crypto_ahash_digestsize(peer_device->connection->csums_tfm);\n\t\t\tD_ASSERT(device, digest_size == di->digest_size);\n\t\t\tdigest = kmalloc(digest_size, GFP_NOIO);\n\t\t}\n\t\tif (digest) {\n\t\t\tdrbd_csum_ee(peer_device->connection->csums_tfm, peer_req, digest);\n\t\t\teq = !memcmp(digest, di->digest, digest_size);\n	f
42907	612	acpi_install_method	drivers/acpi/acpica/nsxfname.c	aml_buffer	1	13	\N	\N	\tstruct acpi_table_header *table =\n\t    ACPI_CAST_PTR(struct acpi_table_header, buffer);\n\tu8 *aml_buffer;\n\tu8 *aml_start;\n\tchar *path;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_operand_object *method_obj;\n\tstruct acpi_parse_state parser_state;\n\tu32 aml_length;\n\tu16 opcode;\n\tu8 method_flags;\n\tacpi_status status;\n\n\t/* Parameter validation */\n\n\tif (!buffer) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t/* Table must be a DSDT or SSDT */\n\n\tif (!ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT) &&\n\t    !ACPI_COMPARE_NAME(table->signature, ACPI_SIG_SSDT)) {\n\t\treturn (AE_BAD_HEADER);\n\t}\n\n\t/* First AML opcode in the table must be a control method */\n\n\tparser_state.aml = buffer + sizeof(struct acpi_table_header);\n\topcode = acpi_ps_peek_opcode(&parser_state);\n\tif (opcode != AML_METHOD_OP) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t/* Extract method information from the raw AML */\n\n\tparser_state.aml += acpi_ps_get_opcode_size(opcode);\n\tparser_state.pkg_end = acpi_ps_get_next_package_end(&parser_state);\n\tpath = acpi_ps_get_next_namestring(&parser_state);\n\n\tmethod_flags = *parser_state.aml++;\n\taml_start = parser_state.aml;\n\taml_length = ACPI_PTR_DIFF(parser_state.pkg_end, aml_start);\n\n\t/*\n\t * Allocate resources up-front. We don't want to have to delete a new\n\t * node from the namespace if we cannot allocate memory.\n\t */\n\taml_buffer = ACPI_ALLOCATE(aml_length);\n\tif (!aml_buffer) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\n\tif (!method_obj) {\n\t\tACPI_FREE(aml_buffer);\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t/* Lock namespace for acpi_ns_lookup, we may be creating a new node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\t/* The lookup either returns an existing node or creates a new one */\n\n\tstatus =\n\t    acpi_ns_lookup(NULL, path, ACPI_TYPE_METHOD, ACPI_IMODE_LOAD_PASS1,\n\t\t\t   ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,\n\t\t\t   NULL, &node);\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tif (ACPI_FAILURE(status)) {\t/* ns_lookup */\n\t\tif (status != AE_ALREADY_EXISTS) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\t/* Node existed previously, make sure it is a method node */\n\n\t\tif (node->type != ACPI_TYPE_METHOD) {\n\t\t\tstatus = AE_TYPE;\n\t\t\tgoto error_exit;\n\t\t}\n\t}\n\n\t/* Copy the method AML to the local buffer */\n\n\tmemcpy(aml_buffer, aml_start, aml_length);\n	f
43051	838	do_one_initcall	init/main.c	msgbuf	1	13	\N	\N	\tint count = preempt_count();\n\tint ret;\n\tchar msgbuf[64];\n\n\tif (initcall_blacklisted(fn))\n\t\treturn -EPERM;\n\n\tif (initcall_debug)\n\t\tret = do_one_initcall_debug(fn);\n\telse\n\t\tret = fn();\n\n\tmsgbuf[0] = 0;\n\n\tif (preempt_count() != count) {\n\t\tsprintf(msgbuf, "preemption imbalance ");\n\t\tpreempt_count_set(count);\n\t}\n\tif (irqs_disabled()) {\n\t\tstrlcat(msgbuf, "disabled interrupts ", sizeof(msgbuf));\n\t\tlocal_irq_enable();\n\t}\n\tWARN(msgbuf[0], "initcall %pF returned with %s\\n", fn, msgbuf);\n	f
43081	151	hih6130_update_measurements	drivers/hwmon/hih6130.c	t	1	13	\N	\N	\tstruct hih6130 *hih6130 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = hih6130->client;\n\tint ret = 0;\n\tint t;\n\tunsigned char tmp[4];\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 4,\n\t\t\t.buf = tmp,\n\t\t}\n\t};\n\n\tmutex_lock(&hih6130->lock);\n\n\t/*\n\t * While the measurement can be completed in ~40ms the sensor takes\n\t * much longer to react to a change in external conditions. How quickly\n\t * it reacts depends on airflow and other factors outwith our control.\n\t * The datasheet specifies maximum 'Response time' for humidity at 8s\n\t * and temperature at 30s under specified conditions.\n\t * We therefore choose to only read the sensor at most once per second.\n\t * This trades off pointless activity polling the sensor much faster\n\t * than it can react against better response times in conditions more\n\t * favourable than specified in the datasheet.\n\t */\n\tif (time_after(jiffies, hih6130->last_update + HZ) || !hih6130->valid) {\n\n\t\t/*\n\t\t * Write to slave address to request a measurement.\n\t\t * According with the datasheet it should be with no data, but\n\t\t * for systems with I2C bus drivers that do not allow zero\n\t\t * length packets we write one dummy byte to allow sensor\n\t\t * measurements on them.\n\t\t */\n\t\ttmp[0] = 0;\n\t\tret = i2c_master_send(client, tmp, hih6130->write_length);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/* measurement cycle time is ~36.65msec */\n\t\tmsleep(40);\n\n\t\tret = i2c_transfer(client->adapter, msgs, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif ((tmp[0] & 0xC0) != 0) {\n\t\t\tdev_err(&client->dev, "Error while reading measurement result\\n");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tt = (tmp[0] << 8) + tmp[1];\n\t\thih6130->humidity = hih6130_rh_ticks_to_per_cent_mille(t);\n	f
59393	2527	fore200e_load_and_start_fw	drivers/atm/fore200e.c	fore200e_load_and_start_fw_$fw_header$obj$3	0	13	\N	\N	    const struct firmware *firmware;\n    struct device *device;\n    const struct fw_header *fw_header;\n    const __le32 *fw_data;\n    u32 fw_size;\n    u32 __iomem *load_addr;\n    char buf[48];\n    int err = -ENODEV;\n\n    if (strcmp(fore200e->bus->model_name, "PCA-200E") == 0)\n\tdevice = &((struct pci_dev *) fore200e->bus_dev)->dev;\n#ifdef CONFIG_SBUS\n    else if (strcmp(fore200e->bus->model_name, "SBA-200E") == 0)\n\tdevice = &((struct platform_device *) fore200e->bus_dev)->dev;\n#endif\n    else\n\treturn err;\n\n    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);\n    if ((err = request_firmware(&firmware, buf, device)) < 0) {\n\tprintk(FORE200E "problem loading firmware image %s\\n", fore200e->bus->model_name);\n\treturn err;\n    }\n\n    fw_data = (const __le32 *)firmware->data;\n    fw_size = firmware->size / sizeof(u32);\n    fw_header = (const struct fw_header *)firmware->data;\n    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);\n\n    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\\n",\n\t    fore200e->name, load_addr, fw_size);\n\n    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {\n\tprintk(FORE200E "corrupted %s firmware image\\n", fore200e->bus->model_name);\n\tgoto release;\n    }\n\n    for (; fw_size--; fw_data++, load_addr++)\n\tfore200e->bus->write(le32_to_cpu(*fw_data), load_addr);\n\n    DPRINTK(2, "device %s firmware being started\\n", fore200e->name);\n\n#if defined(__sparc_v9__)\n    /* reported to be required by SBA cards on some sparc64 hosts */\n    fore200e_spin(100);\n#endif\n\n    sprintf(buf, "\\rgo %x\\r", le32_to_cpu(fw_header->start_offset));\n	f
32877	884	atombios_dig_encoder_setup2	drivers/gpu/drm/radeon/atombios_encoders.c	frev	1	13	\N	\N	\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tunion dig_encoder_control args;\n\tint index = 0;\n\tuint8_t frev, crev;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint hpd_id = RADEON_HPD_NONE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\thpd_id = radeon_connector->hpd.hpd;\n\t}\n\n\t/* no dig encoder assigned */\n\tif (dig->dig_encoder == -1)\n\t\treturn;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);\n\telse {\n\t\tif (dig->dig_encoder)\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);\n\t}\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n	f
58894	897	ieee80211_ibss_process_chanswitch	net/mac80211/ibss.c	csa_ie.mode	1	13	\N	\N	\tstruct cfg80211_csa_settings params;\n\tstruct ieee80211_csa_ie csa_ie;\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tenum nl80211_channel_type ch_type;\n\tint err;\n\tu32 sta_flags;\n\n\tsdata_assert_lock(sdata);\n\n\tsta_flags = IEEE80211_STA_DISABLE_VHT;\n\tswitch (ifibss->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tsta_flags |= IEEE80211_STA_DISABLE_HT;\n\t\t/* fall through */\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tsta_flags |= IEEE80211_STA_DISABLE_40MHZ;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\terr = ieee80211_parse_ch_switch_ie(sdata, elems,\n\t\t\t\t\t   ifibss->chandef.chan->band,\n\t\t\t\t\t   sta_flags, ifibss->bssid, &csa_ie);\n\t/* can't switch to destination channel, fail */\n\tif (err < 0)\n\t\tgoto disconnect;\n\n\t/* did not contain a CSA */\n\tif (err)\n\t\treturn false;\n\n\t/* channel switch is not supported, disconnect */\n\tif (!(sdata->local->hw.wiphy->flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\tgoto disconnect;\n\n\tparams.count = csa_ie.count;\n\tparams.chandef = csa_ie.chandef;\n\n\tswitch (ifibss->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t/* keep our current HT mode (HT20/HT40+/HT40-), even if\n\t\t * another mode  has been announced. The mode is not adopted\n\t\t * within the beacon while doing CSA and we should therefore\n\t\t * keep the mode which we announce.\n\t\t */\n\t\tch_type = cfg80211_get_chandef_type(&ifibss->chandef);\n\t\tcfg80211_chandef_create(&params.chandef, params.chandef.chan,\n\t\t\t\t\tch_type);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tif (params.chandef.width != ifibss->chandef.width) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   "IBSS %pM received channel switch from incompatible channel width (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\\n",\n\t\t\t\t   ifibss->bssid,\n\t\t\t\t   params.chandef.chan->center_freq,\n\t\t\t\t   params.chandef.width,\n\t\t\t\t   params.chandef.center_freq1,\n\t\t\t\t   params.chandef.center_freq2);\n\t\t\tgoto disconnect;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* should not happen, sta_flags should prevent VHT modes. */\n\t\tWARN_ON(1);\n\t\tgoto disconnect;\n\t}\n\n\tif (!cfg80211_reg_can_beacon(sdata->local->hw.wiphy, &params.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC)) {\n\t\tsdata_info(sdata,\n\t\t\t   "IBSS %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\\n",\n\t\t\t   ifibss->bssid,\n\t\t\t   params.chandef.chan->center_freq,\n\t\t\t   params.chandef.width,\n\t\t\t   params.chandef.center_freq1,\n\t\t\t   params.chandef.center_freq2);\n\t\tgoto disconnect;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    NL80211_IFTYPE_ADHOC);\n\tif (err < 0)\n\t\tgoto disconnect;\n\tif (err > 0 && !ifibss->userspace_handles_dfs) {\n\t\t/* IBSS-DFS only allowed with a control program */\n\t\tgoto disconnect;\n\t}\n\n\tparams.radar_required = err;\n\n\tif (cfg80211_chandef_identical(&params.chandef,\n\t\t\t\t       &sdata->vif.bss_conf.chandef)) {\n\t\tibss_dbg(sdata,\n\t\t\t "received csa with an identical chandef, ignoring\\n");\n\t\treturn true;\n\t}\n\n\t/* all checks done, now perform the channel switch. */\n\tibss_dbg(sdata,\n\t\t "received channel switch announcement to go to channel %d MHz\\n",\n\t\t params.chandef.chan->center_freq);\n\n\tparams.block_tx = !!csa_ie.mode;\n	f
61801	1758	hci_sock_sendmsg	net/bluetooth/hci_sock.c	ocf & HCI_FLT_OCF_BITS	1	13	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct hci_mgmt_chan *chan;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG("sock %p sk %p", sock, sk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE|\n\t\t\t       MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\t\tbreak;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\tcase HCI_CHANNEL_LOGGING:\n\t\terr = hci_logging_frame(sk, msg, len);\n\t\tgoto done;\n\tdefault:\n\t\tmutex_lock(&mgmt_chan_list_lock);\n\t\tchan = __hci_mgmt_chan_find(hci_pi(sk)->channel);\n\t\tif (chan)\n\t\t\terr = hci_mgmt_cmd(chan, sk, msg, len);\n\t\telse\n\t\t\terr = -EINVAL;\n\n\t\tmutex_unlock(&mgmt_chan_list_lock);\n\t\tgoto done;\n\t}\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto done;\n\t}\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\thci_skb_pkt_type(skb) = skb->data[0];\n\tskb_pull(skb, 1);\n\n\tif (hci_pi(sk)->channel == HCI_CHANNEL_USER) {\n\t\t/* No permission check is needed for user channel\n\t\t * since that gets enforced when binding the socket.\n\t\t *\n\t\t * However check that the packet type is valid.\n\t\t */\n\t\tif (hci_skb_pkt_type(skb) != HCI_COMMAND_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_SCODATA_PKT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t} else if (hci_skb_pkt_type(skb) == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n	f
34041	255	ath10k_tm_cmd_utf_start	drivers/net/wireless/ath/ath10k/testmode.c	ar->testmode.utf_mode_fw.fw_file.codeswap_len	1	13	\N	\N	\tconst char *ver;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, "testmode cmd utf start\\n");\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH10K_STATE_UTF) {\n\t\tret = -EALREADY;\n\t\tgoto err;\n\t}\n\n\t/* start utf only when the driver is not in use  */\n\tif (ar->state != ATH10K_STATE_OFF) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tif (WARN_ON(ar->testmode.utf_mode_fw.fw_file.firmware != NULL)) {\n\t\t/* utf image is already downloaded, it shouldn't be */\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_tm_fetch_firmware(ar);\n\tif (ret) {\n\t\tath10k_err(ar, "failed to fetch UTF firmware: %d", ret);\n\t\tgoto err;\n\t}\n\n\tif (ar->testmode.utf_mode_fw.fw_file.codeswap_data &&\n\t    ar->testmode.utf_mode_fw.fw_file.codeswap_len) {\n	f
45283	6249	ath10k_wmi_op_gen_vdev_delete	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_vdev_delete_$cmd$obj	0	13	\N	\N	\tstruct wmi_vdev_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_delete_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n	f
45776	380	beiscsi_if_mod_gw	drivers/scsi/be2iscsi/be_mgmt.c	beiscsi_if_mod_gw_$req$obj$9$3	0	13	\N	\N	\tstruct be_cmd_set_def_gateway_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rt_val;\n\n\trt_val = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\n\t\t\t\tOPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,\n\t\t\t\tsizeof(*req));\n\tif (rt_val)\n\t\treturn rt_val;\n\n\treq = nonemb_cmd.va;\n\treq->action = action;\n\treq->ip_addr.ip_type = ip_type;\n\tmemcpy(req->ip_addr.addr, gw,\n	f
4886	80	multiq_enqueue	net/sched/sch_multiq.c	ret	1	13	\N	\N	\tstruct Qdisc *qdisc;\n\tint ret;\n\n\tqdisc = multiq_classify(skb, sch, &ret);\n#ifdef CONFIG_NET_CLS_ACT\n\tif (qdisc == NULL) {\n\n\t\tif (ret & __NET_XMIT_BYPASS)\n	f
9670	166	atmtcp_v_ioctl	drivers/atm/atmtcp.c	ci.vci_bits	1	13	\N	\N	\tstruct atm_cirange ci;\n\tstruct atm_vcc *vcc;\n\tstruct sock *s;\n\tint i;\n\n\tif (cmd != ATM_SETCIRANGE) return -ENOIOCTLCMD;\n\tif (copy_from_user(&ci, arg,sizeof(ci))) return -EFAULT;\n\tif (ci.vpi_bits == ATM_CI_MAX) ci.vpi_bits = MAX_VPI_BITS;\n\tif (ci.vci_bits == ATM_CI_MAX) ci.vci_bits = MAX_VCI_BITS;\n	f
24238	3336	reset_mmc	drivers/staging/rts5208/sd.c	sd_card	1	13	\N	\N	\tstruct sd_info *sd_card = &chip->sd_card;\n\tint retval, i = 0, j = 0, k = 0;\n\tbool switch_ddr = true;\n\tu8 rsp[16];\n\tu8 spec_ver = 0;\n\tu32 temp;\n\n#ifdef SUPPORT_SD_LOCK\n\tif (sd_card->sd_lock_status & SD_UNLOCK_POW_ON)\n\t\tgoto MMC_UNLOCK_ENTRY;\n#endif\n\nswitch_fail:\n\tretval = sd_prepare_reset(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn retval;\n\t}\n\n\tSET_MMC(sd_card);\n\nRTY_MMC_RST:\n\tretval = sd_send_cmd_get_rsp(chip, GO_IDLE_STATE, 0, SD_RSP_TYPE_R0,\n\t\t\t\t     NULL, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tdo {\n\t\tif (detect_card_cd(chip, SD_CARD) != STATUS_SUCCESS) {\n\t\t\tsd_set_err_code(chip, SD_NO_CARD);\n\t\t\trtsx_trace(chip);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = sd_send_cmd_get_rsp(chip, SEND_OP_COND,\n\t\t\t\t\t     (SUPPORT_VOLTAGE | 0x40000000),\n\t\t\t\t\t     SD_RSP_TYPE_R3, rsp, 5);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (sd_check_err_code(chip, SD_BUSY) ||\n\t\t\t    sd_check_err_code(chip, SD_TO_ERR)) {\n\t\t\t\tk++;\n\t\t\t\tif (k < 20) {\n\t\t\t\t\tsd_clr_err_code(chip);\n\t\t\t\t\tgoto RTY_MMC_RST;\n\t\t\t\t} else {\n\t\t\t\t\trtsx_trace(chip);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t\tif (j < 100) {\n\t\t\t\t\tsd_clr_err_code(chip);\n\t\t\t\t\tgoto RTY_MMC_RST;\n\t\t\t\t} else {\n\t\t\t\t\trtsx_trace(chip);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twait_timeout(20);\n\t\ti++;\n\t} while (!(rsp[1] & 0x80) && (i < 255));\n\n\tif (i == 255) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif ((rsp[1] & 0x60) == 0x40)\n\t\tSET_MMC_SECTOR_MODE(sd_card);\n\telse\n\t\tCLR_MMC_SECTOR_MODE(sd_card);\n\n\tretval = sd_send_cmd_get_rsp(chip, ALL_SEND_CID, 0, SD_RSP_TYPE_R2,\n\t\t\t\t     NULL, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tsd_card->sd_addr = 0x00100000;\n\tretval = sd_send_cmd_get_rsp(chip, SET_RELATIVE_ADDR, sd_card->sd_addr,\n\t\t\t\t     SD_RSP_TYPE_R6, rsp, 5);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = sd_check_csd(chip, 1);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tspec_ver = (sd_card->raw_csd[0] & 0x3C) >> 2;\n\n\tretval = sd_select_card(chip, 1);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = sd_send_cmd_get_rsp(chip, SET_BLOCKLEN, 0x200, SD_RSP_TYPE_R1,\n\t\t\t\t     NULL, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n#ifdef SUPPORT_SD_LOCK\nMMC_UNLOCK_ENTRY:\n\tretval = sd_update_lock_status(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n#endif\n\n\tretval = sd_set_clock_divider(chip, SD_CLK_DIVIDE_0);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_trace(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tchip->card_bus_width[chip->card2lun[SD_CARD]] = 1;\n\n\tif (!sd_card->mmc_dont_switch_bus) {\n\t\tif (spec_ver == 4) {\n\t\t\t/* MMC 4.x Cards */\n\t\t\tretval = mmc_switch_timing_bus(chip, switch_ddr);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tretval = sd_init_power(chip);\n\t\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\t\trtsx_trace(chip);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t\tsd_card->mmc_dont_switch_bus = 1;\n\t\t\t\trtsx_trace(chip);\n\t\t\t\tgoto switch_fail;\n\t\t\t}\n\t\t}\n\n\t\tif (CHK_MMC_SECTOR_MODE(sd_card) && (sd_card->capacity == 0)) {\n	f
42120	6359	qla4xxx_is_session_exists	drivers/scsi/qla4xxx/ql4_os.c	tmp_tddb	1	13	\N	\N	\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_tuple_ddb *fw_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tint idx;\n\tint ret = QLA_ERROR;\n\n\tfw_tddb = vzalloc(sizeof(*fw_tddb));\n\tif (!fw_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  "Memory Allocation failed.\\n"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  "Memory Allocation failed.\\n"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\tqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tqla4xxx_get_param_ddb(ddb_entry, tmp_tddb);\n\t\tif (!qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, false)) {\n	f
58504	417	dmi_sel_raw_read_helper	drivers/firmware/dmi-sysfs.c	&sel	1	13	\N	\N	\tstruct dmi_read_state *state = _state;\n\tstruct dmi_system_event_log sel;\n\n\tif (sizeof(sel) > dmi_entry_length(dh))\n\t\treturn -EIO;\n\n\tmemcpy(&sel, dh, sizeof(sel));\n\n\tswitch (sel.access_method) {\n\tcase DMI_SEL_ACCESS_METHOD_IO8:\n\tcase DMI_SEL_ACCESS_METHOD_IO2x8:\n\tcase DMI_SEL_ACCESS_METHOD_IO16:\n\t\treturn dmi_sel_raw_read_io(entry, &sel, state->buf,\n\t\t\t\t\t   state->pos, state->count);\n\tcase DMI_SEL_ACCESS_METHOD_PHYS32:\n\t\treturn dmi_sel_raw_read_phys32(entry, &sel, state->buf,\n	f
61229	3003	delayed_ref_async_start	fs/btrfs/extent-tree.c	trans	1	13	\N	\N	\tstruct async_delayed_refs *async = to_async_delayed_refs(work);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = async->root->fs_info;\n\tint ret;\n\n\t/* if the commit is already started, we don't need to wait here */\n\tif (btrfs_transaction_blocked(fs_info))\n\t\tgoto done;\n\n\ttrans = btrfs_join_transaction(async->root);\n\tif (IS_ERR(trans)) {\n\t\tasync->error = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * trans->sync means that when we call end_transaction, we won't\n\t * wait on delayed refs\n\t */\n\ttrans->sync = true;\n\n\t/* Don't bother flushing if we got into a different transaction */\n\tif (trans->transid > async->transid)\n\t\tgoto end;\n\n\tret = btrfs_run_delayed_refs(trans, fs_info, async->count);\n	f
36799	576	sun4i_can_err	drivers/net/can/sun4i_can.c	cf->data	1	13	\N	\N	\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state state = priv->can.state;\n\tenum can_state rx_state, tx_state;\n\tunsigned int rxerr, txerr, errc;\n\tu32 ecc, alc;\n\n\t/* we don't skip if alloc fails because we want the stats anyhow */\n\tskb = alloc_can_err_skb(dev, &cf);\n\n\terrc = readl(priv->base + SUN4I_REG_ERRC_ADDR);\n\trxerr = (errc >> 16) & 0xFF;\n\ttxerr = errc & 0xFF;\n\n\tif (skb) {\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\n\tif (isrc & SUN4I_INT_DATA_OR) {\n\t\t/* data overrun interrupt */\n\t\tnetdev_dbg(dev, "data overrun interrupt\\n");\n\t\tif (likely(skb)) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t}\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\t/* reset the CAN IP by entering reset mode\n\t\t * ignoring timeout error\n\t\t */\n\t\tset_reset_mode(dev);\n\t\tset_normal_mode(dev);\n\n\t\t/* clear bit */\n\t\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_CLEAR_OR_FLAG);\n\t}\n\tif (isrc & SUN4I_INT_ERR_WRN) {\n\t\t/* error warning interrupt */\n\t\tnetdev_dbg(dev, "error warning interrupt\\n");\n\n\t\tif (status & SUN4I_STA_BUS_OFF)\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\telse if (status & SUN4I_STA_ERR_STA)\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t}\n\tif (isrc & SUN4I_INT_BUS_ERR) {\n\t\t/* bus error interrupt */\n\t\tnetdev_dbg(dev, "bus error interrupt\\n");\n\t\tpriv->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tif (likely(skb)) {\n\t\t\tecc = readl(priv->base + SUN4I_REG_STA_ADDR);\n\n\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\t\tswitch (ecc & SUN4I_STA_MASK_ERR) {\n\t\t\tcase SUN4I_STA_BIT_ERR:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n	f
43984	1704	setup_blkring	drivers/block/xen-blkfront.c	rinfo->evtchn	1	13	\N	\N	\tstruct blkif_sring *sring;\n\tint err, i;\n\tstruct blkfront_info *info = rinfo->dev_info;\n\tunsigned long ring_size = info->nr_ring_pages * XEN_PAGE_SIZE;\n\tgrant_ref_t gref[XENBUS_MAX_RING_GRANTS];\n\n\tfor (i = 0; i < info->nr_ring_pages; i++)\n\t\trinfo->ring_ref[i] = GRANT_INVALID_REF;\n\n\tsring = (struct blkif_sring *)__get_free_pages(GFP_NOIO | __GFP_HIGH,\n\t\t\t\t\t\t       get_order(ring_size));\n\tif (!sring) {\n\t\txenbus_dev_fatal(dev, -ENOMEM, "allocating shared ring");\n\t\treturn -ENOMEM;\n\t}\n\tSHARED_RING_INIT(sring);\n\tFRONT_RING_INIT(&rinfo->ring, sring, ring_size);\n\n\terr = xenbus_grant_ring(dev, rinfo->ring.sring, info->nr_ring_pages, gref);\n\tif (err < 0) {\n\t\tfree_pages((unsigned long)sring, get_order(ring_size));\n\t\trinfo->ring.sring = NULL;\n\t\tgoto fail;\n\t}\n\tfor (i = 0; i < info->nr_ring_pages; i++)\n\t\trinfo->ring_ref[i] = gref[i];\n\n\terr = xenbus_alloc_evtchn(dev, &rinfo->evtchn);\n\tif (err)\n\t\tgoto fail;\n\n\terr = bind_evtchn_to_irqhandler(rinfo->evtchn, blkif_interrupt, 0,\n	f
24892	1576	LNetNIInit	drivers/staging/lustre/lnet/lnet/api-ni.c	pinfo	1	13	\N	\N	\tint im_a_router = 0;\n\tint rc;\n\tint ni_count;\n\tstruct lnet_ping_info *pinfo;\n\tstruct lnet_handle_md md_handle;\n\tstruct list_head net_head;\n\n\tINIT_LIST_HEAD(&net_head);\n\n\tmutex_lock(&the_lnet.ln_api_mutex);\n\n\tCDEBUG(D_OTHER, "refs %d\\n", the_lnet.ln_refcount);\n\n\tif (the_lnet.ln_refcount > 0) {\n\t\trc = the_lnet.ln_refcount++;\n\t\tmutex_unlock(&the_lnet.ln_api_mutex);\n\t\treturn rc;\n\t}\n\n\trc = lnet_prepare(requested_pid);\n\tif (rc) {\n\t\tmutex_unlock(&the_lnet.ln_api_mutex);\n\t\treturn rc;\n\t}\n\n\t/* Add in the loopback network */\n\tif (!lnet_ni_alloc(LNET_MKNET(LOLND, 0), NULL, &net_head)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_empty_list;\n\t}\n\n\t/*\n\t * If LNet is being initialized via DLC it is possible\n\t * that the user requests not to load module parameters (ones which\n\t * are supported by DLC) on initialization.  Therefore, make sure not\n\t * to load networks, routes and forwarding from module parameters\n\t * in this case. On cleanup in case of failure only clean up\n\t * routes if it has been loaded\n\t */\n\tif (!the_lnet.ln_nis_from_mod_params) {\n\t\trc = lnet_parse_networks(&net_head, lnet_get_networks());\n\t\tif (rc < 0)\n\t\t\tgoto err_empty_list;\n\t}\n\n\tni_count = lnet_startup_lndnis(&net_head);\n\tif (ni_count < 0) {\n\t\trc = ni_count;\n\t\tgoto err_empty_list;\n\t}\n\n\tif (!the_lnet.ln_nis_from_mod_params) {\n\t\trc = lnet_parse_routes(lnet_get_routes(), &im_a_router);\n\t\tif (rc)\n\t\t\tgoto err_shutdown_lndnis;\n\n\t\trc = lnet_check_routes();\n\t\tif (rc)\n\t\t\tgoto err_destroy_routes;\n\n\t\trc = lnet_rtrpools_alloc(im_a_router);\n\t\tif (rc)\n\t\t\tgoto err_destroy_routes;\n\t}\n\n\trc = lnet_acceptor_start();\n\tif (rc)\n\t\tgoto err_destroy_routes;\n\n\tthe_lnet.ln_refcount = 1;\n\t/* Now I may use my own API functions... */\n\n\trc = lnet_ping_info_setup(&pinfo, &md_handle, ni_count, true);\n\tif (rc)\n\t\tgoto err_acceptor_stop;\n\n\tlnet_ping_target_update(pinfo, md_handle);\n	f
61707	1320	dce_v6_0_audio_write_sad_regs	drivers/gpu/drm/amd/amdgpu/dce_v6_0.c	sads	1	13	\N	\N	\tstruct amdgpu_device *adev = encoder->dev->dev_private;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\tstruct drm_connector *connector;\n\tstruct amdgpu_connector *amdgpu_connector = NULL;\n\tstruct cea_sad *sads;\n\tint i, sad_count;\n\n\tstatic const u16 eld_reg_to_type[][2] = {\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\n\t\t{ ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\n\t};\n\n\tlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\n\t\tif (connector->encoder == encoder) {\n\t\t\tamdgpu_connector = to_amdgpu_connector(connector);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!amdgpu_connector) {\n\t\tDRM_ERROR("Couldn't find encoder's connector\\n");\n\t\treturn;\n\t}\n\n\tsad_count = drm_edid_to_sad(amdgpu_connector_edid(connector), &sads);\n\tif (sad_count <= 0) {\n\t\tDRM_ERROR("Couldn't read SADs: %d\\n", sad_count);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\n\t\tu32 tmp = 0;\n\t\tu8 stereo_freqs = 0;\n\t\tint max_channels = -1;\n\t\tint j;\n\n\t\tfor (j = 0; j < sad_count; j++) {\n\t\t\tstruct cea_sad *sad = &sads[j];\n	f
32534	4718	si_init_arb_table_index	drivers/gpu/drm/amd/amdgpu/si_dpm.c	tmp	1	13	\N	\N	\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tint ret;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev, si_pi->arb_table_start,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= 0x00FFFFFF;\n\ttmp |= MC_CG_ARB_FREQ_F1 << 24;\n\n\treturn amdgpu_si_write_smc_sram_dword(adev, si_pi->arb_table_start,\n	f
34659	1003	defrag_check_next_extent	fs/btrfs/ioctl.c	next	1	13	\N	\N	\tstruct extent_map *next;\n\tbool ret = true;\n\n\t/* this is the last extent */\n\tif (em->start + em->len >= i_size_read(inode))\n\t\treturn false;\n\n\tnext = defrag_lookup_extent(inode, em->start + em->len);\n\tif (!next || next->block_start >= EXTENT_MAP_LAST_BYTE)\n	f
42245	846	efx_mcdi_phy_module_type	drivers/net/ethernet/sfc/mcdi_port.c	efx_mcdi_phy_module_type_	1	13	\N	\N	\tstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\n\n\tif (phy_data->media != MC_CMD_MEDIA_QSFP_PLUS)\n\t\treturn phy_data->media;\n\n\t/* A QSFP+ NIC may actually have an SFP+ module attached.\n\t * The ID is page 0, byte 0.\n\t */\n\tswitch (efx_mcdi_phy_get_module_eeprom_byte(efx, 0, 0)) {\n	f
3270	102	da9052_i2c_disable_multiwrite	drivers/mfd/da9052-i2c.c	reg_val	1	13	\N	\N	\tint reg_val, ret;\n\n\tret = regmap_read(da9052->regmap, DA9052_CONTROL_B_REG, &reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(reg_val & DA9052_CONTROL_B_WRITEMODE)) {\n	f
42962	125	acpi_ec_add_debugfs	drivers/acpi/ec_sys.c	dev_dir	1	13	\N	\N	\tstruct dentry *dev_dir;\n\tchar name[64];\n\tumode_t mode = 0400;\n\n\tif (ec_device_count == 0) {\n\t\tacpi_ec_debugfs_dir = debugfs_create_dir("ec", NULL);\n\t\tif (!acpi_ec_debugfs_dir)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsprintf(name, "ec%u", ec_device_count);\n\tdev_dir = debugfs_create_dir(name, acpi_ec_debugfs_dir);\n\tif (!dev_dir) {\n	f
43993	3288	check_committed_ref	fs/btrfs/extent-tree.c	ref	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_data_ref *ref;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tint type;\n\tint ret;\n\n\tkey.objectid = bytenr;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_search_slot(NULL, extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0); /* Corruption */\n\n\tret = -ENOENT;\n\tif (path->slots[0] == 0)\n\t\tgoto out;\n\n\tpath->slots[0]--;\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tif (key.objectid != bytenr || key.type != BTRFS_EXTENT_ITEM_KEY)\n\t\tgoto out;\n\n\tret = 1;\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (item_size < sizeof(*ei)) {\n\t\tWARN_ON(item_size != sizeof(struct btrfs_extent_item_v0));\n\t\tgoto out;\n\t}\n#endif\n\tei = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\n\tif (item_size != sizeof(*ei) +\n\t    btrfs_extent_inline_ref_size(BTRFS_EXTENT_DATA_REF_KEY))\n\t\tgoto out;\n\n\tif (btrfs_extent_generation(leaf, ei) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tgoto out;\n\n\tiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\n\ttype = btrfs_get_extent_inline_ref_type(leaf, iref, BTRFS_REF_TYPE_DATA);\n\tif (type != BTRFS_EXTENT_DATA_REF_KEY)\n\t\tgoto out;\n\n\tref = (struct btrfs_extent_data_ref *)(&iref->offset);\n	f
55291	649	nmclan_config	drivers/net/ethernet/amd/nmclan_cs.c	sig	1	13	\N	\N	  struct net_device *dev = link->priv;\n  mace_private *lp = netdev_priv(dev);\n  u8 *buf;\n  size_t len;\n  int i, ret;\n  unsigned int ioaddr;\n\n  dev_dbg(&link->dev, "nmclan_config\\n");\n\n  link->io_lines = 5;\n  ret = pcmcia_request_io(link);\n  if (ret)\n\t  goto failed;\n  ret = pcmcia_request_irq(link, mace_interrupt);\n  if (ret)\n\t  goto failed;\n  ret = pcmcia_enable_device(link);\n  if (ret)\n\t  goto failed;\n\n  dev->irq = link->irq;\n  dev->base_addr = link->resource[0]->start;\n\n  ioaddr = dev->base_addr;\n\n  /* Read the ethernet address from the CIS. */\n  len = pcmcia_get_tuple(link, 0x80, &buf);\n  if (!buf || len < ETH_ALEN) {\n\t  kfree(buf);\n\t  goto failed;\n  }\n  memcpy(dev->dev_addr, buf, ETH_ALEN);\n  kfree(buf);\n\n  /* Verify configuration by reading the MACE ID. */\n  {\n    char sig[2];\n\n    sig[0] = mace_read(lp, ioaddr, MACE_CHIPIDL);\n    sig[1] = mace_read(lp, ioaddr, MACE_CHIPIDH);\n    if ((sig[0] == 0x40) && ((sig[1] & 0x0F) == 0x09)) {\n	f
58347	873	txq_submit_tso	drivers/net/ethernet/marvell/mv643xx_eth.c	int	1	13	\N	\N	\tstruct mv643xx_eth_private *mp = txq_to_mp(txq);\n\tint total_len, data_left, ret;\n\tint desc_count = 0;\n\tstruct tso_t tso;\n\tint hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\n\tstruct tx_desc *first_tx_desc;\n\tu32 first_cmd_sts = 0;\n\n\t/* Count needed descriptors */\n\tif ((txq->tx_desc_count + tso_count_descs(skb)) >= txq->tx_ring_size) {\n\t\tnetdev_dbg(dev, "not enough descriptors for TSO!\\n");\n\t\treturn -EBUSY;\n\t}\n\n\tfirst_tx_desc = &txq->tx_desc_area[txq->tx_curr_desc];\n\n\t/* Initialize the TSO handler, and prepare the first payload */\n\ttso_start(skb, &tso);\n\n\ttotal_len = skb->len - hdr_len;\n\twhile (total_len > 0) {\n\t\tbool first_desc = (desc_count == 0);\n\t\tchar *hdr;\n\n\t\tdata_left = min_t(int, skb_shinfo(skb)->gso_size, total_len);\n\t\ttotal_len -= data_left;\n\t\tdesc_count++;\n\n\t\t/* prepare packet headers: MAC + IP + TCP */\n\t\thdr = txq->tso_hdrs + txq->tx_curr_desc * TSO_HEADER_SIZE;\n\t\ttso_build_hdr(skb, hdr, &tso, data_left, total_len == 0);\n\t\ttxq_put_hdr_tso(skb, txq, data_left, &first_cmd_sts,\n\t\t\t\tfirst_desc);\n\n\t\twhile (data_left > 0) {\n\t\t\tint size;\n\t\t\tdesc_count++;\n\n\t\t\tsize = min_t(int, tso.size, data_left);\n	f
27925	64	hfsplus_lookup	fs/hfsplus/dir.c	type	1	13	\N	\N	\tstruct inode *inode = NULL;\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\thfsplus_cat_entry entry;\n\tint err;\n\tu32 cnid, linkid = 0;\n\tu16 type;\n\n\tsb = dir->i_sb;\n\n\tdentry->d_fsdata = NULL;\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino,\n\t\t\t&dentry->d_name);\n\tif (unlikely(err < 0))\n\t\tgoto fail;\nagain:\n\terr = hfs_brec_read(&fd, &entry, sizeof(entry));\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\thfs_find_exit(&fd);\n\t\t\t/* No such entry */\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto fail;\n\t}\n\ttype = be16_to_cpu(entry.type);\n\tif (type == HFSPLUS_FOLDER) {\n	f
1141	814	debug_objects_init_debugfs	lib/debugobjects.c	dbgdir	1	13	\N	\N	\tstruct dentry *dbgdir, *dbgstats;\n\n\tif (!debug_objects_enabled)\n\t\treturn 0;\n\n\tdbgdir = debugfs_create_dir("debug_objects", NULL);\n\tif (!dbgdir)\n	f
7589	374	acpi_sleep_dmi_check	drivers/acpi/sleep.c	year	1	13	\N	\N	\tint year;\n\n\tif (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)\n	f
7660	185	btt_map_read	drivers/nvdimm/btt.c	ze	1	13	\N	\N	\tint ret;\n\t__le32 in;\n\tu32 raw_mapping, postmap, ze, z_flag, e_flag;\n\tu64 ns_off = arena->mapoff + (lba * MAP_ENT_SIZE);\n\n\tif (unlikely(lba >= arena->external_nlba))\n\t\tdev_err_ratelimited(to_dev(arena),\n\t\t\t"%s: lba %#x out of range (max: %#x)\\n",\n\t\t\t__func__, lba, arena->external_nlba);\n\n\tret = arena_read_bytes(arena, ns_off, &in, MAP_ENT_SIZE, rwb_flags);\n\tif (ret)\n\t\treturn ret;\n\n\traw_mapping = le32_to_cpu(in);\n\n\tz_flag = ent_z_flag(raw_mapping);\n\te_flag = ent_e_flag(raw_mapping);\n\tze = (z_flag << 1) + e_flag;\n\tpostmap = ent_lba(raw_mapping);\n\n\t/* Reuse the {z,e}_flag variables for *trim and *error */\n\tz_flag = 0;\n\te_flag = 0;\n\n\tswitch (ze) {\n	f
36842	1042	prism2_sta_send_mgmt	drivers/net/wireless/intersil/hostap/hostap_main.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct hostap_ieee80211_mgmt *mgmt;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct net_device *dev = local->dev;\n\n\tskb = dev_alloc_skb(IEEE80211_MGMT_HDR_LEN + bodylen);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tmgmt = skb_put_zero(skb, IEEE80211_MGMT_HDR_LEN);\n	f
44303	1208	trace_event_raw_event_ext4_da_release_space	fs/ext4/super.c	inode	1	13	\N	\N	\thandle_t *handle = fs_data;\n\tint res, res2, credits, retries = 0;\n\n\t/*\n\t * Encrypting the root directory is not allowed because e2fsck expects\n\t * lost+found to exist and be unencrypted, and encrypting the root\n\t * directory would imply encrypting the lost+found directory as well as\n\t * the filename "lost+found" itself.\n\t */\n\tif (inode->i_ino == EXT4_ROOT_INO)\n\t\treturn -EPERM;\n\n\tres = ext4_convert_inline_data(inode);\n\tif (res)\n\t\treturn res;\n\n\t/*\n\t * If a journal handle was specified, then the encryption context is\n\t * being set on a new inode via inheritance and is part of a larger\n\t * transaction to create the inode.  Otherwise the encryption context is\n\t * being set on an existing inode in its own transaction.  Only in the\n\t * latter case should the "retry on ENOSPC" logic be used.\n\t */\n\n\tif (handle) {\n\t\tres = ext4_xattr_set_handle(handle, inode,\n\t\t\t\t\t    EXT4_XATTR_INDEX_ENCRYPTION,\n\t\t\t\t\t    EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\t\t    ctx, len, 0);\n\t\tif (!res) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_ENCRYPT);\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\tEXT4_STATE_MAY_INLINE_DATA);\n\t\t\t/*\n\t\t\t * Update inode->i_flags - e.g. S_DAX may get disabled\n\t\t\t */\n\t\t\text4_set_inode_flags(inode);\n\t\t}\n\t\treturn res;\n\t}\n\n\tres = dquot_initialize(inode);\n\tif (res)\n\t\treturn res;\nretry:\n\tres = ext4_xattr_set_credits(inode, len, false /* is_create */,\n\t\t\t\t     &credits);\n\tif (res)\n\t\treturn res;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tres = ext4_xattr_set_handle(handle, inode, EXT4_XATTR_INDEX_ENCRYPTION,\n\t\t\t\t    EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\t    ctx, len, 0);\n\tif (!res) {\n\t\text4_set_inode_flag(inode, EXT4_INODE_ENCRYPT);\n	f
61214	2093	fst_ioctl	drivers/net/wan/farsync.c	&info	1	13	\N	\N	\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, "ioctl: %x, %p\\n", cmd, ifr->ifr_data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t/* Code write (download) */\n\n\t\t/* First copy in the header with the length and offset of data\n\t\t * to write\n\t\t */\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&wrthdr, ifr->ifr_data,\n\t\t\t\t   sizeof (struct fstioc_write))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* Sanity check the parameters. We don't support partial writes\n\t\t * when going over the top\n\t\t */\n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE) {\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t/* Now copy the data to the card. */\n\n\t\tbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t/* Writes to the memory of a card in the reset state constitute\n\t\t * a download\n\t\t */\n\t\tif (card->state == FST_RESET) {\n\t\t\tcard->state = FST_DOWNLOAD;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t/* If card has just been started check the shared memory config\n\t\t * version and marker\n\t\t */\n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t/* If everything checked out enable card interrupts */\n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\n\t\t/*\n\t\t * Most of the settings have been moved to the generic ioctls\n\t\t * this just covers debug and board ident now\n\t\t */\n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err("Attempt to configure card %d in non-running state (%d)\\n",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treturn set_conf_from_info(card, port, &info);\n	f
62796	1129	mt9t112_probe	drivers/media/i2c/soc_camera/mt9t112.c	priv	1	13	\N	\N	\tstruct mt9t112_priv *priv;\n\tstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\n\tstruct v4l2_rect rect = {\n\t\t.width = VGA_WIDTH,\n\t\t.height = VGA_HEIGHT,\n\t\t.left = (MAX_WIDTH - VGA_WIDTH) / 2,\n\t\t.top = (MAX_HEIGHT - VGA_HEIGHT) / 2,\n\t};\n\tint ret;\n\n\tif (!ssdd || !ssdd->drv_priv) {\n\t\tdev_err(&client->dev, "mt9t112: missing platform data!\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->info = ssdd->drv_priv;\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &mt9t112_subdev_ops);\n\n\tpriv->clk = v4l2_clk_get(&client->dev, "mclk");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tret = mt9t112_camera_probe(client);\n\n\t/* Cannot fail: using the default supported pixel code */\n\tif (!ret)\n\t\tmt9t112_set_params(priv, &rect, MEDIA_BUS_FMT_UYVY8_2X8);\n	f
-1060	3188	SiS_GetCRT2DataLVDS	drivers/video/fbdev/sis/init301.c	ResIndex	2	3	\N	\N	   unsigned short CRT2Index, ResIndex, backup;\n   const struct SiS_LVDSData *LVDSData = NULL;\n\n   SiS_GetCRT2ResInfo(SiS_Pr, ModeNo, ModeIdIndex);\n\n   if(SiS_Pr->SiS_VBType & VB_SISVB) {\n      SiS_Pr->SiS_RVBHCMAX  = 1;\n      SiS_Pr->SiS_RVBHCFACT = 1;\n      SiS_Pr->SiS_NewFlickerMode = 0;\n      SiS_Pr->SiS_RVBHRS = 50;\n      SiS_Pr->SiS_RY1COE = 0;\n      SiS_Pr->SiS_RY2COE = 0;\n      SiS_Pr->SiS_RY3COE = 0;\n      SiS_Pr->SiS_RY4COE = 0;\n      SiS_Pr->SiS_RVBHRS2 = 0;\n   }\n\n   if((SiS_Pr->SiS_VBType & VB_SISVB) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA)) {\n\n#ifdef CONFIG_FB_SIS_315\n      SiS_CalcPanelLinkTiming(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);\n      SiS_CalcLCDACRT1Timing(SiS_Pr, ModeNo, ModeIdIndex);\n#endif\n\n   } else {\n\n      /* 301BDH needs LVDS Data */\n      backup = SiS_Pr->SiS_IF_DEF_LVDS;\n      if((SiS_Pr->SiS_VBType & VB_NoLCD) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD)) {\n\t SiS_Pr->SiS_IF_DEF_LVDS = 1;\n      }\n\n      SiS_GetCRT2Ptr(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex,\n                     \t\t            &CRT2Index, &ResIndex);\n\n      SiS_Pr->SiS_IF_DEF_LVDS = backup;\n\n      switch(CRT2Index) {\n\t case 10: LVDSData = SiS_Pr->SiS_LVDS320x240Data_1;    break;\n\t case 14: LVDSData = SiS_Pr->SiS_LVDS320x240Data_2;    break;\n\t case 12: LVDSData = SiS_Pr->SiS_LVDS640x480Data_1;    break;\n\t case 16: LVDSData = SiS_Pr->SiS_LVDS800x600Data_1;    break;\n\t case 18: LVDSData = SiS_Pr->SiS_LVDS1024x600Data_1;   break;\n\t case 20: LVDSData = SiS_Pr->SiS_LVDS1024x768Data_1;   break;\n#ifdef CONFIG_FB_SIS_300\n\t case 80: LVDSData = SiS_Pr->SiS_LVDSBARCO1366Data_1;  break;\n\t case 81: LVDSData = SiS_Pr->SiS_LVDSBARCO1366Data_2;  break;\n\t case 82: LVDSData = SiS_Pr->SiS_LVDSBARCO1024Data_1;  break;\n\t case 84: LVDSData = SiS_Pr->SiS_LVDS848x480Data_1;    break;\n\t case 85: LVDSData = SiS_Pr->SiS_LVDS848x480Data_2;    break;\n#endif\n\t case 90: LVDSData = SiS_Pr->SiS_CHTVUNTSCData;        break;\n\t case 91: LVDSData = SiS_Pr->SiS_CHTVONTSCData;        break;\n\t case 92: LVDSData = SiS_Pr->SiS_CHTVUPALData;         break;\n\t case 93: LVDSData = SiS_Pr->SiS_CHTVOPALData;         break;\n\t case 94: LVDSData = SiS_Pr->SiS_CHTVUPALMData;        break;\n\t case 95: LVDSData = SiS_Pr->SiS_CHTVOPALMData;        break;\n\t case 96: LVDSData = SiS_Pr->SiS_CHTVUPALNData;        break;\n\t case 97: LVDSData = SiS_Pr->SiS_CHTVOPALNData;        break;\n\t case 99: LVDSData = SiS_Pr->SiS_CHTVSOPALData;\t       break;\n      }\n\n      if(LVDSData) {\n\t SiS_Pr->SiS_VGAHT = (LVDSData+ResIndex)->VGAHT;\n\t SiS_Pr->SiS_VGAVT = (LVDSData+ResIndex)->VGAVT;\n\t SiS_Pr->SiS_HT    = (LVDSData+ResIndex)->LCDHT;\n\t SiS_Pr->SiS_VT    = (LVDSData+ResIndex)->LCDVT;\n      } else {\n\t SiS_CalcPanelLinkTiming(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);\n      }\n\n      if( (!(SiS_Pr->SiS_VBType & VB_SISVB)) &&\n\t  (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) &&\n\t  (!(SiS_Pr->SiS_LCDInfo & LCDPass11)) ) {\n\t if( (!(SiS_Pr->SiS_LCDInfo & DontExpandLCD)) ||\n\t     (SiS_Pr->SiS_SetFlag & SetDOSMode) ) {\n\t    SiS_Pr->SiS_HDE = SiS_Pr->PanelXRes;\n            SiS_Pr->SiS_VDE = SiS_Pr->PanelYRes;\n#ifdef CONFIG_FB_SIS_300\n\t    if(SiS_Pr->SiS_CustomT == CUT_BARCO1366) {\n\t       if(ResIndex < 0x08) {\n	f
29908	1795	pm8001_send_read_log	drivers/scsi/pm8001/pm8001_hwi.c	ccb_tag	1	13	\N	\N	\tstruct sata_start_req sata_cmd;\n\tint res;\n\tu32 ccb_tag;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct sas_task *task = NULL;\n\tstruct host_to_dev_fis fis;\n\tstruct domain_device *dev;\n\tstruct inbound_queue_table *circularQ;\n\tu32 opc = OPC_INB_SATA_HOST_OPSTART;\n\n\ttask = sas_alloc_slow_task(GFP_ATOMIC);\n\n\tif (!task) {\n\t\tPM8001_FAIL_DBG(pm8001_ha,\n\t\t\tpm8001_printk("cannot allocate task !!!\\n"));\n\t\treturn;\n\t}\n\ttask->task_done = pm8001_task_done;\n\n\tres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\n\tif (res) {\n\t\tsas_free_task(task);\n\t\tPM8001_FAIL_DBG(pm8001_ha,\n\t\t\tpm8001_printk("cannot allocate tag !!!\\n"));\n\t\treturn;\n\t}\n\n\t/* allocate domain device by ourselves as libsas\n\t * is not going to provide any\n\t*/\n\tdev = kzalloc(sizeof(struct domain_device), GFP_ATOMIC);\n\tif (!dev) {\n\t\tsas_free_task(task);\n\t\tpm8001_tag_free(pm8001_ha, ccb_tag);\n	f
30165	234	exynos_report_trigger	drivers/thermal/samsung/exynos_tmu.c	temp	1	13	\N	\N	\tchar data[10], *envp[] = { data, NULL };\n\tstruct thermal_zone_device *tz = p->tzd;\n\tint temp;\n\tunsigned int i;\n\n\tif (!tz) {\n\t\tpr_err("No thermal zone device defined\\n");\n\t\treturn;\n\t}\n\n\tthermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\n\n\tmutex_lock(&tz->lock);\n\t/* Find the level for which trip happened */\n\tfor (i = 0; i < of_thermal_get_ntrips(tz); i++) {\n\t\ttz->ops->get_trip_temp(tz, i, &temp);\n\t\tif (tz->last_temperature < temp)\n	f
52117	3550	ext4_rename	fs/ext4/namei.c	old.bh	1	13	\N	\N	\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tint force_reread;\n\tint retval;\n\tstruct inode *whiteout = NULL;\n\tint credits;\n\tu8 old_file_type;\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT)) &&\n\t    (!projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tif ((ext4_encrypted_inode(old_dir) &&\n\t     !fscrypt_has_encryption_key(old_dir)) ||\n\t    (ext4_encrypted_inode(new_dir) &&\n\t     !fscrypt_has_encryption_key(new_dir)))\n\t\treturn -ENOKEY;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new.inode) {\n\t\tretval = dquot_initialize(new.inode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de, NULL);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n	f
53872	1133	alc5632_i2c_probe	sound/soc/codecs/alc5632.c	vid1	1	13	\N	\N	\tstruct alc5632_priv *alc5632;\n\tint ret, ret1, ret2;\n\tunsigned int vid1, vid2;\n\n\talc5632 = devm_kzalloc(&client->dev,\n\t\t\t sizeof(struct alc5632_priv), GFP_KERNEL);\n\tif (alc5632 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, alc5632);\n\n\talc5632->regmap = devm_regmap_init_i2c(client, &alc5632_regmap);\n\tif (IS_ERR(alc5632->regmap)) {\n\t\tret = PTR_ERR(alc5632->regmap);\n\t\tdev_err(&client->dev, "regmap_init() failed: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret1 = regmap_read(alc5632->regmap, ALC5632_VENDOR_ID1, &vid1);\n\tret2 = regmap_read(alc5632->regmap, ALC5632_VENDOR_ID2, &vid2);\n\tif (ret1 != 0 || ret2 != 0) {\n\t\tdev_err(&client->dev,\n\t\t"Failed to read chip ID: ret1=%d, ret2=%d\\n", ret1, ret2);\n\t\treturn -EIO;\n\t}\n\n\tvid2 >>= 8;\n\n\tif ((vid1 != 0x10EC) || (vid2 != id->driver_data)) {\n	f
60809	598	rsnd_adg_probe	sound/soc/sh/rcar/adg.c	adg	1	13	\N	\N	\tstruct rsnd_adg *adg;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint ret;\n\n\tadg = devm_kzalloc(dev, sizeof(*adg), GFP_KERNEL);\n\tif (!adg)\n\t\treturn -ENOMEM;\n\n\tret = rsnd_mod_init(priv, &adg->mod, &adg_ops,\n\t\t      NULL, NULL, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\trsnd_adg_get_clkin(priv, adg);\n\trsnd_adg_get_clkout(priv, adg);\n	f
60928	399	virtblk_config_changed_work	drivers/block/virtio_blk.c	nblocks	1	13	\N	\N	\tstruct virtio_blk *vblk =\n\t\tcontainer_of(work, struct virtio_blk, config_work);\n\tstruct virtio_device *vdev = vblk->vdev;\n\tstruct request_queue *q = vblk->disk->queue;\n\tchar cap_str_2[10], cap_str_10[10];\n\tchar *envp[] = { "RESIZE=1", NULL };\n\tunsigned long long nblocks;\n\tu64 capacity;\n\n\t/* Host must always specify the capacity. */\n\tvirtio_cread(vdev, struct virtio_blk_config, capacity, &capacity);\n\n\t/* If capacity is too big, truncate with warning. */\n\tif ((sector_t)capacity != capacity) {\n\t\tdev_warn(&vdev->dev, "Capacity %llu too large: truncating\\n",\n\t\t\t (unsigned long long)capacity);\n\t\tcapacity = (sector_t)-1;\n\t}\n\n\tnblocks = DIV_ROUND_UP_ULL(capacity, queue_logical_block_size(q) >> 9);\n\n\tstring_get_size(nblocks, queue_logical_block_size(q),\n	f
41913	189	SYSC_setgroups16	kernel/uid16.c	group_info	1	13	\N	\N	\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups16_from_user(group_info, grouplist);\n	f
42988	371	compal_rfkill_poll	drivers/platform/x86/compal-laptop.c	result	1	13	\N	\N	\tu8 result = ec_read_u8(WIRELESS_ADDR);\n\tbool hw_blocked = !(result & WIRELESS_KILLSWITCH);\n	f
44994	1717	store_event_char	drivers/usb/serial/ftdi_sio.c	rv	1	13	\N	\N	\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *udev = port->serial->dev;\n\tunsigned int v;\n\tint rv;\n\n\tif (kstrtouint(valbuf, 0, &v) || v >= 0x200)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&port->dev, "%s: setting event char = 0x%03x\\n", __func__, v);\n\n\trv = usb_control_msg(udev,\n\t\t\t     usb_sndctrlpipe(udev, 0),\n\t\t\t     FTDI_SIO_SET_EVENT_CHAR_REQUEST,\n\t\t\t     FTDI_SIO_SET_EVENT_CHAR_REQUEST_TYPE,\n\t\t\t     v, priv->interface,\n\t\t\t     NULL, 0, WDR_TIMEOUT);\n\tif (rv < 0) {\n	f
48803	394	elan_smbus_prepare_fw_update	drivers/input/mouse/elan_i2c_smbus.c	password	1	13	\N	\N	\tstruct device *dev = &client->dev;\n\tint len;\n\tint error;\n\tenum tp_mode mode;\n\tu8 val[3];\n\tu8 cmd[4] = {0x0F, 0x78, 0x00, 0x06};\n\tu16 password;\n\n\t/* Get FW in which mode\t(IAP_MODE/MAIN_MODE)  */\n\terror = elan_smbus_iap_get_mode(client, &mode);\n\tif (error)\n\t\treturn error;\n\n\tif (mode == MAIN_MODE) {\n\n\t\t/* set flash key */\n\t\terror = elan_smbus_set_flash_key(client);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* write iap password */\n\t\tif (i2c_smbus_write_byte(client,\n\t\t\t\t\t ETP_SMBUS_IAP_PASSWORD_WRITE) < 0) {\n\t\t\tdev_err(dev, "cannot write iap password\\n");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\terror = i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\n\t\t\t\t\t\t   sizeof(cmd), cmd);\n\t\tif (error) {\n\t\t\tdev_err(dev, "failed to write iap password: %d\\n",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read back password to make sure we enabled flash\n\t\t * successfully.\n\t\t */\n\t\tlen = i2c_smbus_read_block_data(client,\n\t\t\t\t\t\tETP_SMBUS_IAP_PASSWORD_READ,\n\t\t\t\t\t\tval);\n\t\tif (len < sizeof(u16)) {\n\t\t\terror = len < 0 ? len : -EIO;\n\t\t\tdev_err(dev, "failed to read iap password: %d\\n",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tpassword = be16_to_cpup((__be16 *)val);\n\t\tif (password != ETP_SMBUS_IAP_PASSWORD) {\n	f
49320	613	ocfs2_create_refcount_tree	fs/ocfs2/refcounttree.c	first_blkno	1	13	\N	\N	\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(ocfs2_is_refcount_inode(inode));\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n	f
50244	1044	create_debug_files	drivers/usb/host/ehci-hcd.c	create_debug_files_	1	13	\N	\N	\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct ehci_qh\t\t*qh;\n\tint\t\t\teptype = usb_endpoint_type(&ep->desc);\n\tint\t\t\tepnum = usb_endpoint_num(&ep->desc);\n\tint\t\t\tis_out = usb_endpoint_dir_out(&ep->desc);\n\tunsigned long\t\tflags;\n\n\tif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\n\t\treturn;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\tqh = ep->hcpriv;\n	f
57486	580	snd_mixart_setup_firmware	sound/pci/mixart/mixart_hwdep.c	fw_entry	1	13	\N	\N	\tstatic char *fw_files[3] = {\n\t\t"miXart8.xlx", "miXart8.elf", "miXart8AES.xlx"\n\t};\n\tchar path[32];\n\n\tconst struct firmware *fw_entry;\n\tint i, err;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tsprintf(path, "mixart/%s", fw_files[i]);\n\t\tif (request_firmware(&fw_entry, path, &mgr->pci->dev)) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t"miXart: can't load firmware %s\\n", path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t/* fake hwdep dsp record */\n\t\terr = mixart_dsp_load(mgr, i, fw_entry);\n	f
60389	1768	xfs_inactive_truncate	fs/xfs/xfs_inode.c	error	1	13	\N	\N	\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Log the inode size first to prevent stale data exposure in the event\n\t * of a system crash before the truncate completes. See the related\n\t * comment in xfs_vn_setattr_size() for details.\n\t */\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n	f
62186	181	asd_map_ha	drivers/scsi/aic94xx/aic94xx_init.c	cmd_reg	1	13	\N	\N	\tint err;\n\tu16 cmd_reg;\n\n\terr = pci_read_config_word(asd_ha->pcidev, PCI_COMMAND, &cmd_reg);\n\tif (err) {\n\t\tasd_printk("couldn't read command register of %s\\n",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto Err;\n\t}\n\n\terr = -ENODEV;\n\tif (cmd_reg & PCI_COMMAND_MEMORY) {\n\t\tif ((err = asd_map_memio(asd_ha)))\n\t\t\tgoto Err;\n\t} else if (cmd_reg & PCI_COMMAND_IO) {\n	f
38114	759	sierra_net_bind	drivers/net/usb/sierra_net.c	fwattr	1	13	\N	\N	\tu8\tifacenum;\n\tu8\tnumendpoints;\n\tu16\tfwattr = 0;\n\tint\tstatus;\n\tstruct sierra_net_data *priv;\n\tstatic const u8 sync_tmplate[sizeof(priv->sync_msg)] = {\n\t\t0x00, 0x00, SIERRA_NET_HIP_MSYNC_ID, 0x00};\n\tstatic const u8 shdwn_tmplate[sizeof(priv->shdwn_msg)] = {\n\t\t0x00, 0x00, SIERRA_NET_HIP_SHUTD_ID, 0x00};\n\n\tdev_dbg(&dev->udev->dev, "%s", __func__);\n\n\tifacenum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tnumendpoints = intf->cur_altsetting->desc.bNumEndpoints;\n\t/* We have three endpoints, bulk in and out, and a status */\n\tif (numendpoints != 3) {\n\t\tdev_err(&dev->udev->dev, "Expected 3 endpoints, found: %d",\n\t\t\tnumendpoints);\n\t\treturn -ENODEV;\n\t}\n\t/* Status endpoint set in usbnet_get_endpoints() */\n\tdev->status = NULL;\n\tstatus = usbnet_get_endpoints(dev, intf);\n\tif (status < 0) {\n\t\tdev_err(&dev->udev->dev, "Error in usbnet_get_endpoints (%d)",\n\t\t\tstatus);\n\t\treturn -ENODEV;\n\t}\n\t/* Initialize sierra private data */\n\tpriv = kzalloc(sizeof *priv, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->usbnet = dev;\n\tpriv->ifnum = ifacenum;\n\tdev->net->netdev_ops = &sierra_net_device_ops;\n\n\t/* change MAC addr to include, ifacenum, and to be unique */\n\tdev->net->dev_addr[ETH_ALEN-2] = atomic_inc_return(&iface_counter);\n\tdev->net->dev_addr[ETH_ALEN-1] = ifacenum;\n\n\t/* prepare shutdown message template */\n\tmemcpy(priv->shdwn_msg, shdwn_tmplate, sizeof(priv->shdwn_msg));\n\t/* set context index initially to 0 - prepares tx hdr template */\n\tsierra_net_set_ctx_index(priv, 0);\n\n\t/* prepare sync message template */\n\tmemcpy(priv->sync_msg, sync_tmplate, sizeof(priv->sync_msg));\n\n\t/* decrease the rx_urb_size and max_tx_size to 4k on USB 1.1 */\n\tdev->rx_urb_size  = SIERRA_NET_RX_URB_SIZE;\n\tif (dev->udev->speed != USB_SPEED_HIGH)\n\t\tdev->rx_urb_size  = min_t(size_t, 4096, SIERRA_NET_RX_URB_SIZE);\n\n\tdev->net->hard_header_len += SIERRA_NET_HIP_EXT_HDR_LEN;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\tdev->net->max_mtu = SIERRA_NET_MAX_SUPPORTED_MTU;\n\n\t/* Set up the netdev */\n\tdev->net->flags |= IFF_NOARP;\n\tdev->net->ethtool_ops = &sierra_net_ethtool_ops;\n\tnetif_carrier_off(dev->net);\n\n\tsierra_net_set_private(dev, priv);\n\n\tpriv->kevent_flags = 0;\n\n\t/* Use the shared workqueue */\n\tINIT_WORK(&priv->sierra_net_kevent, sierra_net_kevent);\n\n\t/* Only need to do this once */\n\tinit_timer(&priv->sync_timer);\n\n\t/* verify fw attributes */\n\tstatus = sierra_net_get_fw_attr(dev, &fwattr);\n\tdev_dbg(&dev->udev->dev, "Fw attr: %x\\n", fwattr);\n	f
41157	896	nxt2002_init	drivers/media/dvb-frontends/nxt200x.c	fw	1	13	\N	\N	\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret;\n\tu8 buf[2];\n\n\t/* request the firmware, this will block until someone uploads it */\n\tpr_debug("%s: Waiting for firmware upload (%s)...\\n",\n\t\t __func__, NXT2002_DEFAULT_FIRMWARE);\n\tret = request_firmware(&fw, NXT2002_DEFAULT_FIRMWARE,\n\t\t\t       state->i2c->dev.parent);\n\tpr_debug("%s: Waiting for firmware upload(2)...\\n", __func__);\n\tif (ret) {\n\t\tpr_err("%s: No firmware uploaded (timeout or file not found?)\\n",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\tret = nxt2002_load_firmware(fe, fw);\n	f
33232	1013	vmw_cmd_set_render_target_check	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c	vmw_cmd_set_render_target_check_$ctx_node$obj$7	0	13	\N	\N	\tstruct vmw_sid_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdSetRenderTarget body;\n\t} *cmd;\n\tstruct vmw_resource_val_node *ctx_node;\n\tstruct vmw_resource_val_node *res_node;\n\tint ret;\n\n\tcmd = container_of(header, struct vmw_sid_cmd, header);\n\n\tif (cmd->body.type >= SVGA3D_RT_MAX) {\n\t\tDRM_ERROR("Illegal render target type %u.\\n",\n\t\t\t  (unsigned) cmd->body.type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tuser_context_converter, &cmd->body.cid,\n\t\t\t\t&ctx_node);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tuser_surface_converter,\n\t\t\t\t&cmd->body.target.sid, &res_node);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (dev_priv->has_mob) {\n\t\tstruct vmw_ctx_bindinfo_view binding;\n\n\t\tbinding.bi.ctx = ctx_node->res;\n\t\tbinding.bi.res = res_node ? res_node->res : NULL;\n\t\tbinding.bi.bt = vmw_ctx_binding_rt;\n\t\tbinding.slot = cmd->body.type;\n\t\tvmw_binding_add(ctx_node->staged_bindings,\n	f
44757	1196	genwqe_ioctl	drivers/misc/genwqe/card_dev.c	&m	1	13	\N	\N	\tint rc = 0;\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct genwqe_reg_io __user *io;\n\tu64 val;\n\tu32 reg_offs;\n\n\t/* Return -EIO if card hit EEH */\n\tif (pci_channel_offline(pci_dev))\n\t\treturn -EIO;\n\n\tif (_IOC_TYPE(cmd) != GENWQE_IOC_CODE)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\n\tcase GENWQE_GET_CARD_STATE:\n\t\tput_user(cd->card_state, (enum genwqe_card_state __user *)arg);\n\t\treturn 0;\n\n\t\t/* Register access */\n\tcase GENWQE_READ_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readq(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writeq(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_READ_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readl(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writel(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\t\t/* Flash update/reading */\n\tcase GENWQE_SLU_UPDATE: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&load, (void __user *)arg,\n\t\t\t\t   sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_update(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\tcase GENWQE_SLU_READ: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif (genwqe_flash_readback_fails(cd))\n\t\t\treturn -ENOSPC;\t /* known to fail for old versions */\n\n\t\tif (copy_from_user(&load, (void __user *)arg, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_read(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\t\t/* memory pinning and unpinning */\n\tcase GENWQE_PIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_pin_mem(cfile, &m);\n	f
-616	531	icmp_route_lookup	net/ipv4/icmp.c	fl4_dec.daddr	2	3	\N	\N	\tstruct rtable *rt, *rt2;\n\tstruct flowi4 fl4_dec;\n\tint err;\n\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->daddr = (param->replyopts.opt.opt.srr ?\n\t\t      param->replyopts.opt.opt.faddr : iph->saddr);\n\tfl4->saddr = saddr;\n\tfl4->flowi4_mark = mark;\n\tfl4->flowi4_uid = sock_net_uid(net, NULL);\n\tfl4->flowi4_tos = RT_TOS(tos);\n\tfl4->flowi4_proto = IPPROTO_ICMP;\n\tfl4->fl4_icmp_type = type;\n\tfl4->fl4_icmp_code = code;\n\tfl4->flowi4_oif = l3mdev_master_ifindex(skb_dst(skb_in)->dev);\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(fl4));\n\trt = ip_route_output_key_hash(net, fl4, skb_in);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4_dec), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type_dev_table(net, skb_dst(skb_in)->dev,\n\t\t\t\t     fl4_dec.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4_dec);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4_dec.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\tskb_dst_set(skb_in, NULL);\n\t\terr = ip_route_input(skb_in, fl4_dec.daddr, fl4_dec.saddr,\n	f
37444	175	ip_vs_nfct_expect_callback	net/netfilter/ipvs/ip_vs_nfct.c	ip_vs_nfct_expect_callback_phi$$new_reply$3$1$obj$and$255$shl$8$or$%new_reply$3$1$obj$and$65280$ashr$8$	0	13	\N	\N	\tstruct nf_conntrack_tuple *orig, new_reply;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_conn_param p;\n\tstruct net *net = nf_ct_net(ct);\n\n\tif (exp->tuple.src.l3num != PF_INET)\n\t\treturn;\n\n\t/*\n\t * We assume that no NF locks are held before this callback.\n\t * ip_vs_conn_out_get and ip_vs_conn_in_get should match their\n\t * expectations even if they use wildcard values, now we provide the\n\t * actual values from the newly created original conntrack direction.\n\t * The conntrack is confirmed when packet reaches IPVS hooks.\n\t */\n\n\t/* RS->CLIENT */\n\torig = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\tip_vs_conn_fill_param(net_ipvs(net), exp->tuple.src.l3num, orig->dst.protonum,\n\t\t\t      &orig->src.u3, orig->src.u.tcp.port,\n\t\t\t      &orig->dst.u3, orig->dst.u.tcp.port, &p);\n\tcp = ip_vs_conn_out_get(&p);\n\tif (cp) {\n\t\t/* Change reply CLIENT->RS to CLIENT->VS */\n\t\tnew_reply = ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\tIP_VS_DBG(7, "%s: ct=%p, status=0x%lX, tuples=" FMT_TUPLE ", "\n	f
37794	891	ixgbevf_fetch_rx_buffer	drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c	skb)	1	13	\N	\N	\tstruct ixgbevf_rx_buffer *rx_buffer;\n\tstruct page *page;\n\n\trx_buffer = &rx_ring->rx_buffer_info[rx_ring->next_to_clean];\n\tpage = rx_buffer->page;\n\tprefetchw(page);\n\n\tif (likely(!skb)) {\n\t\tvoid *page_addr = page_address(page) +\n\t\t\t\t  rx_buffer->page_offset;\n\n\t\t/* prefetch first cache line of first page */\n\t\tprefetch(page_addr);\n#if L1_CACHE_BYTES < 128\n\t\tprefetch(page_addr + L1_CACHE_BYTES);\n#endif\n\n\t\t/* allocate a skb to store the frags */\n\t\tskb = netdev_alloc_skb_ip_align(rx_ring->netdev,\n\t\t\t\t\t\tIXGBEVF_RX_HDR_SIZE);\n\t\tif (unlikely(!skb)) {\n\t\t\trx_ring->rx_stats.alloc_rx_buff_failed++;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* we will be copying header into skb->data in\n\t\t * pskb_may_pull so it is in our interest to prefetch\n\t\t * it now to avoid a possible cache miss\n\t\t */\n\t\tprefetchw(skb->data);\n\t}\n\n\t/* we are reusing so sync this buffer for CPU use */\n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      IXGBEVF_RX_BUFSZ,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\t/* pull page into skb */\n\tif (ixgbevf_add_rx_frag(rx_ring, rx_buffer, rx_desc, skb)) {\n	f
38373	402	cyapa_gen6_get_interval_setting	drivers/input/mouse/cyapa_gen6.c	resp_data	1	13	\N	\N	\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00,\n\t\t     GEN6_GET_POWER_MODE_INTERVAL };\n\tu8 resp_data[11];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN6_GET_POWER_MODE_INTERVAL))\n	f
55728	6322	thermal_init	drivers/platform/x86/thinkpad_acpi.c	ta2	1	13	\N	\N	\tu8 t, ta1, ta2;\n\tint i;\n\tint acpi_tmp7;\n\tint res;\n\n\tvdbg_printk(TPACPI_DBG_INIT, "initializing thermal subdriver\\n");\n\n\tacpi_tmp7 = acpi_evalf(ec_handle, NULL, "TMP7", "qv");\n\n\tif (thinkpad_id.ec_model) {\n\t\t/*\n\t\t * Direct EC access mode: sensors at registers\n\t\t * 0x78-0x7F, 0xC0-0xC7.  Registers return 0x00 for\n\t\t * non-implemented, thermal sensors return 0x80 when\n\t\t * not available\n\t\t */\n\n\t\tta1 = ta2 = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP0 + i, &t)) {\n\t\t\t\tta1 |= t;\n\t\t\t} else {\n\t\t\t\tta1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP8 + i, &t)) {\n\t\t\t\tta2 |= t;\n\t\t\t} else {\n\t\t\t\tta1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ta1 == 0) {\n\t\t\t/* This is sheer paranoia, but we handle it anyway */\n\t\t\tif (acpi_tmp7) {\n\t\t\t\tpr_err("ThinkPad ACPI EC access misbehaving, falling back to ACPI TMPx access mode\\n");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\n\t\t\t} else {\n\t\t\t\tpr_err("ThinkPad ACPI EC access misbehaving, disabling thermal sensors access\\n");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tthermal_read_mode =\n\t\t\t    (ta2 != 0) ?\n	f
59131	3896	lpfc_sli_brdready_s3	drivers/scsi/lpfc/lpfc_sli.c	status	1	13	\N	\N	\tuint32_t status;\n\tint i = 0;\n\tint retval = 0;\n\n\t/* Read the HBA Host Status Register */\n\tif (lpfc_readl(phba->HSregaddr, &status))\n\t\treturn 1;\n\n\t/*\n\t * Check status register every 100ms for 5 retries, then every\n\t * 500ms for 5, then every 2.5 sec for 5, then reset board and\n\t * every 2.5 sec for 4.\n\t * Break our of the loop if errors occurred during init.\n\t */\n\twhile (((status & mask) != mask) &&\n\t       !(status & HS_FFERM) &&\n	f
61015	302	as102_dvb_register	drivers/media/usb/as102/as102_drv.c	ret	1	13	\N	\N	\tstruct device *dev = &as102_dev->bus_adap.usb_dev->dev;\n\tint ret;\n\n\tret = dvb_register_adapter(&as102_dev->dvb_adap,\n\t\t\t   as102_dev->name, THIS_MODULE,\n\t\t\t   dev, adapter_nr);\n\tif (ret < 0) {\n	f
-405	6936	airo_get_range	drivers/net/wireless/cisco/airo.c	cap_rid.softCap	2	3	\N	\N	\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint\t\ti;\n\tint\t\tk;\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t/* Should be based on cap_rid.country to give only\n\t * what the current card support */\n\tk = 0;\n\tfor(i = 0; i < 14; i++) {\n\t\trange->freq[k].i = i + 1; /* List index */\n\t\trange->freq[k].m = 100000 *\n\t\t     ieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ);\n\t\trange->freq[k++].e = 1;\t/* Values in MHz -> * 10^5 * 10 */\n\t}\n\trange->num_frequency = k;\n\n\trange->sensitivity = 65535;\n\n\t/* Hum... Should put the right values there */\n\tif (local->rssi)\n\t\trange->max_qual.qual = 100;\t/* % */\n\telse\n\t\trange->max_qual.qual = airo_get_max_quality(&cap_rid);\n\trange->max_qual.level = 0x100 - 120;\t/* -120 dBm */\n\trange->max_qual.noise = 0x100 - 120;\t/* -120 dBm */\n\n\t/* Experimental measurements - boundary 11/5.5 Mb/s */\n\t/* Note : with or without the (local->rssi), results\n\t * are somewhat different. - Jean II */\n\tif (local->rssi) {\n\t\trange->avg_qual.qual = 50;\t\t/* % */\n\t\trange->avg_qual.level = 0x100 - 70;\t/* -70 dBm */\n\t} else {\n\t\trange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\n\t\trange->avg_qual.level = 0x100 - 80;\t/* -80 dBm */\n\t}\n\trange->avg_qual.noise = 0x100 - 85;\t\t/* -85 dBm */\n\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\n\t\tif(range->bitrate[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_bitrates = i;\n\n\t/* Set an indication of the max TCP throughput\n\t * in bit/s that we can expect using this interface.\n\t * May be use for QoS stuff... Jean II */\n\tif(i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = AIRO_DEF_MTU;\n\trange->min_frag = 256;\n\trange->max_frag = AIRO_DEF_MTU;\n\n\tif(cap_rid.softCap & cpu_to_le16(2)) {\n	f
60877	2753	efx_ef10_rx_pull_rss_config	drivers/net/ethernet/sfc/ef10.c	efx_ef10_rx_pull_rss_config_$__ret_warn_on59$obj	0	13	\N	\N	\tstruct efx_ef10_nic_data *nic_data = efx->nic_data;\n\tMCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_GET_TABLE_IN_LEN);\n\tMCDI_DECLARE_BUF(tablebuf, MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_LEN);\n\tMCDI_DECLARE_BUF(keybuf, MC_CMD_RSS_CONTEXT_GET_KEY_OUT_LEN);\n\tsize_t outlen;\n\tint rc, i;\n\n\tBUILD_BUG_ON(MC_CMD_RSS_CONTEXT_GET_TABLE_IN_LEN !=\n\t\t     MC_CMD_RSS_CONTEXT_GET_KEY_IN_LEN);\n\n\tif (nic_data->rx_rss_context == EFX_EF10_RSS_CONTEXT_INVALID)\n\t\treturn -ENOENT;\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_TABLE_IN_RSS_CONTEXT_ID,\n\t\t       nic_data->rx_rss_context);\n\tBUILD_BUG_ON(ARRAY_SIZE(efx->rx_indir_table) !=\n\t\t     MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_INDIRECTION_TABLE_LEN);\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_GET_TABLE, inbuf, sizeof(inbuf),\n\t\t\t  tablebuf, sizeof(tablebuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (WARN_ON(outlen != MC_CMD_RSS_CONTEXT_GET_TABLE_OUT_LEN))\n\t\treturn -EIO;\n\n\tfor (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)\n\t\tefx->rx_indir_table[i] = MCDI_PTR(tablebuf,\n\t\t\t\tRSS_CONTEXT_GET_TABLE_OUT_INDIRECTION_TABLE)[i];\n\n\tMCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_KEY_IN_RSS_CONTEXT_ID,\n\t\t       nic_data->rx_rss_context);\n\tBUILD_BUG_ON(ARRAY_SIZE(efx->rx_hash_key) !=\n\t\t     MC_CMD_RSS_CONTEXT_SET_KEY_IN_TOEPLITZ_KEY_LEN);\n\trc = efx_mcdi_rpc(efx, MC_CMD_RSS_CONTEXT_GET_KEY, inbuf, sizeof(inbuf),\n\t\t\t  keybuf, sizeof(keybuf), &outlen);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (WARN_ON(outlen != MC_CMD_RSS_CONTEXT_GET_KEY_OUT_LEN))\n	f
50920	164	nilfs_dat_prepare_end	fs/nilfs2/dat.c	nilfs_dat_prepare_end_$req.addr$obj$3$obj$2	0	13	\N	\N	\tstruct nilfs_dat_entry *entry;\n\tsector_t blocknr;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_dat_prepare_entry(dat, req, 0);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOENT);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req->pr_entry_bh->b_page);\n	f
52930	2031	liquidio_vlan_rx_add_vid	drivers/net/ethernet/cavium/liquidio/lio_vf_main.c	liquidio_vlan_rx_add_vid_$tmp$obj	0	13	\N	\N	\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octnic_ctrl_pkt nctrl;\n\tstruct completion compl;\n\tu16 response_code;\n\tint ret = 0;\n\n\tmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\n\n\tnctrl.ncmd.u64 = 0;\n\tnctrl.ncmd.s.cmd = OCTNET_CMD_ADD_VLAN_FILTER;\n\tnctrl.ncmd.s.param1 = vid;\n\tnctrl.iq_no = lio->linfo.txpciq[0].s.q_no;\n\tnctrl.wait_time = 100;\n\tnctrl.netpndev = (u64)netdev;\n\tnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\n\tinit_completion(&compl);\n\tnctrl.completion = &compl;\n\tnctrl.response_code = &response_code;\n\n\tret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl);\n\tif (ret < 0) {\n\t\tdev_err(&oct->pci_dev->dev, "Add VLAN filter failed in core (ret: 0x%x)\\n",\n\t\t\tret);\n\t\treturn -EIO;\n\t}\n\n\tif (!wait_for_completion_timeout(&compl,\n\t\t\t\t\t msecs_to_jiffies(nctrl.wait_time)))\n\t\treturn -EPERM;\n\n\tif (READ_ONCE(response_code))\n	f
40696	3672	ath6kl_wmi_send_action_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_send_action_cmd *p;\n\tu8 *buf;\n\n\tif (wait)\n\t\treturn -EINVAL; /* Offload for wait not supported */\n\n\tbuf = kmalloc(data_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + data_len);\n\tif (!skb) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tkfree(wmi->last_mgmt_tx_frame);\n\tmemcpy(buf, data, data_len);\n\twmi->last_mgmt_tx_frame = buf;\n\twmi->last_mgmt_tx_frame_len = data_len;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "send_action_cmd: id=%u freq=%u wait=%u len=%u\\n",\n\t\t   id, freq, wait, data_len);\n\tp = (struct wmi_send_action_cmd *) skb->data;\n\tp->id = cpu_to_le32(id);\n\tp->freq = cpu_to_le32(freq);\n\tp->wait = cpu_to_le32(wait);\n\tp->len = cpu_to_le16(data_len);\n\tmemcpy(p->data, data, data_len);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SEND_ACTION_CMDID,\n	f
44776	364	genwqe_init_debugfs	drivers/misc/genwqe/card_debugfs.c	file	1	13	\N	\N	\tstruct dentry *root;\n\tstruct dentry *file;\n\tint ret;\n\tchar card_name[64];\n\tchar name[64];\n\tunsigned int i;\n\n\tsprintf(card_name, "%s%d_card", GENWQE_DEVNAME, cd->card_idx);\n\n\troot = debugfs_create_dir(card_name, cd->debugfs_genwqe);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\t/* non privileged interfaces are done here */\n\tfile = debugfs_create_file("ddcb_info", S_IRUGO, root, cd,\n\t\t\t\t   &genwqe_ddcb_info_fops);\n\tif (!file) {\n	f
48817	737	dccp_v6_rcv	net/dccp/ipv6.c	sk->sk_state	1	13	\N	\N	\tconst struct dccp_hdr *dh;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN("dropped packet with invalid checksum\\n");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb), 0, &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug("failed to look up flow ID in table and "\n\t\t\t      "get corresponding socket\\n");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug("sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n	f
50369	102	stk1160_i2c_read_reg	drivers/media/usb/stk1160/stk1160-i2c.c	rc	1	13	\N	\N	\tint rc;\n\n\t/* Set serial device address */\n\trc = stk1160_write_reg(dev, STK1160_SICTL_SDA, addr);\n\tif (rc < 0)\n	f
38904	3905	intel_dp_sink_crc_stop	drivers/gpu/drm/i915/intel_dp.c	count	1	13	\N	\N	\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(dig_port->base.base.crtc);\n\tu8 buf;\n\tint ret = 0;\n\tint count = 0;\n\tint attempts = 10;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK, &buf) < 0) {\n\t\tDRM_DEBUG_KMS("Sink CRC couldn't be stopped properly\\n");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_SINK,\n\t\t\t       buf & ~DP_TEST_SINK_START) < 0) {\n\t\tDRM_DEBUG_KMS("Sink CRC couldn't be stopped properly\\n");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tintel_wait_for_vblank(dev_priv, intel_crtc->pipe);\n\n\t\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t\t      DP_TEST_SINK_MISC, &buf) < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = buf & DP_TEST_COUNT_MASK;\n\t} while (--attempts && count);\n	f
43537	60	wimax_debugfs_add	net/wimax/debugfs.c	dentry	1	13	\N	\N	\tint result;\n\tstruct net_device *net_dev = wimax_dev->net_dev;\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct dentry *dentry;\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), "wimax:%s", net_dev->name);\n\tdentry = debugfs_create_dir(buf, NULL);\n\tresult = PTR_ERR(dentry);\n\tif (IS_ERR(dentry)) {\n\t\tif (result == -ENODEV)\n\t\t\tresult = 0;\t/* No debugfs support */\n\t\telse\n\t\t\tdev_err(dev, "Can't create debugfs dentry: %d\\n",\n\t\t\t\tresult);\n\t\tgoto out;\n\t}\n\twimax_dev->debugfs_dentry = dentry;\n\t__debugfs_register("wimax_dl_", debugfs, dentry);\n\t__debugfs_register("wimax_dl_", id_table, dentry);\n	f
31016	758	rsi_hal_load_key	drivers/net/wireless/rsi/rsi_91x_mgmt.c	rsi_hal_load_key_$set_key$obj	0	13	\N	\N	\tstruct ieee80211_vif *vif = common->priv->vifs[0];\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_set_key *set_key;\n\tu16 key_descriptor = 0;\n\tu16 frame_len = sizeof(struct rsi_set_key);\n\n\trsi_dbg(MGMT_TX_ZONE, "%s: Sending load key frame\\n", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\\n",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tset_key = (struct rsi_set_key *)skb->data;\n\n\tif (key_type == RSI_GROUP_KEY) {\n\t\tkey_descriptor = RSI_KEY_TYPE_BROADCAST;\n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tkey_descriptor |= RSI_KEY_MODE_AP;\n\t}\n\tif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\n\t    (cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\tkey_id = 0;\n\t\tkey_descriptor |= RSI_WEP_KEY;\n\t\tif (key_len >= 13)\n\t\t\tkey_descriptor |= RSI_WEP_KEY_104;\n\t} else if (cipher != KEY_TYPE_CLEAR) {\n\t\tkey_descriptor |= RSI_CIPHER_WPA;\n\t\tif (cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\tkey_descriptor |= RSI_CIPHER_TKIP;\n\t}\n\tkey_descriptor |= RSI_PROTECT_DATA_FRAMES;\n\tkey_descriptor |= ((key_id << RSI_KEY_ID_OFFSET) & RSI_KEY_ID_MASK);\n\n\trsi_set_len_qno(&set_key->desc_dword0.len_qno,\n	f
9087	378	pca953x_gpio_get_direction	drivers/gpio/gpio-pca953x.c	reg_val	1	13	\N	\N	\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu32 reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = pca953x_read_single(chip, chip->regs->direction, &reg_val, off);\n\tmutex_unlock(&chip->i2c_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(reg_val & (1u << (off % BANK_SZ)));\n	f
27020	744	cmpc_tablet_idev_init	drivers/platform/x86/classmate-laptop.c	val	1	13	\N	\N	\tunsigned long long val = 0;\n\tstruct acpi_device *acpi;\n\n\tset_bit(EV_SW, inputdev->evbit);\n\tset_bit(SW_TABLET_MODE, inputdev->swbit);\n\n\tacpi = to_acpi_device(inputdev->dev.parent);\n\tif (ACPI_SUCCESS(cmpc_get_tablet(acpi->handle, &val))) {\n\t\tinput_report_switch(inputdev, SW_TABLET_MODE, !val);\n	f
58212	865	fm10k_tx_csum	drivers/net/ethernet/intel/fm10k/fm10k_main.c	frag_off	1	13	\N	\N	\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t "failed to offload encap csum!\\n");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n	f
63177	1436	lcd_proc_write	drivers/platform/x86/toshiba_acpi.c	&value	1	13	\N	\N	\tstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint levels;\n\tint value;\n\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\n\tlevels = dev->backlight_dev->props.max_brightness + 1;\n\tif (sscanf(cmd, " brightness : %i", &value) != 1 &&\n	f
9374	5123	cgroup_init_early	kernel/cgroup/cgroup.c	cgroup_init_early_$__ret_warn_on$obj$icmp$0$xor$-1$xor$-1	0	13	\N	\N	\tstatic struct cgroup_sb_opts __initdata opts;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tinit_cgroup_root(&cgrp_dfl_root, &opts);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n	f
41259	1916	s2255_vendor_req	drivers/media/usb/s2255/s2255drv.c	r	1	13	\N	\N	\tint r;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(TransferBufferLength, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (!bOut) {\n\t\tr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t\t    Request,\n\t\t\t\t    USB_TYPE_VENDOR | USB_RECIP_DEVICE |\n\t\t\t\t    USB_DIR_IN,\n\t\t\t\t    Value, Index, buf,\n\t\t\t\t    TransferBufferLength, HZ * 5);\n\n\t\tif (r >= 0)\n	f
50907	230	dw2102_serit_i2c_transfer	drivers/media/usb/dvb-usb/dw2102.c	buf6 + 2	1	13	\N	\N	\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 buf6[] = {0, 0, 0, 0, 0, 0, 0};\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2:\n\t\tif (msg[0].len != 1) {\n\t\t\twarn("i2c rd: len=%d is not 1!\\n",\n\t\t\t     msg[0].len);\n\t\t\tnum = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (2 + msg[1].len > sizeof(buf6)) {\n\t\t\twarn("i2c rd: len=%d is too big!\\n",\n\t\t\t     msg[1].len);\n\t\t\tnum = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* read si2109 register by number */\n\t\tbuf6[0] = msg[0].addr << 1;\n\t\tbuf6[1] = msg[0].len;\n\t\tbuf6[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tbuf6, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* read si2109 register */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0xd0, 0,\n\t\t\t\tbuf6, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, buf6 + 2, msg[1].len);\n	f
21305	417	cafe_nand_read_page	drivers/mtd/nand/cafe_nand.c	p	1	13	\N	\N	\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tunsigned int max_bitflips = 0;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, "ECC result %08x SYN1,2 %08x\\n",\n\t\t     cafe_readl(cafe, NAND_ECC_RESULT),\n\t\t     cafe_readl(cafe, NAND_ECC_SYN01));\n\n\tchip->read_buf(mtd, buf, mtd->writesize);\n\tchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\n\n\tif (checkecc && cafe_readl(cafe, NAND_ECC_RESULT) & (1<<18)) {\n\t\tunsigned short syn[8], pat[4];\n\t\tint pos[4];\n\t\tu8 *oob = chip->oob_poi;\n\t\tint i, n;\n\n\t\tfor (i=0; i<8; i+=2) {\n\t\t\tuint32_t tmp = cafe_readl(cafe, NAND_ECC_SYN01 + (i*2));\n\t\t\tsyn[i] = cafe->rs->index_of[tmp & 0xfff];\n\t\t\tsyn[i+1] = cafe->rs->index_of[(tmp >> 16) & 0xfff];\n\t\t}\n\n\t\tn = decode_rs16(cafe->rs, NULL, NULL, 1367, syn, 0, pos, 0,\n\t\t                pat);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint p = pos[i];\n\n\t\t\t/* The 12-bit symbols are mapped to bytes here */\n\n\t\t\tif (p > 1374) {\n	f
53485	2445	snd_rme9652_create_pcm	sound/pci/rme9652/rme9652.c	pcm->name	1	13	\N	\N	\tstruct snd_pcm *pcm;\n\tint err;\n\n\tif ((err = snd_pcm_new(card,\n\t\t\t       rme9652->card_name,\n\t\t\t       0, 1, 1, &pcm)) < 0) {\n\t\treturn err;\n\t}\n\n\trme9652->pcm = pcm;\n\tpcm->private_data = rme9652;\n\tstrcpy(pcm->name, rme9652->card_name);\n	f
54395	1710	igt_topdown	drivers/gpu/drm/selftests/test-drm_mm.c	node	1	13	\N	\N	\tconst struct insert_mode *topdown = &insert_modes[TOPDOWN];\n\tDRM_RND_STATE(prng, random_seed);\n\tconst unsigned int count = 8192;\n\tunsigned int size;\n\tunsigned long *bitmap = NULL;\n\tstruct drm_mm mm;\n\tstruct drm_mm_node *nodes, *node, *next;\n\tunsigned int *order, n, m, o = 0;\n\tint ret;\n\n\t/* When allocating top-down, we expect to be returned a node\n\t * from a suitable hole at the top of the drm_mm. We check that\n\t * the returned node does match the highest available slot.\n\t */\n\n\tret = -ENOMEM;\n\tnodes = vzalloc(count * sizeof(*nodes));\n\tif (!nodes)\n\t\tgoto err;\n\n\tbitmap = kzalloc(count / BITS_PER_LONG * sizeof(unsigned long),\n\t\t\t GFP_KERNEL);\n\tif (!bitmap)\n\t\tgoto err_nodes;\n\n\torder = drm_random_order(count, &prng);\n\tif (!order)\n\t\tgoto err_bitmap;\n\n\tret = -EINVAL;\n\tfor (size = 1; size <= 64; size <<= 1) {\n\t\tdrm_mm_init(&mm, 0, size*count);\n\t\tfor (n = 0; n < count; n++) {\n\t\t\tif (!expect_insert(&mm, &nodes[n],\n\t\t\t\t\t   size, 0, n,\n\t\t\t\t\t   topdown)) {\n\t\t\t\tpr_err("insert failed, size %u step %d\\n", size, n);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (drm_mm_hole_follows(&nodes[n])) {\n\t\t\t\tpr_err("hole after topdown insert %d, start=%llx\\n, size=%u",\n\t\t\t\t       n, nodes[n].start, size);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!assert_one_hole(&mm, 0, size*(count - n - 1)))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (!assert_continuous(&mm, size))\n\t\t\tgoto out;\n\n\t\tdrm_random_reorder(order, count, &prng);\n\t\tfor_each_prime_number_from(n, 1, min(count, max_prime)) {\n\t\t\tfor (m = 0; m < n; m++) {\n\t\t\t\tnode = &nodes[order[(o + m) % count]];\n\t\t\t\tdrm_mm_remove_node(node);\n\t\t\t\t__set_bit(node_index(node), bitmap);\n\t\t\t}\n\n\t\t\tfor (m = 0; m < n; m++) {\n\t\t\t\tunsigned int last;\n\n\t\t\t\tnode = &nodes[order[(o + m) % count]];\n\t\t\t\tif (!expect_insert(&mm, node,\n\t\t\t\t\t\t   size, 0, 0,\n\t\t\t\t\t\t   topdown)) {\n\t\t\t\t\tpr_err("insert failed, step %d/%d\\n", m, n);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (drm_mm_hole_follows(node)) {\n\t\t\t\t\tpr_err("hole after topdown insert %d/%d, start=%llx\\n",\n\t\t\t\t\t       m, n, node->start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tlast = find_last_bit(bitmap, count);\n\t\t\t\tif (node_index(node) != last) {\n\t\t\t\t\tpr_err("node %d/%d, size %d, not inserted into upmost hole, expected %d, found %d\\n",\n\t\t\t\t\t       m, n, size, last, node_index(node));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t__clear_bit(last, bitmap);\n\t\t\t}\n\n\t\t\tDRM_MM_BUG_ON(find_first_bit(bitmap, count) != count);\n\n\t\t\to += n;\n\t\t}\n\n\t\tdrm_mm_for_each_node_safe(node, next, &mm)\n\t\t\tdrm_mm_remove_node(node);\n\t\tDRM_MM_BUG_ON(!drm_mm_clean(&mm));\n\t\tcond_resched();\n\t}\n\n\tret = 0;\nout:\n\tdrm_mm_for_each_node_safe(node, next, &mm)\n	f
55056	487	s5k4aa_start	drivers/media/usb/gspca/m5602/m5602_s5k4aa.c	err	1	13	\N	\N	\tint i, err = 0;\n\tu8 data[2];\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tswitch (cam->cam_mode[sd->gspca_dev.curr_mode].width) {\n\tcase 1280:\n\t\tPDEBUG(D_CONF, "Configuring camera for SXGA mode");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(SXGA_s5k4aa); i++) {\n\t\t\tswitch (SXGA_s5k4aa[i][0]) {\n\t\t\tcase BRIDGE:\n\t\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\t\t\t SXGA_s5k4aa[i][1],\n\t\t\t\t\t\t SXGA_s5k4aa[i][2]);\n\t\t\tbreak;\n\n\t\t\tcase SENSOR:\n\t\t\t\tdata[0] = SXGA_s5k4aa[i][2];\n\t\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\t\t\t SXGA_s5k4aa[i][1],\n\t\t\t\t\t\t data, 1);\n\t\t\tbreak;\n\n\t\t\tcase SENSOR_LONG:\n\t\t\t\tdata[0] = SXGA_s5k4aa[i][2];\n\t\t\t\tdata[1] = SXGA_s5k4aa[i][3];\n\t\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\t\t\t  SXGA_s5k4aa[i][1],\n\t\t\t\t\t\t  data, 2);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_err("Invalid stream command, exiting init\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 640:\n\t\tPDEBUG(D_CONF, "Configuring camera for VGA mode");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(VGA_s5k4aa); i++) {\n\t\t\tswitch (VGA_s5k4aa[i][0]) {\n\t\t\tcase BRIDGE:\n\t\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\t\t\t VGA_s5k4aa[i][1],\n\t\t\t\t\t\t VGA_s5k4aa[i][2]);\n\t\t\tbreak;\n\n\t\t\tcase SENSOR:\n\t\t\t\tdata[0] = VGA_s5k4aa[i][2];\n\t\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\t\t\t VGA_s5k4aa[i][1],\n\t\t\t\t\t\t data, 1);\n\t\t\tbreak;\n\n\t\t\tcase SENSOR_LONG:\n\t\t\t\tdata[0] = VGA_s5k4aa[i][2];\n\t\t\t\tdata[1] = VGA_s5k4aa[i][3];\n\t\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\t\t\t  VGA_s5k4aa[i][1],\n\t\t\t\t\t\t  data, 2);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_err("Invalid stream command, exiting init\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (err < 0)\n	f
42068	487	xfs_qm_scall_setqlim	fs/xfs/xfs_qm_syscalls.c	ddq->d_ino_softlimit	1	13	\N	\N	\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_def_quota\t*defq;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t/*\n\t * We don't want to race with a quotaoff so take the quotaoff lock.\n\t * We don't hold an inode lock, so there's nothing else to stop\n\t * a quotaoff from happening.\n\t */\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * Get the dquot (locked) before we start, as we need to do a\n\t * transaction to allocate it if it doesn't exist. Once we have the\n\t * dquot, unlock it so we can start the next transaction safely. We hold\n\t * a reference to the dquot, so it's safe to do this unlock/lock without\n\t * it being reclaimed in the mean time.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_unlock;\n\t}\n\n\tdefq = xfs_get_defquota(dqp, q);\n\txfs_dqunlock(dqp);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_setqlim, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_rele;\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\tddq = &dqp->q_core;\n\n\t/*\n\t * Make sure that hardlimits are >= soft limits before changing.\n\t */\n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_blk_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_blk_softlimit = cpu_to_be64(soft);\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\t\tif (id == 0) {\n\t\t\tdefq->bhardlimit = hard;\n\t\t\tdefq->bsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, "blkhard %Ld < blksoft %Ld", hard, soft);\n\t}\n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_rtb_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_rtb_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tdefq->rtbhardlimit = hard;\n\t\t\tdefq->rtbsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, "rtbhard %Ld < rtbsoft %Ld", hard, soft);\n\t}\n\n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_softlimit);\n	f
2417	355	ms_sensors_show_heater	drivers/iio/common/ms_sensors/ms_sensors_i2c.c	config_reg	1	13	\N	\N	\tu8 config_reg;\n\tint ret;\n\n\tmutex_lock(&dev_data->lock);\n\tret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, "%d\\n", (config_reg & 0x4) >> 2);\n	f
9235	441	verify_pefile_signature	crypto/asymmetric_keys/verify_pefile.c	ret	1	13	\N	\N	\tstruct pefile_context ctx;\n\tint ret;\n\n\tkenter("");\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tret = pefile_parse_binary(pebuf, pelen, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pefile_strip_sig_wrapper(pebuf, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = verify_pkcs7_signature(NULL, 0,\n\t\t\t\t     pebuf + ctx.sig_offset, ctx.sig_len,\n\t\t\t\t     trusted_keys, usage,\n\t\t\t\t     mscode_parse, &ctx);\n\tif (ret < 0)\n	f
25419	1776	sel_make_dir	security/selinux/selinuxfs.c	dentry	1	13	\N	\N	\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n	f
25863	1195	stmpe_chip_init	drivers/mfd/stmpe.c	id	1	13	\N	\N	\tunsigned int irq_trigger = stmpe->pdata->irq_trigger;\n\tint autosleep_timeout = stmpe->pdata->autosleep_timeout;\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tu8 icr = 0;\n\tunsigned int id;\n\tu8 data[2];\n\tint ret;\n\n\tret = stmpe_block_read(stmpe, stmpe->regs[STMPE_IDX_CHIP_ID],\n\t\t\t       ARRAY_SIZE(data), data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tid = (data[0] << 8) | data[1];\n\tif ((id & variant->id_mask) != variant->id_val) {\n\t\tdev_err(stmpe->dev, "unknown chip id: %#x\\n", id);\n	f
58039	399	cap11xx_i2c_probe	drivers/input/keyboard/cap11xx.c	gain32	1	13	\N	\N	\tstruct device *dev = &i2c_client->dev;\n\tstruct cap11xx_priv *priv;\n\tstruct device_node *node;\n\tconst struct cap11xx_hw_model *cap;\n\tint i, error, irq, gain = 0;\n\tunsigned int val, rev;\n\tu32 gain32;\n\n\tif (id->driver_data >= ARRAY_SIZE(cap11xx_devices)) {\n\t\tdev_err(dev, "Invalid device ID %lu\\n", id->driver_data);\n\t\treturn -EINVAL;\n\t}\n\n\tcap = &cap11xx_devices[id->driver_data];\n\tif (!cap || !cap->num_channels) {\n\t\tdev_err(dev, "Invalid device configuration\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev,\n\t\t\t    sizeof(*priv) +\n\t\t\t\tcap->num_channels * sizeof(priv->keycodes[0]),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c_client, &cap11xx_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_PRODUCT_ID, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != cap->product_id) {\n\t\tdev_err(dev, "Product ID: Got 0x%02x, expected 0x%02x\\n",\n\t\t\tval, cap->product_id);\n\t\treturn -ENXIO;\n\t}\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_MANUFACTURER_ID, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != CAP11XX_MANUFACTURER_ID) {\n\t\tdev_err(dev, "Manufacturer ID: Got 0x%02x, expected 0x%02x\\n",\n\t\t\tval, CAP11XX_MANUFACTURER_ID);\n\t\treturn -ENXIO;\n\t}\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_REVISION, &rev);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_info(dev, "CAP11XX detected, revision 0x%02x\\n", rev);\n\tnode = dev->of_node;\n\n\tif (!of_property_read_u32(node, "microchip,sensor-gain", &gain32)) {\n\t\tif (is_power_of_2(gain32) && gain32 <= 8)\n\t\t\tgain = ilog2(gain32);\n	f
-1007	404	exynos_ppmu_v2_set_event	drivers/devfreq/event/exynos-ppmu.c	pmnc	2	3	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tunsigned int pmnc, cntens;\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\n\t/* Enable all counters */\n\tret = regmap_read(info->regmap, PPMU_V2_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Set the event of Read/Write data count  */\n\tswitch (id) {\n\tcase PPMU_PMNCNT0:\n\tcase PPMU_PMNCNT1:\n\tcase PPMU_PMNCNT2:\n\t\tret = regmap_write(info->regmap, PPMU_V2_CH_EVx_TYPE(id),\n\t\t\t\tPPMU_V2_RO_DATA_CNT | PPMU_V2_WO_DATA_CNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PPMU_PMNCNT3:\n\t\tret = regmap_write(info->regmap, PPMU_V2_CH_EVx_TYPE(id),\n\t\t\t\tPPMU_V2_EVT3_RW_DATA_CNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* Reset cycle counter/performance counter and enable PPMU */\n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_DIVIDER_MASK\n\t\t\t| PPMU_V2_PMNC_START_MODE_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tpmnc |= (PPMU_V2_MODE_MANUAL << PPMU_V2_PMNC_START_MODE_SHIFT);\n\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n	f
28593	1416	ucma_join_ip_multicast	drivers/infiniband/core/ucma.c	&join_cmd	1	13	\N	\N	\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size((struct sockaddr *) &cmd.addr);\n\tjoin_cmd.join_flags = RDMA_MC_JOIN_FLAG_FULLMEMBER;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n	f
1830	135	configfs_new_inode	fs/configfs/inode.c	configfs_new_inode_$inode$obj$9$obj	0	13	\N	\N	\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n	f
40451	1058	divacapi_connect_didd	drivers/isdn/hardware/eicon/capifunc.c	DIDD_Table	1	13	\N	\N	\tint x = 0;\n\tint dadapter = 0;\n\tIDI_SYNC_REQ req;\n\tDESCRIPTOR DIDD_Table[MAX_DESCRIPTORS];\n\n\tDIVA_DIDD_Read(DIDD_Table, sizeof(DIDD_Table));\n	f
41440	178	tm6000_get_reg32	drivers/media/usb/tm6000/tm6000-core.c	rc	1	13	\N	\N	\tint rc;\n\tu8 buf[4];\n\n\trc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR, req,\n\t\t\t\t\tvalue, index, buf, 4);\n\n\tif (rc < 0)\n	f
54469	435	asoc_qcom_lpass_cpu_platform_probe	sound/soc/qcom/lpass-cpu.c	dsp_of_node	1	13	\N	\N	\tstruct lpass_data *drvdata;\n\tstruct device_node *dsp_of_node;\n\tstruct resource *res;\n\tstruct lpass_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tint ret, i, dai_id;\n\n\tdsp_of_node = of_parse_phandle(pdev->dev.of_node, "qcom,adsp", 0);\n\tif (dsp_of_node) {\n	f
55823	974	__qlcnic_83xx_process_aen	drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c	event	1	13	\N	\N	\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 event[QLC_83XX_MBX_AEN_CNT];\n\tint i;\n\n\tfor (i = 0; i < QLC_83XX_MBX_AEN_CNT; i++)\n\t\tevent[i] = readl(QLCNIC_MBX_FW(ahw, i));\n\n\tswitch (QLCNIC_MBX_RSP(event[0])) {\n	f
58157	3071	SYSC_rt_sigqueueinfo	kernel/signal.c	&info	1	13	\N	\N	\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n	f
59459	1449	nb8800_probe	drivers/net/ethernet/aurora/nb8800.c	priv->phy_node	1	13	\N	\N	\tconst struct of_device_id *match;\n\tconst struct nb8800_ops *ops = NULL;\n\tstruct nb8800_priv *priv;\n\tstruct resource *res;\n\tstruct net_device *dev;\n\tstruct mii_bus *bus;\n\tconst unsigned char *mac;\n\tvoid __iomem *base;\n\tint irq;\n\tint ret;\n\n\tmatch = of_match_device(nb8800_dt_ids, &pdev->dev);\n\tif (match)\n\t\tops = match->data;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0) {\n\t\tdev_err(&pdev->dev, "No IRQ\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdev_dbg(&pdev->dev, "AU-NB8800 Ethernet at %pa\\n", &res->start);\n\n\tdev = alloc_etherdev(sizeof(*priv));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->base = base;\n\n\tpriv->phy_mode = of_get_phy_mode(pdev->dev.of_node);\n\tif (priv->phy_mode < 0)\n\t\tpriv->phy_mode = PHY_INTERFACE_MODE_RGMII;\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, "failed to get clock\\n");\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto err_free_dev;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tspin_lock_init(&priv->tx_lock);\n\n\tif (ops && ops->reset) {\n\t\tret = ops->reset(dev);\n\t\tif (ret)\n\t\t\tgoto err_disable_clk;\n\t}\n\n\tbus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!bus) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_clk;\n\t}\n\n\tbus->name = "nb8800-mii";\n\tbus->read = nb8800_mdio_read;\n\tbus->write = nb8800_mdio_write;\n\tbus->parent = &pdev->dev;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, "%lx.nb8800-mii",\n\t\t (unsigned long)res->start);\n\tbus->priv = priv;\n\n\tret = of_mdiobus_register(bus, pdev->dev.of_node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, "failed to register MII bus\\n");\n\t\tgoto err_disable_clk;\n\t}\n\n\tif (of_phy_is_fixed_link(pdev->dev.of_node)) {\n\t\tret = of_phy_register_fixed_link(pdev->dev.of_node);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, "bad fixed-link spec\\n");\n\t\t\tgoto err_free_bus;\n\t\t}\n\t\tpriv->phy_node = of_node_get(pdev->dev.of_node);\n\t}\n\n\tif (!priv->phy_node)\n\t\tpriv->phy_node = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t  "phy-handle", 0);\n\n\tif (!priv->phy_node) {\n	f
60271	271	gpio_clk_driver_probe	drivers/clk/clk-gpio.c	of_flags	1	13	\N	\N	\tstruct device_node *node = pdev->dev.of_node;\n\tconst char **parent_names, *gpio_name;\n\tunsigned int num_parents;\n\tint gpio;\n\tenum of_gpio_flags of_flags;\n\tstruct clk *clk;\n\tbool active_low, is_mux;\n\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (num_parents) {\n\t\tparent_names = devm_kcalloc(&pdev->dev, num_parents,\n\t\t\t\t\t    sizeof(char *), GFP_KERNEL);\n\t\tif (!parent_names)\n\t\t\treturn -ENOMEM;\n\n\t\tof_clk_parent_fill(node, parent_names, num_parents);\n\t} else {\n\t\tparent_names = NULL;\n\t}\n\n\tis_mux = of_device_is_compatible(node, "gpio-mux-clock");\n\n\tgpio_name = is_mux ? "select-gpios" : "enable-gpios";\n\tgpio = of_get_named_gpio_flags(node, gpio_name, 0, &of_flags);\n\tif (gpio < 0) {\n\t\tif (gpio == -EPROBE_DEFER)\n\t\t\tpr_debug("%s: %s: GPIOs not yet available, retry later\\n",\n\t\t\t\t\tnode->name, __func__);\n\t\telse\n\t\t\tpr_err("%s: %s: Can't get '%s' DT property\\n",\n\t\t\t\t\tnode->name, __func__,\n\t\t\t\t\tgpio_name);\n\t\treturn gpio;\n\t}\n\n\tactive_low = of_flags & OF_GPIO_ACTIVE_LOW;\n	f
31180	738	persistent_commit_exception	drivers/md/dm-snap-persistent.c	persistent_commit_exception_	1	13	\N	\N	\tunsigned int i;\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tstruct commit_callback *cb;\n\n\tif (!valid)\n\t\tps->valid = 0;\n\n\tce.old_chunk = e->old_chunk;\n\tce.new_chunk = e->new_chunk;\n\twrite_exception(ps, ps->current_committed++, &ce);\n\n\t/*\n\t * Add the callback to the back of the array.  This code\n\t * is the only place where the callback array is\n\t * manipulated, and we know that it will never be called\n\t * multiple times concurrently.\n\t */\n\tcb = ps->callbacks + ps->callback_count++;\n\tcb->callback = callback;\n\tcb->context = callback_context;\n\n\t/*\n\t * If there are exceptions in flight and we have not yet\n\t * filled this metadata area there's nothing more to do.\n\t */\n\tif (!atomic_dec_and_test(&ps->pending_count) &&\n\t    (ps->current_committed != ps->exceptions_per_area))\n\t\treturn;\n\n\t/*\n\t * If we completely filled the current area, then wipe the next one.\n\t */\n\tif ((ps->current_committed == ps->exceptions_per_area) &&\n\t    zero_disk_area(ps, ps->current_area + 1))\n	f
31346	1048	dm_integrity_rw_tag	drivers/md/dm-integrity.c	b	1	13	\N	\N	\tdo {\n\t\tunsigned char *data, *dp;\n\t\tstruct dm_buffer *b;\n\t\tunsigned to_copy;\n\t\tint r;\n\n\t\tr = dm_integrity_failed(ic);\n\t\tif (unlikely(r))\n\t\t\treturn r;\n\n\t\tdata = dm_bufio_read(ic->bufio, *metadata_block, &b);\n\t\tif (unlikely(IS_ERR(data)))\n\t\t\treturn PTR_ERR(data);\n\n\t\tto_copy = min((1U << SECTOR_SHIFT << ic->log2_buffer_sectors) - *metadata_offset, total_size);\n\t\tdp = data + *metadata_offset;\n\t\tif (op == TAG_READ) {\n\t\t\tmemcpy(tag, dp, to_copy);\n\t\t} else if (op == TAG_WRITE) {\n\t\t\tmemcpy(dp, tag, to_copy);\n\t\t\tdm_bufio_mark_partial_buffer_dirty(b, *metadata_offset, *metadata_offset + to_copy);\n	f
-1005	363	qcom_ebi2_probe	drivers/bus/qcom-ebi2.c	csindex	2	3	\N	\N	\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tvoid __iomem *ebi2_base;\n\tvoid __iomem *ebi2_xmem;\n\tstruct clk *ebi2xclk;\n\tstruct clk *ebi2clk;\n\tbool have_children = false;\n\tu32 val;\n\tint ret;\n\n\tebi2xclk = devm_clk_get(dev, "ebi2x");\n\tif (IS_ERR(ebi2xclk))\n\t\treturn PTR_ERR(ebi2xclk);\n\n\tret = clk_prepare_enable(ebi2xclk);\n\tif (ret) {\n\t\tdev_err(dev, "could not enable EBI2X clk (%d)\\n", ret);\n\t\treturn ret;\n\t}\n\n\tebi2clk = devm_clk_get(dev, "ebi2");\n\tif (IS_ERR(ebi2clk)) {\n\t\tret = PTR_ERR(ebi2clk);\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tret = clk_prepare_enable(ebi2clk);\n\tif (ret) {\n\t\tdev_err(dev, "could not enable EBI2 clk\\n");\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tebi2_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_base)) {\n\t\tret = PTR_ERR(ebi2_base);\n\t\tgoto err_disable_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tebi2_xmem = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_xmem)) {\n\t\tret = PTR_ERR(ebi2_xmem);\n\t\tgoto err_disable_clk;\n\t}\n\n\t/* Allegedly this turns the power save mode off */\n\twritel(0UL, ebi2_xmem + EBI2_XMEM_CFG);\n\n\t/* Disable all chipselects */\n\tval = readl(ebi2_base);\n\tval &= ~EBI2_CSN_MASK;\n\twritel(val, ebi2_base);\n\n\t/* Walk over the child nodes and see what chipselects we use */\n\tfor_each_available_child_of_node(np, child) {\n\t\tu32 csindex;\n\n\t\t/* Figure out the chipselect */\n\t\tret = of_property_read_u32(child, "reg", &csindex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (csindex > 5) {\n	f
23352	315	ocfs2_blockcheck_stats_debugfs_install	fs/ocfs2/blockcheck.c	stats	1	13	\N	\N	\treturn ocfs2_blockcheck_debug_install(stats, parent);\n	f
35778	1262	nilfs_ioctl_set_suinfo	fs/nilfs2/ioctl.c	len	1	13	\N	\N	\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n	f
44658	1130	bnx2fc_fip_send	drivers/scsi/bnx2fc/bnx2fc_fcoe.c	skb	1	13	\N	\N	\tstruct fip_header *fiph;\n\tstruct ethhdr *eth_hdr;\n\tu16 op;\n\tu8 sub;\n\n\tfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\n\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tif (op == FIP_OP_CTRL && sub == FIP_SC_SOL && bnx2fc_log_fka)\n\t\tBNX2FC_MISC_DBG("Sending FKA from %pM to %pM.\\n",\n\t\t    eth_hdr->h_source, eth_hdr->h_dest);\n\n\tskb->dev = bnx2fc_from_ctlr(fip)->netdev;\n\tdev_queue_xmit(skb);\n	f
52332	299	b53_spi_probe	drivers/net/dsa/b53/b53_spi.c	ret	1	13	\N	\N	\tstruct b53_device *dev;\n\tint ret;\n\n\tdev = b53_switch_alloc(&spi->dev, &b53_spi_ops, spi);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tif (spi->dev.platform_data)\n\t\tdev->pdata = spi->dev.platform_data;\n\n\tret = b53_switch_register(dev);\n\tif (ret)\n	f
58475	79	ct_card_probe	sound/pci/ctxfi/xfi.c	card->dev	1	13	\N	\N	\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct ct_atc *atc;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err)\n\t\treturn err;\n\tif ((reference_rate != 48000) && (reference_rate != 44100)) {\n\t\tdev_err(card->dev,\n	f
36295	3409	skd_pci_resume	drivers/block/skd_main.c	rc	1	13	\N	\N	\tint i;\n\tint rc = 0;\n\tstruct skd_device *skdev;\n\n\tskdev = pci_get_drvdata(pdev);\n\tif (!skdev) {\n\t\tdev_err(&pdev->dev, "no device data for PCI\\n");\n\t\treturn -1;\n\t}\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out;\n\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\n\tif (!rc) {\n\t\tif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {\n\n\t\t\tdev_err(&pdev->dev, "consistent DMA mask error %d\\n",\n\t\t\t\trc);\n\t\t}\n\t} else {\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (rc) {\n\n\t\t\tdev_err(&pdev->dev, "DMA mask error %d\\n", rc);\n\t\t\tgoto err_out_regions;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\trc = pci_enable_pcie_error_reporting(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t"bad enable of PCIe error reporting rc=%d\\n", rc);\n\t\tskdev->pcie_error_reporting_is_enabled = 0;\n\t} else\n\t\tskdev->pcie_error_reporting_is_enabled = 1;\n\n\tfor (i = 0; i < SKD_MAX_BARS; i++) {\n\n\t\tskdev->mem_phys[i] = pci_resource_start(pdev, i);\n\t\tskdev->mem_size[i] = (u32)pci_resource_len(pdev, i);\n\t\tskdev->mem_map[i] = ioremap(skdev->mem_phys[i],\n\t\t\t\t\t    skdev->mem_size[i]);\n\t\tif (!skdev->mem_map[i]) {\n\t\t\tdev_err(&pdev->dev, "Unable to map adapter memory!\\n");\n\t\t\trc = -ENODEV;\n\t\t\tgoto err_out_iounmap;\n\t\t}\n\t\tdev_dbg(&pdev->dev, "mem_map=%p, phyd=%016llx, size=%d\\n",\n\t\t\tskdev->mem_map[i], (uint64_t)skdev->mem_phys[i],\n\t\t\tskdev->mem_size[i]);\n\t}\n\trc = skd_acquire_irq(skdev);\n\tif (rc) {\n	f
39605	1454	count_inode_refs	fs/btrfs/tree-log.c	ptr_end	1	13	\N	\N	\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n	f
2576	140	iproc_adc_reg_dump	drivers/iio/adc/bcm_iproc_adc.c	iproc_adc_reg_dump_$val101$obj	0	13	\N	\N	\tstruct device *dev = &indio_dev->dev;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL1);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL2);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_THRES);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_MASK);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_STATUS);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_CONTROLLER_STATUS);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_ANALOG_CONTROL);\n	f
2394	3663	add_cea_modes	drivers/gpu/drm/drm_edid.c	i	1	13	\N	\N	\tconst u8 *cea = drm_find_cea_extension(edid);\n\tconst u8 *db, *hdmi = NULL, *video = NULL;\n\tu8 dbl, hdmi_len, video_len = 0;\n\tint modes = 0;\n\n\tif (cea && cea_revision(cea) >= 3) {\n\t\tint i, start, end;\n\n\t\tif (cea_db_offsets(cea, &start, &end))\n\t\t\treturn 0;\n\n\t\tfor_each_cea_db(cea, i, start, end) {\n	f
8634	773	ucma_copy_iboe_route	drivers/infiniband/core/ucma.c	&resp->ib_route[1]	1	13	\N	\N	\n\tresp->num_paths = route->num_paths;\n\tswitch (route->num_paths) {\n\tcase 0:\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.dst_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].dgid);\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.src_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(0xffff);\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n	f
8909	953	mv88e6xxx_g2_misc_5_bit_port	drivers/net/dsa/mv88e6xxx/global2.c	val	1	13	\N	\N	\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_g2_read(chip, MV88E6XXX_G2_MISC, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (port_5_bit)\n\t\tval |= MV88E6XXX_G2_MISC_5_BIT_PORT;\n\telse\n\t\tval &= ~MV88E6XXX_G2_MISC_5_BIT_PORT;\n\n\treturn mv88e6xxx_g2_write(chip, MV88E6XXX_G2_MISC, val);\n	f
42238	366	cfctrl_recv	net/caif/cfctrl.c	cmdrsp	1	13	\N	\N	\tu8 cmdrsp;\n\tu8 cmd;\n\tint ret = -1;\n\tu16 tmp16;\n\tu8 len;\n\tu8 param[255];\n\tu8 linkid;\n\tstruct cfctrl *cfctrl = container_obj(layer);\n\tstruct cfctrl_request_info rsp, *req;\n\n\n\tcfpkt_extr_head(pkt, &cmdrsp, 1);\n\tcmd = cmdrsp & CFCTRL_CMD_MASK;\n\tif (cmd != CFCTRL_CMD_LINK_ERR\n\t    && CFCTRL_RSP_BIT != (CFCTRL_RSP_BIT & cmdrsp)\n	f
44448	4599	btrfs_check_ref_name_override	fs/btrfs/tree-log.c	di_key.type	1	13	\N	\N	\tint ret;\n\tstruct btrfs_path *search_path;\n\tchar *name = NULL;\n\tu32 name_len = 0;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tu32 cur_offset = 0;\n\tunsigned long ptr = btrfs_item_ptr_offset(eb, slot);\n\n\tsearch_path = btrfs_alloc_path();\n\tif (!search_path)\n\t\treturn -ENOMEM;\n\tsearch_path->search_commit_root = 1;\n\tsearch_path->skip_locking = 1;\n\n\twhile (cur_offset < item_size) {\n\t\tu64 parent;\n\t\tu32 this_name_len;\n\t\tu32 this_len;\n\t\tunsigned long name_ptr;\n\t\tstruct btrfs_dir_item *di;\n\n\t\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tstruct btrfs_inode_ref *iref;\n\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur_offset);\n\t\t\tparent = key->offset;\n\t\t\tthis_name_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_ptr = (unsigned long)(iref + 1);\n\t\t\tthis_len = sizeof(*iref) + this_name_len;\n\t\t} else {\n\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t\t       cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tthis_name_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_ptr = (unsigned long)&extref->name;\n\t\t\tthis_len = sizeof(*extref) + this_name_len;\n\t\t}\n\n\t\tret = btrfs_is_name_len_valid(eb, slot, name_ptr,\n\t\t\t\t\t      this_name_len);\n\t\tif (!ret) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (this_name_len > name_len) {\n\t\t\tchar *new_name;\n\n\t\t\tnew_name = krealloc(name, this_name_len, GFP_NOFS);\n\t\t\tif (!new_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tname_len = this_name_len;\n\t\t\tname = new_name;\n\t\t}\n\n\t\tread_extent_buffer(eb, name, name_ptr, this_name_len);\n\t\tdi = btrfs_lookup_dir_item(NULL, inode->root, search_path,\n\t\t\t\tparent, name, this_name_len, 0);\n\t\tif (di && !IS_ERR(di)) {\n\t\t\tstruct btrfs_key di_key;\n\n\t\t\tbtrfs_dir_item_key_to_cpu(search_path->nodes[0],\n\t\t\t\t\t\t  di, &di_key);\n\t\t\tif (di_key.type == BTRFS_INODE_ITEM_KEY) {\n	f
53718	78	crypto_ecb_encrypt	crypto/ecb.c	&walk	1	13	\N	\N	\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct crypto_ecb_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tstruct crypto_cipher *child = ctx->child;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n	f
58279	2630	msr_io	arch/x86/kvm/x86.c	size	1	13	\N	\N	\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n	f
29931	314	ata_ncq_prio_enable_store	drivers/ata/libata-scsi.c	input	1	13	\N	\N	\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap;\n\tstruct ata_device *dev;\n\tlong int input;\n\tint rc;\n\n\trc = kstrtol(buf, 10, &input);\n\tif (rc)\n\t\treturn rc;\n\tif ((input < 0) || (input > 1))\n	f
41481	2102	dequeue_rx	drivers/atm/nicstar.c	dequeue_rx_$iov$obj	0	13	\N	\N	\tu32 vpi, vci;\n\tvc_map *vc;\n\tstruct sk_buff *iovb;\n\tstruct iovec *iov;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tunsigned short aal5_len;\n\tint len;\n\tu32 stat;\n\tu32 id;\n\n\tstat = readl(card->membase + STAT);\n\tcard->sbfqc = ns_stat_sfbqc_get(stat);\n\tcard->lbfqc = ns_stat_lfbqc_get(stat);\n\n\tid = le32_to_cpu(rsqe->buffer_handle);\n\tskb = idr_remove(&card->idr, id);\n\tif (!skb) {\n\t\tRXPRINTK(KERN_ERR\n\t\t\t "nicstar%d: skb not found!\\n", card->index);\n\t\treturn;\n\t}\n\tdma_sync_single_for_cpu(&card->pcidev->dev,\n\t\t\t\tNS_PRV_DMA(skb),\n\t\t\t\t(NS_PRV_BUFTYPE(skb) == BUF_SM\n\t\t\t\t ? NS_SMSKBSIZE : NS_LGSKBSIZE),\n\t\t\t\tDMA_FROM_DEVICE);\n\tdma_unmap_single(&card->pcidev->dev,\n\t\t\t NS_PRV_DMA(skb),\n\t\t\t (NS_PRV_BUFTYPE(skb) == BUF_SM\n\t\t\t  ? NS_SMSKBSIZE : NS_LGSKBSIZE),\n\t\t\t DMA_FROM_DEVICE);\n\tvpi = ns_rsqe_vpi(rsqe);\n\tvci = ns_rsqe_vci(rsqe);\n\tif (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {\n\t\tprintk("nicstar%d: SDU received for out-of-range vc %d.%d.\\n",\n\t\t       card->index, vpi, vci);\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\tvc = &(card->vcmap[vpi << card->vcibits | vci]);\n\tif (!vc->rx) {\n\t\tRXPRINTK("nicstar%d: SDU received on non-rx vc %d.%d.\\n",\n\t\t\t card->index, vpi, vci);\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\tvcc = vc->rx_vcc;\n\n\tif (vcc->qos.aal == ATM_AAL0) {\n\t\tstruct sk_buff *sb;\n\t\tunsigned char *cell;\n\t\tint i;\n\n\t\tcell = skb->data;\n\t\tfor (i = ns_rsqe_cellcount(rsqe); i; i--) {\n\t\t\tsb = dev_alloc_skb(NS_SMSKBSIZE);\n\t\t\tif (!sb) {\n\t\t\t\tprintk\n\t\t\t\t    ("nicstar%d: Can't allocate buffers for aal0.\\n",\n\t\t\t\t     card->index);\n\t\t\t\tatomic_add(i, &vcc->stats->rx_drop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\t\tRXPRINTK\n\t\t\t\t    ("nicstar%d: atm_charge() dropped aal0 packets.\\n",\n\t\t\t\t     card->index);\n\t\t\t\tatomic_add(i - 1, &vcc->stats->rx_drop);\t/* already increased by 1 */\n\t\t\t\tdev_kfree_skb_any(sb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Rebuild the header */\n\t\t\t*((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |\n\t\t\t    (ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);\n\t\t\tif (i == 1 && ns_rsqe_eopdu(rsqe))\n\t\t\t\t*((u32 *) sb->data) |= 0x00000002;\n\t\t\tskb_put(sb, NS_AAL0_HEADER);\n\t\t\tmemcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);\n\t\t\tskb_put(sb, ATM_CELL_PAYLOAD);\n\t\t\tATM_SKB(sb)->vcc = vcc;\n\t\t\t__net_timestamp(sb);\n\t\t\tvcc->push(vcc, sb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\tcell += ATM_CELL_PAYLOAD;\n\t\t}\n\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\t/* To reach this point, the AAL layer can only be AAL5 */\n\n\tif ((iovb = vc->rx_iov) == NULL) {\n\t\tiovb = skb_dequeue(&(card->iovpool.queue));\n\t\tif (iovb == NULL) {\t/* No buffers in the queue */\n\t\t\tiovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);\n\t\t\tif (iovb == NULL) {\n\t\t\t\tprintk("nicstar%d: Out of iovec buffers.\\n",\n\t\t\t\t       card->index);\n\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t\trecycle_rx_buf(card, skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\t} else if (--card->iovpool.count < card->iovnr.min) {\n\t\t\tstruct sk_buff *new_iovb;\n\t\t\tif ((new_iovb =\n\t\t\t     alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL) {\n\t\t\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\t\t\tskb_queue_tail(&card->iovpool.queue, new_iovb);\n\t\t\t\tcard->iovpool.count++;\n\t\t\t}\n\t\t}\n\t\tvc->rx_iov = iovb;\n\t\tNS_PRV_IOVCNT(iovb) = 0;\n\t\tiovb->len = 0;\n\t\tiovb->data = iovb->head;\n\t\tskb_reset_tail_pointer(iovb);\n\t\t/* IMPORTANT: a pointer to the sk_buff containing the small or large\n\t\t   buffer is stored as iovec base, NOT a pointer to the\n\t\t   small or large buffer itself. */\n\t} else if (NS_PRV_IOVCNT(iovb) >= NS_MAX_IOVECS) {\n\t\tprintk("nicstar%d: received too big AAL5 SDU.\\n", card->index);\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t\trecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\n\t\t\t\t      NS_MAX_IOVECS);\n\t\tNS_PRV_IOVCNT(iovb) = 0;\n\t\tiovb->len = 0;\n\t\tiovb->data = iovb->head;\n\t\tskb_reset_tail_pointer(iovb);\n\t}\n\tiov = &((struct iovec *)iovb->data)[NS_PRV_IOVCNT(iovb)++];\n\tiov->iov_base = (void *)skb;\n	f
35883	3419	mwifiex_cfg80211_suspend	drivers/net/wireless/marvell/mwifiex/cfg80211.c	ret	1	13	\N	\N	\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_ds_hs_cfg hs_cfg;\n\tint i, ret = 0, retry_num = 10;\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_private *sta_priv =\n\t\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\n\tsta_priv->scan_aborting = true;\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tmwifiex_abort_cac(priv);\n\t}\n\n\tmwifiex_cancel_all_pending_cmd(adapter);\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv && priv->netdev)\n\t\t\tnetif_device_detach(priv->netdev);\n\t}\n\n\tfor (i = 0; i < retry_num; i++) {\n\t\tif (!mwifiex_wmm_lists_empty(adapter) ||\n\t\t    !mwifiex_bypass_txlist_empty(adapter) ||\n\t\t    !skb_queue_empty(&adapter->tx_data_q))\n\t\t\tusleep_range(10000, 15000);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!wowlan) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    "None of the WOWLAN triggers enabled\\n");\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tif (!sta_priv->media_connected && !wowlan->nd_config) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    "Can not configure WOWLAN in disconnected state\\n");\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tret = mwifiex_set_mef_filter(sta_priv, wowlan);\n\tif (ret) {\n	f
44516	101	stm32_dwmac_probe	drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c	&stmmac_res	1	13	\N	\N	\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct stm32_dwmac *dwmac;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n	f
37278	11676	ipw_pci_probe	drivers/net/wireless/intel/ipw2x00/ipw2200.c	val	1	13	\N	\N	\tint err = 0;\n\tstruct net_device *net_dev;\n\tvoid __iomem *base;\n\tu32 length, val;\n\tstruct ipw_priv *priv;\n\tint i;\n\n\tnet_dev = alloc_libipw(sizeof(struct ipw_priv), 0);\n\tif (net_dev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpriv = libipw_priv(net_dev);\n\tpriv->ieee = netdev_priv(net_dev);\n\n\tpriv->net_dev = net_dev;\n\tpriv->pci_dev = pdev;\n\tipw_debug_level = debug;\n\tspin_lock_init(&priv->irq_lock);\n\tspin_lock_init(&priv->lock);\n\tfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&priv->ibss_mac_hash[i]);\n\n\tmutex_init(&priv->mutex);\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_libipw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (!err)\n\t\terr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME ": No suitable DMA available.\\n");\n\t\tgoto out_pci_disable_device;\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_read_config_dword(pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n	f
51474	1584	bond_enslave	drivers/net/bonding/bond_main.c	link_reporting	1	13	\N	\N	\tstruct bonding *bond = netdev_priv(bond_dev);\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct slave *new_slave = NULL, *prev_slave;\n\tstruct sockaddr_storage ss;\n\tint link_reporting;\n\tint res = 0, i;\n\n\tif (!bond->params.use_carrier &&\n\t    slave_dev->ethtool_ops->get_link == NULL &&\n\t    slave_ops->ndo_do_ioctl == NULL) {\n\t\tnetdev_warn(bond_dev, "no link monitoring support for %s\\n",\n\t\t\t    slave_dev->name);\n\t}\n\n\t/* already in-use? */\n\tif (netdev_is_rx_handler_busy(slave_dev)) {\n\t\tnetdev_err(bond_dev,\n\t\t\t   "Error: Device is in use and cannot be enslaved\\n");\n\t\treturn -EBUSY;\n\t}\n\n\tif (bond_dev == slave_dev) {\n\t\tnetdev_err(bond_dev, "cannot enslave bond to itself.\\n");\n\t\treturn -EPERM;\n\t}\n\n\t/* vlan challenged mutual exclusion */\n\t/* no need to lock since we're protected by rtnl_lock */\n\tif (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {\n\t\tnetdev_dbg(bond_dev, "%s is NETIF_F_VLAN_CHALLENGED\\n",\n\t\t\t   slave_dev->name);\n\t\tif (vlan_uses_dev(bond_dev)) {\n\t\t\tnetdev_err(bond_dev, "Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\\n",\n\t\t\t\t   slave_dev->name, bond_dev->name);\n\t\t\treturn -EPERM;\n\t\t} else {\n\t\t\tnetdev_warn(bond_dev, "enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\\n",\n\t\t\t\t    slave_dev->name, slave_dev->name,\n\t\t\t\t    bond_dev->name);\n\t\t}\n\t} else {\n\t\tnetdev_dbg(bond_dev, "%s is !NETIF_F_VLAN_CHALLENGED\\n",\n\t\t\t   slave_dev->name);\n\t}\n\n\t/* Old ifenslave binaries are no longer supported.  These can\n\t * be identified with moderate accuracy by the state of the slave:\n\t * the current ifenslave will set the interface down prior to\n\t * enslaving it; the old ifenslave will not.\n\t */\n\tif (slave_dev->flags & IFF_UP) {\n\t\tnetdev_err(bond_dev, "%s is up - this may be due to an out of date ifenslave\\n",\n\t\t\t   slave_dev->name);\n\t\treturn -EPERM;\n\t}\n\n\t/* set bonding device ether type by slave - bonding netdevices are\n\t * created with ether_setup, so when the slave type is not ARPHRD_ETHER\n\t * there is a need to override some of the type dependent attribs/funcs.\n\t *\n\t * bond ether type mutual exclusion - don't allow slaves of dissimilar\n\t * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond\n\t */\n\tif (!bond_has_slaves(bond)) {\n\t\tif (bond_dev->type != slave_dev->type) {\n\t\t\tnetdev_dbg(bond_dev, "change device type from %d to %d\\n",\n\t\t\t\t   bond_dev->type, slave_dev->type);\n\n\t\t\tres = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,\n\t\t\t\t\t\t       bond_dev);\n\t\t\tres = notifier_to_errno(res);\n\t\t\tif (res) {\n\t\t\t\tnetdev_err(bond_dev, "refused to change device type\\n");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\t/* Flush unicast and multicast addresses */\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse {\n\t\t\t\tether_setup(bond_dev);\n\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\t\t}\n\n\t\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE,\n\t\t\t\t\t\t bond_dev);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tnetdev_err(bond_dev, "%s ether type (%d) is different from other slaves (%d), can not enslave it\\n",\n\t\t\t   slave_dev->name, slave_dev->type, bond_dev->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (slave_dev->type == ARPHRD_INFINIBAND &&\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\tnetdev_warn(bond_dev, "Type (%d) supports only active-backup mode\\n",\n\t\t\t    slave_dev->type);\n\t\tres = -EOPNOTSUPP;\n\t\tgoto err_undo_flags;\n\t}\n\n\tif (!slave_ops->ndo_set_mac_address ||\n\t    slave_dev->type == ARPHRD_INFINIBAND) {\n\t\tnetdev_warn(bond_dev, "The slave device specified does not support setting the MAC address\\n");\n\t\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&\n\t\t    bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t\tif (!bond_has_slaves(bond)) {\n\t\t\t\tbond->params.fail_over_mac = BOND_FOM_ACTIVE;\n\t\t\t\tnetdev_warn(bond_dev, "Setting fail_over_mac to active for active-backup mode\\n");\n\t\t\t} else {\n\t\t\t\tnetdev_err(bond_dev, "The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active\\n");\n\t\t\t\tres = -EOPNOTSUPP;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\t\t}\n\t}\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, slave_dev);\n\n\t/* If this is the first slave, then we need to set the master's hardware\n\t * address to be the same as the slave's.\n\t */\n\tif (!bond_has_slaves(bond) &&\n\t    bond->dev->addr_assign_type == NET_ADDR_RANDOM)\n\t\tbond_set_dev_addr(bond->dev, slave_dev);\n\n\tnew_slave = bond_alloc_slave(bond);\n\tif (!new_slave) {\n\t\tres = -ENOMEM;\n\t\tgoto err_undo_flags;\n\t}\n\n\tnew_slave->bond = bond;\n\tnew_slave->dev = slave_dev;\n\t/* Set the new_slave's queue_id to be zero.  Queue ID mapping\n\t * is set via sysfs or module option if desired.\n\t */\n\tnew_slave->queue_id = 0;\n\n\t/* Save slave's original mtu and then set it to match the bond */\n\tnew_slave->original_mtu = slave_dev->mtu;\n\tres = dev_set_mtu(slave_dev, bond->dev->mtu);\n\tif (res) {\n\t\tnetdev_dbg(bond_dev, "Error %d calling dev_set_mtu\\n", res);\n\t\tgoto err_free;\n\t}\n\n\t/* Save slave's original ("permanent") mac address for modes\n\t * that need it, and for restoring it upon release, and then\n\t * set it to the master's address\n\t */\n\tbond_hw_addr_copy(new_slave->perm_hwaddr, slave_dev->dev_addr,\n\t\t\t  slave_dev->addr_len);\n\n\tif (!bond->params.fail_over_mac ||\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t/* Set slave to master's mac address.  The application already\n\t\t * set the master's mac address to that of the first slave\n\t\t */\n\t\tmemcpy(ss.__data, bond_dev->dev_addr, bond_dev->addr_len);\n\t\tss.ss_family = slave_dev->type;\n\t\tres = dev_set_mac_address(slave_dev, (struct sockaddr *)&ss);\n\t\tif (res) {\n\t\t\tnetdev_dbg(bond_dev, "Error %d calling set_mac_address\\n", res);\n\t\t\tgoto err_restore_mtu;\n\t\t}\n\t}\n\n\t/* set slave flag before open to prevent IPv6 addrconf */\n\tslave_dev->flags |= IFF_SLAVE;\n\n\t/* open the slave since the application closed it */\n\tres = dev_open(slave_dev);\n\tif (res) {\n\t\tnetdev_dbg(bond_dev, "Opening slave %s failed\\n", slave_dev->name);\n\t\tgoto err_restore_mac;\n\t}\n\n\tslave_dev->priv_flags |= IFF_BONDING;\n\t/* initialize slave stats */\n\tdev_get_stats(new_slave->dev, &new_slave->slave_stats);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* bond_alb_init_slave() must be called before all other stages since\n\t\t * it might fail and we do not want to have to undo everything\n\t\t */\n\t\tres = bond_alb_init_slave(bond, new_slave);\n\t\tif (res)\n\t\t\tgoto err_close;\n\t}\n\n\t/* If the mode uses primary, then the following is handled by\n\t * bond_change_active_slave().\n\t */\n\tif (!bond_uses_primary(bond)) {\n\t\t/* set promiscuity level to new slave */\n\t\tif (bond_dev->flags & IFF_PROMISC) {\n\t\t\tres = dev_set_promiscuity(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\t/* set allmulti level to new slave */\n\t\tif (bond_dev->flags & IFF_ALLMULTI) {\n\t\t\tres = dev_set_allmulti(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\tnetif_addr_lock_bh(bond_dev);\n\n\t\tdev_mc_sync_multiple(slave_dev, bond_dev);\n\t\tdev_uc_sync_multiple(slave_dev, bond_dev);\n\n\t\tnetif_addr_unlock_bh(bond_dev);\n\t}\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t/* add lacpdu mc addr to mc list */\n\t\tu8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;\n\n\t\tdev_mc_add(slave_dev, lacpdu_multicast);\n\t}\n\n\tres = vlan_vids_add_by_dev(slave_dev, bond_dev);\n\tif (res) {\n\t\tnetdev_err(bond_dev, "Couldn't add bond vlan ids to %s\\n",\n\t\t\t   slave_dev->name);\n\t\tgoto err_close;\n\t}\n\n\tprev_slave = bond_last_slave(bond);\n\n\tnew_slave->delay = 0;\n\tnew_slave->link_failure_count = 0;\n\n\tif (bond_update_speed_duplex(new_slave) &&\n\t    bond_needs_speed_duplex(bond))\n\t\tnew_slave->link = BOND_LINK_DOWN;\n\n\tnew_slave->last_rx = jiffies -\n\t\t(msecs_to_jiffies(bond->params.arp_interval) + 1);\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++)\n\t\tnew_slave->target_last_arp_rx[i] = new_slave->last_rx;\n\n\tif (bond->params.miimon && !bond->params.use_carrier) {\n\t\tlink_reporting = bond_check_dev_link(bond, slave_dev, 1);\n\n\t\tif ((link_reporting == -1) && !bond->params.arp_interval) {\n	f
4625	486	fan1_div_store	drivers/hwmon/max6650.c	div	1	13	\N	\N	\tstruct max6650_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long div;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &div);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (div) {\n	f
26757	799	bmp180_read_adc_press	drivers/iio/pressure/bmp280-core.c	ret	1	13	\N	\N	\tint ret;\n\t__be32 tmp = 0;\n\tu8 oss = data->oversampling_press;\n\n\tret = bmp180_measure(data, BMP180_MEAS_PRESS_X(oss));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP180_REG_OUT_MSB, (u8 *)&tmp, 3);\n\tif (ret)\n	f
53111	1224	xlgmac_rx_poll	drivers/net/ethernet/synopsys/dwc-xlgmac-net.c	skb->protocol	1	13	\N	\N	\tstruct xlgmac_pdata *pdata = channel->pdata;\n\tstruct xlgmac_ring *ring = channel->rx_ring;\n\tstruct net_device *netdev = pdata->netdev;\n\tunsigned int len, dma_desc_len, max_len;\n\tunsigned int context_next, context;\n\tstruct xlgmac_desc_data *desc_data;\n\tstruct xlgmac_pkt_info *pkt_info;\n\tunsigned int incomplete, error;\n\tstruct xlgmac_hw_ops *hw_ops;\n\tunsigned int received = 0;\n\tstruct napi_struct *napi;\n\tstruct sk_buff *skb;\n\tint packet_count = 0;\n\n\thw_ops = &pdata->hw_ops;\n\n\t/* Nothing to do if there isn't a Rx ring for this channel */\n\tif (!ring)\n\t\treturn 0;\n\n\tincomplete = 0;\n\tcontext_next = 0;\n\n\tnapi = (pdata->per_channel_irq) ? &channel->napi : &pdata->napi;\n\n\tdesc_data = XLGMAC_GET_DESC_DATA(ring, ring->cur);\n\tpkt_info = &ring->pkt_info;\n\twhile (packet_count < budget) {\n\t\t/* First time in loop see if we need to restore state */\n\t\tif (!received && desc_data->state_saved) {\n\t\t\tskb = desc_data->state.skb;\n\t\t\terror = desc_data->state.error;\n\t\t\tlen = desc_data->state.len;\n\t\t} else {\n\t\t\tmemset(pkt_info, 0, sizeof(*pkt_info));\n\t\t\tskb = NULL;\n\t\t\terror = 0;\n\t\t\tlen = 0;\n\t\t}\n\nread_again:\n\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, ring->cur);\n\n\t\tif (xlgmac_rx_dirty_desc(ring) > XLGMAC_RX_DESC_MAX_DIRTY)\n\t\t\txlgmac_rx_refresh(channel);\n\n\t\tif (hw_ops->dev_read(channel))\n\t\t\tbreak;\n\n\t\treceived++;\n\t\tring->cur++;\n\n\t\tincomplete = XLGMAC_GET_REG_BITS(\n\t\t\t\t\tpkt_info->attributes,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_INCOMPLETE_POS,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_INCOMPLETE_LEN);\n\t\tcontext_next = XLGMAC_GET_REG_BITS(\n\t\t\t\t\tpkt_info->attributes,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_CONTEXT_NEXT_POS,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_CONTEXT_NEXT_LEN);\n\t\tcontext = XLGMAC_GET_REG_BITS(\n\t\t\t\t\tpkt_info->attributes,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_CONTEXT_POS,\n\t\t\t\t\tRX_PACKET_ATTRIBUTES_CONTEXT_LEN);\n\n\t\t/* Earlier error, just drain the remaining data */\n\t\tif ((incomplete || context_next) && error)\n\t\t\tgoto read_again;\n\n\t\tif (error || pkt_info->errors) {\n\t\t\tif (pkt_info->errors)\n\t\t\t\tnetif_err(pdata, rx_err, netdev,\n\t\t\t\t\t  "error in received packet\\n");\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto next_packet;\n\t\t}\n\n\t\tif (!context) {\n\t\t\t/* Length is cumulative, get this descriptor's length */\n\t\t\tdma_desc_len = desc_data->rx.len - len;\n\t\t\tlen += dma_desc_len;\n\n\t\t\tif (dma_desc_len && !skb) {\n\t\t\t\tskb = xlgmac_create_skb(pdata, napi, desc_data,\n\t\t\t\t\t\t\tdma_desc_len);\n\t\t\t\tif (!skb)\n\t\t\t\t\terror = 1;\n\t\t\t} else if (dma_desc_len) {\n\t\t\t\tdma_sync_single_range_for_cpu(\n\t\t\t\t\t\tpdata->dev,\n\t\t\t\t\t\tdesc_data->rx.buf.dma_base,\n\t\t\t\t\t\tdesc_data->rx.buf.dma_off,\n\t\t\t\t\t\tdesc_data->rx.buf.dma_len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\tskb_add_rx_frag(\n\t\t\t\t\tskb, skb_shinfo(skb)->nr_frags,\n\t\t\t\t\tdesc_data->rx.buf.pa.pages,\n\t\t\t\t\tdesc_data->rx.buf.pa.pages_offset,\n\t\t\t\t\tdma_desc_len,\n\t\t\t\t\tdesc_data->rx.buf.dma_len);\n\t\t\t\tdesc_data->rx.buf.pa.pages = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete || context_next)\n\t\t\tgoto read_again;\n\n\t\tif (!skb)\n\t\t\tgoto next_packet;\n\n\t\t/* Be sure we don't exceed the configured MTU */\n\t\tmax_len = netdev->mtu + ETH_HLEN;\n\t\tif (!(netdev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t\t    (skb->protocol == htons(ETH_P_8021Q)))\n	f
-1021	479	__assign_resources_sorted	drivers/pci/setup-bus.c	&save_head	2	3	\N	\N	\t/*\n\t * Should not assign requested resources at first.\n\t *   they could be adjacent, so later reassign can not reallocate\n\t *   them one by one in parent resource window.\n\t * Try to assign requested + add_size at beginning\n\t *  if could do that, could get out early.\n\t *  if could not do that, we still try to assign requested at first,\n\t *    then try to reassign add_size for some resources.\n\t *\n\t * Separate three resource type checking if we need to release\n\t * assigned resource after requested + add_size try.\n\t *\t1. if there is io port assign fail, will release assigned\n\t *\t   io port.\n\t *\t2. if there is pref mmio assign fail, release assigned\n\t *\t   pref mmio.\n\t *\t   if assigned pref mmio's parent is non-pref mmio and there\n\t *\t   is non-pref mmio assign fail, will release that assigned\n\t *\t   pref mmio.\n\t *\t3. if there is non-pref mmio assign fail or pref mmio\n\t *\t   assigned fail, will release assigned non-pref mmio.\n\t */\n\tLIST_HEAD(save_head);\n\tLIST_HEAD(local_fail_head);\n\tstruct pci_dev_resource *save_res;\n\tstruct pci_dev_resource *dev_res, *tmp_res, *dev_res2;\n\tunsigned long fail_type;\n\tresource_size_t add_align, align;\n\n\t/* Check if optional add_size is there */\n\tif (!realloc_head || list_empty(realloc_head))\n\t\tgoto requested_and_reassign;\n\n\t/* Save original start, end, flags etc at first */\n\tlist_for_each_entry(dev_res, head, list) {\n\t\tif (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {\n\t\t\tfree_list(&save_head);\n\t\t\tgoto requested_and_reassign;\n\t\t}\n\t}\n\n\t/* Update res in head list with add_size in realloc_head list */\n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list) {\n\t\tdev_res->res->end += get_res_add_size(realloc_head,\n\t\t\t\t\t\t\tdev_res->res);\n\n\t\t/*\n\t\t * There are two kinds of additional resources in the list:\n\t\t * 1. bridge resource  -- IORESOURCE_STARTALIGN\n\t\t * 2. SR-IOV resource   -- IORESOURCE_SIZEALIGN\n\t\t * Here just fix the additional alignment for bridge\n\t\t */\n\t\tif (!(dev_res->res->flags & IORESOURCE_STARTALIGN))\n\t\t\tcontinue;\n\n\t\tadd_align = get_res_add_align(realloc_head, dev_res->res);\n\n\t\t/*\n\t\t * The "head" list is sorted by the alignment to make sure\n\t\t * resources with bigger alignment will be assigned first.\n\t\t * After we change the alignment of a dev_res in "head" list,\n\t\t * we need to reorder the list by alignment to make it\n\t\t * consistent.\n\t\t */\n\t\tif (add_align > dev_res->res->start) {\n\t\t\tresource_size_t r_size = resource_size(dev_res->res);\n\n\t\t\tdev_res->res->start = add_align;\n\t\t\tdev_res->res->end = add_align + r_size - 1;\n\n\t\t\tlist_for_each_entry(dev_res2, head, list) {\n\t\t\t\talign = pci_resource_alignment(dev_res2->dev,\n\t\t\t\t\t\t\t       dev_res2->res);\n\t\t\t\tif (add_align > align) {\n\t\t\t\t\tlist_move_tail(&dev_res->list,\n\t\t\t\t\t\t       &dev_res2->list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* Try updated head list with add_size added */\n\tassign_requested_resources_sorted(head, &local_fail_head);\n\n\t/* all assigned with add_size ? */\n\tif (list_empty(&local_fail_head)) {\n\t\t/* Remove head list from realloc_head list */\n\t\tlist_for_each_entry(dev_res, head, list)\n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\tfree_list(&save_head);\n\t\tfree_list(head);\n\t\treturn;\n\t}\n\n\t/* check failed type */\n\tfail_type = pci_fail_res_type_mask(&local_fail_head);\n\t/* remove not need to be released assigned res from head list etc */\n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list)\n\t\tif (dev_res->res->parent &&\n\t\t    !pci_need_to_release(fail_type, dev_res->res)) {\n\t\t\t/* remove it from realloc_head list */\n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\t\tremove_from_list(&save_head, dev_res->res);\n\t\t\tlist_del(&dev_res->list);\n\t\t\tkfree(dev_res);\n\t\t}\n\n\tfree_list(&local_fail_head);\n\t/* Release assigned resource */\n\tlist_for_each_entry(dev_res, head, list)\n\t\tif (dev_res->res->parent)\n\t\t\trelease_resource(dev_res->res);\n\t/* Restore start/end/flags from saved list */\n\tlist_for_each_entry(save_res, &save_head, list) {\n\t\tstruct resource *res = save_res->res;\n\n\t\tres->start = save_res->start;\n\t\tres->end = save_res->end;\n\t\tres->flags = save_res->flags;\n\t}\n\tfree_list(&save_head);\n	f
56746	535	ip_vs_schedule	net/netfilter/ipvs/ip_vs_core.c	ip_vs_schedule_phi$$cp$obj$3$obj$and$255$shl$8$or$%cp$obj$3$obj$and$65280$ashr$8$	0	13	\N	\N	\tstruct ip_vs_protocol *pp = pd->pp;\n\tstruct ip_vs_conn *cp = NULL;\n\tstruct ip_vs_scheduler *sched;\n\tstruct ip_vs_dest *dest;\n\t__be16 _ports[2], *pptr, cport, vport;\n\tconst void *caddr, *vaddr;\n\tunsigned int flags;\n\n\t*ignored = 1;\n\t/*\n\t * IPv6 frags, only the first hit here.\n\t */\n\tpptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports, iph);\n\tif (pptr == NULL)\n\t\treturn NULL;\n\n\tif (likely(!ip_vs_iph_inverse(iph))) {\n\t\tcport = pptr[0];\n\t\tcaddr = &iph->saddr;\n\t\tvport = pptr[1];\n\t\tvaddr = &iph->daddr;\n\t} else {\n\t\tcport = pptr[1];\n\t\tcaddr = &iph->daddr;\n\t\tvport = pptr[0];\n\t\tvaddr = &iph->saddr;\n\t}\n\n\t/*\n\t * FTPDATA needs this check when using local real server.\n\t * Never schedule Active FTPDATA connections from real server.\n\t * For LVS-NAT they must be already created. For other methods\n\t * with persistence the connection is created on SYN+ACK.\n\t */\n\tif (cport == FTPDATA) {\n\t\tIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\n\t\t\t      "Not scheduling FTPDATA");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *    Do not schedule replies from local real server.\n\t */\n\tif ((!skb->dev || skb->dev->flags & IFF_LOOPBACK)) {\n\t\tiph->hdr_flags ^= IP_VS_HDR_INVERSE;\n\t\tcp = pp->conn_in_get(svc->ipvs, svc->af, skb, iph);\n\t\tiph->hdr_flags ^= IP_VS_HDR_INVERSE;\n\n\t\tif (cp) {\n\t\t\tIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\n\t\t\t\t      "Not scheduling reply for existing"\n\t\t\t\t      " connection");\n\t\t\t__ip_vs_conn_put(cp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/*\n\t *    Persistent service\n\t */\n\tif (svc->flags & IP_VS_SVC_F_PERSISTENT)\n\t\treturn ip_vs_sched_persist(svc, skb, cport, vport, ignored,\n\t\t\t\t\t   iph);\n\n\t*ignored = 0;\n\n\t/*\n\t *    Non-persistent service\n\t */\n\tif (!svc->fwmark && vport != svc->port) {\n\t\tif (!svc->port)\n\t\t\tpr_err("Schedule: port zero only supported "\n\t\t\t       "in persistent services, "\n\t\t\t       "check your ipvs configuration\\n");\n\t\treturn NULL;\n\t}\n\n\tsched = rcu_dereference(svc->scheduler);\n\tif (sched) {\n\t\t/* read svc->sched_data after svc->scheduler */\n\t\tsmp_rmb();\n\t\tdest = sched->schedule(svc, skb, iph);\n\t} else {\n\t\tdest = NULL;\n\t}\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, "Schedule: no dest found.\\n");\n\t\treturn NULL;\n\t}\n\n\tflags = (svc->flags & IP_VS_SVC_F_ONEPACKET\n\t\t && iph->protocol == IPPROTO_UDP) ?\n\t\tIP_VS_CONN_F_ONE_PACKET : 0;\n\n\t/*\n\t *    Create a connection entry.\n\t */\n\t{\n\t\tstruct ip_vs_conn_param p;\n\n\t\tip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\n\t\t\t\t      caddr, cport, vaddr, vport, &p);\n\t\tcp = ip_vs_conn_new(&p, dest->af, &dest->addr,\n\t\t\t\t    dest->port ? dest->port : vport,\n\t\t\t\t    flags, dest, skb->mark);\n\t\tif (!cp) {\n\t\t\t*ignored = -1;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tIP_VS_DBG_BUF(6, "Schedule fwd:%c c:%s:%u v:%s:%u "\n	f
34492	4673	process_all_new_xattrs	fs/btrfs/send.c	found_key.type	1	13	\N	\N	\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n	f
49821	3134	SendDisassociation_rsl	drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c	skb	1	13	\N	\N	\t\tstruct ieee80211_network *beacon = &ieee->current_network;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ieee80211_disassociate_skb(beacon, ieee, asRsn);\n\t\tif (skb) {\n\t\t\t\tsoftmac_mgmt_xmit(skb, ieee);\n	f
3382	3259	gdth_sync_event	drivers/scsi/gdth.c	ha	1	13	\N	\N	    gdth_msg_str *msg;\n    gdth_cmd_str *cmdp;\n    u8 b, t;\n    struct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\n\n    cmdp = ha->pccb;\n    TRACE(("gdth_sync_event() serv %d status %d\\n",\n           service,ha->status));\n\n    if (service == SCREENSERVICE) {\n        msg  = ha->pmsg;\n        TRACE(("len: %d, answer: %d, ext: %d, alen: %d\\n",\n               msg->msg_len,msg->msg_answer,msg->msg_ext,msg->msg_alen));\n        if (msg->msg_len > MSGLEN+1)\n            msg->msg_len = MSGLEN+1;\n        if (msg->msg_len)\n            if (!(msg->msg_answer && msg->msg_ext)) {\n                msg->msg_text[msg->msg_len] = '\\0';\n                printk("%s",msg->msg_text);\n            }\n\n        if (msg->msg_ext && !msg->msg_answer) {\n            while (gdth_test_busy(ha))\n                gdth_delay(0);\n            cmdp->Service       = SCREENSERVICE;\n            cmdp->RequestBuffer = SCREEN_CMND;\n            gdth_get_cmd_index(ha);\n            gdth_set_sema0(ha);\n            cmdp->OpCode        = GDT_READ;\n            cmdp->BoardNode     = LOCALBOARD;\n            cmdp->u.screen.reserved  = 0;\n            cmdp->u.screen.su.msg.msg_handle= msg->msg_handle;\n            cmdp->u.screen.su.msg.msg_addr  = ha->msg_phys;\n            ha->cmd_offs_dpmem = 0;\n            ha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.screen.su.msg.msg_addr) \n                + sizeof(u64);\n            ha->cmd_cnt = 0;\n            gdth_copy_command(ha);\n	f
6870	659	g762_of_prop_import_one	drivers/hwmon/g762.c	g762_of_prop_import_one_	1	13	\N	\N	\tint ret;\n\tu32 pval;\n\n\tif (of_property_read_u32(client->dev.of_node, pname, &pval))\n	f
20596	217	install_process_keyring	security/keys/process_keys.c	new	1	13	\N	\N	\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n	f
57325	145	snd_card_cs46xx_probe	sound/pci/cs46xx/cs46xx.c	chip->irq	1	13	\N	\N	\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_cs46xx *chip;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0)\n\t\treturn err;\n\tif ((err = snd_cs46xx_create(card, pci,\n\t\t\t\t     external_amp[dev], thinkpad[dev],\n\t\t\t\t     &chip)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tcard->private_data = chip;\n\tchip->accept_valid = mmap_valid[dev];\n\tif ((err = snd_cs46xx_pcm(chip, 0)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif ((err = snd_cs46xx_pcm_rear(chip, 1)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tif ((err = snd_cs46xx_pcm_iec958(chip, 2)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n#endif\n\tif ((err = snd_cs46xx_mixer(chip, 2)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (chip->nr_ac97_codecs ==2) {\n\t\tif ((err = snd_cs46xx_pcm_center_lfe(chip, 3)) < 0) {\n\t\t\tsnd_card_free(card);\n\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\tif ((err = snd_cs46xx_midi(chip, 0)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tif ((err = snd_cs46xx_start_dsp(chip)) < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\n\tsnd_cs46xx_gameport(chip);\n\n\tstrcpy(card->driver, "CS46xx");\n\tstrcpy(card->shortname, "Sound Fusion CS46xx");\n\tsprintf(card->longname, "%s at 0x%lx/0x%lx, irq %i",\n\t\tcard->shortname,\n\t\tchip->ba0_addr,\n	f
44789	7268	nfs4_proc_bind_one_conn_to_session	fs/nfs/nfs4proc.c	res.use_conn_in_rdma_mode	1	13	\N	\N	\tint status;\n\tstruct nfs41_bind_conn_to_session_args args = {\n\t\t.client = clp,\n\t\t.dir = NFS4_CDFC4_FORE_OR_BOTH,\n\t};\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_xprt = xprt,\n\t\t.callback_ops = &nfs4_bind_one_conn_to_session_ops,\n\t\t.rpc_message = &msg,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tstruct rpc_task *task;\n\n\tnfs4_copy_sessionid(&args.sessionid, &clp->cl_session->sess_id);\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\t/* Do not set the backchannel flag unless this is clnt->cl_xprt */\n\tif (xprt != rcu_access_pointer(clnt->cl_xprt))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task)) {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t} else\n\t\tstatus = PTR_ERR(task);\n\ttrace_nfs4_bind_conn_to_session(clp, status);\n\tif (status == 0) {\n\t\tif (memcmp(res.sessionid.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk("NFS: %s: Session ID mismatch\\n", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((res.dir & args.dir) != res.dir || res.dir == 0) {\n\t\t\tdprintk("NFS: %s: Unexpected direction from server\\n",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode != args.use_conn_in_rdma_mode) {\n	f
44810	324	__generic_block_fiemap	fs/ioctl.c	inode	1	13	\N	\N	\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n	f
44815	612	ax88179_get_eeprom	drivers/net/usb/ax88179_178a.c	ret	1	13	\N	\N	\tstruct usbnet *dev = netdev_priv(net);\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint i, ret;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = AX88179_EEPROM_MAGIC;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc(sizeof(u16) * (last_word - first_word + 1),\n\t\t\t      GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\t/* ax88179/178A returns 2 bytes from eeprom on read */\n\tfor (i = first_word; i <= last_word; i++) {\n\t\tret = __ax88179_read_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,\n\t\t\t\t\t &eeprom_buff[i - first_word],\n\t\t\t\t\t 0);\n\t\tif (ret < 0) {\n	f
45015	118	gpio_ir_recv_probe	drivers/media/rc/gpio-ir-recv.c	pdata->gpio_nr	1	13	\N	\N	\tstruct gpio_rc_dev *gpio_dev;\n\tstruct rc_dev *rcdev;\n\tconst struct gpio_ir_recv_platform_data *pdata =\n\t\t\t\t\tpdev->dev.platform_data;\n\tint rc;\n\n\tif (pdev->dev.of_node) {\n\t\tstruct gpio_ir_recv_platform_data *dtpdata =\n\t\t\tdevm_kzalloc(&pdev->dev, sizeof(*dtpdata), GFP_KERNEL);\n\t\tif (!dtpdata)\n\t\t\treturn -ENOMEM;\n\t\trc = gpio_ir_recv_get_devtree_pdata(&pdev->dev, dtpdata);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tpdata = dtpdata;\n\t}\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tif (pdata->gpio_nr < 0)\n	f
45049	3711	__ath6kl_wmi_send_mgmt_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	p->data	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_send_mgmt_cmd *p;\n\tu8 *buf;\n\n\tif (wait)\n\t\treturn -EINVAL; /* Offload for wait not supported */\n\n\tbuf = kmalloc(data_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + data_len);\n\tif (!skb) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tkfree(wmi->last_mgmt_tx_frame);\n\tmemcpy(buf, data, data_len);\n\twmi->last_mgmt_tx_frame = buf;\n\twmi->last_mgmt_tx_frame_len = data_len;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "send_action_cmd: id=%u freq=%u wait=%u len=%u\\n",\n\t\t   id, freq, wait, data_len);\n\tp = (struct wmi_send_mgmt_cmd *) skb->data;\n\tp->id = cpu_to_le32(id);\n\tp->freq = cpu_to_le32(freq);\n\tp->wait = cpu_to_le32(wait);\n\tp->no_cck = cpu_to_le32(no_cck);\n\tp->len = cpu_to_le16(data_len);\n\tmemcpy(p->data, data, data_len);\n	f
45075	5219	hub_event	drivers/usb/core/hub.c	hubchange	1	13	\N	\N	\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tdev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\\n",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t/* NOTE: expects max 15 ports... */\n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t/* Lock the device, then check to see if we were\n\t * disconnected while waiting for the lock to succeed. */\n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t/* If the hub has died, clean up after it */\n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* Autoresume */\n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, "Can't autoresume: %d\\n", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* If this is an inactive hub, do nothing */\n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, "resetting for error %d\\n", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, "error resetting hub: %d\\n", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t/* deal with port status changes */\n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t/*\n\t\t\t * The get_noresume and barrier ensure that if\n\t\t\t * the port was in the process of resuming, we\n\t\t\t * flush that work and keep the port active for\n\t\t\t * the duration of the port_event().  However,\n\t\t\t * if the port is runtime pm suspended\n\t\t\t * (powered-off), we leave it in that state, run\n\t\t\t * an abbreviated port_event(), and move on.\n\t\t\t */\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t/* deal with hub status changes */\n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t/* do nothing */\n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, "get_hub_status failed\\n");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, "power change\\n");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t/* FIXME: Is this always true? */\n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n	f
45159	1749	register_cache_set	drivers/md/bcache/super.c	c	1	13	\N	\N	\tchar buf[12];\n\tconst char *err = "cannot allocate memory";\n\tstruct cache_set *c;\n\n\tlist_for_each_entry(c, &bch_cache_sets, list)\n\t\tif (!memcmp(c->sb.set_uuid, ca->sb.set_uuid, 16)) {\n\t\t\tif (c->cache[ca->sb.nr_this_dev])\n\t\t\t\treturn "duplicate cache set member";\n\n\t\t\tif (!can_attach_cache(ca, c))\n\t\t\t\treturn "cache sb does not match set";\n\n\t\t\tif (!CACHE_SYNC(&ca->sb))\n\t\t\t\tSET_CACHE_SYNC(&c->sb, false);\n\n\t\t\tgoto found;\n\t\t}\n\n\tc = bch_cache_set_alloc(&ca->sb);\n\tif (!c)\n\t\treturn err;\n\n\terr = "error creating kobject";\n\tif (kobject_add(&c->kobj, bcache_kobj, "%pU", c->sb.set_uuid) ||\n\t    kobject_add(&c->internal, &c->kobj, "internal"))\n\t\tgoto err;\n\n\tif (bch_cache_accounting_add_kobjs(&c->accounting, &c->kobj))\n\t\tgoto err;\n\n\tbch_debug_init_cache_set(c);\n	f
45383	455	finish_request	drivers/usb/host/sl811-hcd.c	prev	1	13	\N	\N	\tunsigned\t\ti;\n\n\tif (usb_pipecontrol(urb->pipe))\n\t\tep->nextpid = USB_PID_SETUP;\n\n\tusb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);\n\tspin_unlock(&sl811->lock);\n\tusb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);\n\tspin_lock(&sl811->lock);\n\n\t/* leave active endpoints in the schedule */\n\tif (!list_empty(&ep->hep->urb_list))\n\t\treturn;\n\n\t/* async deschedule? */\n\tif (!list_empty(&ep->schedule)) {\n\t\tlist_del_init(&ep->schedule);\n\t\tif (ep == sl811->next_async)\n\t\t\tsl811->next_async = NULL;\n\t\treturn;\n\t}\n\n\t/* periodic deschedule */\n\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t"deschedule qh%d/%p branch %d\\n", ep->period, ep, ep->branch);\n\tfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\n\t\tstruct sl811h_ep\t*temp;\n\t\tstruct sl811h_ep\t**prev = &sl811->periodic[i];\n\n\t\twhile (*prev && ((temp = *prev) != ep))\n	f
45817	225	mlx5_cmdif_debugfs_init	drivers/net/ethernet/mellanox/mlx5/core/debugfs.c	stats->avg	1	13	\N	\N	\tstruct mlx5_cmd_stats *stats;\n\tstruct dentry **cmd;\n\tconst char *namep;\n\tint err;\n\tint i;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\tcmd = &dev->priv.cmdif_debugfs;\n\t*cmd = debugfs_create_dir("commands", dev->priv.dbg_root);\n\tif (!*cmd)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->cmd.stats); i++) {\n\t\tstats = &dev->cmd.stats[i];\n\t\tnamep = mlx5_command_str(i);\n\t\tif (strcmp(namep, "unknown command opcode")) {\n\t\t\tstats->root = debugfs_create_dir(namep, *cmd);\n\t\t\tif (!stats->root) {\n\t\t\t\tmlx5_core_warn(dev, "failed adding command %d\\n",\n\t\t\t\t\t       i);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tstats->avg = debugfs_create_file("average", 0400,\n\t\t\t\t\t\t\t stats->root, stats,\n\t\t\t\t\t\t\t &stats_fops);\n\t\t\tif (!stats->avg) {\n	f
46147	522	usbtmc488_ioctl_simple	drivers/usb/class/usbtmc.c	buffer	1	13	\N	\N	\tstruct device *dev = &data->intf->dev;\n\t__u8 val;\n\tu8 *buffer;\n\tu16 wValue;\n\tint rv;\n\n\tif (!(data->usb488_caps & USBTMC488_CAPABILITY_SIMPLE))\n\t\treturn -EINVAL;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tif (cmd == USBTMC488_REQUEST_REN_CONTROL) {\n\t\trv = copy_from_user(&val, arg, sizeof(val));\n\t\tif (rv) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto exit;\n\t\t}\n\t\twValue = val ? 1 : 0;\n\t} else {\n\t\twValue = 0;\n\t}\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\tusb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\tcmd,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\twValue,\n\t\t\tdata->ifnum,\n\t\t\tbuffer, 0x01, USBTMC_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, "simple usb_control_msg failed %d\\n", rv);\n\t\tgoto exit;\n\t} else if (rv != 1) {\n\t\tdev_warn(dev, "simple usb_control_msg returned %d\\n", rv);\n\t\trv = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n	f
46367	202	rtl8723b_parse_firmware	drivers/bluetooth/btrtl.c	min_size	1	13	\N	\N	\tconst u8 extension_sig[] = { 0x51, 0x04, 0xfd, 0x77 };\n\tstruct rtl_epatch_header *epatch_info;\n\tunsigned char *buf;\n\tint i, ret, len;\n\tsize_t min_size;\n\tu8 opcode, length, data, rom_version = 0;\n\tint project_id = -1;\n\tconst unsigned char *fwptr, *chip_id_base;\n\tconst unsigned char *patch_length_base, *patch_offset_base;\n\tu32 patch_offset = 0;\n\tu16 patch_length, num_patches;\n\tstatic const struct {\n\t\t__u16 lmp_subver;\n\t\t__u8 id;\n\t} project_id_to_lmp_subver[] = {\n\t\t{ RTL_ROM_LMP_8723A, 0 },\n\t\t{ RTL_ROM_LMP_8723B, 1 },\n\t\t{ RTL_ROM_LMP_8821A, 2 },\n\t\t{ RTL_ROM_LMP_8761A, 3 },\n\t\t{ RTL_ROM_LMP_8822B, 8 },\n\t};\n\n\tret = rtl_read_rom_version(hdev, &rom_version);\n\tif (ret)\n\t\treturn ret;\n\n\tmin_size = sizeof(struct rtl_epatch_header) + sizeof(extension_sig) + 3;\n\tif (fw->size < min_size)\n\t\treturn -EINVAL;\n\n\tfwptr = fw->data + fw->size - sizeof(extension_sig);\n\tif (memcmp(fwptr, extension_sig, sizeof(extension_sig)) != 0) {\n\t\tBT_ERR("%s: extension section signature mismatch", hdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Loop from the end of the firmware parsing instructions, until\n\t * we find an instruction that identifies the "project ID" for the\n\t * hardware supported by this firwmare file.\n\t * Once we have that, we double-check that that project_id is suitable\n\t * for the hardware we are working with.\n\t */\n\twhile (fwptr >= fw->data + (sizeof(struct rtl_epatch_header) + 3)) {\n\t\topcode = *--fwptr;\n\t\tlength = *--fwptr;\n\t\tdata = *--fwptr;\n\n\t\tBT_DBG("check op=%x len=%x data=%x", opcode, length, data);\n\n\t\tif (opcode == 0xff) /* EOF */\n\t\t\tbreak;\n\n\t\tif (length == 0) {\n\t\t\tBT_ERR("%s: found instruction with length 0",\n\t\t\t       hdev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (opcode == 0 && length == 1) {\n\t\t\tproject_id = data;\n\t\t\tbreak;\n\t\t}\n\n\t\tfwptr -= length;\n\t}\n\n\tif (project_id < 0) {\n\t\tBT_ERR("%s: failed to find version instruction", hdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Find project_id in table */\n\tfor (i = 0; i < ARRAY_SIZE(project_id_to_lmp_subver); i++) {\n\t\tif (project_id == project_id_to_lmp_subver[i].id)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(project_id_to_lmp_subver)) {\n\t\tBT_ERR("%s: unknown project id %d", hdev->name, project_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lmp_subver != project_id_to_lmp_subver[i].lmp_subver) {\n\t\tBT_ERR("%s: firmware is for %x but this is a %x", hdev->name,\n\t\t       project_id_to_lmp_subver[i].lmp_subver, lmp_subver);\n\t\treturn -EINVAL;\n\t}\n\n\tepatch_info = (struct rtl_epatch_header *)fw->data;\n\tif (memcmp(epatch_info->signature, RTL_EPATCH_SIGNATURE, 8) != 0) {\n\t\tBT_ERR("%s: bad EPATCH signature", hdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_patches = le16_to_cpu(epatch_info->num_patches);\n\tBT_DBG("fw_version=%x, num_patches=%d",\n\t       le32_to_cpu(epatch_info->fw_version), num_patches);\n\n\t/* After the rtl_epatch_header there is a funky patch metadata section.\n\t * Assuming 2 patches, the layout is:\n\t * ChipID1 ChipID2 PatchLength1 PatchLength2 PatchOffset1 PatchOffset2\n\t *\n\t * Find the right patch for this chip.\n\t */\n\tmin_size += 8 * num_patches;\n\tif (fw->size < min_size)\n\t\treturn -EINVAL;\n\n\tchip_id_base = fw->data + sizeof(struct rtl_epatch_header);\n\tpatch_length_base = chip_id_base + (sizeof(u16) * num_patches);\n\tpatch_offset_base = patch_length_base + (sizeof(u16) * num_patches);\n\tfor (i = 0; i < num_patches; i++) {\n\t\tu16 chip_id = get_unaligned_le16(chip_id_base +\n\t\t\t\t\t\t (i * sizeof(u16)));\n\t\tif (chip_id == rom_version + 1) {\n\t\t\tpatch_length = get_unaligned_le16(patch_length_base +\n\t\t\t\t\t\t\t  (i * sizeof(u16)));\n\t\t\tpatch_offset = get_unaligned_le32(patch_offset_base +\n\t\t\t\t\t\t\t  (i * sizeof(u32)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!patch_offset) {\n\t\tBT_ERR("%s: didn't find patch for chip id %d",\n\t\t       hdev->name, rom_version);\n\t\treturn -EINVAL;\n\t}\n\n\tBT_DBG("length=%x offset=%x index %d", patch_length, patch_offset, i);\n\tmin_size = patch_offset + patch_length;\n\tif (fw->size < min_size)\n	f
46954	207	hdlc_loop	drivers/isdn/gigaset/asyncdata.c	skb->len	1	13	\N	\N	\tstruct cardstate *cs = inbuf->cs;\n\tstruct bc_state *bcs = cs->bcs;\n\tint inputstate = bcs->inputstate;\n\t__u16 fcs = bcs->rx_fcs;\n\tstruct sk_buff *skb = bcs->rx_skb;\n\tunsigned char *src = inbuf->data + inbuf->head;\n\tunsigned procbytes = 0;\n\tunsigned char c;\n\n\tif (inputstate & INS_byte_stuff) {\n\t\tif (!numbytes)\n\t\t\treturn 0;\n\t\tinputstate &= ~INS_byte_stuff;\n\t\tgoto byte_stuff;\n\t}\n\n\twhile (procbytes < numbytes) {\n\t\tc = *src++;\n\t\tprocbytes++;\n\t\tif (c == DLE_FLAG) {\n\t\t\tif (inputstate & INS_DLE_char) {\n\t\t\t\t/* quoted DLE: clear quote flag */\n\t\t\t\tinputstate &= ~INS_DLE_char;\n\t\t\t} else if (cs->dle || (inputstate & INS_DLE_command)) {\n\t\t\t\t/* DLE escape, pass up for handling */\n\t\t\t\tinputstate |= INS_DLE_char;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (c == PPP_ESCAPE) {\n\t\t\t/* byte stuffing indicator: pull in next byte */\n\t\t\tif (procbytes >= numbytes) {\n\t\t\t\t/* end of buffer, save for later processing */\n\t\t\t\tinputstate |= INS_byte_stuff;\n\t\t\t\tbreak;\n\t\t\t}\nbyte_stuff:\n\t\t\tc = *src++;\n\t\t\tprocbytes++;\n\t\t\tif (c == DLE_FLAG) {\n\t\t\t\tif (inputstate & INS_DLE_char) {\n\t\t\t\t\t/* quoted DLE: clear quote flag */\n\t\t\t\t\tinputstate &= ~INS_DLE_char;\n\t\t\t\t} else if (cs->dle ||\n\t\t\t\t\t   (inputstate & INS_DLE_command)) {\n\t\t\t\t\t/* DLE escape, pass up for handling */\n\t\t\t\t\tinputstate |=\n\t\t\t\t\t\tINS_DLE_char | INS_byte_stuff;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc ^= PPP_TRANS;\n#ifdef CONFIG_GIGASET_DEBUG\n\t\t\tif (!muststuff(c))\n\t\t\t\tgig_dbg(DEBUG_HDLC, "byte stuffed: 0x%02x", c);\n#endif\n\t\t} else if (c == PPP_FLAG) {\n\t\t\t/* end of frame: process content if any */\n\t\t\tif (inputstate & INS_have_data) {\n\t\t\t\tgig_dbg(DEBUG_HDLC,\n\t\t\t\t\t"7e----------------------------");\n\n\t\t\t\t/* check and pass received frame */\n\t\t\t\tif (!skb) {\n\t\t\t\t\t/* skipped frame */\n\t\t\t\t\tgigaset_isdn_rcv_err(bcs);\n\t\t\t\t} else if (skb->len < 2) {\n	f
47769	106	set_sig_addr	net/ipv4/netfilter/nf_nat_h323.c	addr.ip	1	13	\N	\N	\tconst struct nf_ct_h323_master *info = nfct_help_data(ct);\n\tint dir = CTINFO2DIR(ctinfo);\n\tint i;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (get_h225_addr(ct, *data, &taddr[i], &addr, &port)) {\n\t\t\tif (addr.ip == ct->tuplehash[dir].tuple.src.u3.ip &&\n	f
47900	342	cow_file_range_inline	fs/btrfs/inode.c	ret	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tu64 isize = i_size_read(inode);\n\tu64 actual_end = min(end + 1, isize);\n\tu64 inline_len = actual_end - start;\n\tu64 aligned_end = ALIGN(end, fs_info->sectorsize);\n\tu64 data_len = inline_len;\n\tint ret;\n\tstruct btrfs_path *path;\n\tint extent_inserted = 0;\n\tu32 extent_item_size;\n\n\tif (compressed_size)\n\t\tdata_len = compressed_size;\n\n\tif (start > 0 ||\n\t    actual_end > fs_info->sectorsize ||\n\t    data_len > BTRFS_MAX_INLINE_DATA_SIZE(fs_info) ||\n\t    (!compressed_size &&\n\t    (actual_end & (fs_info->sectorsize - 1)) == 0) ||\n\t    end + 1 < isize ||\n\t    data_len > fs_info->max_inline) {\n\t\treturn 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\ttrans->block_rsv = &fs_info->delalloc_block_rsv;\n\n\tif (compressed_size && compressed_pages)\n\t\textent_item_size = btrfs_file_extent_calc_inline_size(\n\t\t   compressed_size);\n\telse\n\t\textent_item_size = btrfs_file_extent_calc_inline_size(\n\t\t    inline_len);\n\n\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t   start, aligned_end, NULL,\n\t\t\t\t   1, 1, extent_item_size, &extent_inserted);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tif (isize > actual_end)\n\t\tinline_len = min_t(u64, isize, actual_end);\n\tret = insert_inline_extent(trans, path, extent_inserted,\n\t\t\t\t   root, inode, start,\n\t\t\t\t   inline_len, compressed_size,\n\t\t\t\t   compress_type, compressed_pages);\n\tif (ret && ret != -ENOSPC) {\n	f
48073	1070	xfs_vn_update_time	fs/xfs/xfs_iops.c	tp	1	13	\N	\N	\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttrace_xfs_update_time(ip);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *now;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *now;\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *now;\n\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n	f
48106	157	nft_exthdr_tcp_set_eval	net/netfilter/nft_exthdr.c	tcphdr_len	1	13	\N	\N	\tu8 buff[sizeof(struct tcphdr) + MAX_TCP_OPTION_SPACE];\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tunsigned int i, optl, tcphdr_len, offset;\n\tstruct tcphdr *tcph;\n\tu8 *opt;\n\tu32 src;\n\n\ttcph = nft_tcp_header_pointer(pkt, sizeof(buff), buff, &tcphdr_len);\n\tif (!tcph)\n\t\treturn;\n\n\topt = (u8 *)tcph;\n\tfor (i = sizeof(*tcph); i < tcphdr_len - 1; i += optl) {\n\t\tunion {\n\t\t\tu8 octet;\n\t\t\t__be16 v16;\n\t\t\t__be32 v32;\n\t\t} old, new;\n\n\t\toptl = optlen(opt, i);\n\n\t\tif (priv->type != opt[i])\n\t\t\tcontinue;\n\n\t\tif (i + optl > tcphdr_len || priv->len + priv->offset > optl)\n	f
48180	478	bfad_debugfs_init	drivers/scsi/bfa/bfad_debugfs.c	port->port_debugfs_root	1	13	\N	\N	\tstruct bfad_s *bfad = port->bfad;\n\tconst struct bfad_debugfs_entry *file;\n\tchar name[64];\n\tint i;\n\n\tif (!bfa_debugfs_enable)\n\t\treturn;\n\n\t/* Setup the BFA debugfs root directory*/\n\tif (!bfa_debugfs_root) {\n\t\tbfa_debugfs_root = debugfs_create_dir("bfa", NULL);\n\t\tatomic_set(&bfa_debugfs_port_count, 0);\n\t\tif (!bfa_debugfs_root) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t"BFA debugfs root dir creation failed\\n");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Setup the pci_dev debugfs directory for the port */\n\tsnprintf(name, sizeof(name), "pci_dev:%s", bfad->pci_name);\n\tif (!port->port_debugfs_root) {\n\t\tport->port_debugfs_root =\n\t\t\tdebugfs_create_dir(name, bfa_debugfs_root);\n\t\tif (!port->port_debugfs_root) {\n	f
48561	144	isp1760_register	drivers/usb/isp1760/isp1760-core.c	isp	1	13	\N	\N	\tstruct isp1760_device *isp;\n\tbool udc_disabled = !(devflags & ISP1760_FLAG_ISP1761);\n\tint ret;\n\n\t/*\n\t * If neither the HCD not the UDC is enabled return an error, as no\n\t * device would be registered.\n\t */\n\tif ((!IS_ENABLED(CONFIG_USB_ISP1760_HCD) || usb_disabled()) &&\n\t    (!IS_ENABLED(CONFIG_USB_ISP1761_UDC) || udc_disabled))\n\t\treturn -ENODEV;\n\n\t/* prevent usb-core allocating DMA pages */\n\tdev->dma_mask = NULL;\n\n\tisp = devm_kzalloc(dev, sizeof(*isp), GFP_KERNEL);\n\tif (!isp)\n\t\treturn -ENOMEM;\n\n\tisp->dev = dev;\n\tisp->devflags = devflags;\n\n\tisp->rst_gpio = devm_gpiod_get_optional(dev, NULL, GPIOD_OUT_HIGH);\n\tif (IS_ERR(isp->rst_gpio))\n\t\treturn PTR_ERR(isp->rst_gpio);\n\n\tisp->regs = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(isp->regs))\n\t\treturn PTR_ERR(isp->regs);\n\n\tisp1760_init_core(isp);\n	f
49869	499	rsnd_adg_get_clkout	sound/soc/sh/rcar/adg.c	clk	1	13	\N	\N	\tstruct clk *clk;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\tstruct property *prop;\n\tu32 ckr, rbgx, rbga, rbgb;\n\tu32 rate, div;\n#define REQ_SIZE 2\n\tu32 req_rate[REQ_SIZE] = {};\n\tuint32_t count = 0;\n\tunsigned long req_48kHz_rate, req_441kHz_rate;\n\tint i, req_size;\n\tconst char *parent_clk_name = NULL;\n\tstatic const char * const clkout_name[] = {\n\t\t[CLKOUT]  = "audio_clkout",\n\t\t[CLKOUT1] = "audio_clkout1",\n\t\t[CLKOUT2] = "audio_clkout2",\n\t\t[CLKOUT3] = "audio_clkout3",\n\t};\n\tint brg_table[] = {\n\t\t[CLKA] = 0x0,\n\t\t[CLKB] = 0x1,\n\t\t[CLKC] = 0x4,\n\t\t[CLKI] = 0x2,\n\t};\n\n\tckr = 0;\n\trbga = 2; /* default 1/6 */\n\trbgb = 2; /* default 1/6 */\n\n\t/*\n\t * ADG supports BRRA/BRRB output only\n\t * this means all clkout0/1/2/3 will be same rate\n\t */\n\tprop = of_find_property(np, "clock-frequency", NULL);\n\tif (!prop)\n\t\tgoto rsnd_adg_get_clkout_end;\n\n\treq_size = prop->length / sizeof(u32);\n\n\tof_property_read_u32_array(np, "clock-frequency", req_rate, req_size);\n\treq_48kHz_rate = 0;\n\treq_441kHz_rate = 0;\n\tfor (i = 0; i < req_size; i++) {\n\t\tif (0 == (req_rate[i] % 44100))\n\t\t\treq_441kHz_rate = req_rate[i];\n\t\tif (0 == (req_rate[i] % 48000))\n\t\t\treq_48kHz_rate = req_rate[i];\n\t}\n\n\tif (req_rate[0] % 48000 == 0)\n\t\tadg->flags = AUDIO_OUT_48;\n\n\tif (of_get_property(np, "clkout-lr-asynchronous", NULL))\n\t\tadg->flags = LRCLK_ASYNC;\n\n\t/*\n\t * This driver is assuming that AUDIO_CLKA/AUDIO_CLKB/AUDIO_CLKC\n\t * have 44.1kHz or 48kHz base clocks for now.\n\t *\n\t * SSI itself can divide parent clock by 1/1 - 1/16\n\t * see\n\t *\trsnd_adg_ssi_clk_try_start()\n\t *\trsnd_ssi_master_clk_start()\n\t */\n\tadg->rbga_rate_for_441khz\t= 0;\n\tadg->rbgb_rate_for_48khz\t= 0;\n\tfor_each_rsnd_clk(clk, adg, i) {\n\t\trate = clk_get_rate(clk);\n	f
50155	3153	rt5645_jack_detect	sound/soc/codecs/rt5645.c	val	1	13	\N	\N	\tstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\n\tstruct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);\n\tunsigned int val;\n\n\tif (jack_insert) {\n\t\tregmap_write(rt5645->regmap, RT5645_CHARGE_PUMP, 0x0e06);\n\n\t\t/* for jack type detect */\n\t\tsnd_soc_dapm_force_enable_pin(dapm, "LDO2");\n\t\tsnd_soc_dapm_force_enable_pin(dapm, "Mic Det Power");\n\t\tsnd_soc_dapm_sync(dapm);\n\t\tif (!dapm->card->instantiated) {\n\t\t\t/* Power up necessary bits for JD if dapm is\n\t\t\t   not ready yet */\n\t\t\tregmap_update_bits(rt5645->regmap, RT5645_PWR_ANLG1,\n\t\t\t\tRT5645_PWR_MB | RT5645_PWR_VREF2,\n\t\t\t\tRT5645_PWR_MB | RT5645_PWR_VREF2);\n\t\t\tregmap_update_bits(rt5645->regmap, RT5645_PWR_MIXER,\n\t\t\t\tRT5645_PWR_LDO2, RT5645_PWR_LDO2);\n\t\t\tregmap_update_bits(rt5645->regmap, RT5645_PWR_VOL,\n\t\t\t\tRT5645_PWR_MIC_DET, RT5645_PWR_MIC_DET);\n\t\t}\n\n\t\tregmap_write(rt5645->regmap, RT5645_JD_CTRL3, 0x00f0);\n\t\tregmap_update_bits(rt5645->regmap, RT5645_IN1_CTRL2,\n\t\t\tRT5645_CBJ_MN_JD, RT5645_CBJ_MN_JD);\n\t\tregmap_update_bits(rt5645->regmap, RT5645_IN1_CTRL1,\n\t\t\tRT5645_CBJ_BST1_EN, RT5645_CBJ_BST1_EN);\n\t\tmsleep(100);\n\t\tregmap_update_bits(rt5645->regmap, RT5645_IN1_CTRL2,\n\t\t\tRT5645_CBJ_MN_JD, 0);\n\n\t\tmsleep(600);\n\t\tregmap_read(rt5645->regmap, RT5645_IN1_CTRL3, &val);\n\t\tval &= 0x7;\n\t\tdev_dbg(codec->dev, "val = %d\\n", val);\n	f
51370	787	ocfs2_fiemap	fs/ocfs2/extent_map.c	cpos	1	13	\N	\N	\tint ret, is_last;\n\tu32 mapping_end, cpos;\n\tunsigned int hole_size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu64 len_bytes, phys_bytes, virt_bytes;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tret = fiemap_check_flags(fieinfo, OCFS2_FIEMAP_FLAGS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\t/*\n\t * Handle inline-data and fast symlink separately.\n\t */\n\tif ((OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    ocfs2_inode_is_fast_symlink(inode)) {\n\t\tret = ocfs2_fiemap_inline(inode, di_bh, fieinfo, map_start);\n\t\tgoto out_unlock;\n\t}\n\n\tcpos = map_start >> osb->s_clustersize_bits;\n\tmapping_end = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t       map_start + map_len);\n\tis_last = 0;\n\twhile (cpos < mapping_end && !is_last) {\n	f
51696	1565	qtnf_cmd_send_get_phy_params	drivers/net/wireless/quantenna/qtnfmac/commands.c	response_size	1	13	\N	\N	\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tsize_t response_size;\n\tstruct qlink_resp_phy_params *resp;\n\tu16 res_code = QLINK_CMD_RESULT_OK;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, 0,\n\t\t\t\t\t    QLINK_CMD_PHY_PARAMS_GET,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(mac->bus);\n\n\tret = qtnf_cmd_send_with_reply(mac->bus, cmd_skb, &resp_skb, &res_code,\n\t\t\t\t       sizeof(*resp), &response_size);\n\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tif (unlikely(res_code != QLINK_CMD_RESULT_OK)) {\n\t\tpr_err("MAC%u: CMD failed: %u\\n", mac->macid, res_code);\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tresp = (struct qlink_resp_phy_params *)resp_skb->data;\n\tret = qtnf_cmd_resp_proc_phy_params(mac, resp->info, response_size);\n	f
51888	1566	ieee80211_change_station	net/mac80211/cfg.c	sta->sdata->dev	1	13	\N	\N	\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n	f
52797	1716	nbd_genl_connect	drivers/block/nbd.c	nbd	1	13	\N	\N	\tstruct nbd_device *nbd = NULL;\n\tstruct nbd_config *config;\n\tint index = -1;\n\tint ret;\n\tbool put_dev = false;\n\n\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (info->attrs[NBD_ATTR_INDEX])\n\t\tindex = nla_get_u32(info->attrs[NBD_ATTR_INDEX]);\n\tif (!info->attrs[NBD_ATTR_SOCKETS]) {\n\t\tprintk(KERN_ERR "nbd: must specify at least one socket\\n");\n\t\treturn -EINVAL;\n\t}\n\tif (!info->attrs[NBD_ATTR_SIZE_BYTES]) {\n\t\tprintk(KERN_ERR "nbd: must specify a size in bytes for the device\\n");\n\t\treturn -EINVAL;\n\t}\nagain:\n\tmutex_lock(&nbd_index_mutex);\n\tif (index == -1) {\n\t\tret = idr_for_each(&nbd_index_idr, &find_free_cb, &nbd);\n\t\tif (ret == 0) {\n\t\t\tint new_index;\n\t\t\tnew_index = nbd_dev_add(-1);\n\t\t\tif (new_index < 0) {\n\t\t\t\tmutex_unlock(&nbd_index_mutex);\n\t\t\t\tprintk(KERN_ERR "nbd: failed to add new device\\n");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tnbd = idr_find(&nbd_index_idr, new_index);\n\t\t}\n\t} else {\n\t\tnbd = idr_find(&nbd_index_idr, index);\n\t\tif (!nbd) {\n\t\t\tret = nbd_dev_add(index);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&nbd_index_mutex);\n\t\t\t\tprintk(KERN_ERR "nbd: failed to add new device\\n");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tnbd = idr_find(&nbd_index_idr, index);\n\t\t}\n\t}\n\tif (!nbd) {\n\t\tprintk(KERN_ERR "nbd: couldn't find device at index %d\\n",\n\t\t       index);\n\t\tmutex_unlock(&nbd_index_mutex);\n\t\treturn -EINVAL;\n\t}\n\tif (!refcount_inc_not_zero(&nbd->refs)) {\n\t\tmutex_unlock(&nbd_index_mutex);\n\t\tif (index == -1)\n\t\t\tgoto again;\n\t\tprintk(KERN_ERR "nbd: device at index %d is going down\\n",\n\t\t       index);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(&nbd_index_mutex);\n\n\tmutex_lock(&nbd->config_lock);\n\tif (refcount_read(&nbd->config_refs)) {\n\t\tmutex_unlock(&nbd->config_lock);\n\t\tnbd_put(nbd);\n\t\tif (index == -1)\n\t\t\tgoto again;\n\t\tprintk(KERN_ERR "nbd: nbd%d already in use\\n", index);\n\t\treturn -EBUSY;\n\t}\n\tif (WARN_ON(nbd->config)) {\n\t\tmutex_unlock(&nbd->config_lock);\n\t\tnbd_put(nbd);\n\t\treturn -EINVAL;\n\t}\n\tconfig = nbd->config = nbd_alloc_config();\n\tif (!nbd->config) {\n\t\tmutex_unlock(&nbd->config_lock);\n\t\tnbd_put(nbd);\n\t\tprintk(KERN_ERR "nbd: couldn't allocate config\\n");\n\t\treturn -ENOMEM;\n\t}\n\trefcount_set(&nbd->config_refs, 1);\n\tset_bit(NBD_BOUND, &config->runtime_flags);\n\n\tif (info->attrs[NBD_ATTR_SIZE_BYTES]) {\n\t\tu64 bytes = nla_get_u64(info->attrs[NBD_ATTR_SIZE_BYTES]);\n\t\tnbd_size_set(nbd, config->blksize,\n\t\t\t     div64_u64(bytes, config->blksize));\n\t}\n\tif (info->attrs[NBD_ATTR_BLOCK_SIZE_BYTES]) {\n\t\tu64 bsize =\n\t\t\tnla_get_u64(info->attrs[NBD_ATTR_BLOCK_SIZE_BYTES]);\n\t\tnbd_size_set(nbd, bsize, div64_u64(config->bytesize, bsize));\n\t}\n\tif (info->attrs[NBD_ATTR_TIMEOUT]) {\n\t\tu64 timeout = nla_get_u64(info->attrs[NBD_ATTR_TIMEOUT]);\n\t\tnbd->tag_set.timeout = timeout * HZ;\n\t\tblk_queue_rq_timeout(nbd->disk->queue, timeout * HZ);\n\t}\n\tif (info->attrs[NBD_ATTR_DEAD_CONN_TIMEOUT]) {\n\t\tconfig->dead_conn_timeout =\n\t\t\tnla_get_u64(info->attrs[NBD_ATTR_DEAD_CONN_TIMEOUT]);\n\t\tconfig->dead_conn_timeout *= HZ;\n\t}\n\tif (info->attrs[NBD_ATTR_SERVER_FLAGS])\n\t\tconfig->flags =\n\t\t\tnla_get_u64(info->attrs[NBD_ATTR_SERVER_FLAGS]);\n\tif (info->attrs[NBD_ATTR_CLIENT_FLAGS]) {\n\t\tu64 flags = nla_get_u64(info->attrs[NBD_ATTR_CLIENT_FLAGS]);\n\t\tif (flags & NBD_CFLAG_DESTROY_ON_DISCONNECT) {\n\t\t\tset_bit(NBD_DESTROY_ON_DISCONNECT,\n\t\t\t\t&config->runtime_flags);\n\t\t\tput_dev = true;\n\t\t}\n\t}\n\n\tif (info->attrs[NBD_ATTR_SOCKETS]) {\n\t\tstruct nlattr *attr;\n\t\tint rem, fd;\n\n\t\tnla_for_each_nested(attr, info->attrs[NBD_ATTR_SOCKETS],\n\t\t\t\t    rem) {\n\t\t\tstruct nlattr *socks[NBD_SOCK_MAX+1];\n\n\t\t\tif (nla_type(attr) != NBD_SOCK_ITEM) {\n\t\t\t\tprintk(KERN_ERR "nbd: socks must be embedded in a SOCK_ITEM attr\\n");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = nla_parse_nested(socks, NBD_SOCK_MAX, attr,\n\t\t\t\t\t       nbd_sock_policy, info->extack);\n\t\t\tif (ret != 0) {\n\t\t\t\tprintk(KERN_ERR "nbd: error processing sock list\\n");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!socks[NBD_SOCK_FD])\n\t\t\t\tcontinue;\n\t\t\tfd = (int)nla_get_u32(socks[NBD_SOCK_FD]);\n\t\t\tret = nbd_add_socket(nbd, fd, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = nbd_start_device(nbd);\n	f
52925	750	lpfc_bsg_rport_els	drivers/scsi/lpfc/lpfc_bsg.c	creg_val	1	13	\N	\N	\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_rport_data *rdata = fc_bsg_to_rport(job)->dd_data;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tuint32_t elscmd;\n\tuint32_t cmdsize;\n\tstruct lpfc_iocbq *cmdiocbq;\n\tuint16_t rpi = 0;\n\tstruct bsg_job_data *dd_data;\n\tunsigned long flags;\n\tuint32_t creg_val;\n\tint rc = 0;\n\n\t/* in case no data is transferred */\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\t/* verify the els command is not greater than the\n\t * maximum ELS transfer size.\n\t */\n\n\tif (job->request_payload.payload_len > FCELSSIZE) {\n\t\trc = -EINVAL;\n\t\tgoto no_dd_data;\n\t}\n\n\t/* allocate our bsg tracking structure */\n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t"2735 Failed allocation of dd_data\\n");\n\t\trc = -ENOMEM;\n\t\tgoto no_dd_data;\n\t}\n\n\telscmd = bsg_request->rqst_data.r_els.els_code;\n\tcmdsize = job->request_payload.payload_len;\n\n\tif (!lpfc_nlp_get(ndlp)) {\n\t\trc = -ENODEV;\n\t\tgoto free_dd_data;\n\t}\n\n\t/* We will use the allocated dma buffers by prep els iocb for command\n\t * and response to ensure if the job times out and the request is freed,\n\t * we won't be dma into memory that is no longer allocated to for the\n\t * request.\n\t */\n\n\tcmdiocbq = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp,\n\t\t\t\t      ndlp->nlp_DID, elscmd);\n\tif (!cmdiocbq) {\n\t\trc = -EIO;\n\t\tgoto release_ndlp;\n\t}\n\n\trpi = ndlp->nlp_rpi;\n\n\t/* Transfer the request payload to allocated command dma buffer */\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  ((struct lpfc_dmabuf *)cmdiocbq->context2)->virt,\n\t\t\t  cmdsize);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tcmdiocbq->iocb.ulpContext = phba->sli4_hba.rpi_ids[rpi];\n\telse\n\t\tcmdiocbq->iocb.ulpContext = rpi;\n\tcmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\n\tcmdiocbq->context1 = dd_data;\n\tcmdiocbq->context_un.ndlp = ndlp;\n\tcmdiocbq->iocb_cmpl = lpfc_bsg_rport_els_cmp;\n\tdd_data->type = TYPE_IOCB;\n\tdd_data->set_job = job;\n\tdd_data->context_un.iocb.cmdiocbq = cmdiocbq;\n\tdd_data->context_un.iocb.ndlp = ndlp;\n\tdd_data->context_un.iocb.rmp = NULL;\n\tjob->dd_data = dd_data;\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\trc = -EIO;\n\t\t\tgoto linkdown_err;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n	f
53188	659	m88rs6000t_probe	drivers/media/tuners/m88rs6000t.c	utmp	1	13	\N	\N	\tstruct m88rs6000t_config *cfg = client->dev.platform_data;\n\tstruct dvb_frontend *fe = cfg->fe;\n\tstruct m88rs6000t_dev *dev;\n\tint ret, i;\n\tunsigned int utmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\tstatic const struct m88rs6000t_reg_val reg_vals[] = {\n\t\t{0x10, 0xfb},\n\t\t{0x24, 0x38},\n\t\t{0x11, 0x0a},\n\t\t{0x12, 0x00},\n\t\t{0x2b, 0x1c},\n\t\t{0x44, 0x48},\n\t\t{0x54, 0x24},\n\t\t{0x55, 0x06},\n\t\t{0x59, 0x00},\n\t\t{0x5b, 0x4c},\n\t\t{0x60, 0x8b},\n\t\t{0x61, 0xf4},\n\t\t{0x65, 0x07},\n\t\t{0x6d, 0x6f},\n\t\t{0x6e, 0x31},\n\t\t{0x3c, 0xf3},\n\t\t{0x37, 0x0f},\n\t\t{0x48, 0x28},\n\t\t{0x49, 0xd8},\n\t\t{0x70, 0x66},\n\t\t{0x71, 0xCF},\n\t\t{0x72, 0x81},\n\t\t{0x73, 0xA7},\n\t\t{0x74, 0x4F},\n\t\t{0x75, 0xFC},\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&client->dev, "kzalloc() failed\\n");\n\t\tgoto err;\n\t}\n\n\tmemcpy(&dev->cfg, cfg, sizeof(struct m88rs6000t_config));\n\tdev->client = client;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err;\n\t}\n\n\tret = regmap_update_bits(dev->regmap, 0x11, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(5000, 50000);\n\tret = regmap_update_bits(dev->regmap, 0x10, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(10000, 50000);\n\tret = regmap_write(dev->regmap, 0x07, 0x7d);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x04, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t/* check tuner chip id */\n\tret = regmap_read(dev->regmap, 0x01, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tdev_info(&dev->client->dev, "chip_id=%02x\\n", utmp);\n	f
53239	3359	adap_init0_config	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c	cf->size	1	13	\N	\N	\tstruct fw_caps_config_cmd caps_cmd;\n\tconst struct firmware *cf;\n\tunsigned long mtype = 0, maddr = 0;\n\tu32 finiver, finicsum, cfcsum;\n\tint ret;\n\tint config_issued = 0;\n\tchar *fw_config_file, fw_config_file_path[256];\n\tchar *config_name = NULL;\n\n\t/*\n\t * Reset device if necessary.\n\t */\n\tif (reset) {\n\t\tret = t4_fw_reset(adapter, adapter->mbox,\n\t\t\t\t  PIORSTMODE_F | PIORST_F);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t/* If this is a 10Gb/s-BT adapter make sure the chip-external\n\t * 10Gb/s-BT PHYs have up-to-date firmware.  Note that this step needs\n\t * to be performed after any global adapter RESET above since some\n\t * PHYs only have local RAM copies of the PHY firmware.\n\t */\n\tif (is_10gbt_device(adapter->pdev->device)) {\n\t\tret = adap_init0_phy(adapter);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\t/*\n\t * If we have a T4 configuration file under /lib/firmware/cxgb4/,\n\t * then use that.  Otherwise, use the configuration file stored\n\t * in the adapter flash ...\n\t */\n\tswitch (CHELSIO_CHIP_VERSION(adapter->params.chip)) {\n\tcase CHELSIO_T4:\n\t\tfw_config_file = FW4_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\tfw_config_file = FW5_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\tfw_config_file = FW6_CFNAME;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, "Device %d is not supported\\n",\n\t\t       adapter->pdev->device);\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\tret = request_firmware(&cf, fw_config_file, adapter->pdev_dev);\n\tif (ret < 0) {\n\t\tconfig_name = "On FLASH";\n\t\tmtype = FW_MEMTYPE_CF_FLASH;\n\t\tmaddr = t4_flash_cfg_addr(adapter);\n\t} else {\n\t\tu32 params[7], val[7];\n\n\t\tsprintf(fw_config_file_path,\n\t\t\t"/lib/firmware/%s", fw_config_file);\n\t\tconfig_name = fw_config_file_path;\n\n\t\tif (cf->size >= FLASH_CFG_MAX_SIZE)\n	f
53249	3385	adap_init0_config	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c	size	1	13	\N	\N	\tstruct fw_caps_config_cmd caps_cmd;\n\tconst struct firmware *cf;\n\tunsigned long mtype = 0, maddr = 0;\n\tu32 finiver, finicsum, cfcsum;\n\tint ret;\n\tint config_issued = 0;\n\tchar *fw_config_file, fw_config_file_path[256];\n\tchar *config_name = NULL;\n\n\t/*\n\t * Reset device if necessary.\n\t */\n\tif (reset) {\n\t\tret = t4_fw_reset(adapter, adapter->mbox,\n\t\t\t\t  PIORSTMODE_F | PIORST_F);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t/* If this is a 10Gb/s-BT adapter make sure the chip-external\n\t * 10Gb/s-BT PHYs have up-to-date firmware.  Note that this step needs\n\t * to be performed after any global adapter RESET above since some\n\t * PHYs only have local RAM copies of the PHY firmware.\n\t */\n\tif (is_10gbt_device(adapter->pdev->device)) {\n\t\tret = adap_init0_phy(adapter);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\t/*\n\t * If we have a T4 configuration file under /lib/firmware/cxgb4/,\n\t * then use that.  Otherwise, use the configuration file stored\n\t * in the adapter flash ...\n\t */\n\tswitch (CHELSIO_CHIP_VERSION(adapter->params.chip)) {\n\tcase CHELSIO_T4:\n\t\tfw_config_file = FW4_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\tfw_config_file = FW5_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\tfw_config_file = FW6_CFNAME;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, "Device %d is not supported\\n",\n\t\t       adapter->pdev->device);\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\tret = request_firmware(&cf, fw_config_file, adapter->pdev_dev);\n\tif (ret < 0) {\n\t\tconfig_name = "On FLASH";\n\t\tmtype = FW_MEMTYPE_CF_FLASH;\n\t\tmaddr = t4_flash_cfg_addr(adapter);\n\t} else {\n\t\tu32 params[7], val[7];\n\n\t\tsprintf(fw_config_file_path,\n\t\t\t"/lib/firmware/%s", fw_config_file);\n\t\tconfig_name = fw_config_file_path;\n\n\t\tif (cf->size >= FLASH_CFG_MAX_SIZE)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\t\t\tret = t4_query_params(adapter, adapter->mbox,\n\t\t\t\t\t      adapter->pf, 0, 1, params, val);\n\t\t\tif (ret == 0) {\n\t\t\t\t/*\n\t\t\t\t * For t4_memory_rw() below addresses and\n\t\t\t\t * sizes have to be in terms of multiples of 4\n\t\t\t\t * bytes.  So, if the Configuration File isn't\n\t\t\t\t * a multiple of 4 bytes in length we'll have\n\t\t\t\t * to write that out separately since we can't\n\t\t\t\t * guarantee that the bytes following the\n\t\t\t\t * residual byte in the buffer returned by\n\t\t\t\t * request_firmware() are zeroed out ...\n\t\t\t\t */\n\t\t\t\tsize_t resid = cf->size & 0x3;\n\t\t\t\tsize_t size = cf->size & ~0x3;\n\t\t\t\t__be32 *data = (__be32 *)cf->data;\n\n\t\t\t\tmtype = FW_PARAMS_PARAM_Y_G(val[0]);\n\t\t\t\tmaddr = FW_PARAMS_PARAM_Z_G(val[0]) << 16;\n\n\t\t\t\tspin_lock(&adapter->win0_lock);\n\t\t\t\tret = t4_memory_rw(adapter, 0, mtype, maddr,\n	f
53631	3312	sctp_asconf_param_success	net/sctp/sm_make_chunk.c	&addr)	1	13	\N	\N	\tstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_sockaddr_entry *saddr;\n\tstruct sctp_transport *transport;\n\tunion sctp_addr\taddr;\n\tstruct sctp_af *af;\n\n\taddr_param = (void *)asconf_param + sizeof(*asconf_param);\n\n\t/* We have checked the packet before, so we do not check again.\t*/\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\taf->from_addr_param(&addr, addr_param, htons(bp->port), 0);\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t/* This is always done in BH context with a socket lock\n\t\t * held, so the list can not change.\n\t\t */\n\t\tlocal_bh_disable();\n\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\tif (sctp_cmp_addr_exact(&saddr->a, &addr))\n	f
53858	1400	isdn_ppp_xmit	drivers/isdn/i4l/isdn_ppp.c	skb->data	1	13	\N	\N	\tisdn_net_local *lp, *mlp;\n\tisdn_net_dev *nd;\n\tunsigned int proto = PPP_IP;     /* 0x21 */\n\tstruct ippp_struct *ipt, *ipts;\n\tint slot, retval = NETDEV_TX_OK;\n\n\tmlp = netdev_priv(netdev);\n\tnd = mlp->netdev;       /* get master lp */\n\n\tslot = mlp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR "isdn_ppp_xmit: lp->ppp_slot(%d)\\n",\n\t\t       mlp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\tipts = ippp_table[slot];\n\n\tif (!(ipts->pppcfg & SC_ENABLE_IP)) {\t/* PPP connected ? */\n\t\tif (ipts->debug & 0x1)\n\t\t\tprintk(KERN_INFO "%s: IP frame delayed.\\n", netdev->name);\n\t\tretval = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\n\tswitch (ntohs(skb->protocol)) {\n\tcase ETH_P_IP:\n\t\tproto = PPP_IP;\n\t\tbreak;\n\tcase ETH_P_IPX:\n\t\tproto = PPP_IPX;\t/* untested */\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR "isdn_ppp: skipped unsupported protocol: %#x.\\n",\n\t\t       skb->protocol);\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tlp = isdn_net_get_locked_lp(nd);\n\tif (!lp) {\n\t\tprintk(KERN_WARNING "%s: all channels busy - requeuing!\\n", netdev->name);\n\t\tretval = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\t/* we have our lp locked from now on */\n\n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR "isdn_ppp_xmit: lp->ppp_slot(%d)\\n",\n\t\t       lp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\tgoto unlock;\n\t}\n\tipt = ippp_table[slot];\n\n\t/*\n\t * after this line .. requeueing in the device queue is no longer allowed!!!\n\t */\n\n\t/* Pull off the fake header we stuck on earlier to keep\n\t * the fragmentation code happy.\n\t */\n\tskb_pull(skb, IPPP_MAX_HEADER);\n\n#ifdef CONFIG_IPPP_FILTER\n\t/* check if we should pass this packet\n\t * the filter instructions are constructed assuming\n\t * a four-byte PPP header on each packet */\n\t*(u8 *)skb_push(skb, 4) = 1; /* indicate outbound */\n\n\t{\n\t\t__be16 *p = (__be16 *)skb->data;\n\n\t\tp++;\n\t\t*p = htons(proto);\n\t}\n\n\tif (ipt->pass_filter\n\t    && BPF_PROG_RUN(ipt->pass_filter, skb) == 0) {\n\t\tif (ipt->debug & 0x4)\n\t\t\tprintk(KERN_DEBUG "IPPP: outbound frame filtered.\\n");\n\t\tkfree_skb(skb);\n\t\tgoto unlock;\n\t}\n\tif (!(ipt->active_filter\n\t      && BPF_PROG_RUN(ipt->active_filter, skb) == 0)) {\n\t\tif (ipt->debug & 0x4)\n\t\t\tprintk(KERN_DEBUG "IPPP: link-active filter: resetting huptimer.\\n");\n\t\tlp->huptimer = 0;\n\t}\n\tskb_pull(skb, 4);\n#else /* CONFIG_IPPP_FILTER */\n\tlp->huptimer = 0;\n#endif /* CONFIG_IPPP_FILTER */\n\n\tif (ipt->debug & 0x4)\n\t\tprintk(KERN_DEBUG "xmit skb, len %d\\n", (int) skb->len);\n\tif (ipts->debug & 0x40)\n\t\tisdn_ppp_frame_log("xmit0", skb->data, skb->len, 32, ipts->unit, lp->ppp_slot);\n\n#ifdef CONFIG_ISDN_PPP_VJ\n\tif (proto == PPP_IP && ipts->pppcfg & SC_COMP_TCP) {\t/* ipts here? probably yes, but check this again */\n\t\tstruct sk_buff *new_skb;\n\t\tunsigned short hl;\n\t\t/*\n\t\t * we need to reserve enough space in front of\n\t\t * sk_buff. old call to dev_alloc_skb only reserved\n\t\t * 16 bytes, now we are looking what the driver want.\n\t\t */\n\t\thl = dev->drv[lp->isdn_device]->interface->hl_hdrlen + IPPP_MAX_HEADER;\n\t\t/*\n\t\t * Note: hl might still be insufficient because the method\n\t\t * above does not account for a possibible MPPP slave channel\n\t\t * which had larger HL header space requirements than the\n\t\t * master.\n\t\t */\n\t\tnew_skb = alloc_skb(hl + skb->len, GFP_ATOMIC);\n\t\tif (new_skb) {\n\t\t\tu_char *buf;\n\t\t\tint pktlen;\n\n\t\t\tskb_reserve(new_skb, hl);\n\t\t\tnew_skb->dev = skb->dev;\n\t\t\tskb_put(new_skb, skb->len);\n\t\t\tbuf = skb->data;\n\n\t\t\tpktlen = slhc_compress(ipts->slcomp, skb->data, skb->len, new_skb->data,\n\t\t\t\t\t       &buf, !(ipts->pppcfg & SC_NO_TCP_CCID));\n\n\t\t\tif (buf != skb->data) {\n\t\t\t\tif (new_skb->data != buf)\n\t\t\t\t\tprintk(KERN_ERR "isdn_ppp: FATAL error after slhc_compress!!\\n");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tskb = new_skb;\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb(new_skb);\n\t\t\t}\n\n\t\t\tskb_trim(skb, pktlen);\n\t\t\tif (skb->data[0] & SL_TYPE_COMPRESSED_TCP) {\t/* cslip? style -> PPP */\n\t\t\t\tproto = PPP_VJC_COMP;\n\t\t\t\tskb->data[0] ^= SL_TYPE_COMPRESSED_TCP;\n\t\t\t} else {\n\t\t\t\tif (skb->data[0] >= SL_TYPE_UNCOMPRESSED_TCP)\n	f
53907	2505	btrfs_punch_hole	fs/btrfs/file.c	offset	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trans_metadata_size(fs_info, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tunsigned int rsv_count;\n\tbool same_block;\n\tbool no_holes = btrfs_fs_incompat(fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_block = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\tino_size = round_up(inode->i_size, fs_info->sectorsize);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, btrfs_inode_sectorsize(inode));\n\tlockend = round_down(offset + len,\n\t\t\t     btrfs_inode_sectorsize(inode)) - 1;\n\tsame_block = (BTRFS_BYTES_TO_BLKS(fs_info, offset))\n\t\t== (BTRFS_BYTES_TO_BLKS(fs_info, offset + len - 1));\n\t/*\n\t * We needn't truncate any block which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same block and we aren't doing the\n\t * entire block.\n\t */\n\tif (same_block && len < fs_info->sectorsize) {\n\t\tif (offset < ino_size) {\n	f
54421	674	gl860_guess_sensor	drivers/media/usb/gspca/gl860/gl860.c	probe	1	13	\N	\N	\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 probe, nb26, nb96, nOV, ntry;\n\n\tif (product_id == 0xf191)\n\t\tsd->sensor = ID_MI1320;\n\n\tif (sd->sensor == 0xff) {\n\t\tctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\n\t\tctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\n\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0000, 0x0000, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0010, 0x0010, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0008, 0x00c0, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c1, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c2, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0020, 0x0006, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x006a, 0x000d, 0, NULL);\n\t\tmsleep(56);\n\n\t\tPDEBUG(D_PROBE, "probing for sensor MI2020 or OVXXXX");\n\t\tnOV = 0;\n\t\tfor (ntry = 0; ntry < 4; ntry++) {\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x0040, 0x0000, 0, NULL);\n\t\t\tmsleep(3);\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x0063, 0x0006, 0, NULL);\n\t\t\tmsleep(3);\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x7a00, 0x8030, 0, NULL);\n\t\t\tmsleep(10);\n\t\t\tctrl_in(gspca_dev, 0xc0, 2, 0x7a00, 0x8030, 1, &probe);\n\t\t\tPDEBUG(D_PROBE, "probe=0x%02x", probe);\n	f
54440	1783	mlxsw_sp_fdb_notify_mac_lag_process	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c	bridge_port->dev	1	13	\N	\N	\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tenum switchdev_notifier_type type;\n\tchar mac[ETH_ALEN];\n\tu16 lag_vid = 0;\n\tu16 lag_id;\n\tu16 vid, fid;\n\tbool do_notification = true;\n\tint err;\n\n\tmlxsw_reg_sfn_mac_lag_unpack(sfn_pl, rec_index, mac, &fid, &lag_id);\n\tmlxsw_sp_port = mlxsw_sp_lag_rep_port(mlxsw_sp, lag_id);\n\tif (!mlxsw_sp_port) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, "Cannot find port representor for LAG\\n");\n\t\tgoto just_remove;\n\t}\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_fid(mlxsw_sp_port, fid);\n\tif (!mlxsw_sp_port_vlan) {\n\t\tnetdev_err(mlxsw_sp_port->dev, "Failed to find a matching {Port, VID} following FDB notification\\n");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_port = mlxsw_sp_port_vlan->bridge_port;\n\tif (!bridge_port) {\n\t\tnetdev_err(mlxsw_sp_port->dev, "{Port, VID} not associated with a bridge\\n");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_device = bridge_port->bridge_device;\n\tvid = bridge_device->vlan_enabled ? mlxsw_sp_port_vlan->vid : 0;\n\tlag_vid = mlxsw_sp_port_vlan->vid;\n\ndo_fdb_op:\n\terr = mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp, lag_id, mac, fid, lag_vid,\n\t\t\t\t\t  adding, true);\n\tif (err) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to set FDB entry\\n");\n\t\treturn;\n\t}\n\n\tif (!do_notification)\n\t\treturn;\n\ttype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;\n\tmlxsw_sp_fdb_call_notifiers(type, mac, vid, bridge_port->dev);\n	f
54829	1117	ivtv_probe	drivers/media/pci/ivtv/ivtv-driver.c	itv->options.tuner	1	13	\N	\N	\tint retval = 0;\n\tint vbi_buf_size;\n\tstruct ivtv *itv;\n\n\titv = kzalloc(sizeof(struct ivtv), GFP_ATOMIC);\n\tif (itv == NULL)\n\t\treturn -ENOMEM;\n\titv->pdev = pdev;\n\titv->instance = v4l2_device_set_name(&itv->v4l2_dev, "ivtv",\n\t\t\t\t\t\t&ivtv_instance);\n\n\tretval = v4l2_device_register(&pdev->dev, &itv->v4l2_dev);\n\tif (retval) {\n\t\tkfree(itv);\n\t\treturn retval;\n\t}\n\tIVTV_INFO("Initializing card %d\\n", itv->instance);\n\n\tivtv_process_options(itv);\n\tif (itv->options.cardtype == -1) {\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\tif (ivtv_init_struct1(itv)) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\tretval = cx2341x_handler_init(&itv->cxhdl, 50);\n\tif (retval)\n\t\tgoto err;\n\titv->v4l2_dev.ctrl_handler = &itv->cxhdl.hdl;\n\titv->cxhdl.ops = &ivtv_cxhdl_ops;\n\titv->cxhdl.priv = itv;\n\titv->cxhdl.func = ivtv_api_func;\n\n\tIVTV_DEBUG_INFO("base addr: 0x%llx\\n", (u64)itv->base_addr);\n\n\t/* PCI Device Setup */\n\tretval = ivtv_setup_pci(itv, pdev, pci_id);\n\tif (retval == -EIO)\n\t\tgoto free_worker;\n\tif (retval == -ENXIO)\n\t\tgoto free_mem;\n\n\t/* map io memory */\n\tIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\\n",\n\t\t   (u64)itv->base_addr + IVTV_ENCODER_OFFSET, IVTV_ENCODER_SIZE);\n\titv->enc_mem = ioremap_nocache(itv->base_addr + IVTV_ENCODER_OFFSET,\n\t\t\t\t       IVTV_ENCODER_SIZE);\n\tif (!itv->enc_mem) {\n\t\tIVTV_ERR("ioremap failed. Can't get a window into CX23415/6 encoder memory\\n");\n\t\tIVTV_ERR("Each capture card with a CX23415/6 needs 8 MB of vmalloc address space for this window\\n");\n\t\tIVTV_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\\n");\n\t\tIVTV_ERR("Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n");\n\t\tretval = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\tif (itv->has_cx23415) {\n\t\tIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\\n",\n\t\t\t\t(u64)itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\n\t\titv->dec_mem = ioremap_nocache(itv->base_addr + IVTV_DECODER_OFFSET,\n\t\t\t\tIVTV_DECODER_SIZE);\n\t\tif (!itv->dec_mem) {\n\t\t\tIVTV_ERR("ioremap failed. Can't get a window into CX23415 decoder memory\\n");\n\t\t\tIVTV_ERR("Each capture card with a CX23415 needs 8 MB of vmalloc address space for this window\\n");\n\t\t\tIVTV_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\\n");\n\t\t\tIVTV_ERR("Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto free_mem;\n\t\t}\n\t}\n\telse {\n\t\titv->dec_mem = itv->enc_mem;\n\t}\n\n\t/* map registers memory */\n\tIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\\n",\n\t\t   (u64)itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\titv->reg_mem =\n\t    ioremap_nocache(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\tif (!itv->reg_mem) {\n\t\tIVTV_ERR("ioremap failed. Can't get a window into CX23415/6 register space\\n");\n\t\tIVTV_ERR("Each capture card with a CX23415/6 needs 64 kB of vmalloc address space for this window\\n");\n\t\tIVTV_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\\n");\n\t\tIVTV_ERR("Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n");\n\t\tretval = -ENOMEM;\n\t\tgoto free_io;\n\t}\n\n\tretval = ivtv_gpio_init(itv);\n\tif (retval)\n\t\tgoto free_io;\n\n\t/* active i2c  */\n\tIVTV_DEBUG_INFO("activating i2c...\\n");\n\tif (init_ivtv_i2c(itv)) {\n\t\tIVTV_ERR("Could not initialize i2c\\n");\n\t\tgoto free_io;\n\t}\n\n\tif (itv->card->hw_all & IVTV_HW_TVEEPROM) {\n\t\t/* Based on the model number the cardtype may be changed.\n\t\t   The PCI IDs are not always reliable. */\n\t\tivtv_process_eeprom(itv);\n\t}\n\tif (itv->card->comment)\n\t\tIVTV_INFO("%s", itv->card->comment);\n\tif (itv->card->v4l2_capabilities == 0) {\n\t\t/* card was detected but is not supported */\n\t\tretval = -ENODEV;\n\t\tgoto free_i2c;\n\t}\n\n\tif (itv->std == 0) {\n\t\titv->std = V4L2_STD_NTSC_M;\n\t}\n\n\tif (itv->options.tuner == -1) {\n	f
55105	704	az6027_ci_poll_slot_status	drivers/media/usb/dvb-usb/az6027.c	b	1	13	\N	\N	\tstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\n\tstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC5;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6027_usb_in_op(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\twarn("usb in operation failed. (%d)", ret);\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tif (!ret && b[0] == 1) {\n	f
55545	2410	kvm_create_vcpu_debugfs	virt/kvm/kvm_main.c	vcpu	1	13	\N	\N	\tchar dir_name[ITOA_MAX_LEN * 2];\n\tint ret;\n\n\tif (!kvm_arch_has_vcpu_debugfs())\n\t\treturn 0;\n\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\n\tsnprintf(dir_name, sizeof(dir_name), "vcpu%d", vcpu->vcpu_id);\n\tvcpu->debugfs_dentry = debugfs_create_dir(dir_name,\n\t\t\t\t\t\t\t\tvcpu->kvm->debugfs_dentry);\n\tif (!vcpu->debugfs_dentry)\n\t\treturn -ENOMEM;\n\n\tret = kvm_arch_create_vcpu_debugfs(vcpu);\n	f
55700	1863	qtnf_cmd_send_change_sta	drivers/net/wireless/quantenna/qtnfmac/commands.c	cmd->sta_addr	1	13	\N	\N	\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_change_sta *cmd;\n\tu16 res_code = QLINK_CMD_RESULT_OK;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CHANGE_STA,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (unlikely(!cmd_skb))\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_change_sta *)cmd_skb->data;\n\tether_addr_copy(cmd->sta_addr, mac);\n	f
47576	555	rsi_send_aggregation_params_frame	drivers/net/wireless/rsi/rsi_91x_mgmt.c	skb->data	1	13	\N	\N	\tstruct sk_buff *skb = NULL;\n\tstruct rsi_aggr_params *aggr_params;\n\tu16 frame_len = sizeof(struct rsi_aggr_params);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\\n",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n	f
55731	1729	sl811h_probe	drivers/usb/host/sl811-hcd.c	retval	1	13	\N	\N	\tstruct usb_hcd\t\t*hcd;\n\tstruct sl811\t\t*sl811;\n\tstruct resource\t\t*addr, *data, *ires;\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*addr_reg;\n\tvoid __iomem\t\t*data_reg;\n\tint\t\t\tretval;\n\tu8\t\t\ttmp, ioaddr = 0;\n\tunsigned long\t\tirqflags;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t/* basic sanity checks first.  board-specific init logic should\n\t * have initialized these three resources and probably board\n\t * specific platform_data.  we don't probe for IRQs, and do only\n\t * minimal sanity checking.\n\t */\n\tires = platform_get_resource(dev, IORESOURCE_IRQ, 0);\n\tif (dev->num_resources < 3 || !ires)\n\t\treturn -ENODEV;\n\n\tirq = ires->start;\n\tirqflags = ires->flags & IRQF_TRIGGER_MASK;\n\n\t/* refuse to confuse usbcore */\n\tif (dev->dev.dma_mask) {\n\t\tdev_dbg(&dev->dev, "no we won't dma\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* the chip may be wired for either kind of addressing */\n\taddr = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tdata = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tretval = -EBUSY;\n\tif (!addr || !data) {\n\t\taddr = platform_get_resource(dev, IORESOURCE_IO, 0);\n\t\tdata = platform_get_resource(dev, IORESOURCE_IO, 1);\n\t\tif (!addr || !data)\n\t\t\treturn -ENODEV;\n\t\tioaddr = 1;\n\t\t/*\n\t\t * NOTE: 64-bit resource->start is getting truncated\n\t\t * to avoid compiler warning, assuming that ->start\n\t\t * is always 32-bit for this case\n\t\t */\n\t\taddr_reg = (void __iomem *) (unsigned long) addr->start;\n\t\tdata_reg = (void __iomem *) (unsigned long) data->start;\n\t} else {\n\t\taddr_reg = ioremap(addr->start, 1);\n\t\tif (addr_reg == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tdata_reg = ioremap(data->start, 1);\n\t\tif (data_reg == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err4;\n\t\t}\n\t}\n\n\t/* allocate and initialize hcd */\n\thcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev_name(&dev->dev));\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto err5;\n\t}\n\thcd->rsrc_start = addr->start;\n\tsl811 = hcd_to_sl811(hcd);\n\n\tspin_lock_init(&sl811->lock);\n\tINIT_LIST_HEAD(&sl811->async);\n\tsl811->board = dev_get_platdata(&dev->dev);\n\tsetup_timer(&sl811->timer, sl811h_timer, (unsigned long)sl811);\n\tsl811->addr_reg = addr_reg;\n\tsl811->data_reg = data_reg;\n\n\tspin_lock_irq(&sl811->lock);\n\tport_power(sl811, 0);\n\tspin_unlock_irq(&sl811->lock);\n\tmsleep(200);\n\n\ttmp = sl811_read(sl811, SL11H_HWREVREG);\n\tswitch (tmp >> 4) {\n\tcase 1:\n\t\thcd->product_desc = "SL811HS v1.2";\n\t\tbreak;\n\tcase 2:\n\t\thcd->product_desc = "SL811HS v1.5";\n\t\tbreak;\n\tdefault:\n\t\t/* reject case 0, SL11S is less functional */\n\t\tdev_dbg(&dev->dev, "chiprev %02x\\n", tmp);\n\t\tretval = -ENXIO;\n\t\tgoto err6;\n\t}\n\n\t/* The chip's IRQ is level triggered, active high.  A requirement\n\t * for platform device setup is to cope with things like signal\n\t * inverters (e.g. CF is active low) or working only with edge\n\t * triggers (e.g. most ARM CPUs).  Initial driver stress testing\n\t * was on a system with single edge triggering, so most sorts of\n\t * triggering arrangement should work.\n\t *\n\t * Use resource IRQ flags if set by platform device setup.\n\t */\n\tirqflags |= IRQF_SHARED;\n\tretval = usb_add_hcd(hcd, irq, irqflags);\n\tif (retval != 0)\n	f
56136	284	st21nfca_hci_ready	drivers/nfc/st21nfca/core.c	skb->data	1	13	\N	\N	\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tstruct sk_buff *skb;\n\n\tu8 param;\n\tu8 white_list[2];\n\tint wl_size = 0;\n\tint r;\n\n\tif (info->se_status->is_uicc_present)\n\t\twhite_list[wl_size++] = NFC_HCI_UICC_HOST_ID;\n\tif (info->se_status->is_ese_present)\n\t\twhite_list[wl_size++] = ST21NFCA_ESE_HOST_ID;\n\n\tif (wl_size) {\n\t\tr = nfc_hci_set_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\t\t\tNFC_HCI_ADMIN_WHITELIST,\n\t\t\t\t\t(u8 *) &white_list, wl_size);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\t/* Set NFC_MODE in device management gate to enable */\n\tr = nfc_hci_get_param(hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t      ST21NFCA_NFC_MODE, &skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tparam = skb->data[0];\n	f
56156	3138	rt5663_calibrate	sound/soc/codecs/rt5663.c	value	1	13	\N	\N	\tint value, count;\n\n\tregmap_write(rt5663->regmap, RT5663_RESET, 0x0000);\n\tmsleep(20);\n\tregmap_write(rt5663->regmap, RT5663_ANA_BIAS_CUR_4, 0x00a1);\n\tregmap_write(rt5663->regmap, RT5663_RC_CLK, 0x0380);\n\tregmap_write(rt5663->regmap, RT5663_GLB_CLK, 0x8000);\n\tregmap_write(rt5663->regmap, RT5663_ADDA_CLK_1, 0x1000);\n\tregmap_write(rt5663->regmap, RT5663_VREF_RECMIX, 0x0032);\n\tregmap_write(rt5663->regmap, RT5663_HP_IMP_SEN_19, 0x000c);\n\tregmap_write(rt5663->regmap, RT5663_DUMMY_1, 0x0324);\n\tregmap_write(rt5663->regmap, RT5663_DIG_MISC, 0x8001);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_1, 0xa23b);\n\tmsleep(30);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_1, 0xf23b);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_2, 0x8000);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_3, 0x0008);\n\tregmap_write(rt5663->regmap, RT5663_PRE_DIV_GATING_1, 0xffff);\n\tregmap_write(rt5663->regmap, RT5663_PRE_DIV_GATING_2, 0xffff);\n\tregmap_write(rt5663->regmap, RT5663_CBJ_1, 0x8c10);\n\tregmap_write(rt5663->regmap, RT5663_IL_CMD_2, 0x00c1);\n\tregmap_write(rt5663->regmap, RT5663_EM_JACK_TYPE_1, 0xb880);\n\tregmap_write(rt5663->regmap, RT5663_EM_JACK_TYPE_2, 0x4110);\n\tregmap_write(rt5663->regmap, RT5663_EM_JACK_TYPE_2, 0x4118);\n\n\tcount = 0;\n\twhile (true) {\n\t\tregmap_read(rt5663->regmap, RT5663_INT_ST_2, &value);\n\t\tif (!(value & 0x80))\n\t\t\tusleep_range(10000, 10005);\n\t\telse\n\t\t\tbreak;\n\n\t\tif (++count > 200)\n\t\t\tbreak;\n\t}\n\n\tregmap_write(rt5663->regmap, RT5663_HP_IMP_SEN_19, 0x0000);\n\tregmap_write(rt5663->regmap, RT5663_DEPOP_2, 0x3003);\n\tregmap_write(rt5663->regmap, RT5663_DEPOP_1, 0x0038);\n\tregmap_write(rt5663->regmap, RT5663_DEPOP_1, 0x003b);\n\tregmap_write(rt5663->regmap, RT5663_PWR_DIG_2, 0x8400);\n\tregmap_write(rt5663->regmap, RT5663_PWR_DIG_1, 0x8df8);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_2, 0x8003);\n\tregmap_write(rt5663->regmap, RT5663_PWR_ANLG_3, 0x018c);\n\tregmap_write(rt5663->regmap, RT5663_HP_CHARGE_PUMP_1, 0x1e32);\n\tregmap_write(rt5663->regmap, RT5663_DACREF_LDO, 0x3b0b);\n\tmsleep(40);\n\tregmap_write(rt5663->regmap, RT5663_STO_DAC_MIXER, 0x0000);\n\tregmap_write(rt5663->regmap, RT5663_BYPASS_STO_DAC, 0x000c);\n\tregmap_write(rt5663->regmap, RT5663_HP_BIAS, 0xafaa);\n\tregmap_write(rt5663->regmap, RT5663_CHARGE_PUMP_1, 0x2224);\n\tregmap_write(rt5663->regmap, RT5663_HP_OUT_EN, 0x8088);\n\tregmap_write(rt5663->regmap, RT5663_STO_DRE_9, 0x0017);\n\tregmap_write(rt5663->regmap, RT5663_STO_DRE_10, 0x0017);\n\tregmap_write(rt5663->regmap, RT5663_STO1_ADC_MIXER, 0x4040);\n\tregmap_write(rt5663->regmap, RT5663_CHOP_ADC, 0x3000);\n\tregmap_write(rt5663->regmap, RT5663_RECMIX, 0x0005);\n\tregmap_write(rt5663->regmap, RT5663_ADDA_RST, 0xc000);\n\tregmap_write(rt5663->regmap, RT5663_STO1_HPF_ADJ1, 0x3320);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_2, 0x00c9);\n\tregmap_write(rt5663->regmap, RT5663_DUMMY_1, 0x004c);\n\tregmap_write(rt5663->regmap, RT5663_ANA_BIAS_CUR_1, 0x1111);\n\tregmap_write(rt5663->regmap, RT5663_BIAS_CUR_8, 0x4402);\n\tregmap_write(rt5663->regmap, RT5663_CHARGE_PUMP_2, 0x3311);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_1, 0x0069);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_3, 0x06ce);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_1_1, 0x6800);\n\tregmap_write(rt5663->regmap, RT5663_CHARGE_PUMP_2, 0x1100);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_7, 0x0057);\n\tregmap_write(rt5663->regmap, RT5663_HP_CALIB_1_1, 0xe800);\n\n\tcount = 0;\n\twhile (true) {\n\t\tregmap_read(rt5663->regmap, RT5663_HP_CALIB_1_1, &value);\n\t\tif (value & 0x8000)\n	f
56328	666	qed_roce_sp_modify_requester	drivers/net/ethernet/qlogic/qed/qed_roce.c	p_ramrod->src_gid	1	13	\N	\N	\tstruct roce_modify_qp_req_ramrod_data *p_ramrod;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tint rc;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "icid = %08x\\n", qp->icid);\n\n\tif (move_to_err && !(qp->req_offloaded))\n\t\treturn 0;\n\n\t/* Get SPQ entry */\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qp->icid + 1;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ROCE_EVENT_MODIFY_QP,\n\t\t\t\t PROTOCOLID_ROCE, &init_data);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, "rc = %d\\n", rc);\n\t\treturn rc;\n\t}\n\n\tp_ramrod = &p_ent->ramrod.roce_modify_qp_req;\n\n\tp_ramrod->flags = 0;\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_MOVE_TO_ERR_FLG, move_to_err);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_MOVE_TO_SQD_FLG, move_to_sqd);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_EN_SQD_ASYNC_NOTIFY,\n\t\t  qp->sqd_async);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_P_KEY_FLG,\n\t\t  GET_FIELD(modify_flags, QED_ROCE_MODIFY_QP_VALID_PKEY));\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_ADDRESS_VECTOR_FLG,\n\t\t  GET_FIELD(modify_flags,\n\t\t\t    QED_ROCE_MODIFY_QP_VALID_ADDRESS_VECTOR));\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_MAX_ORD_FLG,\n\t\t  GET_FIELD(modify_flags,\n\t\t\t    QED_RDMA_MODIFY_QP_VALID_MAX_RD_ATOMIC_REQ));\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_RNR_NAK_CNT_FLG,\n\t\t  GET_FIELD(modify_flags,\n\t\t\t    QED_ROCE_MODIFY_QP_VALID_RNR_RETRY_CNT));\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_ERR_RETRY_CNT_FLG,\n\t\t  GET_FIELD(modify_flags, QED_ROCE_MODIFY_QP_VALID_RETRY_CNT));\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_ACK_TIMEOUT_FLG,\n\t\t  GET_FIELD(modify_flags,\n\t\t\t    QED_ROCE_MODIFY_QP_VALID_ACK_TIMEOUT));\n\n\tp_ramrod->fields = 0;\n\tSET_FIELD(p_ramrod->fields,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_ERR_RETRY_CNT, qp->retry_cnt);\n\n\tSET_FIELD(p_ramrod->fields,\n\t\t  ROCE_MODIFY_QP_REQ_RAMROD_DATA_RNR_NAK_CNT,\n\t\t  qp->rnr_retry_cnt);\n\n\tp_ramrod->max_ord = qp->max_rd_atomic_req;\n\tp_ramrod->traffic_class = qp->traffic_class_tos;\n\tp_ramrod->hop_limit = qp->hop_limit_ttl;\n\tp_ramrod->p_key = cpu_to_le16(qp->pkey);\n\tp_ramrod->flow_label = cpu_to_le32(qp->flow_label);\n\tp_ramrod->ack_timeout_val = cpu_to_le32(qp->ack_timeout);\n\tp_ramrod->mtu = cpu_to_le16(qp->mtu);\n\tqed_rdma_copy_gids(qp, p_ramrod->src_gid, p_ramrod->dst_gid);\n	f
56343	528	cifs_open	fs/cifs/file.c	&open	1	13	\N	\N	\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifsFileInfo *cfile = NULL;\n\tchar *full_path = NULL;\n\tbool posix_open_ok = false;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\n\txid = get_xid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tfull_path = build_path_from_dentry(file_dentry(file));\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, "inode = 0x%p file flags are 0x%x for %s\\n",\n\t\t inode, file->f_flags, full_path);\n\n\tif (file->f_flags & O_DIRECT &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t}\n\n\tif (server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (!tcon->broken_posix_open && tcon->unix_ext &&\n\t    cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/* can not refresh inode info since size could be stale */\n\t\trc = cifs_posix_open(full_path, &inode, inode->i_sb,\n\t\t\t\tcifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\tfile->f_flags, &oplock, &fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, "posix open succeeded\\n");\n\t\t\tposix_open_ok = true;\n\t\t} else if ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tif (tcon->ses->serverNOS)\n\t\t\t\tcifs_dbg(VFS, "server %s of type %s returned unexpected error on SMB posix open, disabling posix open support. Check if server update available.\\n",\n\t\t\t\t\t tcon->ses->serverName,\n\t\t\t\t\t tcon->ses->serverNOS);\n\t\t\ttcon->broken_posix_open = true;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP)) /* path not found or net err */\n\t\t\tgoto out;\n\t\t/*\n\t\t * Else fallthrough to retry open the old way on network i/o\n\t\t * or DFS errors.\n\t\t */\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n	f
62347	700	show_deepsleep_status	drivers/platform/x86/alienware-wmi.c	status	1	13	\N	\N	\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus = alienware_wmax_command(&in_args, WMAX_METHOD_DEEP_SLEEP_STATUS,\n\t\t\t\t\t(u32 *) &out_data);\n\tif (ACPI_SUCCESS(status)) {\n	f
-623	625	ak4642_of_parse_mcko	sound/soc/codecs/ak4642.c	rate	2	3	\N	\N	\tstruct device_node *np = dev->of_node;\n\tstruct clk *clk;\n\tconst char *clk_name = np->name;\n\tconst char *parent_clk_name = NULL;\n\tu32 rate;\n\n\tif (of_property_read_u32(np, "clock-frequency", &rate))\n\t\treturn NULL;\n\n\tif (of_property_read_bool(np, "clocks"))\n\t\tparent_clk_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, "clock-output-names", &clk_name);\n\n\tclk = clk_register_fixed_rate(dev, clk_name, parent_clk_name, 0, rate);\n	f
57752	145	ext4_sync_file	fs/ext4/fsync.c	ext4_sync_file_	1	13	\N	\N	\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\tint ret = 0, err;\n\ttid_t commit_tid;\n\tbool needs_barrier = false;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\n\tJ_ASSERT(ext4_journal_current_handle() == NULL);\n\n\ttrace_ext4_sync_file_enter(file, datasync);\n\n\tif (sb_rdonly(inode->i_sb)) {\n\t\t/* Make sure that we read updated s_mount_flags value */\n\t\tsmp_rmb();\n\t\tif (EXT4_SB(inode->i_sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (!journal) {\n\t\tret = __generic_file_fsync(file, start, end, datasync);\n\t\tif (!ret)\n\t\t\tret = ext4_sync_parent(inode);\n\t\tif (test_opt(inode->i_sb, BARRIER))\n\t\t\tgoto issue_flush;\n\t\tgoto out;\n\t}\n\n\tret = file_write_and_wait_range(file, start, end);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * data=writeback,ordered:\n\t *  The caller's filemap_fdatawrite()/wait will sync the data.\n\t *  Metadata is in the journal, we wait for proper transaction to\n\t *  commit here.\n\t *\n\t * data=journal:\n\t *  filemap_fdatawrite won't do anything (the buffers are clean).\n\t *  ext4_force_commit will write the file data into the journal and\n\t *  will wait on that.\n\t *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n\t *  (they were dirtied by commit).  But that's OK - the blocks are\n\t *  safe in-journal, which is all fsync() needs to ensure.\n\t */\n\tif (ext4_should_journal_data(inode)) {\n	f
58379	11197	bnx2x_54618se_config_init	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	temp	1	13	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 autoneg_val, an_1000_val, an_10_100_val, fc_val, temp;\n\tu32 cfg_pin;\n\n\tDP(NETIF_MSG_LINK, "54618SE cfg init\\n");\n\tusleep_range(1000, 2000);\n\n\t/* This works with E3 only, no need to check the chip\n\t * before determining the port.\n\t */\n\tport = params->port;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t/* Drive pin high to bring the GPHY out of reset. */\n\tbnx2x_set_cfg_pin(bp, cfg_pin, 1);\n\n\t/* wait for GPHY to reset */\n\tmsleep(50);\n\n\t/* reset phy */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t MDIO_PMA_REG_CTRL, 0x8000);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t/* Wait for GPHY to reset */\n\tmsleep(50);\n\n\n\tbnx2x_54618se_specific_func(phy, params, PHY_INIT);\n\t/* Flip the signal detect polarity (set 0x1c.0x1e[8]). */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_AUTO_DET_MED);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t&temp);\n\ttemp |= MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD;\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\n\t/* Set up fc */\n\t/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tfc_val = 0;\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\n\t/* Read all advertisement */\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x04,\n\t\t\t&an_10_100_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL,\n\t\t\t&autoneg_val);\n\n\t/* Disable forced speed */\n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8) | (1<<10) |\n\t\t\t   (1<<11));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, "Advertising 1G\\n");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x09,\n\t\t\tan_1000_val);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\t/* Advertise 10/100 link speed */\n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 10M-HD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 10M-FD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 100M-HD\\n");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, "Advertising 100M-FD\\n");\n\t\t}\n\t}\n\n\t/* Only 10/100 are allowed to work in FORCE mode */\n\tif (phy->req_line_speed == SPEED_100) {\n\t\tautoneg_val |= (1<<13);\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, "Setting 100M force\\n");\n\t}\n\tif (phy->req_line_speed == SPEED_10) {\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, "Setting 10M force\\n");\n\t}\n\n\tif ((phy->flags & FLAGS_EEE) && bnx2x_eee_has_cap(params)) {\n\t\tint rc;\n\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS,\n\t\t\t\t MDIO_REG_GPHY_EXP_ACCESS_TOP |\n\t\t\t\t MDIO_REG_GPHY_EXP_TOP_2K_BUF);\n\t\tbnx2x_cl22_read(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, &temp);\n\t\ttemp &= 0xfffe;\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, temp);\n	f
58683	4190	wm8994_codec_probe	sound/soc/codecs/wm8994.c	reg	1	13	\N	\N	\tstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\n\tstruct wm8994 *control = dev_get_drvdata(codec->dev->parent);\n\tstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\n\tunsigned int reg;\n\tint ret, i;\n\n\twm8994->hubs.codec = codec;\n\n\tmutex_init(&wm8994->accdet_lock);\n\tINIT_DELAYED_WORK(&wm8994->jackdet_bootstrap,\n\t\t\t  wm1811_jackdet_bootstrap);\n\tINIT_DELAYED_WORK(&wm8994->open_circuit_work,\n\t\t\t  wm8958_open_circuit_work);\n\n\tswitch (control->type) {\n\tcase WM8994:\n\t\tINIT_DELAYED_WORK(&wm8994->mic_work, wm8994_mic_work);\n\t\tbreak;\n\tcase WM1811:\n\t\tINIT_DELAYED_WORK(&wm8994->mic_work, wm1811_mic_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tINIT_DELAYED_WORK(&wm8994->mic_complete_work, wm8958_mic_work);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++)\n\t\tinit_completion(&wm8994->fll_locked[i]);\n\n\twm8994->micdet_irq = control->pdata.micdet_irq;\n\n\t/* By default use idle_bias_off, will override for WM8994 */\n\tdapm->idle_bias_off = 1;\n\n\t/* Set revision-specific configuration */\n\tswitch (control->type) {\n\tcase WM8994:\n\t\t/* Single ended line outputs should have VMID on. */\n\t\tif (!control->pdata.lineout1_diff ||\n\t\t    !control->pdata.lineout2_diff)\n\t\t\tdapm->idle_bias_off = 0;\n\n\t\tswitch (control->revision) {\n\t\tcase 2:\n\t\tcase 3:\n\t\t\twm8994->hubs.dcs_codes_l = -5;\n\t\t\twm8994->hubs.dcs_codes_r = -5;\n\t\t\twm8994->hubs.hp_startup_mode = 1;\n\t\t\twm8994->hubs.dcs_readback_mode = 1;\n\t\t\twm8994->hubs.series_startup = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twm8994->hubs.dcs_readback_mode = 2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM8958:\n\t\twm8994->hubs.dcs_readback_mode = 1;\n\t\twm8994->hubs.hp_startup_mode = 1;\n\n\t\tswitch (control->revision) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twm8994->fll_byp = true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM1811:\n\t\twm8994->hubs.dcs_readback_mode = 2;\n\t\twm8994->hubs.no_series_update = 1;\n\t\twm8994->hubs.hp_startup_mode = 1;\n\t\twm8994->hubs.no_cache_dac_hp_direct = true;\n\t\twm8994->fll_byp = true;\n\n\t\twm8994->hubs.dcs_codes_l = -9;\n\t\twm8994->hubs.dcs_codes_r = -7;\n\n\t\tsnd_soc_update_bits(codec, WM8994_ANALOGUE_HP_1,\n\t\t\t\t    WM1811_HPOUT1_ATTN, WM1811_HPOUT1_ATTN);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\twm8994_request_irq(wm8994->wm8994, WM8994_IRQ_FIFOS_ERR,\n\t\t\t   wm8994_fifo_error, "FIFO error", codec);\n\twm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_WARN,\n\t\t\t   wm8994_temp_warn, "Thermal warning", codec);\n\twm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT,\n\t\t\t   wm8994_temp_shut, "Thermal shutdown", codec);\n\n\tswitch (control->type) {\n\tcase WM8994:\n\t\tif (wm8994->micdet_irq)\n\t\t\tret = request_threaded_irq(wm8994->micdet_irq, NULL,\n\t\t\t\t\t\t   wm8994_mic_irq,\n\t\t\t\t\t\t   IRQF_TRIGGER_RISING |\n\t\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t\t   "Mic1 detect",\n\t\t\t\t\t\t   wm8994);\n\t\t else\n\t\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\tWM8994_IRQ_MIC1_DET,\n\t\t\t\t\twm8994_mic_irq, "Mic 1 detect",\n\t\t\t\t\twm8994);\n\n\t\tif (ret != 0)\n\t\t\tdev_warn(codec->dev,\n\t\t\t\t "Failed to request Mic1 detect IRQ: %d\\n",\n\t\t\t\t ret);\n\n\n\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\t WM8994_IRQ_MIC1_SHRT,\n\t\t\t\t\t wm8994_mic_irq, "Mic 1 short",\n\t\t\t\t\t wm8994);\n\t\tif (ret != 0)\n\t\t\tdev_warn(codec->dev,\n\t\t\t\t "Failed to request Mic1 short IRQ: %d\\n",\n\t\t\t\t ret);\n\n\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\t WM8994_IRQ_MIC2_DET,\n\t\t\t\t\t wm8994_mic_irq, "Mic 2 detect",\n\t\t\t\t\t wm8994);\n\t\tif (ret != 0)\n\t\t\tdev_warn(codec->dev,\n\t\t\t\t "Failed to request Mic2 detect IRQ: %d\\n",\n\t\t\t\t ret);\n\n\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\t WM8994_IRQ_MIC2_SHRT,\n\t\t\t\t\t wm8994_mic_irq, "Mic 2 short",\n\t\t\t\t\t wm8994);\n\t\tif (ret != 0)\n\t\t\tdev_warn(codec->dev,\n\t\t\t\t "Failed to request Mic2 short IRQ: %d\\n",\n\t\t\t\t ret);\n\t\tbreak;\n\n\tcase WM8958:\n\tcase WM1811:\n\t\tif (wm8994->micdet_irq) {\n\t\t\tret = request_threaded_irq(wm8994->micdet_irq, NULL,\n\t\t\t\t\t\t   wm8958_mic_irq,\n\t\t\t\t\t\t   IRQF_TRIGGER_RISING |\n\t\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t\t   "Mic detect",\n\t\t\t\t\t\t   wm8994);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_warn(codec->dev,\n\t\t\t\t\t "Failed to request Mic detect IRQ: %d\\n",\n\t\t\t\t\t ret);\n\t\t} else {\n\t\t\twm8994_request_irq(wm8994->wm8994, WM8994_IRQ_MIC1_DET,\n\t\t\t\t\t   wm8958_mic_irq, "Mic detect",\n\t\t\t\t\t   wm8994);\n\t\t}\n\t}\n\n\tswitch (control->type) {\n\tcase WM1811:\n\t\tif (control->cust_id > 1 || control->revision > 1) {\n\t\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\t\t WM8994_IRQ_GPIO(6),\n\t\t\t\t\t\t wm1811_jackdet_irq, "JACKDET",\n\t\t\t\t\t\t wm8994);\n\t\t\tif (ret == 0)\n\t\t\t\twm8994->jackdet = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twm8994->fll_locked_irq = true;\n\tfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++) {\n\t\tret = wm8994_request_irq(wm8994->wm8994,\n\t\t\t\t\t WM8994_IRQ_FLL1_LOCK + i,\n\t\t\t\t\t wm8994_fll_locked_irq, "FLL lock",\n\t\t\t\t\t &wm8994->fll_locked[i]);\n\t\tif (ret != 0)\n\t\t\twm8994->fll_locked_irq = false;\n\t}\n\n\t/* Make sure we can read from the GPIOs if they're inputs */\n\tpm_runtime_get_sync(codec->dev);\n\n\t/* Remember if AIFnLRCLK is configured as a GPIO.  This should be\n\t * configured on init - if a system wants to do this dynamically\n\t * at runtime we can deal with that then.\n\t */\n\tret = regmap_read(control->regmap, WM8994_GPIO_1, &reg);\n\tif (ret < 0) {\n\t\tdev_err(codec->dev, "Failed to read GPIO1 state: %d\\n", ret);\n\t\tgoto err_irq;\n\t}\n\tif ((reg & WM8994_GPN_FN_MASK) != WM8994_GP_FN_PIN_SPECIFIC) {\n	f
58844	365	sysv_inode_by_name	fs/sysv/dir.c	page	1	13	\N	\N	\tstruct page *page;\n\tstruct sysv_dir_entry *de = sysv_find_entry (dentry, &page);\n\tino_t res = 0;\n\t\n\tif (de) {\n\t\tres = fs16_to_cpu(SYSV_SB(dentry->d_sb), de->inode);\n\t\tdir_put_page(page);\n	f
59017	7685	volume_write	drivers/platform/x86/thinkpad_acpi.c	new_level	1	13	\N	\N	\tu8 s;\n\tu8 new_level, new_mute;\n\tint l;\n\tchar *cmd;\n\tint rc;\n\n\t/*\n\t * We do allow volume control at driver startup, so that the\n\t * user can set initial state through the volume=... parameter hack.\n\t */\n\tif (!volume_control_allowed && tpacpi_lifecycle != TPACPI_LIFE_INIT) {\n\t\tif (unlikely(!tp_warned.volume_ctrl_forbidden)) {\n\t\t\ttp_warned.volume_ctrl_forbidden = 1;\n\t\t\tpr_notice("Console audio control in monitor mode, changes are not allowed\\n");\n\t\t\tpr_notice("Use the volume_control=1 module parameter to enable volume control\\n");\n\t\t}\n\t\treturn -EPERM;\n\t}\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tnew_level = s & TP_EC_AUDIO_LVL_MSK;\n\tnew_mute  = s & TP_EC_AUDIO_MUTESW_MSK;\n\n\twhile ((cmd = next_cmd(&buf))) {\n\t\tif (!tp_features.mixer_no_level_control) {\n\t\t\tif (strlencmp(cmd, "up") == 0) {\n\t\t\t\tif (new_mute)\n\t\t\t\t\tnew_mute = 0;\n\t\t\t\telse if (new_level < TP_EC_VOLUME_MAX)\n	f
59140	523	__tipc_shutdown	net/tipc/socket.c	skb	1	13	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tlong timeout = CONN_TIMEOUT_DEFAULT;\n\tu32 dnode = tsk_peer_node(tsk);\n\tstruct sk_buff *skb;\n\n\t/* Avoid that hi-prio shutdown msgs bypass msgs in link wakeup queue */\n\ttipc_wait_for_cond(sock, &timeout, (!tsk->cong_link_cnt &&\n\t\t\t\t\t    !tsk_conn_cong(tsk)));\n\n\t/* Reject all unreceived messages, except on an active connection\n\t * (which disconnects locally & sends a 'FIN+' to peer).\n\t */\n\twhile ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (TIPC_SKB_CB(skb)->bytes_read) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tipc_sk_type_connectionless(sk) &&\n\t\t    sk->sk_state != TIPC_DISCONNECTING) {\n\t\t\ttipc_set_sk_state(sk, TIPC_DISCONNECTING);\n\t\t\ttipc_node_remove_conn(net, dnode, tsk->portid);\n\t\t}\n\t\ttipc_sk_respond(sk, skb, error);\n\t}\n\n\tif (tipc_sk_type_connectionless(sk))\n\t\treturn;\n\n\tif (sk->sk_state != TIPC_DISCONNECTING) {\n\t\tskb = tipc_msg_create(TIPC_CRITICAL_IMPORTANCE,\n\t\t\t\t      TIPC_CONN_MSG, SHORT_H_SIZE, 0, dnode,\n\t\t\t\t      tsk_own_node(tsk), tsk_peer_port(tsk),\n\t\t\t\t      tsk->portid, error);\n\t\tif (skb)\n\t\t\ttipc_node_xmit_skb(net, skb, dnode, tsk->portid);\n	f
59256	358	qt2_open	drivers/usb/serial/quatech2.c	status	1	13	\N	\N	\tstruct usb_serial *serial;\n\tstruct qt2_port_private *port_priv;\n\tu8 *data;\n\tu16 device_port;\n\tint status;\n\tunsigned long flags;\n\n\tdevice_port = port->port_number;\n\n\tserial = port->serial;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\t/* set the port to RS232 mode */\n\tstatus = qt2_control_msg(serial->dev, QT2_GET_SET_QMCR,\n\t\t\t\t QT2_QMCR_RS232, device_port);\n\tif (status < 0) {\n	f
59300	2804	init	drivers/usb/gadget/udc/dummy_hcd.c	the_hcd_pdev[i--]	1	13	\N	\N	\tint\tretval = -ENOMEM;\n\tint\ti;\n\tstruct\tdummy *dum[MAX_NUM_UDC];\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (!mod_data.is_high_speed && mod_data.is_super_speed)\n\t\treturn -EINVAL;\n\n\tif (mod_data.num < 1 || mod_data.num > MAX_NUM_UDC) {\n\t\tpr_err("Number of emulated UDC must be in range of 1...%d\\n",\n\t\t\t\tMAX_NUM_UDC);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tthe_hcd_pdev[i] = platform_device_alloc(driver_name, i);\n\t\tif (!the_hcd_pdev[i]) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_put(the_hcd_pdev[i--]);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tthe_udc_pdev[i] = platform_device_alloc(gadget_name, i);\n\t\tif (!the_udc_pdev[i]) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_put(the_udc_pdev[i--]);\n\t\t\tgoto err_alloc_udc;\n\t\t}\n\t}\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tdum[i] = kzalloc(sizeof(struct dummy), GFP_KERNEL);\n\t\tif (!dum[i]) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_add_pdata;\n\t\t}\n\t\tretval = platform_device_add_data(the_hcd_pdev[i], &dum[i],\n\t\t\t\tsizeof(void *));\n\t\tif (retval)\n\t\t\tgoto err_add_pdata;\n\t\tretval = platform_device_add_data(the_udc_pdev[i], &dum[i],\n\t\t\t\tsizeof(void *));\n\t\tif (retval)\n\t\t\tgoto err_add_pdata;\n\t}\n\n\tretval = platform_driver_register(&dummy_hcd_driver);\n\tif (retval < 0)\n\t\tgoto err_add_pdata;\n\tretval = platform_driver_register(&dummy_udc_driver);\n\tif (retval < 0)\n\t\tgoto err_register_udc_driver;\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tretval = platform_device_add(the_hcd_pdev[i]);\n\t\tif (retval < 0) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_del(the_hcd_pdev[i--]);\n	f
59410	2290	de4x5_pci_probe	drivers/net/ethernet/dec/tulip/de4x5.c	timer	1	13	\N	\N	\tu_char pb, pbus = 0, dev_num, dnum = 0, timer;\n\tu_short vendor, status;\n\tu_int irq = 0, device;\n\tu_long iobase = 0;\t/* Clear upper 32 bits in Alphas */\n\tint error;\n\tstruct net_device *dev;\n\tstruct de4x5_private *lp;\n\n\tdev_num = PCI_SLOT(pdev->devfn);\n\tpb = pdev->bus->number;\n\n\tif (io) { /* probe a single PCI device */\n\t\tpbus = (u_short)(io >> 8);\n\t\tdnum = (u_short)(io & 0xff);\n\t\tif ((pbus != pb) || (dnum != dev_num))\n\t\t\treturn -ENODEV;\n\t}\n\n\tvendor = pdev->vendor;\n\tdevice = pdev->device << 8;\n\tif (!(is_DC21040 || is_DC21041 || is_DC21140 || is_DC2114x))\n\t\treturn -ENODEV;\n\n\t/* Ok, the device seems to be for us. */\n\tif ((error = pci_enable_device (pdev)))\n\t\treturn error;\n\n\tif (!(dev = alloc_etherdev (sizeof (struct de4x5_private)))) {\n\t\terror = -ENOMEM;\n\t\tgoto disable_dev;\n\t}\n\n\tlp = netdev_priv(dev);\n\tlp->bus = PCI;\n\tlp->bus_num = 0;\n\n\t/* Search for an SROM on this bus */\n\tif (lp->bus_num != pb) {\n\t    lp->bus_num = pb;\n\t    srom_search(dev, pdev);\n\t}\n\n\t/* Get the chip configuration revision register */\n\tlp->cfrv = pdev->revision;\n\n\t/* Set the device number information */\n\tlp->device = dev_num;\n\tlp->bus_num = pb;\n\n\t/* Set the chipset information */\n\tif (is_DC2114x) {\n\t    device = ((lp->cfrv & CFRV_RN) < DC2114x_BRK ? DC21142 : DC21143);\n\t}\n\tlp->chipset = device;\n\n\t/* Get the board I/O address (64 bits on sparc64) */\n\tiobase = pci_resource_start(pdev, 0);\n\n\t/* Fetch the IRQ to be used */\n\tirq = pdev->irq;\n\tif ((irq == 0) || (irq == 0xff) || ((int)irq == -1)) {\n\t\terror = -ENODEV;\n\t\tgoto free_dev;\n\t}\n\n\t/* Check if I/O accesses and Bus Mastering are enabled */\n\tpci_read_config_word(pdev, PCI_COMMAND, &status);\n#ifdef __powerpc__\n\tif (!(status & PCI_COMMAND_IO)) {\n\t    status |= PCI_COMMAND_IO;\n\t    pci_write_config_word(pdev, PCI_COMMAND, status);\n\t    pci_read_config_word(pdev, PCI_COMMAND, &status);\n\t}\n#endif /* __powerpc__ */\n\tif (!(status & PCI_COMMAND_IO)) {\n\t\terror = -ENODEV;\n\t\tgoto free_dev;\n\t}\n\n\tif (!(status & PCI_COMMAND_MASTER)) {\n\t    status |= PCI_COMMAND_MASTER;\n\t    pci_write_config_word(pdev, PCI_COMMAND, status);\n\t    pci_read_config_word(pdev, PCI_COMMAND, &status);\n\t}\n\tif (!(status & PCI_COMMAND_MASTER)) {\n\t\terror = -ENODEV;\n\t\tgoto free_dev;\n\t}\n\n\t/* Check the latency timer for values >= 0x60 */\n\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &timer);\n\tif (timer < 0x60) {\n	f
59435	3014	ath10k_wmi_tlv_op_gen_wow_add_pattern	drivers/net/wireless/ath/ath10k/wmi-tlv.c	bitmask	1	13	\N	\N	\tstruct wmi_tlv_wow_add_pattern_cmd *cmd;\n\tstruct wmi_tlv_wow_bitmap_pattern *bitmap;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) +\t\t\t/* array struct */\n\t      sizeof(*tlv) + sizeof(*bitmap) +  /* bitmap */\n\t      sizeof(*tlv) +\t\t\t/* empty ipv4 sync */\n\t      sizeof(*tlv) +\t\t\t/* empty ipv6 sync */\n\t      sizeof(*tlv) +\t\t\t/* empty magic */\n\t      sizeof(*tlv) +\t\t\t/* empty info timeout */\n\t      sizeof(*tlv) + sizeof(u32);\t/* ratelimit interval */\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* cmd */\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ADD_PATTERN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->pattern_id = __cpu_to_le32(pattern_id);\n\tcmd->pattern_type = __cpu_to_le32(WOW_BITMAP_PATTERN);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\t/* bitmap */\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(sizeof(*tlv) + sizeof(*bitmap));\n\n\tptr += sizeof(*tlv);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_BITMAP_PATTERN_T);\n\ttlv->len = __cpu_to_le16(sizeof(*bitmap));\n\tbitmap = (void *)tlv->value;\n\n\tmemcpy(bitmap->patternbuf, pattern, pattern_len);\n\tmemcpy(bitmap->bitmaskbuf, bitmask, pattern_len);\n	f
59436	1849	cs42l42_i2c_probe	sound/soc/codecs/cs42l42.c	reg	1	13	\N	\N	\tstruct cs42l42_private *cs42l42;\n\tint ret, i;\n\tunsigned int devid = 0;\n\tunsigned int reg;\n\n\tcs42l42 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs42l42_private),\n\t\t\t       GFP_KERNEL);\n\tif (!cs42l42)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c_client, cs42l42);\n\n\tcs42l42->regmap = devm_regmap_init_i2c(i2c_client, &cs42l42_regmap);\n\tif (IS_ERR(cs42l42->regmap)) {\n\t\tret = PTR_ERR(cs42l42->regmap);\n\t\tdev_err(&i2c_client->dev, "regmap_init() failed: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l42->supplies); i++)\n\t\tcs42l42->supplies[i].supply = cs42l42_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\t\t\t      ARRAY_SIZE(cs42l42->supplies),\n\t\t\t\t      cs42l42->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t"Failed to request supplies: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l42->supplies),\n\t\t\t\t    cs42l42->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t"Failed to enable supplies: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\t/* Reset the Device */\n\tcs42l42->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\n\t\t"reset", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs42l42->reset_gpio))\n\t\treturn PTR_ERR(cs42l42->reset_gpio);\n\n\tif (cs42l42->reset_gpio) {\n\t\tdev_dbg(&i2c_client->dev, "Found reset GPIO\\n");\n\t\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\n\t}\n\tmdelay(3);\n\n\t/* Request IRQ */\n\tret = devm_request_threaded_irq(&i2c_client->dev,\n\t\t\ti2c_client->irq,\n\t\t\tNULL, cs42l42_irq_thread,\n\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t"cs42l42", cs42l42);\n\n\tif (ret != 0)\n\t\tdev_err(&i2c_client->dev,\n\t\t\t"Failed to request IRQ: %d\\n", ret);\n\n\t/* initialize codec */\n\tret = regmap_read(cs42l42->regmap, CS42L42_DEVID_AB, &reg);\n\tdevid = (reg & 0xFF) << 12;\n\n\tret = regmap_read(cs42l42->regmap, CS42L42_DEVID_CD, &reg);\n\tdevid |= (reg & 0xFF) << 4;\n\n\tret = regmap_read(cs42l42->regmap, CS42L42_DEVID_E, &reg);\n\tdevid |= (reg & 0xF0) >> 4;\n\n\tif (devid != CS42L42_CHIP_ID) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c_client->dev,\n\t\t\t"CS42L42 Device ID (%X). Expected %X\\n",\n\t\t\tdevid, CS42L42_CHIP_ID);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(cs42l42->regmap, CS42L42_REVID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, "Get Revision ID failed\\n");\n\t\treturn ret;\n\t}\n\n\tdev_info(&i2c_client->dev,\n	f
59497	146	ecb_decrypt	arch/x86/crypto/des3_ede_glue.c	&walk	1	13	\N	\N	\tstruct des3_ede_x86_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct blkcipher_walk walk;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n	f
59554	3998	evergreen_gpu_soft_reset	drivers/gpu/drm/radeon/evergreen.c	&save	1	13	\N	\N	\tstruct evergreen_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, "GPU softreset: 0x%08X\\n", reset_mask);\n\n\tevergreen_print_gpu_status_regs(rdev);\n\n\t/* Disable CP parsing/prefetching */\n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t/* Disable DMA */\n\t\ttmp = RREG32(DMA_RB_CNTL);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL, tmp);\n\t}\n\n\tudelay(50);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, "Wait for MC idle timedout !\\n");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE)) {\n\t\tgrbm_soft_reset |= SOFT_RESET_DB |\n\t\t\tSOFT_RESET_CB |\n\t\t\tSOFT_RESET_PA |\n\t\t\tSOFT_RESET_SC |\n\t\t\tSOFT_RESET_SPI |\n\t\t\tSOFT_RESET_SX |\n\t\t\tSOFT_RESET_SH |\n\t\t\tSOFT_RESET_TC |\n\t\t\tSOFT_RESET_TA |\n\t\t\tSOFT_RESET_VC |\n\t\t\tSOFT_RESET_VGT;\n\t}\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= SOFT_RESET_CP |\n\t\t\tSOFT_RESET_VGT;\n\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA;\n\n\tif (reset_mask & RADEON_RESET_DISPLAY)\n\t\tsrbm_soft_reset |= SOFT_RESET_DC;\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tsrbm_soft_reset |= SOFT_RESET_RLC;\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= SOFT_RESET_SEM;\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= SOFT_RESET_IH;\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= SOFT_RESET_VMC;\n\n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tif (reset_mask & RADEON_RESET_MC)\n\t\t\tsrbm_soft_reset |= SOFT_RESET_MC;\n\t}\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, "GRBM_SOFT_RESET=0x%08X\\n", tmp);\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, "SRBM_SOFT_RESET=0x%08X\\n", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t/* Wait a little for things to settle down */\n\tudelay(50);\n\n\tevergreen_mc_resume(rdev, &save);\n	f
60511	1278	mip4_execute_fw_update	drivers/input/touchscreen/melfas_mip4.c	fw_size	1	13	\N	\N	\tconst struct mip4_bin_tail *fw_info;\n\tu32 fw_start_offset;\n\tu32 fw_size;\n\tint retires = 3;\n\tint error;\n\n\terror = mip4_parse_firmware(ts, fw,\n\t\t\t\t    &fw_start_offset, &fw_size, &fw_info);\n\tif (error)\n\t\treturn error;\n\n\tif (ts->input->users) {\n\t\tdisable_irq(ts->client->irq);\n\t} else {\n\t\terror = mip4_power_on(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Update firmware */\n\tdo {\n\t\terror = mip4_flash_fw(ts, fw->data, fw_size, fw_start_offset);\n	f
60773	2128	falcon_reset_sram	drivers/net/ethernet/sfc/falcon/falcon.c	&srm_cfg_reg_ker	1	13	\N	\N	\tef4_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;\n\tint count;\n\n\t/* Set the SRAM wake/sleep GPIO appropriately. */\n\tef4_reado(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\n\tEF4_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OEN, 1);\n\tEF4_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OUT, 1);\n\tef4_writeo(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\n\n\t/* Initiate SRAM reset */\n\tEF4_POPULATE_OWORD_2(srm_cfg_reg_ker,\n\t\t\t     FRF_AZ_SRM_INIT_EN, 1,\n\t\t\t     FRF_AZ_SRM_NB_SZ, 0);\n\tef4_writeo(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);\n	f
61596	1811	xfrm_get_policy	net/xfrm/xfrm_user.c	resp_skb	1	13	\N	\N	\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_userpolicy_id *p;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct km_event c;\n\tint delete;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tp = nlmsg_data(nlh);\n\tdelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\n\t\t\t\t\t   ctx, delete, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (!delete) {\n\t\tstruct sk_buff *resp_skb;\n\n\t\tresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\n\t\tif (IS_ERR(resp_skb)) {\n\t\t\terr = PTR_ERR(resp_skb);\n\t\t} else {\n\t\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\n	f
62171	3110	efx_ef10_ev_init	drivers/net/ethernet/sfc/ef10.c	flags	1	13	\N	\N	\tMCDI_DECLARE_BUF(inbuf,\n\t\t\t MC_CMD_INIT_EVQ_V2_IN_LEN(EFX_MAX_EVQ_SIZE * 8 /\n\t\t\t\t\t\t   EFX_BUF_SIZE));\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_INIT_EVQ_V2_OUT_LEN);\n\tsize_t entries = channel->eventq.buf.len / EFX_BUF_SIZE;\n\tstruct efx_nic *efx = channel->efx;\n\tstruct efx_ef10_nic_data *nic_data;\n\tsize_t inlen, outlen;\n\tunsigned int enabled, implemented;\n\tdma_addr_t dma_addr;\n\tint rc;\n\tint i;\n\n\tnic_data = efx->nic_data;\n\n\t/* Fill event queue with all ones (i.e. empty events) */\n\tmemset(channel->eventq.buf.addr, 0xff, channel->eventq.buf.len);\n\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_SIZE, channel->eventq_mask + 1);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_INSTANCE, channel->channel);\n\t/* INIT_EVQ expects index in vector table, not absolute */\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_IRQ_NUM, channel->channel);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_MODE,\n\t\t       MC_CMD_INIT_EVQ_IN_TMR_MODE_DIS);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_LOAD, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_TMR_RELOAD, 0);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_COUNT_MODE,\n\t\t       MC_CMD_INIT_EVQ_IN_COUNT_MODE_DIS);\n\tMCDI_SET_DWORD(inbuf, INIT_EVQ_IN_COUNT_THRSHLD, 0);\n\n\tif (nic_data->datapath_caps2 &\n\t    1 << MC_CMD_GET_CAPABILITIES_V2_OUT_INIT_EVQ_V2_LBN) {\n\t\t/* Use the new generic approach to specifying event queue\n\t\t * configuration, requesting lower latency or higher throughput.\n\t\t * The options that actually get used appear in the output.\n\t\t */\n\t\tMCDI_POPULATE_DWORD_2(inbuf, INIT_EVQ_V2_IN_FLAGS,\n\t\t\t\t      INIT_EVQ_V2_IN_FLAG_INTERRUPTING, 1,\n\t\t\t\t      INIT_EVQ_V2_IN_FLAG_TYPE,\n\t\t\t\t      MC_CMD_INIT_EVQ_V2_IN_FLAG_TYPE_AUTO);\n\t} else {\n\t\tbool cut_thru = !(nic_data->datapath_caps &\n\t\t\t1 << MC_CMD_GET_CAPABILITIES_OUT_RX_BATCHING_LBN);\n\n\t\tMCDI_POPULATE_DWORD_4(inbuf, INIT_EVQ_IN_FLAGS,\n\t\t\t\t      INIT_EVQ_IN_FLAG_INTERRUPTING, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_RX_MERGE, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_TX_MERGE, 1,\n\t\t\t\t      INIT_EVQ_IN_FLAG_CUT_THRU, cut_thru);\n\t}\n\n\tdma_addr = channel->eventq.buf.dma_addr;\n\tfor (i = 0; i < entries; ++i) {\n\t\tMCDI_SET_ARRAY_QWORD(inbuf, INIT_EVQ_IN_DMA_ADDR, i, dma_addr);\n\t\tdma_addr += EFX_BUF_SIZE;\n\t}\n\n\tinlen = MC_CMD_INIT_EVQ_IN_LEN(entries);\n\n\trc = efx_mcdi_rpc(efx, MC_CMD_INIT_EVQ, inbuf, inlen,\n\t\t\t  outbuf, sizeof(outbuf), &outlen);\n\n\tif (outlen >= MC_CMD_INIT_EVQ_V2_OUT_LEN)\n\t\tnetif_dbg(efx, drv, efx->net_dev,\n\t\t\t  "Channel %d using event queue flags %08x\\n",\n\t\t\t  channel->channel,\n\t\t\t  MCDI_DWORD(outbuf, INIT_EVQ_V2_OUT_FLAGS));\n\n\t/* IRQ return is ignored */\n\tif (channel->channel || rc)\n\t\treturn rc;\n\n\t/* Successfully created event queue on channel 0 */\n\trc = efx_mcdi_get_workarounds(efx, &implemented, &enabled);\n\tif (rc == -ENOSYS) {\n\t\t/* GET_WORKAROUNDS was implemented before this workaround,\n\t\t * thus it must be unavailable in this firmware.\n\t\t */\n\t\tnic_data->workaround_26807 = false;\n\t\trc = 0;\n\t} else if (rc) {\n\t\tgoto fail;\n\t} else {\n\t\tnic_data->workaround_26807 =\n\t\t\t!!(enabled & MC_CMD_GET_WORKAROUNDS_OUT_BUG26807);\n\n\t\tif (implemented & MC_CMD_GET_WORKAROUNDS_OUT_BUG26807 &&\n\t\t    !nic_data->workaround_26807) {\n\t\t\tunsigned int flags;\n\n\t\t\trc = efx_mcdi_set_workaround(efx,\n\t\t\t\t\t\t     MC_CMD_WORKAROUND_BUG26807,\n\t\t\t\t\t\t     true, &flags);\n\n\t\t\tif (!rc) {\n\t\t\t\tif (flags &\n	f
62303	581	gpio_fan_probe	drivers/hwmon/gpio-fan.c	pdata->speed	1	13	\N	\N	\tint err;\n\tstruct gpio_fan_data *fan_data;\n\tstruct gpio_fan_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tfan_data = devm_kzalloc(&pdev->dev, sizeof(struct gpio_fan_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!fan_data)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_OF_GPIO\n\tif (!pdata) {\n\t\tpdata = devm_kzalloc(&pdev->dev,\n\t\t\t\t\tsizeof(struct gpio_fan_platform_data),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\terr = gpio_fan_get_of_pdata(&pdev->dev, pdata);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#else /* CONFIG_OF_GPIO */\n\tif (!pdata)\n\t\treturn -EINVAL;\n#endif /* CONFIG_OF_GPIO */\n\n\tfan_data->pdev = pdev;\n\tplatform_set_drvdata(pdev, fan_data);\n\tmutex_init(&fan_data->lock);\n\n\t/* Configure alarm GPIO if available. */\n\tif (pdata->alarm) {\n\t\terr = fan_alarm_init(fan_data, pdata->alarm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Configure control GPIOs if available. */\n\tif (pdata->ctrl && pdata->num_ctrl > 0) {\n\t\tif (!pdata->speed || pdata->num_speed <= 1)\n	f
62674	320	pppol2tp_sendmsg	net/l2tp/l2tp_ppp.c	skb	1	13	\N	\N	\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint uhlen;\n\n\terror = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto error;\n\n\t/* Get session and tunnel contexts */\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto error;\n\n\tps = l2tp_session_priv(session);\n\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\tif (tunnel == NULL)\n\t\tgoto error_put_sess;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\n\t/* Allocate a socket buffer */\n\terror = -ENOMEM;\n\tskb = sock_wmalloc(sk, NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   uhlen + session->hdr_len +\n\t\t\t   2 + total_len, /* 2 bytes for PPP_ALLSTATIONS & PPP_UI */\n\t\t\t   0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error_put_sess_tun;\n\n\t/* Reserve space for headers. */\n\tskb_reserve(skb, NET_SKB_PAD);\n	f
63369	380	raw_send_hdrinc	net/ipv4/raw.c	skb	1	13	\N	\N	\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\tunsigned int iphlen;\n\tint err;\n\tstruct rtable *rt = *rtp;\n\tint hlen, tlen;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (length < sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\thlen = LL_RESERVED_SPACE(rt->dst.dev);\n\ttlen = rt->dst.dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n	f
63449	899	sg_ioctl	drivers/scsi/sg.c	srp->done	1	13	\N	\N	\tvoid __user *p = (void __user *)arg;\n\tint __user *ip = p;\n\tint result, val, read_only;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tunsigned long iflags;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t   "sg_ioctl: cmd=0x%x\\n", (int) cmd_in));\n\tread_only = (O_RDWR != (filp->f_flags & O_ACCMODE));\n\n\tswitch (cmd_in) {\n\tcase SG_IO:\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\tif (!scsi_block_when_processing_errors(sdp->device))\n\t\t\treturn -ENXIO;\n\t\tif (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))\n\t\t\treturn -EFAULT;\n\t\tresult = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,\n\t\t\t\t 1, read_only, 1, &srp);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tresult = wait_event_interruptible(sfp->read_wait,\n\t\t\t(srp_done(sfp, srp) || atomic_read(&sdp->detaching)));\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\twrite_lock_irq(&sfp->rq_list_lock);\n\t\tif (srp->done) {\n	f
63660	240	i2c_24xxx_ir	drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c	dat	1	13	\N	\N	\tu8 dat[4];\n\tunsigned int stat;\n\n\tif (!(rlen || wlen)) {\n\t\t/* This is a probe attempt.  Just let it succeed. */\n\t\treturn 0;\n\t}\n\n\t/* We don't understand this kind of transaction */\n\tif ((wlen != 0) || (rlen == 0)) return -EIO;\n\n\tif (rlen < 3) {\n\t\t/* Mike Isely <isely@pobox.com> Appears to be a probe\n\t\t   attempt from lirc.  Just fill in zeroes and return.  If\n\t\t   we try instead to do the full transaction here, then bad\n\t\t   things seem to happen within the lirc driver module\n\t\t   (version 0.8.0-7 sources from Debian, when run under\n\t\t   vanilla 2.6.17.6 kernel) - and I don't have the patience\n\t\t   to chase it down. */\n\t\tif (rlen > 0) rdata[0] = 0;\n\t\tif (rlen > 1) rdata[1] = 0;\n\t\treturn 0;\n\t}\n\n\t/* Issue a command to the FX2 to read the IR receiver. */\n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\thdw->cmd_buffer[0] = FX2CMD_GET_IR_CODE;\n\t\tstat = pvr2_send_request(hdw,\n\t\t\t\t\t hdw->cmd_buffer,1,\n\t\t\t\t\t hdw->cmd_buffer,4);\n\t\tdat[0] = hdw->cmd_buffer[0];\n\t\tdat[1] = hdw->cmd_buffer[1];\n\t\tdat[2] = hdw->cmd_buffer[2];\n\t\tdat[3] = hdw->cmd_buffer[3];\n\t} while (0); LOCK_GIVE(hdw->ctl_lock);\n\n\t/* Give up if that operation failed. */\n\tif (stat != 0) return stat;\n\n\t/* Mangle the results into something that looks like the real IR\n\t   receiver. */\n\trdata[2] = 0xc1;\n\tif (dat[0] != 1) {\n	f
50846	334	perf_ftrace_function_call	kernel/trace/trace_event_perf.c	rctx	1	13	\N	\N	\tstruct perf_event *event;\n\tstruct ftrace_entry *entry;\n\tstruct hlist_head *head;\n\tstruct pt_regs regs;\n\tint rctx;\n\n\thead = this_cpu_ptr(event_function.perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\n\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);\n\n\tmemset(&regs, 0, sizeof(regs));\n\tperf_fetch_caller_regs(&regs);\n\n\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->ip = ip;\n\tentry->parent_ip = parent_ip;\n\tevent = container_of(ops, struct perf_event, ftrace_ops);\n\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,\n	f
-100	558	p9_check_errors	net/9p/client.c	ecode	44	2	arg_no	TP	\tint8_t type;\n\tint err;\n\tint ecode;\n\n\terr = p9_parse_header(req->rc, NULL, &type, NULL, 0);\n\t/*\n\t * dump the response from server\n\t * This should be after check errors which poplulate pdu_fcall.\n\t */\n\ttrace_9p_protocol_dump(c, req->rc);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_ERROR, "couldn't parse header %d\\n", err);\n\t\treturn err;\n\t}\n\tif (type != P9_RERROR && type != P9_RLERROR)\n\t\treturn 0;\n\n\tif (!p9_is_proto_dotl(c)) {\n\t\tchar *ename;\n\t\terr = p9pdu_readf(req->rc, c->proto_version, "s?d",\n\t\t\t\t  &ename, &ecode);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (p9_is_proto_dotu(c) && ecode < 512)\n\t\t\terr = -ecode;\n\n\t\tif (!err) {\n\t\t\terr = p9_errstr2errno(ename, strlen(ename));\n\n\t\t\tp9_debug(P9_DEBUG_9P, "<<< RERROR (%d) %s\\n",\n\t\t\t\t -ecode, ename);\n\t\t}\n\t\tkfree(ename);\n\t} else {\n\t\terr = p9pdu_readf(req->rc, c->proto_version, "d", &ecode);\n\t\terr = -ecode;\n	f
-2	173	compress_sliced_buf	drivers/media/pci/cx18/cx18-vbi.c	vbi.type	20	2	arg_no	\N	\tstruct v4l2_decode_vbi_line vbi;\n\tint i;\n\tu32 line = 0;\n\tu32 line_size = cx->is_60hz ? VBI_HBLANK_SAMPLES_60HZ\n\t\t\t\t    : VBI_HBLANK_SAMPLES_50HZ;\n\n\t/* find the first valid line */\n\tfor (i = hdr_size, buf += hdr_size; i < size; i++, buf++) {\n\t\tif (buf[0] == 0xff && !buf[1] && !buf[2] &&\n\t\t    (buf[3] == sliced_vbi_eav_rp[0] ||\n\t\t     buf[3] == sliced_vbi_eav_rp[1]))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The last line is short by hdr_size bytes, but for the remaining\n\t * checks against size, we pretend that it is not, by counting the\n\t * header bytes we knowingly skipped\n\t */\n\tsize -= (i - hdr_size);\n\tif (size < line_size)\n\t\treturn line;\n\n\tfor (i = 0; i < size / line_size; i++) {\n\t\tu8 *p = buf + i * line_size;\n\n\t\t/* Look for EAV code  */\n\t\tif (p[0] != 0xff || p[1] || p[2] ||\n\t\t    (p[3] != sliced_vbi_eav_rp[0] &&\n\t\t     p[3] != sliced_vbi_eav_rp[1]))\n\t\t\tcontinue;\n\t\tvbi.p = p + 4;\n\t\tv4l2_subdev_call(cx->sd_av, vbi, decode_vbi_line, &vbi);\n\t\tif (vbi.type) {\n	f
29768	1240	rtl2832u_tuner_attach	drivers/media/usb/dvb-usb-v2/rtl28xxu.c	ret	1	13	\N	\N	\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct dvb_frontend *fe = NULL;\n\tstruct i2c_board_info info;\n\tstruct i2c_client *client;\n\tstruct v4l2_subdev *subdev = NULL;\n\tstruct platform_device *pdev;\n\tstruct rtl2832_sdr_platform_data pdata;\n\n\tdev_dbg(&d->intf->dev, "\\n");\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tmemset(&pdata, 0, sizeof(pdata));\n\n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2832_FC0012:\n\t\tfe = dvb_attach(fc0012_attach, adap->fe[0],\n\t\t\tdev->demod_i2c_adapter, &rtl2832u_fc0012_config);\n\n\t\t/* since fc0012 includs reading the signal strength delegate\n\t\t * that to the tuner driver */\n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\t\tbreak;\n\tcase TUNER_RTL2832_FC0013:\n\t\tfe = dvb_attach(fc0013_attach, adap->fe[0],\n\t\t\tdev->demod_i2c_adapter, 0xc6>>1, 0, FC_XTAL_28_8_MHZ);\n\n\t\t/* fc0013 also supports signal strength reading */\n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\t\tbreak;\n\tcase TUNER_RTL2832_E4000: {\n\t\t\tstruct e4000_config e4000_config = {\n\t\t\t\t.fe = adap->fe[0],\n\t\t\t\t.clock = 28800000,\n\t\t\t};\n\n\t\t\tstrlcpy(info.type, "e4000", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &e4000_config;\n\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_device(dev->demod_i2c_adapter, &info);\n\t\t\tif (client == NULL || client->dev.driver == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev->i2c_client_tuner = client;\n\t\t\tsubdev = i2c_get_clientdata(client);\n\t\t}\n\t\tbreak;\n\tcase TUNER_RTL2832_FC2580: {\n\t\t\tstruct fc2580_platform_data fc2580_pdata = {\n\t\t\t\t.dvb_frontend = adap->fe[0],\n\t\t\t};\n\t\t\tstruct i2c_board_info board_info = {};\n\n\t\t\tstrlcpy(board_info.type, "fc2580", I2C_NAME_SIZE);\n\t\t\tboard_info.addr = 0x56;\n\t\t\tboard_info.platform_data = &fc2580_pdata;\n\t\t\trequest_module("fc2580");\n\t\t\tclient = i2c_new_device(dev->demod_i2c_adapter,\n\t\t\t\t\t\t&board_info);\n\t\t\tif (client == NULL || client->dev.driver == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev->i2c_client_tuner = client;\n\t\t\tsubdev = fc2580_pdata.get_v4l2_subdev(client);\n\t\t}\n\t\tbreak;\n\tcase TUNER_RTL2832_TUA9001: {\n\t\tstruct tua9001_platform_data tua9001_pdata = {\n\t\t\t.dvb_frontend = adap->fe[0],\n\t\t};\n\t\tstruct i2c_board_info board_info = {};\n\n\t\t/* enable GPIO1 and GPIO4 as output */\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x12);\n\t\tif (ret)\n	f
40952	582	skge_set_pauseparam	drivers/net/ethernet/marvell/skge.c	&old	1	13	\N	\N	\tstruct skge_port *skge = netdev_priv(dev);\n\tstruct ethtool_pauseparam old;\n\tint err = 0;\n\n\tskge_get_pauseparam(dev, &old);\n	f
37962	641	regmap_debugfs_initcall	drivers/base/regmap/regmap-debugfs.c	regmap_debugfs_initcall_@regmap_debugfs_root $obj	0	13	\N	\N	\tstruct regmap_debugfs_node *node, *tmp;\n\n\tregmap_debugfs_root = debugfs_create_dir("regmap", NULL);\n\tif (!regmap_debugfs_root) {\n	f
1363	663	ioat_cleanup	drivers/dma/ioat/dma.c	phys_complete	1	13	\N	\N	\tu64 phys_complete;\n\n\tspin_lock_bh(&ioat_chan->cleanup_lock);\n\n\tif (ioat_cleanup_preamble(ioat_chan, &phys_complete))\n\t\t__cleanup(ioat_chan, phys_complete);\n	f
8659	965	rx_int	drivers/net/hippi/rrunner.c	skb	1	13	\N	\N	\tstruct rr_private *rrpriv = netdev_priv(dev);\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\n\tdo {\n\t\tstruct rx_desc *desc;\n\t\tu32 pkt_len;\n\n\t\tdesc = &(rrpriv->rx_ring[index]);\n\t\tpkt_len = desc->size;\n#if (DEBUG > 2)\n\t\tprintk("index %i, rxlimit %i\\n", index, rxlimit);\n\t\tprintk("len %x, mode %x\\n", pkt_len, desc->mode);\n#endif\n\t\tif ( (rrpriv->rx_ring[index].mode & PACKET_BAD) == PACKET_BAD){\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto defer;\n\t\t}\n\n\t\tif (pkt_len > 0){\n\t\t\tstruct sk_buff *skb, *rx_skb;\n\n\t\t\trx_skb = rrpriv->rx_skbuff[index];\n\n\t\t\tif (pkt_len < PKT_COPY_THRESHOLD) {\n\t\t\t\tskb = alloc_skb(pkt_len, GFP_ATOMIC);\n\t\t\t\tif (skb == NULL){\n\t\t\t\t\tprintk(KERN_WARNING "%s: Unable to allocate skb (%i bytes), deferring packet\\n", dev->name, pkt_len);\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tgoto defer;\n\t\t\t\t} else {\n\t\t\t\t\tpci_dma_sync_single_for_cpu(rrpriv->pci_dev,\n\t\t\t\t\t\t\t\t    desc->addr.addrlo,\n\t\t\t\t\t\t\t\t    pkt_len,\n\t\t\t\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\n\t\t\t\t\tskb_put_data(skb, rx_skb->data,\n	f
25427	872	ath10k_htt_mgmt_tx	drivers/net/wireless/ath/ath10k/htt_tx.c	cmd->hdr.msg_type	1	13	\N	\N	\tstruct ath10k *ar = htt->ar;\n\tstruct device *dev = ar->dev;\n\tstruct sk_buff *txdesc = NULL;\n\tstruct htt_cmd *cmd;\n\tstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(msdu);\n\tu8 vdev_id = ath10k_htt_tx_get_vdev_id(ar, msdu);\n\tint len = 0;\n\tint msdu_id = -1;\n\tint res;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)msdu->data;\n\n\tlen += sizeof(cmd->hdr);\n\tlen += sizeof(cmd->mgmt_tx);\n\n\tspin_lock_bh(&htt->tx_lock);\n\tres = ath10k_htt_tx_alloc_msdu_id(htt, msdu);\n\tspin_unlock_bh(&htt->tx_lock);\n\tif (res < 0)\n\t\tgoto err;\n\n\tmsdu_id = res;\n\n\tif ((ieee80211_is_action(hdr->frame_control) ||\n\t     ieee80211_is_deauth(hdr->frame_control) ||\n\t     ieee80211_is_disassoc(hdr->frame_control)) &&\n\t     ieee80211_has_protected(hdr->frame_control)) {\n\t\tskb_put(msdu, IEEE80211_CCMP_MIC_LEN);\n\t}\n\n\ttxdesc = ath10k_htc_alloc_skb(ar, len);\n\tif (!txdesc) {\n\t\tres = -ENOMEM;\n\t\tgoto err_free_msdu_id;\n\t}\n\n\tskb_cb->paddr = dma_map_single(dev, msdu->data, msdu->len,\n\t\t\t\t       DMA_TO_DEVICE);\n\tres = dma_mapping_error(dev, skb_cb->paddr);\n\tif (res) {\n\t\tres = -EIO;\n\t\tgoto err_free_txdesc;\n\t}\n\n\tskb_put(txdesc, len);\n\tcmd = (struct htt_cmd *)txdesc->data;\n\tmemset(cmd, 0, len);\n\n\tcmd->hdr.msg_type         = HTT_H2T_MSG_TYPE_MGMT_TX;\n	f
61856	455	fc0013_set_params	drivers/media/tuners/fc0013.c	tmp	1	13	\N	\N	\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint i, ret = 0;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 freq = p->frequency / 1000;\n\tu32 delsys = p->delivery_system;\n\tunsigned char reg[7], am, pm, multi, tmp;\n\tunsigned long f_vco;\n\tunsigned short xtal_freq_khz_2, xin, xdiv;\n\tbool vco_select = false;\n\n\tif (fe->callback) {\n\t\tret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\tFC_FE_CALLBACK_VHF_ENABLE, (freq > 300000 ? 0 : 1));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tswitch (priv->xtal_freq) {\n\tcase FC_XTAL_27_MHZ:\n\t\txtal_freq_khz_2 = 27000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_36_MHZ:\n\t\txtal_freq_khz_2 = 36000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_28_8_MHZ:\n\tdefault:\n\t\txtal_freq_khz_2 = 28800 / 2;\n\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */\n\n\t/* set VHF track */\n\tret = fc0013_set_vhf_track(priv, freq);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (freq < 300000) {\n\t\t/* enable VHF filter */\n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp | 0x10);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t/* disable UHF & disable GPS */\n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, tmp & 0x1f);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else if (freq <= 862000) {\n\t\t/* disable VHF filter */\n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp & 0xef);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t/* enable UHF & disable GPS */\n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x40);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else {\n\t\t/* disable VHF filter */\n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp & 0xef);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t/* disable UHF & enable GPS */\n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x20);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t/* select frequency divider and the frequency of VCO */\n\tif (freq < 37084) {\t\t/* freq * 96 < 3560000 */\n\t\tmulti = 96;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x00;\n\t} else if (freq < 55625) {\t/* freq * 64 < 3560000 */\n\t\tmulti = 64;\n\t\treg[5] = 0x02;\n\t\treg[6] = 0x02;\n\t} else if (freq < 74167) {\t/* freq * 48 < 3560000 */\n\t\tmulti = 48;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x00;\n\t} else if (freq < 111250) {\t/* freq * 32 < 3560000 */\n\t\tmulti = 32;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x02;\n\t} else if (freq < 148334) {\t/* freq * 24 < 3560000 */\n\t\tmulti = 24;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x00;\n\t} else if (freq < 222500) {\t/* freq * 16 < 3560000 */\n\t\tmulti = 16;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x02;\n\t} else if (freq < 296667) {\t/* freq * 12 < 3560000 */\n\t\tmulti = 12;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x00;\n\t} else if (freq < 445000) {\t/* freq * 8 < 3560000 */\n\t\tmulti = 8;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x02;\n\t} else if (freq < 593334) {\t/* freq * 6 < 3560000 */\n\t\tmulti = 6;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x00;\n\t} else if (freq < 950000) {\t/* freq * 4 < 3800000 */\n\t\tmulti = 4;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x02;\n\t} else {\n\t\tmulti = 2;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x02;\n\t}\n\n\tf_vco = freq * multi;\n\n\tif (f_vco >= 3060000) {\n\t\treg[6] |= 0x08;\n\t\tvco_select = true;\n\t}\n\n\tif (freq >= 45000) {\n\t\t/* From divided value (XDIV) determined the FA and FP value */\n\t\txdiv = (unsigned short)(f_vco / xtal_freq_khz_2);\n\t\tif ((f_vco - xdiv * xtal_freq_khz_2) >= (xtal_freq_khz_2 / 2))\n\t\t\txdiv++;\n\n\t\tpm = (unsigned char)(xdiv / 8);\n\t\tam = (unsigned char)(xdiv - (8 * pm));\n\n\t\tif (am < 2) {\n\t\t\treg[1] = am + 8;\n\t\t\treg[2] = pm - 1;\n\t\t} else {\n\t\t\treg[1] = am;\n\t\t\treg[2] = pm;\n\t\t}\n\t} else {\n\t\t/* fix for frequency less than 45 MHz */\n\t\treg[1] = 0x06;\n\t\treg[2] = 0x11;\n\t}\n\n\t/* fix clock out */\n\treg[6] |= 0x20;\n\n\t/* From VCO frequency determines the XIN ( fractional part of Delta\n\t   Sigma PLL) and divided value (XDIV) */\n\txin = (unsigned short)(f_vco - (f_vco / xtal_freq_khz_2) * xtal_freq_khz_2);\n\txin = (xin << 15) / xtal_freq_khz_2;\n\tif (xin >= 16384)\n\t\txin += 32768;\n\n\treg[3] = xin >> 8;\n\treg[4] = xin & 0xff;\n\n\tif (delsys == SYS_DVBT) {\n\t\treg[6] &= 0x3f; /* bits 6 and 7 describe the bandwidth */\n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\treg[6] |= 0x80;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\treg[6] |= 0x40;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\terr("%s: modulation type not supported!", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/* modified for Realtek demod */\n\treg[5] |= 0x07;\n\n\tfor (i = 1; i <= 6; i++) {\n\t\tret = fc0013_writereg(priv, i, reg[i]);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = fc0013_readreg(priv, 0x11, &tmp);\n\tif (ret)\n\t\tgoto exit;\n\tif (multi == 64)\n\t\tret = fc0013_writereg(priv, 0x11, tmp | 0x04);\n\telse\n\t\tret = fc0013_writereg(priv, 0x11, tmp & 0xfb);\n\tif (ret)\n\t\tgoto exit;\n\n\t/* VCO Calibration */\n\tret = fc0013_writereg(priv, 0x0e, 0x80);\n\tif (!ret)\n\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\n\t/* VCO Re-Calibration if needed */\n\tif (!ret)\n\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\n\tif (!ret) {\n\t\tmsleep(10);\n\t\tret = fc0013_readreg(priv, 0x0e, &tmp);\n\t}\n\tif (ret)\n\t\tgoto exit;\n\n\t/* vco selection */\n\ttmp &= 0x3f;\n\n\tif (vco_select) {\n\t\tif (tmp > 0x3c) {\n	f
33399	1322	table_load	drivers/md/dm-ioctl.c	t	1	13	\N	\N	\tint r;\n\tstruct hash_cell *hc;\n\tstruct dm_table *t, *old_map = NULL;\n\tstruct mapped_device *md;\n\tstruct target_type *immutable_target_type;\n\n\tmd = find_device(param);\n\tif (!md)\n\t\treturn -ENXIO;\n\n\tr = dm_table_create(&t, get_mode(param), param->target_count, md);\n\tif (r)\n\t\tgoto err;\n\n\t/* Protect md->type and md->queue against concurrent table loads. */\n\tdm_lock_md_type(md);\n\tr = populate_table(t, param, param_size);\n	f
25393	871	i915_gem_obj_prepare_shmem_write	drivers/gpu/drm/i915/i915_gem.c	i915_gem_obj_prepare_shmem_write_$obj.addr$obj$59$obj$lshr$6$and$1	0	13	\N	\N	\tint ret;\n\n\tlockdep_assert_held(&obj->base.dev->struct_mutex);\n\n\t*needs_clflush = 0;\n\tif (!i915_gem_object_has_struct_page(obj))\n\t\treturn -ENODEV;\n\n\tret = i915_gem_object_wait(obj,\n\t\t\t\t   I915_WAIT_INTERRUPTIBLE |\n\t\t\t\t   I915_WAIT_LOCKED |\n\t\t\t\t   I915_WAIT_ALL,\n\t\t\t\t   MAX_SCHEDULE_TIMEOUT,\n\t\t\t\t   NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tif (obj->cache_coherent & I915_BO_CACHE_COHERENT_FOR_WRITE ||\n\t    !static_cpu_has(X86_FEATURE_CLFLUSH)) {\n\t\tret = i915_gem_object_set_to_cpu_domain(obj, true);\n\t\tif (ret)\n\t\t\tgoto err_unpin;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tflush_write_domain(obj, ~I915_GEM_DOMAIN_CPU);\n\n\t/* If we're not in the cpu write domain, set ourself into the\n\t * gtt write domain and manually flush cachelines (as required).\n\t * This optimizes for the case when the gpu will use the data\n\t * right away and we therefore have to clflush anyway.\n\t */\n\tif (!obj->cache_dirty) {\n	f
37810	7194	qla24xx_configure_vhba	drivers/scsi/qla2xxx/qla_init.c	mb	1	13	\N	\N	\tint rval = QLA_SUCCESS;\n\tint rval2;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tstruct req_que *req;\n\tstruct rsp_que *rsp;\n\n\tif (!vha->vp_idx)\n\t\treturn -EINVAL;\n\n\trval = qla2x00_fw_ready(base_vha);\n\tif (vha->qpair)\n\t\treq = vha->qpair->req;\n\telse\n\t\treq = ha->req_q_map[0];\n\trsp = req->rsp;\n\n\tif (rval == QLA_SUCCESS) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tqla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL);\n\t}\n\n\tvha->flags.management_server_logged_in = 0;\n\n\t/* Login to SNS first */\n\trval2 = ha->isp_ops->fabric_login(vha, NPH_SNS, 0xff, 0xff, 0xfc, mb,\n\t    BIT_1);\n\tif (rval2 != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n	f
53810	1713	wm_adsp_load	sound/soc/codecs/wm_adsp.c	wm_adsp_load_$adsp2_sizes$obj$0$obj	0	13	\N	\N	\tLIST_HEAD(buf_list);\n\tconst struct firmware *firmware;\n\tstruct regmap *regmap = dsp->regmap;\n\tunsigned int pos = 0;\n\tconst struct wmfw_header *header;\n\tconst struct wmfw_adsp1_sizes *adsp1_sizes;\n\tconst struct wmfw_adsp2_sizes *adsp2_sizes;\n\tconst struct wmfw_footer *footer;\n\tconst struct wmfw_region *region;\n\tconst struct wm_adsp_region *mem;\n\tconst char *region_name;\n\tchar *file, *text = NULL;\n\tstruct wm_adsp_buf *buf;\n\tunsigned int reg;\n\tint regions = 0;\n\tint ret, offset, type, sizes;\n\n\tfile = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (file == NULL)\n\t\treturn -ENOMEM;\n\n\tsnprintf(file, PAGE_SIZE, "%s-dsp%d-%s.wmfw", dsp->part, dsp->num,\n\t\t wm_adsp_fw[dsp->fw].file);\n\tfile[PAGE_SIZE - 1] = '\\0';\n\n\tret = request_firmware(&firmware, file, dsp->dev);\n\tif (ret != 0) {\n\t\tadsp_err(dsp, "Failed to request '%s'\\n", file);\n\t\tgoto out;\n\t}\n\tret = -EINVAL;\n\n\tpos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\n\tif (pos >= firmware->size) {\n\t\tadsp_err(dsp, "%s: file too short, %zu bytes\\n",\n\t\t\t file, firmware->size);\n\t\tgoto out_fw;\n\t}\n\n\theader = (void *)&firmware->data[0];\n\n\tif (memcmp(&header->magic[0], "WMFW", 4) != 0) {\n\t\tadsp_err(dsp, "%s: invalid magic\\n", file);\n\t\tgoto out_fw;\n\t}\n\n\tswitch (header->ver) {\n\tcase 0:\n\t\tadsp_warn(dsp, "%s: Depreciated file format %d\\n",\n\t\t\t  file, header->ver);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\tadsp_err(dsp, "%s: unknown file format %d\\n",\n\t\t\t file, header->ver);\n\t\tgoto out_fw;\n\t}\n\n\tadsp_info(dsp, "Firmware version: %d\\n", header->ver);\n\tdsp->fw_ver = header->ver;\n\n\tif (header->core != dsp->type) {\n\t\tadsp_err(dsp, "%s: invalid core %d != %d\\n",\n\t\t\t file, header->core, dsp->type);\n\t\tgoto out_fw;\n\t}\n\n\tswitch (dsp->type) {\n\tcase WMFW_ADSP1:\n\t\tpos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\n\t\tadsp1_sizes = (void *)&(header[1]);\n\t\tfooter = (void *)&(adsp1_sizes[1]);\n\t\tsizes = sizeof(*adsp1_sizes);\n\n\t\tadsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\\n",\n\t\t\t file, le32_to_cpu(adsp1_sizes->dm),\n\t\t\t le32_to_cpu(adsp1_sizes->pm),\n\t\t\t le32_to_cpu(adsp1_sizes->zm));\n\t\tbreak;\n\n\tcase WMFW_ADSP2:\n\t\tpos = sizeof(*header) + sizeof(*adsp2_sizes) + sizeof(*footer);\n\t\tadsp2_sizes = (void *)&(header[1]);\n\t\tfooter = (void *)&(adsp2_sizes[1]);\n\t\tsizes = sizeof(*adsp2_sizes);\n\n\t\tadsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\\n",\n	f
9668	165	atmtcp_v_ioctl	drivers/atm/atmtcp.c	ci.vpi_bits	1	13	\N	\N	\tstruct atm_cirange ci;\n\tstruct atm_vcc *vcc;\n\tstruct sock *s;\n\tint i;\n\n\tif (cmd != ATM_SETCIRANGE) return -ENOIOCTLCMD;\n\tif (copy_from_user(&ci, arg,sizeof(ci))) return -EFAULT;\n\tif (ci.vpi_bits == ATM_CI_MAX) ci.vpi_bits = MAX_VPI_BITS;\n	f
42231	177	hinic_port_set_mtu	drivers/net/ethernet/huawei/hinic/hinic_port.c	port_mtu_cmd	1	13	\N	\N	\tstruct net_device *netdev = nic_dev->netdev;\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_mtu_cmd port_mtu_cmd;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err, max_frame;\n\tu16 out_size;\n\n\tif (new_mtu < HINIC_MIN_MTU_SIZE) {\n\t\tnetif_err(nic_dev, drv, netdev, "mtu < MIN MTU size");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;\n\tif (max_frame > HINIC_MAX_JUMBO_FRAME_SIZE) {\n\t\tnetif_err(nic_dev, drv, netdev, "mtu > MAX MTU size");\n\t\treturn -EINVAL;\n\t}\n\n\tport_mtu_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tport_mtu_cmd.mtu = new_mtu;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_CHANGE_MTU,\n\t\t\t\t &port_mtu_cmd, sizeof(port_mtu_cmd),\n\t\t\t\t &port_mtu_cmd, &out_size);\n\tif (err || (out_size != sizeof(port_mtu_cmd)) || port_mtu_cmd.status) {\n	f
44097	4651	notify_device_state	drivers/block/drbd/drbd_nl.c	skb	1	13	\N	\N	\tstruct device_statistics device_statistics;\n\tstruct drbd_genlmsghdr *dh;\n\tbool multicast = false;\n\tint err;\n\n\tif (!skb) {\n\t\tseq = atomic_inc_return(&notify_genl_seq);\n\t\tskb = genlmsg_new(NLMSG_GOODSIZE, GFP_NOIO);\n\t\terr = -ENOMEM;\n\t\tif (!skb)\n\t\t\tgoto failed;\n\t\tmulticast = true;\n\t}\n\n\terr = -EMSGSIZE;\n\tdh = genlmsg_put(skb, 0, seq, &drbd_genl_family, 0, DRBD_DEVICE_STATE);\n	f
-1044	383	m5mols_set_mode	drivers/media/i2c/m5mols/m5mols_core.c	reg	2	3	\N	\N	\tstruct v4l2_subdev *sd = &info->sd;\n\tint ret = -EINVAL;\n\tu8 reg;\n\n\tif (mode < REG_PARAMETER || mode > REG_CAPTURE)\n\t\treturn ret;\n\n\tret = m5mols_read_u8(sd, SYSTEM_SYSMODE, &reg);\n\tif (ret || reg == mode)\n	f
9089	820	ivtv_irq_dec_data_req	drivers/media/pci/ivtv/ivtv-irq.c	ivtv_irq_dec_data_req_$itv.addr$obj$468$obj	0	13	\N	\N	\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tstruct ivtv_stream *s;\n\n\t/* YUV or MPG */\n\n\tif (test_bit(IVTV_F_I_DEC_YUV, &itv->i_flags)) {\n\t\tivtv_api_get_data(&itv->dec_mbox, IVTV_MBOX_DMA, 2, data);\n\t\titv->dma_data_req_size =\n\t\t\t\t 1080 * ((itv->yuv_info.v4l2_src_h + 31) & ~31);\n\t\titv->dma_data_req_offset = data[1];\n\t\tif (atomic_read(&itv->yuv_info.next_dma_frame) >= 0)\n\t\t\tivtv_yuv_frame_complete(itv);\n\t\ts = &itv->streams[IVTV_DEC_STREAM_TYPE_YUV];\n\t}\n\telse {\n\t\tivtv_api_get_data(&itv->dec_mbox, IVTV_MBOX_DMA, 3, data);\n\t\titv->dma_data_req_size = min_t(u32, data[2], 0x10000);\n\t\titv->dma_data_req_offset = data[1];\n\t\ts = &itv->streams[IVTV_DEC_STREAM_TYPE_MPG];\n\t}\n\tIVTV_DEBUG_HI_IRQ("DEC DATA REQ %s: %d %08x %u\\n", s->name, s->q_full.bytesused,\n	f
1940	2019	vhost_get_vq_desc	drivers/vhost/vhost.c	vhost_get_vq_desc_$vq.addr$obj$44$obj	0	13	\N	\N	\tstruct vring_desc desc;\n\tunsigned int i, head, found = 0;\n\tu16 last_avail_idx;\n\t__virtio16 avail_idx;\n\t__virtio16 ring_head;\n\tint ret, access;\n\n\t/* Check it isn't doing very strange things with descriptor numbers. */\n\tlast_avail_idx = vq->last_avail_idx;\n\n\tif (vq->avail_idx == vq->last_avail_idx) {\n\t\tif (unlikely(vhost_get_avail(vq, avail_idx, &vq->avail->idx))) {\n\t\t\tvq_err(vq, "Failed to access avail idx at %p\\n",\n\t\t\t\t&vq->avail->idx);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvq->avail_idx = vhost16_to_cpu(vq, avail_idx);\n\n\t\tif (unlikely((u16)(vq->avail_idx - last_avail_idx) > vq->num)) {\n\t\t\tvq_err(vq, "Guest moved used index from %u to %u",\n	f
27302	490	btmrvl_sdio_download_helper	drivers/bluetooth/btmrvl_sdio.c	ret	1	13	\N	\N	\tconst struct firmware *fw_helper = NULL;\n\tconst u8 *helper = NULL;\n\tint ret;\n\tvoid *tmphlprbuf = NULL;\n\tint tmphlprbufsz, hlprblknow, helperlen;\n\tu8 *helperbuf;\n\tu32 tx_len;\n\n\tret = request_firmware(&fw_helper, card->helper,\n\t\t\t\t\t\t&card->func->dev);\n\tif ((ret < 0) || !fw_helper) {\n\t\tBT_ERR("request_firmware(helper) failed, error code = %d",\n\t\t\t\t\t\t\t\t\tret);\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\thelper = fw_helper->data;\n\thelperlen = fw_helper->size;\n\n\tBT_DBG("Downloading helper image (%d bytes), block size %d bytes",\n\t\t\t\t\t\thelperlen, SDIO_BLOCK_SIZE);\n\n\ttmphlprbufsz = ALIGN_SZ(BTM_UPLD_SIZE, BTSDIO_DMA_ALIGN);\n\n\ttmphlprbuf = kzalloc(tmphlprbufsz, GFP_KERNEL);\n\tif (!tmphlprbuf) {\n\t\tBT_ERR("Unable to allocate buffer for helper."\n\t\t\t" Terminating download");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\thelperbuf = (u8 *) ALIGN_ADDR(tmphlprbuf, BTSDIO_DMA_ALIGN);\n\n\t/* Perform helper data transfer */\n\ttx_len = (FIRMWARE_TRANSFER_NBLOCK * SDIO_BLOCK_SIZE)\n\t\t\t- SDIO_HEADER_LEN;\n\thlprblknow = 0;\n\n\tdo {\n\t\tret = btmrvl_sdio_poll_card_status(card,\n\t\t\t\t\t    CARD_IO_READY | DN_LD_CARD_RDY);\n\t\tif (ret < 0) {\n	f
27680	403	efi_runtime_set_waketime	drivers/firmware/efi/test/efi_test.c	&efi_time	1	13	\N	\N	\tstruct efi_setwakeuptime __user *setwakeuptime_user;\n\tstruct efi_setwakeuptime setwakeuptime;\n\tefi_bool_t enabled;\n\tefi_status_t status;\n\tefi_time_t efi_time;\n\n\tsetwakeuptime_user = (struct efi_setwakeuptime __user *)arg;\n\n\tif (copy_from_user(&setwakeuptime, setwakeuptime_user,\n\t\t\t\tsizeof(setwakeuptime)))\n\t\treturn -EFAULT;\n\n\tenabled = setwakeuptime.enabled;\n\tif (setwakeuptime.time) {\n\t\tif (copy_from_user(&efi_time, setwakeuptime.time,\n\t\t\t\t\tsizeof(efi_time_t)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = efi.set_wakeup_time(enabled, &efi_time);\n	f
3722	1974	dvd_read_struct	drivers/cdrom/cdrom.c	s	1	13	\N	\N	\tswitch (s->type) {\n\tcase DVD_STRUCT_PHYSICAL:\n\t\treturn dvd_read_physical(cdi, s, cgc);\n\n\tcase DVD_STRUCT_COPYRIGHT:\n\t\treturn dvd_read_copyright(cdi, s, cgc);\n	f
10077	2457	pn532_sam_configuration	drivers/nfc/pn533/pn533.c	skb	1	13	\N	\N	\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tskb = pn533_alloc_skb(dev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x01);\n	f
22779	426	xlog_find_cycle_start	fs/xfs/xfs_log_recover.c	offset	1	13	\N	\N	\tchar\t\t*offset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n	f
38483	1070	tick_nohz_idle_exit	kernel/time/tick-sched.c	now	1	13	\N	\N	\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\n\tts->inidle = 0;\n\n\tif (ts->idle_active || ts->tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (ts->idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (ts->tick_stopped) {\n\t\ttick_nohz_restart_sched_tick(ts, now);\n	f
40667	3413	handle_reply	net/ceph/osd_client.c	&m	1	13	\N	\N	\tstruct ceph_osd_client *osdc = osd->o_osdc;\n\tstruct ceph_osd_request *req;\n\tstruct MOSDOpReply m;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tu32 data_len = 0;\n\tint ret;\n\tint i;\n\n\tdout("%s msg %p tid %llu\\n", __func__, msg, tid);\n\n\tdown_read(&osdc->lock);\n\tif (!osd_registered(osd)) {\n\t\tdout("%s osd%d unknown\\n", __func__, osd->o_osd);\n\t\tgoto out_unlock_osdc;\n\t}\n\tWARN_ON(osd->o_osd != le64_to_cpu(msg->hdr.src.num));\n\n\tmutex_lock(&osd->lock);\n\treq = lookup_request(&osd->o_requests, tid);\n\tif (!req) {\n\t\tdout("%s osd%d tid %llu unknown\\n", __func__, osd->o_osd, tid);\n\t\tgoto out_unlock_session;\n\t}\n\n\tm.redirect.oloc.pool_ns = req->r_t.target_oloc.pool_ns;\n\tret = decode_MOSDOpReply(msg, &m);\n	f
55763	116	dio_get_pages_alloc	fs/ceph/file.c	&tmp_it	1	13	\N	\N	\tstruct iov_iter tmp_it = *it;\n\tsize_t align;\n\tstruct page **pages;\n\tint ret = 0, idx, npages;\n\n\talign = (unsigned long)(it->iov->iov_base + it->iov_offset) &\n\t\t(PAGE_SIZE - 1);\n\tnpages = calc_pages_for(align, nbytes);\n\tpages = kvmalloc(sizeof(*pages) * npages, GFP_KERNEL);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (idx = 0; idx < npages; ) {\n\t\tsize_t start;\n\t\tret = iov_iter_get_pages(&tmp_it, pages + idx, nbytes,\n	f
56826	553	ak8975_setup	drivers/iio/magnetometer/ak8975.c	ret	1	13	\N	\N	\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t/* Write the fused rom access mode. */\n\tret = ak8975_set_mode(data, FUSE_ROM);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, "Error in setting fuse access mode\\n");\n\t\treturn ret;\n\t}\n\n\t/* Get asa data and store in the device data. */\n\tret = i2c_smbus_read_i2c_block_data_or_emulated(\n\t\t\tclient, data->def->ctrl_regs[ASA_BASE],\n\t\t\t3, data->asa);\n\tif (ret < 0) {\n	f
-1073	447	atlas_read_raw	drivers/iio/chemical/atlas-ph-sensor.c	ret	2	3	\N	\N	\tstruct atlas_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\t\t__be32 reg;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = regmap_bulk_read(data->regmap, chan->address,\n\t\t\t\t\t      (u8 *) &reg, sizeof(reg));\n\t\t\tbreak;\n\t\tcase IIO_PH:\n\t\tcase IIO_CONCENTRATION:\n\t\tcase IIO_ELECTRICALCONDUCTIVITY:\n\t\tcase IIO_VOLTAGE:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = atlas_read_measurement(data, chan->address, &reg);\n\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (!ret) {\n	f
35749	401	nilfs_cpfile_delete_checkpoints	fs/nilfs2/cpfile.c	nilfs_cpfile_delete_checkpoints_$header_bh$obj	0	13	\N	\N	\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tnilfs_msg(cpfile->i_sb, KERN_ERR,\n\t\t\t  "cannot delete checkpoints: invalid range [%llu, %llu)",\n\t\t\t  (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnilfs_msg(cpfile->i_sb, KERN_ERR,\n\t\t\t\t\t\t  "error %d deleting checkpoint block",\n\t\t\t\t\t\t  ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n	f
27909	863	ib_nl_send_msg	drivers/infiniband/core/sa_query.c	nlh	1	13	\N	\N	\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tvoid *data;\n\tint ret = 0;\n\tstruct ib_sa_mad *mad;\n\tint len;\n\n\tmad = query->mad_buf->mad;\n\tlen = ib_nl_get_path_rec_attrs_len(mad->sa_hdr.comp_mask);\n\tif (len <= 0)\n\t\treturn -EMSGSIZE;\n\n\tskb = nlmsg_new(len, gfp_mask);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* Put nlmsg header only for now */\n\tdata = ibnl_put_msg(skb, &nlh, query->seq, 0, RDMA_NL_LS,\n\t\t\t    RDMA_NL_LS_OP_RESOLVE, NLM_F_REQUEST);\n\tif (!data) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* Add attributes */\n\tib_nl_set_path_rec_attrs(skb, query);\n\n\t/* Repair the nlmsg header length */\n\tnlmsg_end(skb, nlh);\n	f
32907	104	tomoyo_write_self	security/tomoyo/securityfs_if.c	tomoyo_write_self_$v.addr.i29$obj$0	0	13	\N	\N	\tconst char *domain = tomoyo_domain()->domainname->name;\n	f
1157	312	probe_setup_port	drivers/tty/serial/8250/8250_fintek.c	max	1	13	\N	\N	\tstatic const u16 addr[] = {0x4e, 0x2e};\n\tstatic const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};\n\tstruct irq_data *irq_data;\n\tbool level_mode = false;\n\tint i, j, k, min, max;\n\n\tfor (i = 0; i < ARRAY_SIZE(addr); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(keys); j++) {\n\t\t\tpdata->base_port = addr[i];\n\t\t\tpdata->key = keys[j];\n\n\t\t\tif (fintek_8250_enter_key(addr[i], keys[j]))\n\t\t\t\tcontinue;\n\t\t\tif (fintek_8250_check_id(pdata) ||\n\t\t\t    fintek_8250_get_ldn_range(pdata, &min, &max)) {\n\t\t\t\tfintek_8250_exit_key(addr[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (k = min; k < max; k++) {\n	f
27003	795	toshiba_accelerometer_get	drivers/platform/x86/toshiba_acpi.c	out	1	13	\N	\N	\tu32 in[TCI_WORDS] = { HCI_GET, HCI_ACCELEROMETER, 0, 1, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\t/* Check the Accelerometer status */\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err("ACPI call to query the accelerometer failed\\n");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n	f
33821	1250	unix_stream_connect	net/unix/af_unix.c	hash	1	13	\N	\N	\tstruct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk), *newu, *otheru;\n\tstruct sock *newsk = NULL;\n\tstruct sock *other = NULL;\n\tstruct sk_buff *skb = NULL;\n\tunsigned int hash;\n\tint st;\n\tint err;\n\tlong timeo;\n\n\terr = unix_mkname(sunaddr, addr_len, &hash);\n\tif (err < 0)\n\t\tgoto out;\n\taddr_len = err;\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr &&\n\t    (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t/* First of all allocate resources.\n\t   If we will make it after state is locked,\n\t   we will have to recheck all again in any case.\n\t */\n\n\terr = -ENOMEM;\n\n\t/* create new sock for complete connection */\n\tnewsk = unix_create1(sock_net(sk), NULL, 0);\n\tif (newsk == NULL)\n\t\tgoto out;\n\n\t/* Allocate skb for sending to listening sock */\n\tskb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\nrestart:\n\t/*  Find listening sock. */\n\tother = unix_find_other(net, sunaddr, addr_len, sk->sk_type, hash, &err);\n	f
39488	568	rt2800_wait_wpdma_ready	drivers/net/wireless/ralink/rt2x00/rt2800lib.c	reg	1	13	\N	\N	\tunsigned int i;\n\tu32 reg;\n\n\t/*\n\t * Some devices are really slow to respond here. Wait a whole second\n\t * before timing out.\n\t */\n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\treg = rt2800_register_read(rt2x00dev, WPDMA_GLO_CFG);\n\t\tif (!rt2x00_get_field32(reg, WPDMA_GLO_CFG_TX_DMA_BUSY) &&\n\t\t    !rt2x00_get_field32(reg, WPDMA_GLO_CFG_RX_DMA_BUSY))\n\t\t\treturn 0;\n\n\t\tmsleep(10);\n\t}\n\n\trt2x00_err(rt2x00dev, "WPDMA TX/RX busy [0x%08x]\\n", reg);\n	f
52037	114	pcxhr_sub_init	sound/pci/pcxhr/pcxhr_hwdep.c	rmh.stat	1	13	\N	\N	\tint err;\n\tstruct pcxhr_rmh rmh;\n\n\t/* get options */\n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\n\trmh.cmd[0] |= IO_NUM_REG_STATUS;\n\trmh.cmd[1]  = REG_STATUS_OPTIONS;\n\trmh.cmd_len = 2;\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\n\tif ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) ==\n	f
-1071	113	lp8727_read_bytes	drivers/power/supply/lp8727_charger.c	ret	2	3	\N	\N	\ts32 ret;\n\n\tmutex_lock(&pchg->xfer_lock);\n\tret = i2c_smbus_read_i2c_block_data(pchg->client, reg, len, data);\n\tmutex_unlock(&pchg->xfer_lock);\n\n\treturn (ret != len) ? -EIO : 0;\n	f
58202	325	drbd_adm_invalidate	drivers/block/drbd/drbd_nl.c	drbd_adm_invalidate_$addr.addr.i$obj	0	13	\N	\N	\tchar *afs;\n\n\t/* FIXME: A future version will not allow this case. */\n\tif (connection->my_addr_len == 0 || connection->peer_addr_len == 0)\n\t\treturn;\n\n\tswitch (((struct sockaddr *)&connection->peer_addr)->sa_family) {\n\tcase AF_INET6:\n\t\tafs = "ipv6";\n\t\tsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI6",\n\t\t\t &((struct sockaddr_in6 *)&connection->peer_addr)->sin6_addr);\n\t\tbreak;\n\tcase AF_INET:\n	f
30855	1427	__ppp_xmit_process	drivers/net/ppp/ppp_generic.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\n\tppp_xmit_lock(ppp);\n\tif (!ppp->closing) {\n\t\tppp_push(ppp);\n\t\twhile (!ppp->xmit_pending &&\n\t\t       (skb = skb_dequeue(&ppp->file.xq)))\n\t\t\tppp_send_frame(ppp, skb);\n	f
21912	195	kone_get_profile	drivers/hid/hid-roccat-kone.c	len	1	13	\N	\N	\tint len;\n\n\tif (number < 1 || number > 5)\n\t\treturn -EINVAL;\n\n\tlen = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\tkone_command_profile, number, buf,\n\t\t\tsizeof(struct kone_profile), USB_CTRL_SET_TIMEOUT);\n\n\tif (len != sizeof(struct kone_profile))\n	f
23476	250	blk_ioctl_zeroout	block/ioctl.c	start	1	13	\N	\N	\tuint64_t range[2];\n\tstruct address_space *mapping;\n\tuint64_t start, end, len;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (copy_from_user(range, (void __user *)arg, sizeof(range)))\n\t\treturn -EFAULT;\n\n\tstart = range[0];\n\tlen = range[1];\n\tend = start + len - 1;\n\n\tif (start & 511)\n\t\treturn -EINVAL;\n\tif (len & 511)\n\t\treturn -EINVAL;\n\tif (end >= (uint64_t)i_size_read(bdev->bd_inode))\n\t\treturn -EINVAL;\n\tif (end < start)\n	f
24073	2641	iscsi_session_event	drivers/scsi/scsi_transport_iscsi.c	skb	1	13	\N	\N	\tstruct iscsi_internal *priv;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_uevent *ev;\n\tstruct sk_buff  *skb;\n\tstruct nlmsghdr *nlh;\n\tint rc, len = nlmsg_total_size(sizeof(*ev));\n\n\tpriv = iscsi_if_transport_lookup(session->transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\tshost = iscsi_session_to_shost(session);\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t "Cannot notify userspace of session "\n\t\t\t\t\t "event %u\\n", event);\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n	f
49047	504	show_turbo_cooldown	drivers/platform/x86/msi-laptop.c	rdata	1	13	\N	\N	\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, "%i\\n", (!!(rdata & MSI_STANDARD_EC_TURBO_MASK)) |\n\t\t(!!(rdata & MSI_STANDARD_EC_TURBO_COOLDOWN_MASK) << 1));\n	f
56070	972	cs42l42_process_hs_type_detect	sound/soc/codecs/cs42l42.c	cs42l42->hs_type	1	13	\N	\N	\tunsigned int hs_det_status;\n\tunsigned int int_status;\n\n\t/* Mask the auto detect interrupt */\n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_CODEC_INT_MASK,\n\t\tCS42L42_PDN_DONE_MASK |\n\t\tCS42L42_HSDET_AUTO_DONE_MASK,\n\t\t(1 << CS42L42_PDN_DONE_SHIFT) |\n\t\t(1 << CS42L42_HSDET_AUTO_DONE_SHIFT));\n\n\t/* Set hs detect to automatic, disabled mode */\n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_HSDET_CTL2,\n\t\tCS42L42_HSDET_CTRL_MASK |\n\t\tCS42L42_HSDET_SET_MASK |\n\t\tCS42L42_HSBIAS_REF_MASK |\n\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t(2 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t(2 << CS42L42_HSDET_SET_SHIFT) |\n\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t/* Read and save the hs detection result */\n\tregmap_read(cs42l42->regmap, CS42L42_HS_DET_STATUS, &hs_det_status);\n\n\tcs42l42->hs_type = (hs_det_status & CS42L42_HSDET_TYPE_MASK) >>\n\t\t\t\tCS42L42_HSDET_TYPE_SHIFT;\n\n\t/* Set up button detection */\n\tif ((cs42l42->hs_type == CS42L42_PLUG_CTIA) ||\n	f
63498	142	pvrdma_create_cq	drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c	ucmd.buf_addr	1	13	\N	\N	\tint entries = attr->cqe;\n\tstruct pvrdma_dev *dev = to_vdev(ibdev);\n\tstruct pvrdma_cq *cq;\n\tint ret;\n\tint npages;\n\tunsigned long flags;\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_create_cq *cmd = &req.create_cq;\n\tstruct pvrdma_cmd_create_cq_resp *resp = &rsp.create_cq_resp;\n\tstruct pvrdma_create_cq ucmd;\n\n\tBUILD_BUG_ON(sizeof(struct pvrdma_cqe) != 64);\n\n\tentries = roundup_pow_of_two(entries);\n\tif (entries < 1 || entries > dev->dsr->caps.max_cqe)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!atomic_add_unless(&dev->num_cqs, 1, dev->dsr->caps.max_cq))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcq = kzalloc(sizeof(*cq), GFP_KERNEL);\n\tif (!cq) {\n\t\tatomic_dec(&dev->num_cqs);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcq->ibcq.cqe = entries;\n\n\tif (context) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_cq;\n\t\t}\n\n\t\tcq->umem = ib_umem_get(context, ucmd.buf_addr, ucmd.buf_size,\n	f
-1069	130	pn533_i2c_read	drivers/nfc/pn533/i2c.c	skb	2	3	\N	\N	\tstruct i2c_client *client = phy->i2c_dev;\n\tint len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t  PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t  PN533_STD_FRAME_TAIL_LEN + 1;\n\tint r;\n\n\t*skb = alloc_skb(len, GFP_KERNEL);\n\tif (*skb == NULL)\n\t\treturn -ENOMEM;\n\n\tr = i2c_master_recv(client, skb_put(*skb, len), len);\n\tif (r != len) {\n\t\tnfc_err(&client->dev, "cannot read. r=%d len=%d\\n", r, len);\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (!((*skb)->data[0] & 0x01)) {\n	f
-2000	200	i40iw_puda_ce_handler	drivers/infiniband/hw/i40iw/i40iw_hw.c	compl_error	1	3	\N	\N	\tstruct i40iw_sc_dev *dev = (struct i40iw_sc_dev *)&iwdev->sc_dev;\n\tenum i40iw_status_code status;\n\tu32 compl_error;\n\n\tdo {\n\t\tstatus = i40iw_puda_poll_completion(dev, cq, &compl_error);\n\t\tif (status == I40IW_ERR_QUEUE_EMPTY)\n\t\t\tbreak;\n\t\tif (status) {\n\t\t\ti40iw_pr_err("puda  status = %d\\n", status);\n\t\t\tbreak;\n\t\t}\n\t\tif (compl_error) {\n	f
-1068	822	cdv_intel_dp_i2c_aux_ch	drivers/gpu/drm/gma500/cdv_intel_dp.c	reply	2	3	\N	\N	\tstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\n\tstruct cdv_intel_dp *intel_dp = container_of(adapter,\n\t\t\t\t\t\tstruct cdv_intel_dp,\n\t\t\t\t\t\tadapter);\n\tstruct gma_encoder *encoder = intel_dp->encoder;\n\tuint16_t address = algo_data->address;\n\tuint8_t msg[5];\n\tuint8_t reply[2];\n\tunsigned retry;\n\tint msg_bytes;\n\tint reply_bytes;\n\tint ret;\n\n\t/* Set up the command byte */\n\tif (mode & MODE_I2C_READ)\n\t\tmsg[0] = DP_AUX_I2C_READ << 4;\n\telse\n\t\tmsg[0] = DP_AUX_I2C_WRITE << 4;\n\n\tif (!(mode & MODE_I2C_STOP))\n\t\tmsg[0] |= DP_AUX_I2C_MOT << 4;\n\n\tmsg[1] = address >> 8;\n\tmsg[2] = address;\n\n\tswitch (mode) {\n\tcase MODE_I2C_WRITE:\n\t\tmsg[3] = 0;\n\t\tmsg[4] = write_byte;\n\t\tmsg_bytes = 5;\n\t\treply_bytes = 1;\n\t\tbreak;\n\tcase MODE_I2C_READ:\n\t\tmsg[3] = 0;\n\t\tmsg_bytes = 4;\n\t\treply_bytes = 2;\n\t\tbreak;\n\tdefault:\n\t\tmsg_bytes = 3;\n\t\treply_bytes = 1;\n\t\tbreak;\n\t}\n\n\tfor (retry = 0; retry < 5; retry++) {\n\t\tret = cdv_intel_dp_aux_ch(encoder,\n\t\t\t\t      msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEBUG_KMS("aux_ch failed %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK) {\n\t\tcase DP_AUX_NATIVE_REPLY_ACK:\n\t\t\t/* I2C-over-AUX Reply field is only valid\n\t\t\t * when paired with AUX ACK.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase DP_AUX_NATIVE_REPLY_NACK:\n\t\t\tDRM_DEBUG_KMS("aux_ch native nack\\n");\n\t\t\treturn -EREMOTEIO;\n\t\tcase DP_AUX_NATIVE_REPLY_DEFER:\n\t\t\tudelay(100);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tDRM_ERROR("aux_ch invalid native reply 0x%02x\\n",\n\t\t\t\t  reply[0]);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tswitch ((reply[0] >> 4) & DP_AUX_I2C_REPLY_MASK) {\n	f
27971	1057	s2255_set_mode	drivers/media/usb/s2255/s2255drv.c	res	1	13	\N	\N	\tint res;\n\tunsigned long chn_rev;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\tint i;\n\t__le32 *buffer = dev->cmdbuf;\n\n\tmutex_lock(&dev->cmdlock);\n\tchn_rev = G_chnmap[vc->idx];\n\tdprintk(dev, 3, "%s channel: %d\\n", __func__, vc->idx);\n\t/* if JPEG, set the quality */\n\tif ((mode->color & MASK_COLOR) == COLOR_JPG) {\n\t\tmode->color &= ~MASK_COLOR;\n\t\tmode->color |= COLOR_JPG;\n\t\tmode->color &= ~MASK_JPG_QUALITY;\n\t\tmode->color |= (vc->jpegqual << 8);\n\t}\n\t/* save the mode */\n\tvc->mode = *mode;\n\tvc->req_image_size = get_transfer_size(mode);\n\tdprintk(dev, 1, "%s: reqsize %ld\\n", __func__, vc->req_image_size);\n\t/* set the mode */\n\tbuffer[0] = IN_DATA_TOKEN;\n\tbuffer[1] = (__le32) cpu_to_le32(chn_rev);\n\tbuffer[2] = CMD_SET_MODE;\n\tfor (i = 0; i < sizeof(struct s2255_mode) / sizeof(u32); i++)\n\t\tbuffer[3 + i] = cpu_to_le32(((u32 *)&vc->mode)[i]);\n\tvc->setmode_ready = 0;\n\tres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\n\tif (debug)\n\t\ts2255_print_cfg(dev, mode);\n\t/* wait at least 3 frames before continuing */\n\tif (mode->restart) {\n\t\twait_event_timeout(vc->wait_setmode,\n\t\t\t\t   (vc->setmode_ready != 0),\n\t\t\t\t   msecs_to_jiffies(S2255_SETMODE_TIMEOUT));\n\t\tif (vc->setmode_ready != 1) {\n\t\t\tdprintk(dev, 0, "s2255: no set mode response\\n");\n\t\t\tres = -EFAULT;\n\t\t}\n\t}\n\t/* clear the restart flag */\n\tvc->mode.restart = 0;\n\tdprintk(dev, 1, "%s chn %d, result: %d\\n", __func__, vc->idx, res);\n	f
30388	414	pcc_cpufreq_probe	drivers/cpufreq/pcc-cpufreq.c	status	1	13	\N	\N	\tacpi_status status;\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct pcc_memory_resource *mem_resource;\n\tstruct pcc_register_resource *reg_resource;\n\tunion acpi_object *out_obj, *member;\n\tacpi_handle handle, osc_handle;\n\tint ret = 0;\n\n\tstatus = acpi_get_handle(NULL, "\\\\_SB", &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tif (!acpi_has_method(handle, "PCCH"))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_handle(handle, "_OSC", &osc_handle);\n\tif (ACPI_SUCCESS(status)) {\n\t\tret = pcc_cpufreq_do_osc(&osc_handle);\n\t\tif (ret)\n\t\t\tpr_debug("probe: _OSC evaluation did not succeed\\n");\n\t\t/* Firmware's use of _OSC is optional */\n\t\tret = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, "PCCH", NULL, &output);\n\tif (ACPI_FAILURE(status))\n	f
34518	2485	send_chmod	fs/btrfs/send.c	p	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, "send_chmod %llu mode=%llu", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n	f
6584	3722	test_g2	net/bluetooth/smp.c	val	1	13	\N	\N	\tconst u8 u[32] = {\n\t\t\t0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,\n\t\t\t0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,\n\t\t\t0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,\n\t\t\t0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20 };\n\tconst u8 v[32] = {\n\t\t\t0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b,\n\t\t\t0xfb, 0x7c, 0x9d, 0xf1, 0xc2, 0x9a, 0xcb, 0x59,\n\t\t\t0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc, 0x0a, 0x90,\n\t\t\t0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55 };\n\tconst u8 x[16] = {\n\t\t\t0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,\n\t\t\t0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };\n\tconst u8 y[16] = {\n\t\t\t0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,\n\t\t\t0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };\n\tconst u32 exp_val = 0x2f9ed5ba % 1000000;\n\tu32 val;\n\tint err;\n\n\terr = smp_g2(tfm_cmac, u, v, x, y, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val != exp_val)\n	f
22804	62	xlog_cil_ticket_alloc	fs/xfs/xfs_log_cil.c	tic->t_curr_res	1	13	\N	\N	\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n	f
40687	795	get_info	net/ipv4/netfilter/arp_tables.c	name	1	13	\N	\N	\tchar name[XT_TABLE_MAXNAMELEN];\n\tstruct xt_table *t;\n\tint ret;\n\n\tif (*len != sizeof(struct arpt_getinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(name, user, sizeof(name)) != 0)\n\t\treturn -EFAULT;\n\n\tname[XT_TABLE_MAXNAMELEN-1] = '\\0';\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\txt_compat_lock(NFPROTO_ARP);\n#endif\n\tt = try_then_request_module(xt_find_table_lock(net, NFPROTO_ARP, name),\n	f
36840	720	rx_urb_complete	drivers/net/wireless/zydas/zd1211rw/zd_usb.c	urb	1	13	\N	\N	\tint r;\n\tstruct zd_usb *usb;\n\tstruct zd_usb_rx *rx;\n\tconst u8 *buffer;\n\tunsigned int length;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg_f(urb_dev(urb), "urb %p error %d\\n", urb, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg_f(urb_dev(urb), "urb %p error %d\\n", urb, urb->status);\n\t\tgoto resubmit;\n\t}\n\n\tbuffer = urb->transfer_buffer;\n\tlength = urb->actual_length;\n\tusb = urb->context;\n\trx = &usb->rx;\n\n\ttasklet_schedule(&rx->reset_timer_tasklet);\n\n\tif (length%rx->usb_packet_size > rx->usb_packet_size-4) {\n\t\t/* If there is an old first fragment, we don't care. */\n\t\tdev_dbg_f(urb_dev(urb), "*** first fragment ***\\n");\n\t\tZD_ASSERT(length <= ARRAY_SIZE(rx->fragment));\n\t\tspin_lock(&rx->lock);\n\t\tmemcpy(rx->fragment, buffer, length);\n\t\trx->fragment_length = length;\n\t\tspin_unlock(&rx->lock);\n\t\tgoto resubmit;\n\t}\n\n\tspin_lock(&rx->lock);\n\tif (rx->fragment_length > 0) {\n\t\t/* We are on a second fragment, we believe */\n\t\tZD_ASSERT(length + rx->fragment_length <=\n\t\t\t  ARRAY_SIZE(rx->fragment));\n\t\tdev_dbg_f(urb_dev(urb), "*** second fragment ***\\n");\n\t\tmemcpy(rx->fragment+rx->fragment_length, buffer, length);\n\t\thandle_rx_packet(usb, rx->fragment,\n\t\t\t         rx->fragment_length + length);\n\t\trx->fragment_length = 0;\n\t\tspin_unlock(&rx->lock);\n\t} else {\n\t\tspin_unlock(&rx->lock);\n\t\thandle_rx_packet(usb, buffer, length);\n\t}\n\nresubmit:\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n	f
31345	752	tcp_accept_from_sock	fs/dlm/lowcomms.c	tcp_accept_from_sock_$newsock$obj$6$obj$7	0	13	\N	\N	\tint result;\n\tstruct sockaddr_storage peeraddr;\n\tstruct socket *newsock;\n\tint len;\n\tint nodeid;\n\tstruct connection *newcon;\n\tstruct connection *addcon;\n\n\tmutex_lock(&connections_lock);\n\tif (!dlm_allow_conn) {\n\t\tmutex_unlock(&connections_lock);\n\t\treturn -1;\n\t}\n\tmutex_unlock(&connections_lock);\n\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tresult = sock_create_lite(dlm_local_addr[0]->ss_family,\n\t\t\t\t  SOCK_STREAM, IPPROTO_TCP, &newsock);\n\tif (result < 0)\n\t\treturn -ENOMEM;\n\n\tmutex_lock_nested(&con->sock_mutex, 0);\n\n\tresult = -ENOTCONN;\n\tif (con->sock == NULL)\n\t\tgoto accept_err;\n\n\tnewsock->type = con->sock->type;\n\tnewsock->ops = con->sock->ops;\n\n\tresult = con->sock->ops->accept(con->sock, newsock, O_NONBLOCK, true);\n\tif (result < 0)\n\t\tgoto accept_err;\n\n\t/* Get the connected socket's peer */\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tif (newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr,\n	f
21480	217	cxgbit_push_tx_frames	drivers/target/iscsi/cxgbit/cxgbit_target.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\n\twhile (csk->wr_cred && ((skb = skb_peek(&csk->txq)) != NULL)) {\n\t\tu32 dlen = skb->len;\n\t\tu32 len = skb->len;\n\t\tu32 credits_needed;\n\t\tu32 compl = 0;\n\t\tu32 flowclen16 = 0;\n\t\tu32 iso_cpl_len = 0;\n\n\t\tif (cxgbit_skcb_flags(skb) & SKCBF_TX_ISO)\n	f
24886	836	cfs_ip_addr_parse	drivers/staging/lustre/lnet/lnet/nidstrings.c	&el->el_link	1	13	\N	\N	\tstruct cfs_expr_list *el;\n\tstruct cfs_lstr src;\n\tint rc;\n\tint i;\n\n\tsrc.ls_str = str;\n\tsrc.ls_len = len;\n\ti = 0;\n\n\twhile (src.ls_str) {\n\t\tstruct cfs_lstr res;\n\n\t\tif (!cfs_gettok(&src, '.', &res)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = cfs_expr_list_parse(res.ls_str, res.ls_len, 0, 255, &el);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tlist_add_tail(&el->el_link, list);\n	f
49126	649	C_SYSC_newfstatat	fs/stat.c	&stat	1	13	\N	\N	\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_compat_stat(&stat, statbuf);\n	f
57848	8927	qla4xxx_destroy_ddb	drivers/scsi/qla4xxx/ql4_os.c	ddb_state	1	13	\N	\N	\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint options;\n\tint status;\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, "%s: Logout failed\\n", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   "%s: Unable to allocate dma buffer\\n", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tstatus = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t\t fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t\t NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t\t NULL, NULL);\n\t\tif (status == QLA_ERROR)\n\t\t\tgoto free_ddb;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n	f
-1066	662	g762_of_prop_import_one	drivers/hwmon/g762.c	pval	2	3	\N	\N	\tint ret;\n\tu32 pval;\n\n\tif (of_property_read_u32(client->dev.of_node, pname, &pval))\n\t\treturn 0;\n\n\tdev_dbg(&client->dev, "found %s (%d)\\n", pname, pval);\n	f
30173	494	mt2060_probe	drivers/media/tuners/mt2060.c	chip_id	1	13	\N	\N	\tstruct mt2060_platform_data *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe;\n\tstruct mt2060_priv *dev;\n\tint ret;\n\tu8 chip_id;\n\n\tdev_dbg(&client->dev, "\\n");\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, "Cannot proceed without platform data\\n");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfe = pdata->dvb_frontend;\n\tdev->config.i2c_address = client->addr;\n\tdev->config.clock_out = pdata->clock_out;\n\tdev->cfg = &dev->config;\n\tdev->i2c = client->adapter;\n\tdev->if1_freq = pdata->if1 ? pdata->if1 : 1220;\n\tdev->client = client;\n\tdev->i2c_max_regs = pdata->i2c_write_max ? pdata->i2c_write_max - 1 : ~0;\n\tdev->sleep = true;\n\n\tret = mt2060_readreg(dev, REG_PART_REV, &chip_id);\n\tif (ret) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&client->dev, "chip id=%02x\\n", chip_id);\n	f
34058	492	ath10k_htt_h2t_ver_req_msg	drivers/net/wireless/ath/ath10k/htt_tx.c	skb	1	13	\N	\N	\tstruct ath10k *ar = htt->ar;\n\tstruct sk_buff *skb;\n\tstruct htt_cmd *cmd;\n\tint len = 0;\n\tint ret;\n\n\tlen += sizeof(cmd->hdr);\n\tlen += sizeof(cmd->ver_req);\n\n\tskb = ath10k_htc_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n	f
34452	5504	btrfs_compare_trees	fs/btrfs/ctree.c	ret	1	13	\N	\N	\tstruct btrfs_fs_info *fs_info = left_root->fs_info;\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kvmalloc(fs_info->nodesize, GFP_KERNEL);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] = left_root->commit_root;\n\textent_buffer_get(left_path->nodes[left_level]);\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] = right_root->commit_root;\n\textent_buffer_get(right_path->nodes[right_level]);\n\tup_read(&fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(fs_info, left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key);\n\t\t\tif (ret == -1)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(fs_info, right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key);\n\t\t\tif (ret == -1)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n	f
36600	1121	ath_chanctx_send_vif_ps_frame	drivers/net/wireless/ath/ath9k/channel.c	nullfunc->frame_control	1	13	\N	\N	\tstruct ieee80211_vif *vif = avp->vif;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ath_tx_control txctl;\n\tstruct sk_buff *skb;\n\tint band = sc->cur_chan->chandef.chan->band;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!avp->assoc)\n\t\t\treturn false;\n\n\t\tskb = ieee80211_nullfunc_get(sc->hw, vif);\n\t\tif (!skb)\n\t\t\treturn false;\n\n\t\tnullfunc = (struct ieee80211_hdr_3addr *) skb->data;\n\t\tif (powersave)\n\t\t\tnullfunc->frame_control |=\n	f
36733	273	hinic_port_link_state	drivers/net/ethernet/huawei/hinic/hinic_port.c	link_cmd	1	13	\N	\N	\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_port_link_cmd link_cmd;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size;\n\tint err;\n\n\tif (!HINIC_IS_PF(hwif) && !HINIC_IS_PPF(hwif)) {\n\t\tdev_err(&pdev->dev, "unsupported PCI Function type\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tlink_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_LINK_STATE,\n\t\t\t\t &link_cmd, sizeof(link_cmd),\n\t\t\t\t &link_cmd, &out_size);\n\tif (err || (out_size != sizeof(link_cmd)) || link_cmd.status) {\n	f
41159	733	nfc_alloc_send_skb	net/nfc/core.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tunsigned int total_size;\n\n\ttotal_size = size +\n\t\tdev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = sock_alloc_send_skb(sk, total_size, flags & MSG_DONTWAIT, err);\n\tif (skb)\n\t\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n	f
49837	438	pucan_handle_cache_critical	drivers/net/can/peak_canfd/peak_canfd.c	cf->data	1	13	\N	\N	\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\tskb = alloc_can_err_skb(priv->ndev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n	f
32037	120	ls_ucode_img_load_gr	drivers/gpu/drm/nouveau/nvkm/subdev/secboot/ls_ucode_gr.c	ls_ucode_img_load_gr_$sig$obj	0	13	\N	\N	\tconst struct firmware *bl, *code, *data, *sig;\n\tchar f[64];\n\tint ret;\n\n\tsnprintf(f, sizeof(f), "gr/%s_bl", falcon_name);\n\tret = nvkm_firmware_get(subdev->device, f, &bl);\n\tif (ret)\n\t\tgoto error;\n\n\tsnprintf(f, sizeof(f), "gr/%s_inst", falcon_name);\n\tret = nvkm_firmware_get(subdev->device, f, &code);\n\tif (ret)\n\t\tgoto free_bl;\n\n\tsnprintf(f, sizeof(f), "gr/%s_data", falcon_name);\n\tret = nvkm_firmware_get(subdev->device, f, &data);\n\tif (ret)\n\t\tgoto free_inst;\n\n\tsnprintf(f, sizeof(f), "gr/%s_sig", falcon_name);\n\tret = nvkm_firmware_get(subdev->device, f, &sig);\n\tif (ret)\n\t\tgoto free_data;\n\n\timg->sig = kmemdup(sig->data, sig->size, GFP_KERNEL);\n	f
44054	216	gssx_dec_linux_creds	net/sunrpc/auth_gss/gss_rpc_xdr.c	gssx_dec_linux_creds_3$add$$N$obj$mul$4	0	13	\N	\N	\tu32 length;\n\t__be32 *p;\n\tu32 tmp;\n\tu32 N;\n\tint i, err;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\n\tlength = be32_to_cpup(p);\n\n\tif (length > (3 + NGROUPS_MAX) * sizeof(u32))\n\t\treturn -ENOSPC;\n\n\t/* uid */\n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tcreds->cr_uid = make_kuid(&init_user_ns, tmp);\n\n\t/* gid */\n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tcreds->cr_gid = make_kgid(&init_user_ns, tmp);\n\n\t/* number of additional gid's */\n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tN = tmp;\n\tif ((3 + N) * sizeof(u32) != length)\n	f
38586	506	pem_probe	drivers/hwmon/lineage-pem.c	data->input_length	1	13	\N	\N	\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct pem_data *data;\n\tint ret, idx = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BLOCK_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WRITE_BYTE))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t/*\n\t * We use the next two commands to determine if the device is really\n\t * there.\n\t */\n\tret = pem_read_block(client, PEM_READ_FIRMWARE_REV,\n\t\t\t     data->firmware_rev, sizeof(data->firmware_rev));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte(client, PEM_CLEAR_INFO_FLAGS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, "Firmware revision %d.%d.%d\\n",\n\t\t data->firmware_rev[0], data->firmware_rev[1],\n\t\t data->firmware_rev[2]);\n\n\t/* sysfs hooks */\n\tdata->groups[idx++] = &pem_group;\n\n\t/*\n\t * Check if input readings are supported.\n\t * This is the case if we can read input data,\n\t * and if the returned data is not all zeros.\n\t * Note that input alarms are always supported.\n\t */\n\tret = pem_read_block(client, PEM_READ_INPUT_STRING,\n\t\t\t     data->input_string,\n\t\t\t     sizeof(data->input_string) - 1);\n\tif (!ret && (data->input_string[0] || data->input_string[1] ||\n\t\t     data->input_string[2]))\n\t\tdata->input_length = sizeof(data->input_string) - 1;\n\telse if (ret < 0) {\n\t\t/* Input string is one byte longer for some devices */\n\t\tret = pem_read_block(client, PEM_READ_INPUT_STRING,\n\t\t\t\t    data->input_string,\n\t\t\t\t    sizeof(data->input_string));\n\t\tif (!ret && (data->input_string[0] || data->input_string[1] ||\n\t\t\t    data->input_string[2] || data->input_string[3]))\n\t\t\tdata->input_length = sizeof(data->input_string);\n\t}\n\n\tif (data->input_length)\n	f
38782	969	xfs_dir2_leaf_to_block	fs/xfs/libxfs/xfs_dir2_block.c	hdr->magic	1	13	\N	\N	\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n	f
50166	752	f2fs_rename	fs/f2fs/namei.c	f2fs_rename_	1	13	\N	\N	\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *whiteout = NULL;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page = NULL;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tbool is_old_inline = f2fs_has_inline_dentry(old_dir);\n\tint err = -ENOENT;\n\n\tif ((f2fs_encrypted_inode(old_dir) &&\n\t\t\t!fscrypt_has_encryption_key(old_dir)) ||\n\t\t\t(f2fs_encrypted_inode(new_dir) &&\n\t\t\t!fscrypt_has_encryption_key(new_dir)))\n\t\treturn -ENOKEY;\n\n\tif ((old_dir != new_dir) && f2fs_encrypted_inode(new_dir) &&\n\t\t\t!fscrypt_has_permitted_context(new_dir, old_inode)) {\n	f
53286	120	stmp3xxx_wdt_register	drivers/rtc/rtc-stmp3xxx.c	rc	1	13	\N	\N	\tint rc = -1;\n\tstruct platform_device *wdt_pdev =\n\t\tplatform_device_alloc("stmp3xxx_rtc_wdt", rtc_pdev->id);\n\n\tif (wdt_pdev) {\n\t\twdt_pdev->dev.parent = &rtc_pdev->dev;\n\t\twdt_pdev->dev.platform_data = &wdt_pdata;\n\t\trc = platform_device_add(wdt_pdev);\n\t}\n\n\tif (rc)\n	f
27662	2144	snd_es1968_ac97_reset	sound/pci/es1968.c	vend	1	13	\N	\N	\tunsigned long ioaddr = chip->io_port;\n\n\tunsigned short save_ringbus_a;\n\tunsigned short save_68;\n\tunsigned short w;\n\tunsigned int vend;\n\n\t/* save configuration */\n\tsave_ringbus_a = inw(ioaddr + 0x36);\n\n\t//outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38); /* clear second codec id? */\n\t/* set command/status address i/o to 1st codec */\n\toutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\n\toutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\n\n\t/* disable ac link */\n\toutw(0x0000, ioaddr + 0x36);\n\tsave_68 = inw(ioaddr + 0x68);\n\tpci_read_config_word(chip->pci, 0x58, &w);\t/* something magical with gpio and bus arb. */\n\tpci_read_config_dword(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\n\tif (w & 1)\n\t\tsave_68 |= 0x10;\n\toutw(0xfffe, ioaddr + 0x64);\t/* unmask gpio 0 */\n\toutw(0x0001, ioaddr + 0x68);\t/* gpio write */\n\toutw(0x0000, ioaddr + 0x60);\t/* write 0 to gpio 0 */\n\tudelay(20);\n\toutw(0x0001, ioaddr + 0x60);\t/* write 1 to gpio 1 */\n\tmsleep(20);\n\n\toutw(save_68 | 0x1, ioaddr + 0x68);\t/* now restore .. */\n\toutw((inw(ioaddr + 0x38) & 0xfffc) | 0x1, ioaddr + 0x38);\n\toutw((inw(ioaddr + 0x3a) & 0xfffc) | 0x1, ioaddr + 0x3a);\n\toutw((inw(ioaddr + 0x3c) & 0xfffc) | 0x1, ioaddr + 0x3c);\n\n\t/* now the second codec */\n\t/* disable ac link */\n\toutw(0x0000, ioaddr + 0x36);\n\toutw(0xfff7, ioaddr + 0x64);\t/* unmask gpio 3 */\n\tsave_68 = inw(ioaddr + 0x68);\n\toutw(0x0009, ioaddr + 0x68);\t/* gpio write 0 & 3 ?? */\n\toutw(0x0001, ioaddr + 0x60);\t/* write 1 to gpio */\n\tudelay(20);\n\toutw(0x0009, ioaddr + 0x60);\t/* write 9 to gpio */\n\tmsleep(500);\n\t//outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);\n\toutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\n\toutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\n\n#if 0\t\t\t\t/* the loop here needs to be much better if we want it.. */\n\tdev_info(chip->card->dev, "trying software reset\\n");\n\t/* try and do a software reset */\n\toutb(0x80 | 0x7c, ioaddr + 0x30);\n\tfor (w = 0;; w++) {\n\t\tif ((inw(ioaddr + 0x30) & 1) == 0) {\n\t\t\tif (inb(ioaddr + 0x32) != 0)\n\t\t\t\tbreak;\n\n\t\t\toutb(0x80 | 0x7d, ioaddr + 0x30);\n\t\t\tif (((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t    && (inb(ioaddr + 0x32) != 0))\n\t\t\t\tbreak;\n\t\t\toutb(0x80 | 0x7f, ioaddr + 0x30);\n\t\t\tif (((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t    && (inb(ioaddr + 0x32) != 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (w > 10000) {\n\t\t\toutb(inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);\t/* do a software reset */\n\t\t\tmsleep(500);\t/* oh my.. */\n\t\t\toutb(inb(ioaddr + 0x37) & ~0x08,\n\t\t\t\tioaddr + 0x37);\n\t\t\tudelay(1);\n\t\t\toutw(0x80, ioaddr + 0x30);\n\t\t\tfor (w = 0; w < 10000; w++) {\n\t\t\t\tif ((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (vend == NEC_VERSA_SUBID1 || vend == NEC_VERSA_SUBID2) {\n	f
2995	590	wm8958_put_vss_hpf_enum	sound/soc/codecs/wm8958-dsp2.c	reg	1	13	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint value = ucontrol->value.enumerated.item[0];\n\tint reg;\n\n\t/* Don't allow on the fly reconfiguration */\n\treg = snd_soc_read(codec, WM8994_CLOCKING_1);\n\tif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\n	f
20337	2542	shmem_seek_hole_data	mm/shmem.c	indices	1	13	\N	\N	\tstruct page *page;\n\tstruct pagevec pvec;\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tbool done = false;\n\tint i;\n\n\tpagevec_init(&pvec, 0);\n\tpvec.nr = 1;\t\t/* start small: we may be there already */\n\twhile (!done) {\n\t\tpvec.nr = find_get_entries(mapping, index,\n\t\t\t\t\tpvec.nr, pvec.pages, indices);\n\t\tif (!pvec.nr) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tindex = end;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < pvec.nr; i++, index++) {\n\t\t\tif (index < indices[i]) {\n	f
22977	4644	xfs_btree_simple_query_range	fs/xfs/libxfs/xfs_btree.c	recp	1	13	\N	\N	\tunion xfs_btree_rec\t\t*recp;\n\tunion xfs_btree_key\t\trec_key;\n\tint64_t\t\t\t\tdiff;\n\tint\t\t\t\tstat;\n\tbool\t\t\t\tfirstrec = true;\n\tint\t\t\t\terror;\n\n\tASSERT(cur->bc_ops->init_high_key_from_rec);\n\tASSERT(cur->bc_ops->diff_two_keys);\n\n\t/*\n\t * Find the leftmost record.  The btree cursor must be set\n\t * to the low record used to generate low_key.\n\t */\n\tstat = 0;\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_LE, &stat);\n\tif (error)\n\t\tgoto out;\n\n\t/* Nothing?  See if there's anything to the right. */\n\tif (!stat) {\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\twhile (stat) {\n\t\t/* Find the record. */\n\t\terror = xfs_btree_get_rec(cur, &recp, &stat);\n\t\tif (error || !stat)\n\t\t\tbreak;\n\n\t\t/* Skip if high_key(rec) < low_key. */\n\t\tif (firstrec) {\n\t\t\tcur->bc_ops->init_high_key_from_rec(&rec_key, recp);\n\t\t\tfirstrec = false;\n\t\t\tdiff = cur->bc_ops->diff_two_keys(cur, low_key,\n\t\t\t\t\t&rec_key);\n\t\t\tif (diff > 0)\n\t\t\t\tgoto advloop;\n\t\t}\n\n\t\t/* Stop if high_key < low_key(rec). */\n\t\tcur->bc_ops->init_key_from_rec(&rec_key, recp);\n\t\tdiff = cur->bc_ops->diff_two_keys(cur, &rec_key, high_key);\n\t\tif (diff > 0)\n\t\t\tbreak;\n\n\t\t/* Callback */\n\t\terror = fn(cur, recp, priv);\n	f
25690	1400	nvme_wait_ready	drivers/nvme/host/core.c	csts	1	13	\N	\N	\tunsigned long timeout =\n\t\t((NVME_CAP_TIMEOUT(cap) + 1) * HZ / 2) + jiffies;\n\tu32 csts, bit = enabled ? NVME_CSTS_RDY : 0;\n\tint ret;\n\n\twhile ((ret = ctrl->ops->reg_read32(ctrl, NVME_REG_CSTS, &csts)) == 0) {\n\t\tif (csts == ~0)\n	f
31855	192	lspcon_resume	drivers/gpu/drm/i915/intel_lspcon.c	lspcon_resume_	1	13	\N	\N	\tenum drm_lspcon_mode expected_mode;\n\n\tif (lspcon_wake_native_aux_ch(lspcon)) {\n\t\texpected_mode = DRM_LSPCON_MODE_PCON;\n\t\tlspcon_resume_in_pcon_wa(lspcon);\n\t} else {\n\t\texpected_mode = DRM_LSPCON_MODE_LS;\n\t}\n\n\tif (lspcon_wait_mode(lspcon, expected_mode) == DRM_LSPCON_MODE_PCON)\n	f
37227	437	ni6501_cnt_insn_read	drivers/staging/comedi/drivers/ni_usb6501.c	ret	1	13	\N	\N	\tint ret;\n\tu32 val;\n\tunsigned int i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tret = ni6501_counter_command(dev, READ_COUNTER,\t&val);\n\t\tif (ret)\n	f
37605	283	uwb_rc_dev_addr_assign	drivers/uwb/address.c	new_addr.data	1	13	\N	\N	\tstruct uwb_dev_addr new_addr;\n\n\tdo {\n\t\tget_random_bytes(new_addr.data, sizeof(new_addr.data));\n\t} while (new_addr.data[0] == 0x00 || new_addr.data[0] == 0xff\n	f
38267	3714	r100_ib_test	drivers/gpu/drm/radeon/r100.c	&ib	1	13	\N	\N	\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR("radeon: failed to get scratch reg (%d).\\n", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, RADEON_RING_TYPE_GFX_INDEX, &ib, NULL, 256);\n	f
47585	2331	cooling_method_show	drivers/platform/x86/toshiba_acpi.c	state	1	13	\N	\N	\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = toshiba_cooling_method_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, "%d %d\\n", state, toshiba->max_cooling_method);\n	f
50019	1203	xfs_unmap_extent	fs/xfs/xfs_bmap_util.c	error	1	13	\N	\N	\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirstfsb;\n\tuint\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, 0, &tp);\n\tif (error) {\n\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot, ip->i_gdquot,\n\t\t\tip->i_pdquot, resblks, 0, XFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\txfs_defer_init(&dfops, &firstfsb);\n\terror = xfs_bunmapi(tp, ip, startoffset_fsb, len_fsb, 0, 2, &firstfsb,\n\t\t\t&dfops, done);\n\tif (error)\n	f
60547	533	pctv452e_power_ctrl	drivers/media/usb/dvb-usb/pctv452e.c	ret	1	13	\N	\N	\tstruct pctv452e_state *state = (struct pctv452e_state *)d->priv;\n\tu8 *b0, *rx;\n\tint ret;\n\n\tinfo("%s: %d\\n", __func__, i);\n\n\tif (!i)\n\t\treturn 0;\n\n\tif (state->initialized)\n\t\treturn 0;\n\n\tb0 = kmalloc(5 + PCTV_ANSWER_LEN, GFP_KERNEL);\n\tif (!b0)\n\t\treturn -ENOMEM;\n\n\trx = b0 + 5;\n\n\t/* hmm where shoud this should go? */\n\tret = usb_set_interface(d->udev, 0, ISOC_INTERFACE_ALTERNATIVE);\n\tif (ret != 0)\n	f
27483	1102	ocrdma_create_cq	drivers/infiniband/hw/ocrdma/ocrdma_verbs.c	ureq.dpp_cq	1	13	\N	\N	\tint entries = attr->cqe;\n\tstruct ocrdma_cq *cq;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(ibdev);\n\tstruct ocrdma_ucontext *uctx = NULL;\n\tu16 pd_id = 0;\n\tint status;\n\tstruct ocrdma_create_cq_ureq ureq;\n\n\tif (attr->flags)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (udata) {\n\t\tif (ib_copy_from_udata(&ureq, udata, sizeof(ureq)))\n\t\t\treturn ERR_PTR(-EFAULT);\n\t} else\n\t\tureq.dpp_cq = 0;\n\tcq = kzalloc(sizeof(*cq), GFP_KERNEL);\n\tif (!cq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&cq->cq_lock);\n\tspin_lock_init(&cq->comp_handler_lock);\n\tINIT_LIST_HEAD(&cq->sq_head);\n\tINIT_LIST_HEAD(&cq->rq_head);\n\n\tif (ib_ctx) {\n\t\tuctx = get_ocrdma_ucontext(ib_ctx);\n\t\tpd_id = uctx->cntxt_pd->id;\n\t}\n\n\tstatus = ocrdma_mbx_create_cq(dev, cq, entries, ureq.dpp_cq, pd_id);\n	f
7122	1010	crtc_set_mode	drivers/gpu/drm/drm_atomic_helper.c	encoder->name	1	13	\N	\N	\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tif (!new_crtc_state->mode_changed)\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (new_crtc_state->enable && funcs->mode_set_nofb) {\n\t\t\tDRM_DEBUG_ATOMIC("modeset on [CRTC:%d:%s]\\n",\n\t\t\t\t\t crtc->base.id, crtc->name);\n\n\t\t\tfuncs->mode_set_nofb(crtc);\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(old_state, connector, new_conn_state, i) {\n\t\tconst struct drm_encoder_helper_funcs *funcs;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_display_mode *mode, *adjusted_mode;\n\n\t\tif (!new_conn_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tencoder = new_conn_state->best_encoder;\n\t\tfuncs = encoder->helper_private;\n\t\tnew_crtc_state = new_conn_state->crtc->state;\n\t\tmode = &new_crtc_state->mode;\n\t\tadjusted_mode = &new_crtc_state->adjusted_mode;\n\n\t\tif (!new_crtc_state->mode_changed)\n\t\t\tcontinue;\n\n\t\tDRM_DEBUG_ATOMIC("modeset on [ENCODER:%d:%s]\\n",\n	f
7497	1117	intel_opregion_get_panel_type	drivers/gpu/drm/i915/intel_opregion.c	ret	1	13	\N	\N	\tu32 panel_details;\n\tint ret;\n\n\tret = swsci(dev_priv, SWSCI_GBDA_PANEL_DETAILS, 0x0, &panel_details);\n\tif (ret) {\n\t\tDRM_DEBUG_KMS("Failed to get panel details from OpRegion (%d)\\n",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tret = (panel_details >> 8) & 0xff;\n\tif (ret > 0x10) {\n\t\tDRM_DEBUG_KMS("Invalid OpRegion panel type 0x%x\\n", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t/* fall back to VBT panel type? */\n\tif (ret == 0x0) {\n\t\tDRM_DEBUG_KMS("No panel type in OpRegion\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * So far we know that some machined must use it, others must not use it.\n\t * There doesn't seem to be any way to determine which way to go, except\n\t * via a quirk list :(\n\t */\n\tif (!dmi_check_system(intel_use_opregion_panel_type)) {\n\t\tDRM_DEBUG_KMS("Ignoring OpRegion panel type (%d)\\n", ret - 1);\n	f
23445	564	blk_trace_setup	kernel/trace/blktrace.c	&buts	1	13	\N	\N	\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n	f
27131	304	fpga_mgr_firmware_load	drivers/fpga/fpga-mgr.c	fw->size	1	13	\N	\N	\tstruct device *dev = &mgr->dev;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tdev_info(dev, "writing %s to %s\\n", image_name, mgr->name);\n\n\tmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ;\n\n\tret = request_firmware(&fw, image_name, dev);\n\tif (ret) {\n\t\tmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ_ERR;\n\t\tdev_err(dev, "Error requesting firmware %s\\n", image_name);\n\t\treturn ret;\n\t}\n\n\tret = fpga_mgr_buf_load(mgr, info, fw->data, fw->size);\n	f
29065	242	si470x_set_report	drivers/media/radio/si470x/radio-si470x-usb.c	retval	1	13	\N	\N	\tunsigned char *report = buf;\n\tint retval;\n\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_sndctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_SET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\treport[0], 2,\n\t\tbuf, size, usb_timeout);\n\n\tif (retval < 0)\n	f
47052	204	xfs_refcount_update_finish_item	fs/xfs/xfs_trans_refcount.c	error	1	13	\N	\N	\tstruct xfs_refcount_intent\t*refc;\n\txfs_fsblock_t\t\t\tnew_fsb;\n\txfs_extlen_t\t\t\tnew_aglen;\n\tint\t\t\t\terror;\n\n\trefc = container_of(item, struct xfs_refcount_intent, ri_list);\n\terror = xfs_trans_log_finish_refcount_update(tp, done_item, dop,\n\t\t\trefc->ri_type,\n\t\t\trefc->ri_startblock,\n\t\t\trefc->ri_blockcount,\n\t\t\t&new_fsb, &new_aglen,\n\t\t\t(struct xfs_btree_cur **)state);\n\t/* Did we run out of reservation?  Requeue what we didn't finish. */\n\tif (!error && new_aglen > 0) {\n	f
52166	1049	__uea_load_page_e4	drivers/usb/atm/ueagle-atm.c	__uea_load_page_e4_	1	13	\N	\N	\tstruct block_info_e4 bi;\n\tstruct block_index *blockidx;\n\tstruct l1_code *p = (struct l1_code *) sc->dsp_firm->data;\n\tu8 blockno = p->page_number_to_block_index[pageno];\n\n\tbi.wHdr = cpu_to_be16(UEA_BIHDR);\n\tbi.bBootPage = boot;\n\tbi.bPageNumber = pageno;\n\tbi.wReserved = cpu_to_be16(UEA_RESERVED);\n\n\tdo {\n\t\tconst u8 *blockoffset;\n\t\tunsigned int blocksize;\n\n\t\tblockidx = &p->page_header[blockno];\n\t\tblocksize = E4_PAGE_BYTES(blockidx->PageSize);\n\t\tblockoffset = sc->dsp_firm->data + le32_to_cpu(\n\t\t\t\t\t\t\tblockidx->PageOffset);\n\n\t\tbi.dwSize = cpu_to_be32(blocksize);\n\t\tbi.dwAddress = cpu_to_be32(le32_to_cpu(blockidx->PageAddress));\n\n\t\tuea_dbg(INS_TO_USBDEV(sc),\n\t\t\t"sending block %u for DSP page "\n\t\t\t"%u size %u address %x\\n",\n\t\t\tblockno, pageno, blocksize,\n\t\t\tle32_to_cpu(blockidx->PageAddress));\n\n\t\t/* send block info through the IDMA pipe */\n\t\tif (uea_idma_write(sc, &bi, E4_BLOCK_INFO_SIZE))\n	f
58139	1146	proc_set_rx_ampdu	drivers/staging/rtl8723bs/core/rtw_debug.c	&mode	1	13	\N	\N	\tstruct net_device *dev = data;\n\tstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\n\tstruct registry_priv *pregpriv = &padapter->registrypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tchar tmp[32];\n\tu32 mode;\n\n\tif (count < 1)\n\t\treturn -EFAULT;\n\n\tif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\n\n\t\tsscanf(tmp, "%d ", &mode);\n	f
9776	288	queue_store_nonrot	block/blk-sysfs.c	queue_store_nonrot_$val$obj	0	13	\N	\N	\tint max_hw_sectors_kb = queue_max_hw_sectors(q) >> 1;\n\n\treturn queue_var_show(max_hw_sectors_kb, (page));\n}\n\n#define QUEUE_SYSFS_BIT_FNS(name, flag, neg)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nqueue_show_##name(struct request_queue *q, char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint bit;\t\t\t\t\t\t\t\\\n\tbit = test_bit(QUEUE_FLAG_##flag, &q->queue_flags);\t\t\\\n\treturn queue_var_show(neg ? !bit : bit, page);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nqueue_store_##name(struct request_queue *q, const char *page, size_t count) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tssize_t ret;\t\t\t\t\t\t\t\\\n\tret = queue_var_store(&val, page, count);\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\t return ret;\t\t\t\t\t\t\\\n\tif (neg)\t\t\t\t\t\t\t\\\n\t\tval = !val;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_irq(q->queue_lock);\t\t\t\t\t\\\n\tif (val)\t\t\t\t\t\t\t\\\n\t\tqueue_flag_set(QUEUE_FLAG_##flag, q);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tqueue_flag_clear(QUEUE_FLAG_##flag, q);\t\t\t\\\n\tspin_unlock_irq(q->queue_lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\nQUEUE_SYSFS_BIT_FNS(nonrot, NONROT, 1);\n	f
31551	342	rio_setup_device	drivers/rapidio/rio-scan.c	result	1	13	\N	\N	\tint ret = 0;\n\tstruct rio_dev *rdev;\n\tstruct rio_switch *rswitch = NULL;\n\tint result, rdid;\n\tsize_t size;\n\tu32 swpinfo = 0;\n\n\tsize = sizeof(struct rio_dev);\n\tif (rio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t     RIO_PEF_CAR, &result))\n\t\treturn NULL;\n\n\tif (result & (RIO_PEF_SWITCH | RIO_PEF_MULTIPORT)) {\n	f
1466	288	gb_manifest_parse_cports	drivers/staging/greybus/manifest.c	gb_manifest_parse_cports_$__mptr84$obj	0	13	\N	\N	\tstruct gb_interface *intf = bundle->intf;\n\tstruct greybus_descriptor_cport *desc_cport;\n\tstruct manifest_desc *desc, *next, *tmp;\n\tLIST_HEAD(list);\n\tu8 bundle_id = bundle->id;\n\tu16 cport_id;\n\tu32 count = 0;\n\tint i;\n\n\t/* Set up all cport descriptors associated with this bundle */\n\tlist_for_each_entry_safe(desc, next, &intf->manifest_descs, links) {\n\t\tif (desc->type != GREYBUS_TYPE_CPORT)\n\t\t\tcontinue;\n\n\t\tdesc_cport = desc->data;\n\t\tif (desc_cport->bundle != bundle_id)\n\t\t\tcontinue;\n\n\t\tcport_id = le16_to_cpu(desc_cport->id);\n\t\tif (cport_id > CPORT_ID_MAX)\n\t\t\tgoto exit;\n\n\t\t/* Nothing else should have its cport_id as control cport id */\n\t\tif (cport_id == GB_CONTROL_CPORT_ID) {\n\t\t\tdev_err(&bundle->dev, "invalid cport id found (%02u)\\n",\n\t\t\t\tcport_id);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/*\n\t\t * Found one, move it to our temporary list after checking for\n\t\t * duplicates.\n\t\t */\n\t\tlist_for_each_entry(tmp, &list, links) {\n\t\t\tdesc_cport = tmp->data;\n\t\t\tif (cport_id == le16_to_cpu(desc_cport->id)) {\n\t\t\t\tdev_err(&bundle->dev,\n\t\t\t\t\t\t"duplicate CPort %u found\\n",\n\t\t\t\t\t\tcport_id);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tlist_move_tail(&desc->links, &list);\n\t\tcount++;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tbundle->cport_desc = kcalloc(count, sizeof(*bundle->cport_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!bundle->cport_desc)\n\t\tgoto exit;\n\n\tbundle->num_cports = count;\n\n\ti = 0;\n\tlist_for_each_entry_safe(desc, next, &list, links) {\n	f
4004	2221	initio_msgin_extend	drivers/scsi/initio.c	host	1	13	\N	\N	\tu8 len, idx;\n\n\tif (initio_msgin_accept(host) != MSG_IN)\n\t\treturn host->phase;\n\n\t/* Get extended msg length      */\n\toutl(1, host->addr + TUL_SCnt0);\n\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\tif (wait_tulip(host) == -1)\n\t\treturn -1;\n\n\tlen = inb(host->addr + TUL_SFifo);\n\thost->msg[0] = len;\n\tfor (idx = 1; len != 0; len--) {\n\n\t\tif ((initio_msgin_accept(host)) != MSG_IN)\n\t\t\treturn host->phase;\n\t\toutl(1, host->addr + TUL_SCnt0);\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t\thost->msg[idx++] = inb(host->addr + TUL_SFifo);\n\t}\n\tif (host->msg[1] == 1) {\t\t/* if it's synchronous data transfer request */\n\t\tu8 r;\n\t\tif (host->msg[0] != 3)\t/* if length is not right */\n\t\t\treturn initio_msgout_reject(host);\n\t\tif (host->active_tc->flags & TCF_NO_SYNC_NEGO) {\t/* Set OFFSET=0 to do async, nego back */\n\t\t\thost->msg[3] = 0;\n\t\t} else {\n\t\t\tif (initio_msgin_sync(host) == 0 &&\n\t\t\t    (host->active_tc->flags & TCF_SYNC_DONE)) {\n\t\t\t\tinitio_sync_done(host);\n\t\t\t\treturn initio_msgin_accept(host);\n\t\t\t}\n\t\t}\n\n\t\tr = inb(host->addr + TUL_SSignal);\n\t\toutb((r & (TSC_SET_ACK | 7)) | TSC_SET_ATN,\n\t\t\thost->addr + TUL_SSignal);\n\t\tif (initio_msgin_accept(host) != MSG_OUT)\n\t\t\treturn host->phase;\n\t\t/* sync msg out */\n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\n\t\tinitio_sync_done(host);\n\n\t\toutb(MSG_EXTEND, host->addr + TUL_SFifo);\n\t\toutb(3, host->addr + TUL_SFifo);\n\t\toutb(1, host->addr + TUL_SFifo);\n\t\toutb(host->msg[2], host->addr + TUL_SFifo);\n\t\toutb(host->msg[3], host->addr + TUL_SFifo);\n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\treturn wait_tulip(host);\n\t}\n\tif (host->msg[0] != 2 || host->msg[1] != 3)\n\t\treturn initio_msgout_reject(host);\n\t/* if it's WIDE DATA XFER REQ   */\n\tif (host->active_tc->flags & TCF_NO_WDTR) {\n\t\thost->msg[2] = 0;\n\t} else {\n\t\tif (host->msg[2] > 2)\t/* > 32 bits            */\n\t\t\treturn initio_msgout_reject(host);\n\t\tif (host->msg[2] == 2) {\t\t/* == 32                */\n\t\t\thost->msg[2] = 1;\n\t\t} else {\n\t\t\tif ((host->active_tc->flags & TCF_NO_WDTR) == 0) {\n\t\t\t\twdtr_done(host);\n\t\t\t\tif ((host->active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)\n\t\t\t\t\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\t\t\t\treturn initio_msgin_accept(host);\n\t\t\t}\n\t\t}\n\t}\n\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\n\tif (initio_msgin_accept(host) != MSG_OUT)\n\t\treturn host->phase;\n\t/* WDTR msg out                 */\n\toutb(MSG_EXTEND, host->addr + TUL_SFifo);\n\toutb(2, host->addr + TUL_SFifo);\n\toutb(3, host->addr + TUL_SFifo);\n\toutb(host->msg[2], host->addr + TUL_SFifo);\n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\treturn wait_tulip(host);\n	f
6890	52	ir_sharp_decode	drivers/media/rc/ir-sharp-decoder.c	ev.reset	1	13	\N	\N	\tstruct sharp_dec *data = &dev->raw->sharp;\n\tu32 msg, echo, address, command, scancode;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.reset)\n	f
9079	278	get_key_purpletv	drivers/media/pci/saa7134/saa7134-input.c	b	1	13	\N	\N	\tunsigned char b;\n\n\t/* poll IR chip */\n\tif (1 != i2c_master_recv(ir->c, &b, 1)) {\n\t\tir_dbg(ir, "read error\\n");\n\t\treturn -EIO;\n\t}\n\n\t/* no button press */\n\tif (b==0)\n\t\treturn 0;\n\n\t/* repeating */\n\tif (b & 0x80)\n	f
21324	215	bcm63xx_parse_cfe_nor_partitions	drivers/mtd/bcm63xxpart.c	rootfslen	1	13	\N	\N	\t/* CFE, NVRAM and global Linux are always present */\n\tint nrparts = 3, curpart = 0;\n\tstruct bcm_tag *buf = NULL;\n\tstruct mtd_partition *parts;\n\tint ret;\n\tunsigned int rootfsaddr, kerneladdr, spareaddr;\n\tunsigned int rootfslen, kernellen, sparelen, totallen;\n\tunsigned int cfelen, nvramlen;\n\tunsigned int cfe_erasesize;\n\tint i;\n\tbool rootfs_first = false;\n\n\tcfe_erasesize = max_t(uint32_t, master->erasesize,\n\t\t\t      BCM963XX_CFE_BLOCK_SIZE);\n\n\tcfelen = cfe_erasesize;\n\tnvramlen = nvram->psi_size * SZ_1K;\n\tnvramlen = roundup(nvramlen, cfe_erasesize);\n\n\tbuf = vmalloc(sizeof(struct bcm_tag));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Get the tag */\n\tret = bcm63xx_read_image_tag(master, "rootfs", cfelen, buf);\n\tif (!ret) {\n\t\tSTR_NULL_TERMINATE(buf->flash_image_start);\n\t\tif (kstrtouint(buf->flash_image_start, 10, &rootfsaddr) ||\n\t\t\t\trootfsaddr < BCM963XX_EXTENDED_SIZE) {\n\t\t\tpr_err("invalid rootfs address: %*ph\\n",\n\t\t\t\t(int)sizeof(buf->flash_image_start),\n\t\t\t\tbuf->flash_image_start);\n\t\t\tgoto invalid_tag;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->kernel_address);\n\t\tif (kstrtouint(buf->kernel_address, 10, &kerneladdr) ||\n\t\t\t\tkerneladdr < BCM963XX_EXTENDED_SIZE) {\n\t\t\tpr_err("invalid kernel address: %*ph\\n",\n\t\t\t\t(int)sizeof(buf->kernel_address),\n\t\t\t\tbuf->kernel_address);\n\t\t\tgoto invalid_tag;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->kernel_length);\n\t\tif (kstrtouint(buf->kernel_length, 10, &kernellen)) {\n\t\t\tpr_err("invalid kernel length: %*ph\\n",\n\t\t\t\t(int)sizeof(buf->kernel_length),\n\t\t\t\tbuf->kernel_length);\n\t\t\tgoto invalid_tag;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->total_length);\n\t\tif (kstrtouint(buf->total_length, 10, &totallen)) {\n\t\t\tpr_err("invalid total length: %*ph\\n",\n\t\t\t\t(int)sizeof(buf->total_length),\n\t\t\t\tbuf->total_length);\n\t\t\tgoto invalid_tag;\n\t\t}\n\n\t\tkerneladdr = kerneladdr - BCM963XX_EXTENDED_SIZE;\n\t\trootfsaddr = rootfsaddr - BCM963XX_EXTENDED_SIZE;\n\t\tspareaddr = roundup(totallen, master->erasesize) + cfelen;\n\n\t\tif (rootfsaddr < kerneladdr) {\n\t\t\t/* default Broadcom layout */\n\t\t\trootfslen = kerneladdr - rootfsaddr;\n\t\t\trootfs_first = true;\n\t\t} else {\n\t\t\t/* OpenWrt layout */\n\t\t\trootfsaddr = kerneladdr + kernellen;\n\t\t\trootfslen = spareaddr - rootfsaddr;\n\t\t}\n\t} else if (ret > 0) {\ninvalid_tag:\n\t\tkernellen = 0;\n\t\trootfslen = 0;\n\t\trootfsaddr = 0;\n\t\tspareaddr = cfelen;\n\t} else {\n\t\tgoto out;\n\t}\n\tsparelen = master->size - spareaddr - nvramlen;\n\n\t/* Determine number of partitions */\n\tif (rootfslen > 0)\n	f
41910	25	nft_do_chain_ipv6	net/ipv6/netfilter/nf_tables_ipv6.c	&pkt	1	13	\N	\N	\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo_ipv6(&pkt, skb, state);\n	f
46781	458	depop_seq_power_stage	sound/soc/codecs/rt5631.c	hp_zc & 0xf7ff	1	13	\N	\N	\tunsigned int soft_vol, hp_zc;\n\n\t/* depop control by register */\n\tsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\n\t\tRT5631_EN_ONE_BIT_DEPOP, RT5631_EN_ONE_BIT_DEPOP);\n\n\t/* keep soft volume and zero crossing setting */\n\tsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\n\tsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\n\thp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\n\tsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\n	f
59781	381	show_lcdtype	drivers/platform/x86/panasonic-laptop.c	show_lcdtype_	1	13	\N	\N	\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n	f
31316	305	dm_btree_del	drivers/md/persistent-data/dm-btree.c	dm_btree_del_$f$obj$1$obj$0$1	0	13	\N	\N	\tint r;\n\tstruct del_stack *s;\n\n\t/*\n\t * dm_btree_del() is called via an ioctl, as such should be\n\t * considered an FS op.  We can't recurse back into the FS, so we\n\t * allocate GFP_NOFS.\n\t */\n\ts = kmalloc(sizeof(*s), GFP_NOFS);\n\tif (!s)\n\t\treturn -ENOMEM;\n\ts->info = info;\n\ts->tm = info->tm;\n\ts->top = -1;\n\n\tr = push_frame(s, root, 0);\n\tif (r)\n\t\tgoto out;\n\n\twhile (unprocessed_frames(s)) {\n\t\tuint32_t flags;\n\t\tstruct frame *f;\n\t\tdm_block_t b;\n\n\t\tr = top_frame(s, &f);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tif (f->current_child >= f->nr_children) {\n\t\t\tpop_frame(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tflags = le32_to_cpu(f->n->header.flags);\n	f
29913	2380	usbvision_stop_isoc	drivers/media/usb/usbvision/usbvision-core.c	err_code	1	13	\N	\N	\tint buf_idx, err_code, reg_value;\n\tint sb_size = USBVISION_URB_FRAMES * usbvision->isoc_packet_size;\n\n\tif ((usbvision->streaming == stream_off) || (usbvision->dev == NULL))\n\t\treturn;\n\n\t/* Unschedule all of the iso td's */\n\tfor (buf_idx = 0; buf_idx < USBVISION_NUMSBUF; buf_idx++) {\n\t\tusb_kill_urb(usbvision->sbuf[buf_idx].urb);\n\t\tif (usbvision->sbuf[buf_idx].data) {\n\t\t\tusb_free_coherent(usbvision->dev,\n\t\t\t\t\t  sb_size,\n\t\t\t\t\t  usbvision->sbuf[buf_idx].data,\n\t\t\t\t\t  usbvision->sbuf[buf_idx].urb->transfer_dma);\n\t\t}\n\t\tusb_free_urb(usbvision->sbuf[buf_idx].urb);\n\t\tusbvision->sbuf[buf_idx].urb = NULL;\n\t}\n\n\tPDEBUG(DBG_ISOC, "%s: streaming=stream_off\\n", __func__);\n\tusbvision->streaming = stream_off;\n\n\tif (!usbvision->remove_pending) {\n\t\t/* Set packet size to 0 */\n\t\tusbvision->iface_alt = 0;\n\t\terr_code = usb_set_interface(usbvision->dev, usbvision->iface,\n\t\t\t\t\t    usbvision->iface_alt);\n\t\tif (err_code < 0) {\n	f
2820	61	max8925_get_voltage_sel	drivers/regulator/max8925-regulator.c	ret	1	13	\N	\N	\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\tunsigned char data, mask;\n\tint ret;\n\n\tret = max8925_reg_read(info->i2c, info->vol_reg);\n\tif (ret < 0)\n	f
30177	176	twl6030_pwmled_enable	drivers/pwm/pwm-twl-led.c	ret	1	13	\N	\N	\tstruct twl_pwmled_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL6030_MODULE_ID1, &val, TWL6030_LED_PWM_CTRL2);\n\tif (ret < 0) {\n	f
32085	1164	drm_atomic_helper_wait_for_fences	drivers/gpu/drm/drm_atomic_helper.c	plane	1	13	\N	\N	\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tint i, ret;\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n	f
36608	1121	ath_chanctx_send_vif_ps_frame	drivers/net/wireless/ath/ath9k/channel.c	nullfunc->frame_control	1	13	\N	\N	\tstruct ieee80211_vif *vif = avp->vif;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ath_tx_control txctl;\n\tstruct sk_buff *skb;\n\tint band = sc->cur_chan->chandef.chan->band;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!avp->assoc)\n\t\t\treturn false;\n\n\t\tskb = ieee80211_nullfunc_get(sc->hw, vif);\n\t\tif (!skb)\n\t\t\treturn false;\n\n\t\tnullfunc = (struct ieee80211_hdr_3addr *) skb->data;\n\t\tif (powersave)\n\t\t\tnullfunc->frame_control |=\n	f
50457	679	vmci_host_do_ctx_add_notify	drivers/misc/vmw_vmci/vmci_host.c	ar_info.remote_cid	1	13	\N	\N	\tstruct vmci_ctx_info ar_info;\n\tstruct vmci_ctx_info __user *info = uptr;\n\ts32 result;\n\tu32 cid;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err("only valid for contexts\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ar_info, uptr, sizeof(ar_info)))\n\t\treturn -EFAULT;\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tresult = vmci_ctx_add_notification(cid, ar_info.remote_cid);\n	f
55532	1166	qed_eth_tx_queue_start	drivers/net/ethernet/qlogic/qed/qed_l2.c	p_cid	1	13	\N	\N	\tstruct qed_queue_cid *p_cid;\n\tint rc;\n\n\tp_cid = qed_eth_queue_to_cid_pf(p_hwfn, opaque_fid, false, p_params);\n\tif (!p_cid)\n\t\treturn -EINVAL;\n\n\tif (IS_PF(p_hwfn->cdev))\n\t\trc = qed_eth_pf_tx_queue_start(p_hwfn, p_cid, tc,\n\t\t\t\t\t       pbl_addr, pbl_size,\n\t\t\t\t\t       &p_ret_params->p_doorbell);\n\telse\n\t\trc = qed_vf_pf_txq_start(p_hwfn, p_cid,\n\t\t\t\t\t pbl_addr, pbl_size,\n\t\t\t\t\t &p_ret_params->p_doorbell);\n\n\tif (rc)\n\t\tqed_eth_queue_cid_release(p_hwfn, p_cid);\n	f
56713	911	bq2415x_timer_work	drivers/power/supply/bq2415x_charger.c	ret	1	13	\N	\N	\tstruct bq2415x_device *bq = container_of(work, struct bq2415x_device,\n\t\t\t\t\t\t work.work);\n\tint ret;\n\tint error;\n\tint boost;\n\n\tif (bq->automode > 0 && (bq->reported_mode != bq->mode)) {\n\t\tsysfs_notify(&bq->charger->dev.kobj, NULL, "reported_mode");\n\t\tbq2415x_set_mode(bq, bq->reported_mode);\n\t}\n\n\tif (!bq->autotimer)\n\t\treturn;\n\n\tret = bq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\n\tif (ret < 0) {\n	f
-7	303	max8907_regulator_probe	drivers/regulator/max8907-regulator.c	val	20	2	arg_no	\N	\tstruct max8907 *max8907 = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8907_platform_data *pdata = dev_get_platdata(max8907->dev);\n\tint ret;\n\tstruct max8907_regulator *pmic;\n\tunsigned int val;\n\tint i;\n\tstruct regulator_config config = {};\n\tstruct regulator_init_data *idata;\n\tconst char *mbatt_rail_name = NULL;\n\n\tret = max8907_regulator_parse_dt(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pmic);\n\n\tmemcpy(pmic->desc, max8907_regulators, sizeof(pmic->desc));\n\n\t/* Backwards compatibility with MAX8907B; SD1 uses different voltages */\n\tregmap_read(max8907->regmap_gen, MAX8907_REG_II2RR, &val);\n\tif ((val & MAX8907_II2RR_VERSION_MASK) ==\n	f
27975	918	scan_swap_map	mm/swapfile.c	si	1	13	\N	\N	\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n	f
42551	7221	ath10k_wmi_op_gen_addba_set_resp	drivers/net/wireless/ath/ath10k/wmi.c	ath10k_wmi_op_gen_addba_set_resp_$cmd$obj$1$0	0	13	\N	\N	\tstruct wmi_addba_setresponse_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_addba_setresponse_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n	f
24867	593	lnet_str2tbs_expand	drivers/staging/lustre/lnet/lnet/config.c	lo	1	13	\N	\N	\tchar num[16];\n\tstruct list_head pending;\n\tchar *sep;\n\tchar *sep2;\n\tchar *parsed;\n\tchar *enditem;\n\tint lo;\n\tint hi;\n\tint stride;\n\tint i;\n\tint nob;\n\tint scanned;\n\n\tINIT_LIST_HEAD(&pending);\n\n\tsep = strchr(str, '[');\n\tif (!sep)\t\t\t/* nothing to expand */\n\t\treturn 0;\n\n\tsep2 = strchr(sep, ']');\n\tif (!sep2)\n\t\tgoto failed;\n\n\tfor (parsed = sep; parsed < sep2; parsed = enditem) {\n\t\tenditem = ++parsed;\n\t\twhile (enditem < sep2 && *enditem != ',')\n\t\t\tenditem++;\n\n\t\tif (enditem == parsed)\t\t/* no empty items */\n\t\t\tgoto failed;\n\n\t\tif (sscanf(parsed, "%d-%d/%d%n", &lo, &hi,\n\t\t\t   &stride, &scanned) < 3) {\n\t\t\tif (sscanf(parsed, "%d-%d%n", &lo, &hi, &scanned) < 2) {\n\t\t\t\t/* simple string enumeration */\n\t\t\t\tif (lnet_expand1tb(&pending, str, sep, sep2,\n\t\t\t\t\t\t   parsed,\n\t\t\t\t\t\t   (int)(enditem - parsed))) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstride = 1;\n\t\t}\n\n\t\t/* range expansion */\n\n\t\tif (enditem != parsed + scanned) /* no trailing junk */\n\t\t\tgoto failed;\n\n\t\tif (hi < 0 || lo < 0 || stride < 0 || hi < lo ||\n	f
32172	5843	ci_dpm_init_microcode	drivers/gpu/drm/amd/amdgpu/ci_dpm.c	chip_name	1	13	\N	\N	\tconst char *chip_name;\n\tchar fw_name[30];\n\tint err;\n\n\tDRM_DEBUG("\\n");\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\tif ((adev->pdev->revision == 0x80) ||\n\t\t    (adev->pdev->revision == 0x81) ||\n\t\t    (adev->pdev->device == 0x665f))\n\t\t\tchip_name = "bonaire_k";\n\t\telse\n\t\t\tchip_name = "bonaire";\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tif (adev->pdev->revision == 0x80)\n\t\t\tchip_name = "hawaii_k";\n\t\telse\n\t\t\tchip_name = "hawaii";\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tdefault: BUG();\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", chip_name);\n	f
33474	701	tomoyo_write_profile	security/tomoyo/common.c	profile	1	13	\N	\N	\tchar *data = head->write_buf;\n\tunsigned int i;\n\tchar *cp;\n\tstruct tomoyo_profile *profile;\n\tif (sscanf(data, "PROFILE_VERSION=%u", &head->w.ns->profile_version)\n\t    == 1)\n\t\treturn 0;\n\ti = simple_strtoul(data, &cp, 10);\n\tif (*cp != '-')\n\t\treturn -EINVAL;\n\tdata = cp + 1;\n\tprofile = tomoyo_assign_profile(head->w.ns, i);\n\tif (!profile)\n\t\treturn -EINVAL;\n\tcp = strchr(data, '=');\n\tif (!cp)\n\t\treturn -EINVAL;\n\t*cp++ = '\\0';\n\tif (!strcmp(data, "COMMENT")) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tconst struct tomoyo_path_info *new_comment\n\t\t\t= tomoyo_get_name(cp);\n\t\tconst struct tomoyo_path_info *old_comment;\n\t\tif (!new_comment)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock(&lock);\n\t\told_comment = profile->comment;\n\t\tprofile->comment = new_comment;\n\t\tspin_unlock(&lock);\n\t\ttomoyo_put_name(old_comment);\n\t\treturn 0;\n\t}\n\tif (!strcmp(data, "PREFERENCE")) {\n\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\ttomoyo_set_uint(&profile->pref[i], cp,\n\t\t\t\t\ttomoyo_pref_keywords[i]);\n\t\treturn 0;\n\t}\n\treturn tomoyo_set_mode(data, cp, profile);\n	f
40403	186	prism54_update_stats	drivers/net/wireless/intersil/prism54/isl_ioctl.c	bss.address	1	13	\N	\N	\tislpci_private *priv = container_of(work, islpci_private, stats_work);\n\tchar *data;\n\tint j;\n\tstruct obj_bss bss, *bss2;\n\tunion oid_res_t r;\n\n\tmutex_lock(&priv->stats_lock);\n\n/* Noise floor.\n * I'm not sure if the unit is dBm.\n * Note : If we are not connected, this value seems to be irrelevant. */\n\n\tmgt_get_request(priv, DOT11_OID_NOISEFLOOR, 0, NULL, &r);\n\tpriv->local_iwstatistics.qual.noise = r.u;\n\n/* Get the rssi of the link. To do this we need to retrieve a bss. */\n\n\t/* First get the MAC address of the AP we are associated with. */\n\tmgt_get_request(priv, DOT11_OID_BSSID, 0, NULL, &r);\n\tdata = r.ptr;\n\n\t/* copy this MAC to the bss */\n\tmemcpy(bss.address, data, ETH_ALEN);\n	f
45332	1593	SYSC_prlimit64	kernel/sys.c	&old	1	13	\N	\N	\tstruct rlimit64 old64, new64;\n\tstruct rlimit old, new;\n\tstruct task_struct *tsk;\n\tunsigned int checkflags = 0;\n\tint ret;\n\n\tif (old_rlim)\n\t\tcheckflags |= LSM_PRLIMIT_READ;\n\n\tif (new_rlim) {\n\t\tif (copy_from_user(&new64, new_rlim, sizeof(new64)))\n\t\t\treturn -EFAULT;\n\t\trlim64_to_rlim(&new64, &new);\n\t\tcheckflags |= LSM_PRLIMIT_WRITE;\n\t}\n\n\trcu_read_lock();\n\ttsk = pid ? find_task_by_vpid(pid) : current;\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tret = check_prlimit_permission(tsk, checkflags);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tget_task_struct(tsk);\n\trcu_read_unlock();\n\n\tret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,\n\t\t\told_rlim ? &old : NULL);\n\n\tif (!ret && old_rlim) {\n\t\trlim_to_rlim64(&old, &old64);\n	f
51803	693	hiddev_ioctl	drivers/hid/usbhid/hiddev.c	rinfo.report_type	1	13	\N	\N	\tstruct hiddev_list *list = file->private_data;\n\tstruct hiddev *hiddev = list->hiddev;\n\tstruct hid_device *hid;\n\tstruct hiddev_collection_info cinfo;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_field_info finfo;\n\tstruct hiddev_devinfo dinfo;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tvoid __user *user_arg = (void __user *)arg;\n\tint i, r = -EINVAL;\n\n\t/* Called without BKL by compat methods so no BKL taken */\n\n\tmutex_lock(&hiddev->existancelock);\n\tif (!hiddev->exist) {\n\t\tr = -ENODEV;\n\t\tgoto ret_unlock;\n\t}\n\n\thid = hiddev->hid;\n\n\tswitch (cmd) {\n\n\tcase HIDIOCGVERSION:\n\t\tr = put_user(HID_VERSION, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCAPPLICATION:\n\t\tif (arg >= hid->maxapplication)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < hid->maxcollection; i++)\n\t\t\tif (hid->collection[i].type ==\n\t\t\t    HID_COLLECTION_APPLICATION && arg-- == 0)\n\t\t\t\tbreak;\n\n\t\tif (i < hid->maxcollection)\n\t\t\tr = hid->collection[i].usage;\n\t\tbreak;\n\n\tcase HIDIOCGDEVINFO:\n\t\t{\n\t\t\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\t\t\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\t\t\tmemset(&dinfo, 0, sizeof(dinfo));\n\n\t\t\tdinfo.bustype = BUS_USB;\n\t\t\tdinfo.busnum = dev->bus->busnum;\n\t\t\tdinfo.devnum = dev->devnum;\n\t\t\tdinfo.ifnum = usbhid->ifnum;\n\t\t\tdinfo.vendor = le16_to_cpu(dev->descriptor.idVendor);\n\t\t\tdinfo.product = le16_to_cpu(dev->descriptor.idProduct);\n\t\t\tdinfo.version = le16_to_cpu(dev->descriptor.bcdDevice);\n\t\t\tdinfo.num_applications = hid->maxapplication;\n\n\t\t\tr = copy_to_user(user_arg, &dinfo, sizeof(dinfo)) ?\n\t\t\t\t-EFAULT : 0;\n\t\t\tbreak;\n\t\t}\n\n\tcase HIDIOCGFLAG:\n\t\tr = put_user(list->flags, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCSFLAG:\n\t\t{\n\t\t\tint newflags;\n\n\t\t\tif (get_user(newflags, (int __user *)arg)) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((newflags & ~HIDDEV_FLAGS) != 0 ||\n\t\t\t    ((newflags & HIDDEV_FLAG_REPORT) != 0 &&\n\t\t\t     (newflags & HIDDEV_FLAG_UREF) == 0))\n\t\t\t\tbreak;\n\n\t\t\tlist->flags = newflags;\n\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\tcase HIDIOCGSTRING:\n\t\tr = hiddev_ioctl_string(hiddev, cmd, user_arg);\n\t\tbreak;\n\n\tcase HIDIOCINITREPORT:\n\t\tusbhid_init_reports(hid);\n\t\thiddev->initialized = true;\n\t\tr = 0;\n\t\tbreak;\n\n\tcase HIDIOCGREPORT:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rinfo.report_type == HID_REPORT_TYPE_OUTPUT)\n	f
29119	4854	nf_tables_getgen	net/netfilter/nf_tables_api.c	skb2	1	13	\N	\N	\tstruct sk_buff *skb2;\n\tint err;\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_gen_info(skb2, net, NETLINK_CB(skb).portid,\n	f
20721	153	mlxfw_flash_component	drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c	mlxfw_flash_component_$__UNIQUE_ID_min2_111$obj	0	13	\N	\N	\tu16 comp_max_write_size;\n\tu8 comp_align_bits;\n\tu32 comp_max_size;\n\tu16 block_size;\n\tu8 *block_ptr;\n\tu32 offset;\n\tint err;\n\n\terr = mlxfw_dev->ops->component_query(mlxfw_dev, comp->index,\n\t\t\t\t\t      &comp_max_size, &comp_align_bits,\n\t\t\t\t\t      &comp_max_write_size);\n\tif (err)\n\t\treturn err;\n\n\tcomp_max_size = min_t(u32, comp_max_size, MLXFW_FSM_MAX_COMPONENT_SIZE);\n\tif (comp->data_size > comp_max_size) {\n\t\tpr_err("Component %d is of size %d which is bigger than limit %d\\n",\n\t\t       comp->index, comp->data_size, comp_max_size);\n\t\treturn -EINVAL;\n\t}\n\n\tcomp_max_write_size = MLXFW_ALIGN_DOWN(comp_max_write_size,\n\t\t\t\t\t       comp_align_bits);\n\n\tpr_debug("Component update\\n");\n\terr = mlxfw_dev->ops->fsm_component_update(mlxfw_dev, fwhandle,\n\t\t\t\t\t\t   comp->index,\n\t\t\t\t\t\t   comp->data_size);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\n\t\t\t\t   MLXFW_FSM_STATE_DOWNLOAD);\n\tif (err)\n\t\tgoto err_out;\n\n\tpr_debug("Component download\\n");\n\tfor (offset = 0;\n\t     offset < MLXFW_ALIGN_UP(comp->data_size, comp_align_bits);\n\t     offset += comp_max_write_size) {\n\t\tblock_ptr = comp->data + offset;\n\t\tblock_size = (u16) min_t(u32, comp->data_size - offset,\n	f
22975	4848	xfs_btree_query_range	fs/xfs/libxfs/xfs_btree.c	&high_key	1	13	\N	\N	\tunion xfs_btree_rec\t\trec;\n\tunion xfs_btree_key\t\tlow_key;\n\tunion xfs_btree_key\t\thigh_key;\n\n\t/* Find the keys of both ends of the interval. */\n\tcur->bc_rec = *high_rec;\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\tcur->bc_ops->init_key_from_rec(&high_key, &rec);\n\n\tcur->bc_rec = *low_rec;\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\tcur->bc_ops->init_key_from_rec(&low_key, &rec);\n\n\t/* Enforce low key < high key. */\n\tif (cur->bc_ops->diff_two_keys(cur, &low_key, &high_key) > 0)\n\t\treturn -EINVAL;\n\n\tif (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))\n\t\treturn xfs_btree_simple_query_range(cur, &low_key,\n	f
24037	690	es2_cport_clear	drivers/staging/greybus/es2.c	ret	1	13	\N	\N	\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_clear_req req;\n\tint ret;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_CLEAR, &req, sizeof(req),\n\t\t\tNULL, ES2_ARPC_CPORT_TIMEOUT);\n\tif (ret) {\n	f
26306	2850	compat_mptfwxfer_ioctl	drivers/message/fusion/mptctl.c	compat_mptfwxfer_ioctl_	1	13	\N	\N	\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n	f
29842	593	m920x_mt352_frontend_attach_vp7049	drivers/media/usb/dvb-usb/m920x.c	ret	1	13	\N	\N	\tstruct m920x_inits vp7049_fe_init_seq[] = {\n\t\t/* XXX without these commands the frontend cannot be detected,\n\t\t * they must be sent BEFORE the frontend is attached */\n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff23,         0x00 },\n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff23,         0x00 },\n\t\t{ 0xff21,         0x20 },\n\t\t{ 0xff21,         0x60 },\n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff22,         0x00 },\n\t\t{ 0xff20,         0x30 },\n\t\t{ 0xff20,         0x20 },\n\t\t{ 0xff20,         0x30 },\n\t\t{ } /* terminating entry */\n\t};\n\tint ret;\n\n\tdeb("%s\\n", __func__);\n\n\tret = m920x_write_seq(adap->dev->udev, M9206_CORE, vp7049_fe_init_seq);\n\tif (ret != 0) {\n	f
56056	557	SYSC_msgctl	ipc/msg.c	&msqid64	1	13	\N	\N	\tint version;\n\tstruct ipc_namespace *ns;\n\tstruct msqid64_ds msqid64;\n\tint err;\n\n\tif (msqid < 0 || cmd < 0)\n\t\treturn -EINVAL;\n\n\tversion = ipc_parse_version(&cmd);\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase MSG_INFO: {\n\t\tstruct msginfo msginfo;\n\t\terr = msgctl_info(ns, msqid, cmd, &msginfo);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_to_user(buf, &msginfo, sizeof(struct msginfo)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase MSG_STAT:\t/* msqid is an index rather than a msg queue id */\n\tcase IPC_STAT:\n\t\terr = msgctl_stat(ns, msqid, cmd, &msqid64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_msqid_to_user(buf, &msqid64, version))\n	f
30780	3154	do_bind_con_driver	drivers/tty/vt/vt.c	do_bind_con_driver_$__UNIQUE_ID_max2_244$obj	0	13	\N	\N	\tstruct module *owner = csw->owner;\n\tconst char *desc = NULL;\n\tstruct con_driver *con_driver;\n\tint i, j = -1, k = -1, retval = -ENODEV;\n\n\tif (!try_module_get(owner))\n\t\treturn -ENODEV;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\t/* check if driver is registered */\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == csw) {\n\t\t\tdesc = con_driver->desc;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval)\n\t\tgoto err;\n\n\tif (!(con_driver->flag & CON_DRIVER_FLAG_INIT)) {\n\t\tcsw->con_startup();\n\t\tcon_driver->flag |= CON_DRIVER_FLAG_INIT;\n\t}\n\n\tif (deflt) {\n\t\tif (conswitchp)\n\t\t\tmodule_put(conswitchp->owner);\n\n\t\t__module_get(owner);\n\t\tconswitchp = csw;\n\t}\n\n\tfirst = max(first, con_driver->first);\n	f
35022	3366	ipw2100_interrupt	drivers/net/wireless/intel/ipw2x00/ipw2100.c	inta	1	13	\N	\N	\tstruct ipw2100_priv *priv = data;\n\tu32 inta, inta_mask;\n\n\tif (!data)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->low_lock);\n\n\t/* We check to see if we should be ignoring interrupts before\n\t * we touch the hardware.  During ucode load if we try and handle\n\t * an interrupt we can cause keyboard problems as well as cause\n\t * the ucode to fail to initialize */\n\tif (!(priv->status & STATUS_INT_ENABLED)) {\n\t\t/* Shared IRQ */\n\t\tgoto none;\n\t}\n\n\tread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\n\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\n\tif (inta == 0xFFFFFFFF) {\n	f
42214	1530	chcr_ahash_final	drivers/crypto/chelsio/chcr_algo.c	&params	1	13	\N	\N	\tstruct chcr_ahash_req_ctx *req_ctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *rtfm = crypto_ahash_reqtfm(req);\n\tstruct chcr_context *ctx = crypto_tfm_ctx(crypto_ahash_tfm(rtfm));\n\tstruct hash_wr_param params;\n\tstruct sk_buff *skb;\n\tstruct uld_ctx *u_ctx = NULL;\n\tu8 bs = crypto_tfm_alg_blocksize(crypto_ahash_tfm(rtfm));\n\n\tu_ctx = ULD_CTX(ctx);\n\tif (is_hmac(crypto_ahash_tfm(rtfm)))\n\t\tparams.opad_needed = 1;\n\telse\n\t\tparams.opad_needed = 0;\n\tparams.sg_len = 0;\n\tget_alg_config(&params.alg_prm, crypto_ahash_digestsize(rtfm));\n\treq_ctx->result = 1;\n\tparams.bfr_len = req_ctx->reqlen;\n\treq_ctx->data_len += params.bfr_len + params.sg_len;\n\tif (req_ctx->reqlen == 0) {\n\t\tcreate_last_hash_block(req_ctx->reqbfr, bs, req_ctx->data_len);\n\t\tparams.last = 0;\n\t\tparams.more = 1;\n\t\tparams.scmd1 = 0;\n\t\tparams.bfr_len = bs;\n\n\t} else {\n\t\tparams.scmd1 = req_ctx->data_len;\n\t\tparams.last = 1;\n\t\tparams.more = 0;\n\t}\n\tskb = create_hash_wr(req, &params);\n	f
43897	394	tmp108_probe	drivers/hwmon/tmp108.c	config	1	13	\N	\N	\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct tmp108 *tmp108;\n\tint err;\n\tu32 config;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_err(dev,\n\t\t\t"adapter doesn't support SMBus word transactions\\n");\n\t\treturn -ENODEV;\n\t}\n\n\ttmp108 = devm_kzalloc(dev, sizeof(*tmp108), GFP_KERNEL);\n\tif (!tmp108)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, tmp108);\n\n\ttmp108->regmap = devm_regmap_init_i2c(client, &tmp108_regmap_config);\n\tif (IS_ERR(tmp108->regmap)) {\n\t\terr = PTR_ERR(tmp108->regmap);\n\t\tdev_err(dev, "regmap init failed: %d", err);\n\t\treturn err;\n\t}\n\n\terr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &config);\n\tif (err < 0) {\n\t\tdev_err(dev, "error reading config register: %d", err);\n\t\treturn err;\n\t}\n\ttmp108->orig_config = config;\n\n\t/* Only continuous mode is supported. */\n\tconfig &= ~TMP108_CONF_MODE_MASK;\n\tconfig |= TMP108_MODE_CONTINUOUS;\n\n\t/* Only comparator mode is supported. */\n\tconfig &= ~TMP108_CONF_TM;\n\n\terr = regmap_write(tmp108->regmap, TMP108_REG_CONF, config);\n	f
51298	7502	create_trace_option_core_file	kernel/trace/trace.c	t_options	1	13	\N	\N	\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n	f
55672	406	sch311x_gpio_init	drivers/gpio/gpio-sch311x.c	err	1	13	\N	\N	\tint err, i;\n\tunsigned short addr = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sch311x_ioports); i++)\n\t\tif (sch311x_detect(sch311x_ioports[i], &addr) == 0)\n\t\t\tbreak;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&sch311x_gpio_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = sch311x_gpio_pdev_add(addr);\n\tif (err)\n	f
55938	633	udf_extend_file	fs/udf/inode.c	epos.bh	1	13	\N	\N	\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\n\t/* File has extent covering the new size (could happen when extending\n\t * inside a block)? */\n\tif (etype != -1)\n\t\treturn 0;\n\tif (newsize & (sb->s_blocksize - 1))\n\t\toffset++;\n\t/* Extended file just to the boundary of the last file block? */\n\tif (offset == 0)\n\t\treturn 0;\n\n\t/* Truncate is extending the file by 'offset' blocks */\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n	f
7903	572	ath9k_hw_get_gain_boundaries_pdadcs	drivers/net/wireless/ath/ath9k/eeprom.c	ath9k_hw_get_gain_boundaries_pdadcs_$maxPwrT4$0$obj$sub$%minPwrT4$0$obj$sdiv$2	0	13	\N	\N	\tint i, j, k;\n\tint16_t ss;\n\tu16 idxL = 0, idxR = 0, numPiers;\n\tstatic u8 vpdTableL[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\tstatic u8 vpdTableR[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\tstatic u8 vpdTableI[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\n\tu8 *pVpdL, *pVpdR, *pPwrL, *pPwrR;\n\tu8 minPwrT4[AR5416_NUM_PD_GAINS];\n\tu8 maxPwrT4[AR5416_NUM_PD_GAINS];\n\tint16_t vpdStep;\n\tint16_t tmpVal;\n\tu16 sizeCurrVpdTable, maxIndex, tgtIndex;\n\tbool match;\n\tint16_t minDelta = 0;\n\tstruct chan_centers centers;\n\tint pdgain_boundary_default;\n\tstruct cal_data_per_freq *data_def = pRawDataSet;\n\tstruct cal_data_per_freq_4k *data_4k = pRawDataSet;\n\tstruct cal_data_per_freq_ar9287 *data_9287 = pRawDataSet;\n\tbool eeprom_4k = AR_SREV_9285(ah) || AR_SREV_9271(ah);\n\tint intercepts;\n\n\tif (AR_SREV_9287(ah))\n\t\tintercepts = AR9287_PD_GAIN_ICEPTS;\n\telse\n\t\tintercepts = AR5416_PD_GAIN_ICEPTS;\n\n\tmemset(&minPwrT4, 0, AR5416_NUM_PD_GAINS);\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tfor (numPiers = 0; numPiers < availPiers; numPiers++) {\n\t\tif (bChans[numPiers] == AR5416_BCHAN_UNUSED)\n\t\t\tbreak;\n\t}\n\n\tmatch = ath9k_hw_get_lower_upper_index((u8)FREQ2FBIN(centers.synth_center,\n\t\t\t\t\t\t\t     IS_CHAN_2GHZ(chan)),\n\t\t\t\t\t       bChans, numPiers, &idxL, &idxR);\n\n\tif (match) {\n\t\tif (AR_SREV_9287(ah)) {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_9287[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_9287[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_9287[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_9287[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t} else if (eeprom_4k) {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_4k[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_4k[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_4k[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_4k[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_def[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_def[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_def[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_def[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\tif (AR_SREV_9287(ah)) {\n\t\t\t\tpVpdL = data_9287[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_9287[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_9287[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_9287[idxR].pwrPdg[i];\n\t\t\t} else if (eeprom_4k) {\n\t\t\t\tpVpdL = data_4k[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_4k[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_4k[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_4k[idxR].pwrPdg[i];\n\t\t\t} else {\n\t\t\t\tpVpdL = data_def[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_def[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_def[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_def[idxR].pwrPdg[i];\n\t\t\t}\n\n\t\t\tminPwrT4[i] = max(pPwrL[0], pPwrR[0]);\n\n\t\t\tmaxPwrT4[i] =\n\t\t\t\tmin(pPwrL[intercepts - 1],\n\t\t\t\t    pPwrR[intercepts - 1]);\n\n\n\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tpPwrL, pVpdL,\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableL[i]);\n\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tpPwrR, pVpdR,\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableR[i]);\n\n\t\t\tfor (j = 0; j <= (maxPwrT4[i] - minPwrT4[i]) / 2; j++) {\n	f
27572	1106	allocate_ctxt	drivers/infiniband/hw/hfi1/file_ops.c	uctxt->comm	1	13	\N	\N	\tstruct hfi1_ctxtdata *uctxt;\n\tint ret, numa;\n\n\tif (dd->flags & HFI1_FROZEN) {\n\t\t/*\n\t\t * Pick an error that is unique from all other errors\n\t\t * that are returned so the user process knows that\n\t\t * it tried to allocate while the SPC was frozen.  It\n\t\t * it should be able to retry with success in a short\n\t\t * while.\n\t\t */\n\t\treturn -EIO;\n\t}\n\n\tif (!dd->freectxts)\n\t\treturn -EBUSY;\n\n\t/*\n\t * If we don't have a NUMA node requested, preference is towards\n\t * device NUMA node.\n\t */\n\tfd->rec_cpu_num = hfi1_get_proc_affinity(dd->node);\n\tif (fd->rec_cpu_num != -1)\n\t\tnuma = cpu_to_node(fd->rec_cpu_num);\n\telse\n\t\tnuma = numa_node_id();\n\tret = hfi1_create_ctxtdata(dd->pport, numa, &uctxt);\n\tif (ret < 0) {\n\t\tdd_dev_err(dd, "user ctxtdata allocation failed\\n");\n\t\treturn ret;\n\t}\n\thfi1_cdbg(PROC, "[%u:%u] pid %u assigned to CPU %d (NUMA %u)",\n\t\t  uctxt->ctxt, fd->subctxt, current->pid, fd->rec_cpu_num,\n\t\t  uctxt->numa_id);\n\n\t/*\n\t * Allocate and enable a PIO send context.\n\t */\n\tuctxt->sc = sc_alloc(dd, SC_USER, uctxt->rcvhdrqentsize, dd->node);\n\tif (!uctxt->sc) {\n\t\tret = -ENOMEM;\n\t\tgoto ctxdata_free;\n\t}\n\thfi1_cdbg(PROC, "allocated send context %u(%u)\\n", uctxt->sc->sw_index,\n\t\t  uctxt->sc->hw_context);\n\tret = sc_enable(uctxt->sc);\n\tif (ret)\n\t\tgoto ctxdata_free;\n\n\t/*\n\t * Setup sub context information if the user-level has requested\n\t * sub contexts.\n\t * This has to be done here so the rest of the sub-contexts find the\n\t * proper base context.\n\t */\n\tif (uinfo->subctxt_cnt)\n\t\tinit_subctxts(uctxt, uinfo);\n\tuctxt->userversion = uinfo->userversion;\n\tuctxt->flags = hfi1_cap_mask; /* save current flag state */\n\tinit_waitqueue_head(&uctxt->wait);\n\tstrlcpy(uctxt->comm, current->comm, sizeof(uctxt->comm));\n	f
852	426	act8945a_set_supply_type	drivers/power/supply/act8945a_charger.c	state	1	13	\N	\N	\tunsigned int status, state;\n\tint ret;\n\n\tret = regmap_read(charger->regmap, ACT8945A_APCH_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(charger->regmap, ACT8945A_APCH_STATE, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & APCH_STATUS_INDAT) {\n\t\tif (state & APCH_STATE_ACINSTAT)\n	f
45397	108	__btrfs_set_acl	fs/btrfs/acl.c	ret	1	13	\N	\N	\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n	f
50490	2195	wm5100_irq	sound/soc/codecs/wm5100.c	irq_val	1	13	\N	\N	\tstruct wm5100_priv *wm5100 = data;\n\tirqreturn_t status = IRQ_NONE;\n\tunsigned int irq_val, mask_val;\n\tint ret;\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, &irq_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, "Failed to read IRQ status 3: %d\\n",\n\t\t\tret);\n\t\tirq_val = 0;\n\t}\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3_MASK,\n\t\t\t  &mask_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, "Failed to read IRQ mask 3: %d\\n",\n\t\t\tret);\n\t\tmask_val = 0xffff;\n\t}\n\n\tirq_val &= ~mask_val;\n\n\tregmap_write(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, irq_val);\n\n\tif (irq_val)\n\t\tstatus = IRQ_HANDLED;\n\n\twm5100_log_status3(wm5100, irq_val);\n\n\tif (irq_val & WM5100_FLL1_LOCK_EINT) {\n\t\tdev_dbg(wm5100->dev, "FLL1 locked\\n");\n\t\tcomplete(&wm5100->fll[0].lock);\n\t}\n\tif (irq_val & WM5100_FLL2_LOCK_EINT) {\n\t\tdev_dbg(wm5100->dev, "FLL2 locked\\n");\n\t\tcomplete(&wm5100->fll[1].lock);\n\t}\n\n\tif (irq_val & WM5100_ACCDET_EINT)\n	f
61904	278	igt_debug	drivers/gpu/drm/selftests/test-drm_mm.c	&mm	1	13	\N	\N	\tstruct drm_mm mm;\n\tstruct drm_mm_node nodes[2];\n\tint ret;\n\n\t/* Create a small drm_mm with a couple of nodes and a few holes, and\n\t * check that the debug iterator doesn't explode over a trivial drm_mm.\n\t */\n\n\tdrm_mm_init(&mm, 0, 4096);\n\n\tmemset(nodes, 0, sizeof(nodes));\n\tnodes[0].start = 512;\n\tnodes[0].size = 1024;\n\tret = drm_mm_reserve_node(&mm, &nodes[0]);\n	f
20147	306	snd_seq_timer_open	sound/core/seq/seq_timer.c	snd_seq_timer_open_$t$obj$2	0	13	\N	\N	\tstruct snd_timer_instance *t;\n\tstruct snd_seq_timer *tmr;\n\tchar str[32];\n\tint err;\n\n\ttmr = q->timer;\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\tif (tmr->timeri)\n\t\treturn -EBUSY;\n\tsprintf(str, "sequencer queue %i", q->queue);\n\tif (tmr->type != SNDRV_SEQ_TIMER_ALSA)\t/* standard ALSA timer */\n\t\treturn -EINVAL;\n\tif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttmr->alsa_id.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\n\terr = snd_timer_open(&t, str, &tmr->alsa_id, q->queue);\n\tif (err < 0 && tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE) {\n\t\tif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_GLOBAL ||\n\t\t    tmr->alsa_id.device != SNDRV_TIMER_GLOBAL_SYSTEM) {\n\t\t\tstruct snd_timer_id tid;\n\t\t\tmemset(&tid, 0, sizeof(tid));\n\t\t\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\t\t\ttid.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\n\t\t\ttid.card = -1;\n\t\t\ttid.device = SNDRV_TIMER_GLOBAL_SYSTEM;\n\t\t\terr = snd_timer_open(&t, str, &tid, q->queue);\n\t\t}\n\t}\n\tif (err < 0) {\n\t\tpr_err("ALSA: seq fatal error: cannot create timer (%i)\\n", err);\n\t\treturn err;\n\t}\n\tt->callback = snd_seq_timer_interrupt;\n\tt->callback_data = q;\n\tt->flags |= SNDRV_TIMER_IFLG_AUTO;\n	f
5430	480	s5c73m3_system_status_wait	drivers/media/i2c/s5c73m3/s5c73m3-core.c	reg	1	13	\N	\N	\tu16 reg = 0;\n\n\twhile (steps-- > 0) {\n\t\tint ret = s5c73m3_read(state, 0x30100010, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (reg == value)\n	f
9019	2418	pn533_pasori_fw_reset	drivers/nfc/pn533/pn533.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tdev_dbg(dev->dev, "%s\\n", __func__);\n\n\tskb = pn533_alloc_skb(dev, sizeof(u8));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x1);\n	f
9842	1326	mv88e6xxx_port_db_load_purge	drivers/net/dsa/mv88e6xxx/chip.c	&vlan	1	13	\N	\N	\tstruct mv88e6xxx_vtu_entry vlan;\n\tstruct mv88e6xxx_atu_entry entry;\n\tint err;\n\n\t/* Null VLAN ID corresponds to the port private database */\n\tif (vid == 0)\n\t\terr = mv88e6xxx_port_get_fid(chip, port, &vlan.fid);\n\telse\n\t\terr = mv88e6xxx_vtu_get(chip, vid, &vlan, false);\n	f
30312	853	mmc_sd_setup_card	drivers/mmc/core/sd.c	card	1	13	\N	\N	\tint err;\n\n\tif (!reinit) {\n\t\t/*\n\t\t * Fetch SCR from card.\n\t\t */\n\t\terr = mmc_app_send_scr(card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mmc_decode_scr(card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * Fetch and process SD Status register.\n\t\t */\n\t\terr = mmc_read_ssr(card);\n	f
44243	9351	nl80211_remain_on_channel	net/wireless/nl80211.c	msg	1	13	\N	\N	\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tconst struct cfg80211_chan_def *compat_chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We should be on that channel for at least a minimum amount of\n\t * time (10ms) but no longer than the driver supports.\n\t */\n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev) &&\n\t    !cfg80211_chandef_identical(&wdev->chandef, &chandef)) {\n\t\tcompat_chandef = cfg80211_chandef_compatible(&wdev->chandef,\n\t\t\t\t\t\t\t     &chandef);\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n	f
58604	1700	wm8903_irq	sound/soc/codecs/wm8903.c	int_val	1	13	\N	\N	\tstruct wm8903_priv *wm8903 = data;\n\tint mic_report, ret;\n\tunsigned int int_val, mask, int_pol;\n\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_STATUS_1_MASK,\n\t\t\t  &mask);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, "Failed to read IRQ mask: %d\\n", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_STATUS_1, &int_val);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, "Failed to read IRQ status: %d\\n", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tint_val &= ~mask;\n\n\tif (int_val & WM8903_WSEQ_BUSY_EINT) {\n\t\tdev_warn(wm8903->dev, "Write sequencer done\\n");\n\t}\n\n\t/*\n\t * The rest is microphone jack detection.  We need to manually\n\t * invert the polarity of the interrupt after each event - to\n\t * simplify the code keep track of the last state we reported\n\t * and just invert the relevant bits in both the report and\n\t * the polarity register.\n\t */\n\tmic_report = wm8903->mic_last_report;\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_POLARITY_1,\n\t\t\t  &int_pol);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, "Failed to read interrupt polarity: %d\\n",\n\t\t\tret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n#ifndef CONFIG_SND_SOC_WM8903_MODULE\n\tif (int_val & (WM8903_MICSHRT_EINT | WM8903_MICDET_EINT))\n\t\ttrace_snd_soc_jack_irq(dev_name(wm8903->dev));\n#endif\n\n\tif (int_val & WM8903_MICSHRT_EINT) {\n\t\tdev_dbg(wm8903->dev, "Microphone short (pol=%x)\\n", int_pol);\n\n\t\tmic_report ^= wm8903->mic_short;\n\t\tint_pol ^= WM8903_MICSHRT_INV;\n\t}\n\n\tif (int_val & WM8903_MICDET_EINT) {\n	f
33804	925	alloc_mr_from_cache	drivers/infiniband/hw/mlx5/mr.c	mr	1	13	\N	\N	\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_mr *mr;\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < 1; i++) {\n\t\tmr = alloc_cached_mr(dev, order);\n\t\tif (mr)\n\t\t\tbreak;\n\n\t\terr = add_keys(dev, order2idx(dev, order), 1);\n\t\tif (err && err != -EAGAIN) {\n\t\t\tmlx5_ib_warn(dev, "add_keys failed, err %d\\n", err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mr)\n	f
35897	1691	sel_make_class_dir_entries	security/selinux/selinuxfs.c	dentry	1	13	\N	\N	\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tdentry = d_alloc_name(dir, "index");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, "perms", &last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\trc = sel_make_perm_files(classname, index, dentry);\n	f
36641	516	pcan_usb_fd_decode_canmsg	drivers/net/can/usb/peak_usb/pcan_usb_fd.c	skb	1	13	\N	\N	\tstruct pucan_rx_msg *rm = (struct pucan_rx_msg *)rx_msg;\n\tstruct peak_usb_device *dev = usb_if->dev[pucan_msg_get_channel(rm)];\n\tstruct net_device *netdev = dev->netdev;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\tconst u16 rx_msg_flags = le16_to_cpu(rm->flags);\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {\n\t\t/* CANFD frame case */\n\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH)\n\t\t\tcfd->flags |= CANFD_BRS;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND)\n\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\tcfd->len = can_dlc2len(get_canfd_dlc(pucan_msg_get_dlc(rm)));\n\t} else {\n\t\t/* CAN 2.0 frame case */\n\t\tskb = alloc_can_skb(netdev, (struct can_frame **)&cfd);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tcfd->len = get_can_dlc(pucan_msg_get_dlc(rm));\n\t}\n\n\tcfd->can_id = le32_to_cpu(rm->can_id);\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_ID)\n\t\tcfd->can_id |= CAN_EFF_FLAG;\n\n\tif (rx_msg_flags & PUCAN_MSG_RTR)\n\t\tcfd->can_id |= CAN_RTR_FLAG;\n\telse\n\t\tmemcpy(cfd->data, rm->d, cfd->len);\n\n\tpeak_usb_netif_rx(skb, &usb_if->time_ref,\n	f
40031	114	create_cq	drivers/infiniband/hw/cxgb4/cq.c	skb	1	13	\N	\N	\tstruct fw_ri_res_wr *res_wr;\n\tstruct fw_ri_res *res;\n\tint wr_len;\n\tint user = (uctx != &rdev->uctx);\n\tstruct c4iw_wr_wait wr_wait;\n\tint ret;\n\tstruct sk_buff *skb;\n\n\tcq->cqid = c4iw_get_cqid(rdev, uctx);\n\tif (!cq->cqid) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tif (!user) {\n\t\tcq->sw_queue = kzalloc(cq->memsize, GFP_KERNEL);\n\t\tif (!cq->sw_queue) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err2;\n\t\t}\n\t}\n\tcq->queue = dma_alloc_coherent(&rdev->lldi.pdev->dev, cq->memsize,\n\t\t\t\t       &cq->dma_addr, GFP_KERNEL);\n\tif (!cq->queue) {\n\t\tret = -ENOMEM;\n\t\tgoto err3;\n\t}\n\tdma_unmap_addr_set(cq, mapping, cq->dma_addr);\n\tmemset(cq->queue, 0, cq->memsize);\n\n\t/* build fw_ri_res_wr */\n\twr_len = sizeof *res_wr + sizeof *res;\n\n\tskb = alloc_skb(wr_len, GFP_KERNEL);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto err4;\n\t}\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, 0);\n	f
44627	226	v9fs_launder_page	fs/9p/vfs_addr.c	retval	1	13	\N	\N	\tint retval;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9fs_fscache_wait_on_page_write(inode, page);\n\tif (clear_page_dirty_for_io(page)) {\n\t\tretval = v9fs_vfs_writepage_locked(page);\n\t\tif (retval)\n	f
44765	1205	genwqe_ioctl	drivers/misc/genwqe/card_dev.c	&m	1	13	\N	\N	\tint rc = 0;\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct genwqe_reg_io __user *io;\n\tu64 val;\n\tu32 reg_offs;\n\n\t/* Return -EIO if card hit EEH */\n\tif (pci_channel_offline(pci_dev))\n\t\treturn -EIO;\n\n\tif (_IOC_TYPE(cmd) != GENWQE_IOC_CODE)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\n\tcase GENWQE_GET_CARD_STATE:\n\t\tput_user(cd->card_state, (enum genwqe_card_state __user *)arg);\n\t\treturn 0;\n\n\t\t/* Register access */\n\tcase GENWQE_READ_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readq(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writeq(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_READ_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readl(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writel(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\t\t/* Flash update/reading */\n\tcase GENWQE_SLU_UPDATE: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&load, (void __user *)arg,\n\t\t\t\t   sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_update(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\tcase GENWQE_SLU_READ: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif (genwqe_flash_readback_fails(cd))\n\t\t\treturn -ENOSPC;\t /* known to fail for old versions */\n\n\t\tif (copy_from_user(&load, (void __user *)arg, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_read(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\t\t/* memory pinning and unpinning */\n\tcase GENWQE_PIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_pin_mem(cfile, &m);\n\t}\n\n\tcase GENWQE_UNPIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_unpin_mem(cfile, &m);\n	f
48309	1781	ims_pcu_line_setup	drivers/input/misc/ims-pcu.c	error	1	13	\N	\N	\tstruct usb_host_interface *interface = pcu->ctrl_intf->cur_altsetting;\n\tstruct usb_cdc_line_coding *line = (void *)pcu->cmd_buf;\n\tint error;\n\n\tmemset(line, 0, sizeof(*line));\n\tline->dwDTERate = cpu_to_le32(57600);\n\tline->bDataBits = 8;\n\n\terror = usb_control_msg(pcu->udev, usb_sndctrlpipe(pcu->udev, 0),\n\t\t\t\tUSB_CDC_REQ_SET_LINE_CODING,\n\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t0, interface->desc.bInterfaceNumber,\n\t\t\t\tline, sizeof(struct usb_cdc_line_coding),\n\t\t\t\t5000);\n\tif (error < 0) {\n	f
54961	433	generic_rndis_bind	drivers/net/usb/rndis_host.c	bp	1	13	\N	\N	\tint\t\t\tretval;\n\tstruct net_device\t*net = dev->net;\n\tstruct cdc_state\t*info = (void *) &dev->data;\n\tunion {\n\t\tvoid\t\t\t*buf;\n\t\tstruct rndis_msg_hdr\t*header;\n\t\tstruct rndis_init\t*init;\n\t\tstruct rndis_init_c\t*init_c;\n\t\tstruct rndis_query\t*get;\n\t\tstruct rndis_query_c\t*get_c;\n\t\tstruct rndis_set\t*set;\n\t\tstruct rndis_set_c\t*set_c;\n\t\tstruct rndis_halt\t*halt;\n\t} u;\n\tu32\t\t\ttmp;\n\t__le32\t\t\tphym_unspec, *phym;\n\tint\t\t\treply_len;\n\tunsigned char\t\t*bp;\n\n\t/* we can't rely on i/o from stack working, or stack allocation */\n\tu.buf = kmalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\n\tif (!u.buf)\n\t\treturn -ENOMEM;\n\tretval = usbnet_generic_cdc_bind(dev, intf);\n\tif (retval < 0)\n\t\tgoto fail;\n\n\tu.init->msg_type = cpu_to_le32(RNDIS_MSG_INIT);\n\tu.init->msg_len = cpu_to_le32(sizeof *u.init);\n\tu.init->major_version = cpu_to_le32(1);\n\tu.init->minor_version = cpu_to_le32(0);\n\n\t/* max transfer (in spec) is 0x4000 at full speed, but for\n\t * TX we'll stick to one Ethernet packet plus RNDIS framing.\n\t * For RX we handle drivers that zero-pad to end-of-packet.\n\t * Don't let userspace change these settings.\n\t *\n\t * NOTE: there still seems to be wierdness here, as if we need\n\t * to do some more things to make sure WinCE targets accept this.\n\t * They default to jumbograms of 8KB or 16KB, which is absurd\n\t * for such low data rates and which is also more than Linux\n\t * can usually expect to allocate for SKB data...\n\t */\n\tnet->hard_header_len += sizeof (struct rndis_data_hdr);\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\n\tdev->maxpacket = usb_maxpacket(dev->udev, dev->out, 1);\n\tif (dev->maxpacket == 0) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  "dev->maxpacket can't be 0\\n");\n\t\tretval = -EINVAL;\n\t\tgoto fail_and_release;\n\t}\n\n\tdev->rx_urb_size = dev->hard_mtu + (dev->maxpacket + 1);\n\tdev->rx_urb_size &= ~(dev->maxpacket - 1);\n\tu.init->max_transfer_size = cpu_to_le32(dev->rx_urb_size);\n\n\tnet->netdev_ops = &rndis_netdev_ops;\n\n\tretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\n\tif (unlikely(retval < 0)) {\n\t\t/* it might not even be an RNDIS device!! */\n\t\tdev_err(&intf->dev, "RNDIS init failed, %d\\n", retval);\n\t\tgoto fail_and_release;\n\t}\n\ttmp = le32_to_cpu(u.init_c->max_transfer_size);\n\tif (tmp < dev->hard_mtu) {\n\t\tif (tmp <= net->hard_header_len) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t"dev can't take %u byte packets (max %u)\\n",\n\t\t\t\tdev->hard_mtu, tmp);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto halt_fail_and_release;\n\t\t}\n\t\tdev_warn(&intf->dev,\n\t\t\t "dev can't take %u byte packets (max %u), "\n\t\t\t "adjusting MTU to %u\\n",\n\t\t\t dev->hard_mtu, tmp, tmp - net->hard_header_len);\n\t\tdev->hard_mtu = tmp;\n\t\tnet->mtu = dev->hard_mtu - net->hard_header_len;\n\t}\n\n\t/* REVISIT:  peripheral "alignment" request is ignored ... */\n\tdev_dbg(&intf->dev,\n\t\t"hard mtu %u (%u from dev), rx buflen %zu, align %d\\n",\n\t\tdev->hard_mtu, tmp, dev->rx_urb_size,\n\t\t1 << le32_to_cpu(u.init_c->packet_alignment));\n\n\t/* module has some device initialization code needs to be done right\n\t * after RNDIS_INIT */\n\tif (dev->driver_info->early_init &&\n\t\t\tdev->driver_info->early_init(dev) != 0)\n\t\tgoto halt_fail_and_release;\n\n\t/* Check physical medium */\n\tphym = NULL;\n\treply_len = sizeof *phym;\n\tretval = rndis_query(dev, intf, u.buf,\n\t\t\t     RNDIS_OID_GEN_PHYSICAL_MEDIUM,\n\t\t\t     0, (void **) &phym, &reply_len);\n\tif (retval != 0 || !phym) {\n\t\t/* OID is optional so don't fail here. */\n\t\tphym_unspec = cpu_to_le32(RNDIS_PHYSICAL_MEDIUM_UNSPECIFIED);\n\t\tphym = &phym_unspec;\n\t}\n\tif ((flags & FLAG_RNDIS_PHYM_WIRELESS) &&\n\t    le32_to_cpup(phym) != RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  "driver requires wireless physical medium, but device is not\\n");\n\t\tretval = -ENODEV;\n\t\tgoto halt_fail_and_release;\n\t}\n\tif ((flags & FLAG_RNDIS_PHYM_NOT_WIRELESS) &&\n\t    le32_to_cpup(phym) == RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  "driver requires non-wireless physical medium, but device is wireless.\\n");\n\t\tretval = -ENODEV;\n\t\tgoto halt_fail_and_release;\n\t}\n\n\t/* Get designated host ethernet address */\n\treply_len = ETH_ALEN;\n\tretval = rndis_query(dev, intf, u.buf,\n\t\t\t     RNDIS_OID_802_3_PERMANENT_ADDRESS,\n\t\t\t     48, (void **) &bp, &reply_len);\n\tif (unlikely(retval< 0)) {\n\t\tdev_err(&intf->dev, "rndis get ethaddr, %d\\n", retval);\n\t\tgoto halt_fail_and_release;\n\t}\n\n\tif (bp[0] & 0x02)\n	f
57932	312	bcd2000_init_midi	sound/usb/bcd2000/bcd2000.c	rmidi->name	1	13	\N	\N	\tint ret;\n\tstruct snd_rawmidi *rmidi;\n\n\tret = snd_rawmidi_new(bcd2k->card, bcd2k->card->shortname, 0,\n\t\t\t\t\t1, /* output */\n\t\t\t\t\t1, /* input */\n\t\t\t\t\t&rmidi);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstrlcpy(rmidi->name, bcd2k->card->shortname, sizeof(rmidi->name));\n	f
33285	411	ak8974_selftest	drivers/iio/magnetometer/ak8974.c	val	1	13	\N	\N	\tstruct device *dev = &ak8974->i2c->dev;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != AK8974_SELFTEST_IDLE) {\n	f
25847	375	tps65217_probe	drivers/mfd/tps65217.c	ret	1	13	\N	\N	\tstruct tps65217 *tps;\n\tunsigned int version;\n\tunsigned long chip_id = ids->driver_data;\n\tconst struct of_device_id *match;\n\tbool status_off = false;\n\tint ret;\n\n\tif (client->dev.of_node) {\n\t\tmatch = of_match_device(tps65217_of_match, &client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t"Failed to find matching dt id\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchip_id = (unsigned long)match->data;\n\t\tstatus_off = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t"ti,pmic-shutdown-controller");\n\t}\n\n\tif (!chip_id) {\n\t\tdev_err(&client->dev, "id is null.\\n");\n\t\treturn -ENODEV;\n\t}\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = &client->dev;\n\ttps->id = chip_id;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65217_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(tps->dev, "Failed to allocate register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq) {\n\t\ttps65217_irq_init(tps, client->irq);\n\t} else {\n\t\tint i;\n\n\t\t/* Don't tell children about IRQ resources which won't fire */\n\t\tfor (i = 0; i < ARRAY_SIZE(tps65217s); i++)\n\t\t\ttps65217s[i].num_resources = 0;\n\t}\n\n\tret = devm_mfd_add_devices(tps->dev, -1, tps65217s,\n\t\t\t\t   ARRAY_SIZE(tps65217s), NULL, 0,\n\t\t\t\t   tps->irq_domain);\n\tif (ret < 0) {\n	f
35401	1090	xcan_probe	drivers/net/can/xilinx_can.c	ret	1	13	\N	\N	\tstruct resource *res; /* IO mem resources */\n\tstruct net_device *ndev;\n\tstruct xcan_priv *priv;\n\tvoid __iomem *addr;\n\tint ret, rx_max, tx_max;\n\n\t/* Get the virtual base address for the device */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\taddr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(addr)) {\n\t\tret = PTR_ERR(addr);\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth", &tx_max);\n\tif (ret < 0)\n	f
42154	2292	ftdi_elan_check_controller	drivers/usb/misc/ftdi-elan.c	roothub_a	1	13	\N	\N	\tint devices = 0;\n\tint retval;\n\tu32 hc_control;\n\tint num_ports;\n\tu32 control;\n\tu32 rh_a = -1;\n\tu32 status;\n\tu32 fminterval;\n\tu32 hc_fminterval;\n\tu32 periodicstart;\n\tu32 cmdstatus;\n\tu32 roothub_a;\n\tint mask = OHCI_INTR_INIT;\n\tint sleep_time = 0;\n\tint reset_timeout = 30;        /* ... allow extra time */\n\tint temp;\n\tretval = ftdi_write_pcimem(ftdi, intrdisable, OHCI_INTR_MIE);\n\tif (retval)\n\t\treturn retval;\n\tretval = ftdi_read_pcimem(ftdi, control, &control);\n\tif (retval)\n\t\treturn retval;\n\tretval = ftdi_read_pcimem(ftdi, roothub.a, &rh_a);\n\tif (retval)\n\t\treturn retval;\n\tnum_ports = rh_a & RH_A_NDP;\n\tretval = ftdi_read_pcimem(ftdi, fminterval, &hc_fminterval);\n\tif (retval)\n\t\treturn retval;\n\thc_fminterval &= 0x3fff;\n\tif (hc_fminterval != FI) {\n\t}\n\thc_fminterval |= FSMP(hc_fminterval) << 16;\n\tretval = ftdi_read_pcimem(ftdi, control, &hc_control);\n\tif (retval)\n\t\treturn retval;\n\tswitch (hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_OPER:\n\t\tsleep_time = 0;\n\t\tbreak;\n\tcase OHCI_USB_SUSPEND:\n\tcase OHCI_USB_RESUME:\n\t\thc_control &= OHCI_CTRL_RWC;\n\t\thc_control |= OHCI_USB_RESUME;\n\t\tsleep_time = 10;\n\t\tbreak;\n\tdefault:\n\t\thc_control &= OHCI_CTRL_RWC;\n\t\thc_control |= OHCI_USB_RESET;\n\t\tsleep_time = 50;\n\t\tbreak;\n\t}\n\tretval = ftdi_write_pcimem(ftdi, control, hc_control);\n\tif (retval)\n\t\treturn retval;\n\tretval = ftdi_read_pcimem(ftdi, control, &control);\n\tif (retval)\n\t\treturn retval;\n\tmsleep(sleep_time);\n\tretval = ftdi_read_pcimem(ftdi, roothub.a, &roothub_a);\n\tif (retval)\n\t\treturn retval;\n\tif (!(roothub_a & RH_A_NPS)) {        /* power down each port */\n	f
49318	950	qca_spi_probe	drivers/net/ethernet/qualcomm/qca_spi.c	signature	1	13	\N	\N	\tstruct qcaspi *qca = NULL;\n\tstruct net_device *qcaspi_devs = NULL;\n\tu8 legacy_mode = 0;\n\tu16 signature;\n\tconst char *mac;\n\n\tif (!spi->dev.of_node) {\n\t\tdev_err(&spi->dev, "Missing device tree\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tlegacy_mode = of_property_read_bool(spi->dev.of_node,\n\t\t\t\t\t    "qca,legacy-mode");\n\n\tif (qcaspi_clkspeed == 0) {\n\t\tif (spi->max_speed_hz)\n\t\t\tqcaspi_clkspeed = spi->max_speed_hz;\n\t\telse\n\t\t\tqcaspi_clkspeed = QCASPI_CLK_SPEED;\n\t}\n\n\tif ((qcaspi_clkspeed < QCASPI_CLK_SPEED_MIN) ||\n\t    (qcaspi_clkspeed > QCASPI_CLK_SPEED_MAX)) {\n\t\tdev_info(&spi->dev, "Invalid clkspeed: %d\\n",\n\t\t\t qcaspi_clkspeed);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((qcaspi_burst_len < QCASPI_BURST_LEN_MIN) ||\n\t    (qcaspi_burst_len > QCASPI_BURST_LEN_MAX)) {\n\t\tdev_info(&spi->dev, "Invalid burst len: %d\\n",\n\t\t\t qcaspi_burst_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((qcaspi_pluggable < QCASPI_PLUGGABLE_MIN) ||\n\t    (qcaspi_pluggable > QCASPI_PLUGGABLE_MAX)) {\n\t\tdev_info(&spi->dev, "Invalid pluggable: %d\\n",\n\t\t\t qcaspi_pluggable);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&spi->dev, "ver=%s, clkspeed=%d, burst_len=%d, pluggable=%d\\n",\n\t\t QCASPI_DRV_VERSION,\n\t\t qcaspi_clkspeed,\n\t\t qcaspi_burst_len,\n\t\t qcaspi_pluggable);\n\n\tspi->mode = SPI_MODE_3;\n\tspi->max_speed_hz = qcaspi_clkspeed;\n\tif (spi_setup(spi) < 0) {\n\t\tdev_err(&spi->dev, "Unable to setup SPI device\\n");\n\t\treturn -EFAULT;\n\t}\n\n\tqcaspi_devs = alloc_etherdev(sizeof(struct qcaspi));\n\tif (!qcaspi_devs)\n\t\treturn -ENOMEM;\n\n\tqcaspi_netdev_setup(qcaspi_devs);\n\tSET_NETDEV_DEV(qcaspi_devs, &spi->dev);\n\n\tqca = netdev_priv(qcaspi_devs);\n\tif (!qca) {\n\t\tfree_netdev(qcaspi_devs);\n\t\tdev_err(&spi->dev, "Fail to retrieve private structure\\n");\n\t\treturn -ENOMEM;\n\t}\n\tqca->net_dev = qcaspi_devs;\n\tqca->spi_dev = spi;\n\tqca->legacy_mode = legacy_mode;\n\n\tspi_set_drvdata(spi, qcaspi_devs);\n\n\tmac = of_get_mac_address(spi->dev.of_node);\n\n\tif (mac)\n\t\tether_addr_copy(qca->net_dev->dev_addr, mac);\n\n\tif (!is_valid_ether_addr(qca->net_dev->dev_addr)) {\n\t\teth_hw_addr_random(qca->net_dev);\n\t\tdev_info(&spi->dev, "Using random MAC address: %pM\\n",\n\t\t\t qca->net_dev->dev_addr);\n\t}\n\n\tnetif_carrier_off(qca->net_dev);\n\n\tif (!qcaspi_pluggable) {\n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\n\t\tif (signature != QCASPI_GOOD_SIGNATURE) {\n	f
54759	590	mixart_set_format	sound/pci/mixart/mixart.c	mixart_set_format_$resp$0$obj	0	13	\N	\N	\tint err;\n\tstruct snd_mixart *chip;\n\tstruct mixart_msg request;\n\tstruct mixart_stream_param_desc stream_param;\n\tstruct mixart_return_uid resp;\n\n\tchip = snd_pcm_substream_chip(stream->substream);\n\n\tmemset(&stream_param, 0, sizeof(stream_param));\n\n\tstream_param.coding_type = CT_LINEAR;\n\tstream_param.number_of_channel = stream->channels;\n\n\tstream_param.sampling_freq = chip->mgr->sample_rate;\n\tif(stream_param.sampling_freq == 0)\n\t\tstream_param.sampling_freq = 44100; /* if frequency not yet defined, use some default */\n\n\tswitch(format){\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tstream_param.sample_type = ST_INTEGER_8;\n\t\tstream_param.sample_size = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tstream_param.sample_type = ST_INTEGER_16LE;\n\t\tstream_param.sample_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tstream_param.sample_type = ST_INTEGER_16BE;\n\t\tstream_param.sample_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tstream_param.sample_type = ST_INTEGER_24LE;\n\t\tstream_param.sample_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\t\tstream_param.sample_type = ST_INTEGER_24BE;\n\t\tstream_param.sample_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_FLOAT_LE:\n\t\tstream_param.sample_type = ST_FLOATING_POINT_32LE;\n\t\tstream_param.sample_size = 32;\n\t\tbreak;\n\tcase  SNDRV_PCM_FORMAT_FLOAT_BE:\n\t\tstream_param.sample_type = ST_FLOATING_POINT_32BE;\n\t\tstream_param.sample_size = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t"error mixart_set_format() : unknown format\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(chip->card->dev,\n\t\t"set SNDRV_PCM_FORMAT sample_type(%d) sample_size(%d) freq(%d) channels(%d)\\n",\n\t\t   stream_param.sample_type, stream_param.sample_size, stream_param.sampling_freq, stream->channels);\n\n\t/* TODO: what else to configure ? */\n\t/* stream_param.samples_per_frame = 2; */\n\t/* stream_param.bytes_per_frame = 4; */\n\t/* stream_param.bytes_per_sample = 2; */\n\n\tstream_param.pipe_count = 1;      /* set to 1 */\n\tstream_param.stream_count = 1;    /* set to 1 */\n\tstream_param.stream_desc[0].uid_pipe = stream->pipe->group_uid;\n\tstream_param.stream_desc[0].stream_idx = stream->substream->number;\n\n\trequest.message_id = MSG_STREAM_SET_INPUT_STAGE_PARAM;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &stream_param;\n\trequest.size = sizeof(stream_param);\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\n\tif((err < 0) || resp.error_code) {\n	f
39763	773	pm3393_mac_reset	drivers/net/ethernet/chelsio/cxgb/pm3393.c	is_xaui_mabc_pll_locked	1	13	\N	\N	\tu32 val;\n\tu32 x;\n\tu32 is_pl4_reset_finished;\n\tu32 is_pl4_outof_lock;\n\tu32 is_xaui_mabc_pll_locked;\n\tu32 successful_reset;\n\tint i;\n\n\t/* The following steps are required to properly reset\n\t * the PM3393. This information is provided in the\n\t * PM3393 datasheet (Issue 2: November 2002)\n\t * section 13.1 -- Device Reset.\n\t *\n\t * The PM3393 has three types of components that are\n\t * individually reset:\n\t *\n\t * DRESETB      - Digital circuitry\n\t * PL4_ARESETB  - PL4 analog circuitry\n\t * XAUI_ARESETB - XAUI bus analog circuitry\n\t *\n\t * Steps to reset PM3393 using RSTB pin:\n\t *\n\t * 1. Assert RSTB pin low ( write 0 )\n\t * 2. Wait at least 1ms to initiate a complete initialization of device.\n\t * 3. Wait until all external clocks and REFSEL are stable.\n\t * 4. Wait minimum of 1ms. (after external clocks and REFEL are stable)\n\t * 5. De-assert RSTB ( write 1 )\n\t * 6. Wait until internal timers to expires after ~14ms.\n\t *    - Allows analog clock synthesizer(PL4CSU) to stabilize to\n\t *      selected reference frequency before allowing the digital\n\t *      portion of the device to operate.\n\t * 7. Wait at least 200us for XAUI interface to stabilize.\n\t * 8. Verify the PM3393 came out of reset successfully.\n\t *    Set successful reset flag if everything worked else try again\n\t *    a few more times.\n\t */\n\n\tsuccessful_reset = 0;\n\tfor (i = 0; i < 3 && !successful_reset; i++) {\n\t\t/* 1 */\n\t\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\t\tval &= ~1;\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\t\t/* 2 */\n\t\tmsleep(1);\n\n\t\t/* 3 */\n\t\tmsleep(1);\n\n\t\t/* 4 */\n\t\tmsleep(2 /*1 extra ms for safety */ );\n\n\t\t/* 5 */\n\t\tval |= 1;\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\t\t/* 6 */\n\t\tmsleep(15 /*1 extra ms for safety */ );\n\n\t\t/* 7 */\n\t\tmsleep(1);\n\n\t\t/* 8 */\n\n\t\t/* Has PL4 analog block come out of reset correctly? */\n\t\tt1_tpi_read(adapter, OFFSET(SUNI1x10GEXP_REG_DEVICE_STATUS), &val);\n\t\tis_pl4_reset_finished = (val & SUNI1x10GEXP_BITMSK_TOP_EXPIRED);\n\n\t\t/* TBD XXX SUNI1x10GEXP_BITMSK_TOP_PL4_IS_DOOL gets locked later in the init sequence\n\t\t *         figure out why? */\n\n\t\t/* Have all PL4 block clocks locked? */\n\t\tx = (SUNI1x10GEXP_BITMSK_TOP_PL4_ID_DOOL\n\t\t     /*| SUNI1x10GEXP_BITMSK_TOP_PL4_IS_DOOL */  |\n\t\t     SUNI1x10GEXP_BITMSK_TOP_PL4_ID_ROOL |\n\t\t     SUNI1x10GEXP_BITMSK_TOP_PL4_IS_ROOL |\n\t\t     SUNI1x10GEXP_BITMSK_TOP_PL4_OUT_ROOL);\n\t\tis_pl4_outof_lock = (val & x);\n\n\t\t/* ??? If this fails, might be able to software reset the XAUI part\n\t\t *     and try to recover... thus saving us from doing another HW reset */\n\t\t/* Has the XAUI MABC PLL circuitry stablized? */\n\t\tis_xaui_mabc_pll_locked =\n\t\t    (val & SUNI1x10GEXP_BITMSK_TOP_SXRA_EXPIRED);\n\n\t\tsuccessful_reset = (is_pl4_reset_finished && !is_pl4_outof_lock\n\t\t\t\t    && is_xaui_mabc_pll_locked);\n	f
40078	841	gfs2_dirent_search	fs/gfs2/dir.c	gfs2_dirent_search_$leaf$obj$8	0	13	\N	\N	\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned int hsize = BIT(ip->i_depth);\n\t\tunsigned int index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n	f
7720	150	pem_read_block	drivers/hwmon/lineage-pem.c	result	1	13	\N	\N	\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX];\n\tint result;\n\n\tresult = i2c_smbus_read_block_data(client, command, block_buffer);\n\tif (unlikely(result < 0))\n	f
52604	62	navman_read_int_callback	drivers/usb/serial/navman.c	urb	1	13	\N	\N	\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&port->dev, "%s - urb shutting down with status: %d\\n",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, "%s - nonzero urb status received: %d\\n",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\tif (urb->actual_length) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n	f
53323	931	eeepc_hotk_thaw	drivers/platform/x86/eeepc-laptop.c	wlan	1	13	\N	\N	\tstruct eeepc_laptop *eeepc = dev_get_drvdata(device);\n\n\tif (eeepc->wlan_rfkill) {\n\t\tint wlan;\n\n\t\t/*\n\t\t * Work around bios bug - acpi _PTS turns off the wireless led\n\t\t * during suspend.  Normally it restores it on resume, but\n\t\t * we should kick it ourselves in case hibernation is aborted.\n\t\t */\n\t\twlan = get_acpi(eeepc, CM_ASL_WLAN);\n\t\tif (wlan >= 0)\n	f
-514	7941	tracing_init_dentry	kernel/trace/trace.c	tr->dir	1000	3	\N	\N	\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount("tracing", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n	f
30761	279	get_wireless_state_ec_standard	drivers/platform/x86/msi-laptop.c	rdata	1	13	\N	\N	\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_COMMAND_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\twlan_s = !!(rdata & MSI_STANDARD_EC_WLAN_MASK);\n\n\tbluetooth_s = !!(rdata & MSI_STANDARD_EC_BLUETOOTH_MASK);\n\n\tthreeg_s = !!(rdata & MSI_STANDARD_EC_3G_MASK);\n	f
21137	2061	bnxt_ud_qp_hw_stall_workaround	drivers/infiniband/hw/bnxt_re/ib_verbs.c	&qp_attr	1	13	\N	\N	\tif ((qp->ib_qp.qp_type == IB_QPT_UD ||\n\t     qp->ib_qp.qp_type == IB_QPT_GSI ||\n\t     qp->ib_qp.qp_type == IB_QPT_RAW_ETHERTYPE) &&\n\t     qp->qplib_qp.wqe_cnt == BNXT_RE_UD_QP_HW_STALL) {\n\t\tint qp_attr_mask;\n\t\tstruct ib_qp_attr qp_attr;\n\n\t\tqp_attr_mask = IB_QP_STATE;\n\t\tqp_attr.qp_state = IB_QPS_RTS;\n\t\tbnxt_re_modify_qp(&qp->ib_qp, &qp_attr, qp_attr_mask, NULL);\n	f
31200	872	dmz_lookup_secondary_sb	drivers/md/dm-zoned-metadata.c	dmz_lookup_secondary_sb_	1	13	\N	\N	\tunsigned int zone_nr_blocks = zmd->dev->zone_nr_blocks;\n\tstruct dmz_mblock *mblk;\n\tint i;\n\n\t/* Allocate a block */\n\tmblk = dmz_alloc_mblock(zmd, 0);\n\tif (!mblk)\n\t\treturn -ENOMEM;\n\n\tzmd->sb[1].mblk = mblk;\n\tzmd->sb[1].sb = mblk->data;\n\n\t/* Bad first super block: search for the second one */\n\tzmd->sb[1].block = zmd->sb[0].block + zone_nr_blocks;\n\tfor (i = 0; i < zmd->nr_rnd_zones - 1; i++) {\n\t\tif (dmz_read_sb(zmd, 1) != 0)\n	f
43564	3491	setup_dig_out_stream	sound/pci/hda/hda_codec.c	curr_fmt	1	13	\N	\N	\tstruct hda_spdif_out *spdif;\n\tunsigned int curr_fmt;\n\tbool reset;\n\n\tspdif = snd_hda_spdif_out_of_nid(codec, nid);\n\t/* Add sanity check to pass klockwork check.\n\t * This should never happen.\n\t */\n\tif (WARN_ON(spdif == NULL))\n\t\treturn;\n\n\tcurr_fmt = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t      AC_VERB_GET_STREAM_FORMAT, 0);\n\treset = codec->spdif_status_reset &&\n\t\t(spdif->ctls & AC_DIG1_ENABLE) &&\n\t\tcurr_fmt != format;\n	f
44613	4662	sched_setaffinity	kernel/sched/core.c	cpus_allowed	1	13	\N	\N	\tcpumask_var_t cpus_allowed, new_mask;\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_cpus_allowed;\n\t}\n\tretval = -EPERM;\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_free_new_mask;\n\n\n\tcpuset_cpus_allowed(p, cpus_allowed);\n	f
59917	388	r600_dma_ib_test	drivers/gpu/drm/radeon/r600_dma.c	i	1	13	\N	\N	\tstruct radeon_ib ib;\n\tunsigned i;\n\tunsigned index;\n\tint r;\n\tu32 tmp = 0;\n\tu64 gpu_addr;\n\n\tif (ring->idx == R600_RING_TYPE_DMA_INDEX)\n\t\tindex = R600_WB_DMA_RING_TEST_OFFSET;\n\telse\n\t\tindex = CAYMAN_WB_DMA1_RING_TEST_OFFSET;\n\n\tgpu_addr = rdev->wb.gpu_addr + index;\n\n\tr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\n\tif (r) {\n\t\tDRM_ERROR("radeon: failed to get ib (%d).\\n", r);\n\t\treturn r;\n\t}\n\n\tib.ptr[0] = DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 1);\n\tib.ptr[1] = lower_32_bits(gpu_addr);\n\tib.ptr[2] = upper_32_bits(gpu_addr) & 0xff;\n\tib.ptr[3] = 0xDEADBEEF;\n\tib.length_dw = 4;\n\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r) {\n\t\tradeon_ib_free(rdev, &ib);\n\t\tDRM_ERROR("radeon: failed to schedule ib (%d).\\n", r);\n\t\treturn r;\n\t}\n\tr = radeon_fence_wait_timeout(ib.fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR("radeon: fence wait failed (%d).\\n", r);\n\t\treturn r;\n\t} else if (r == 0) {\n\t\tDRM_ERROR("radeon: fence wait timed out.\\n");\n\t\treturn -ETIMEDOUT;\n\t}\n\tr = 0;\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = le32_to_cpu(rdev->wb.wb[index/4]);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tDRM_UDELAY(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO("ib test on ring %d succeeded in %u usecs\\n", ib.fence->ring, i);\n	f
61604	408	phonet_rcv	net/phonet/af_phonet.c	sa.spn_resource	1	13	\N	\N	\tstruct net *net = dev_net(dev);\n\tstruct phonethdr *ph;\n\tstruct sockaddr_pn sa;\n\tu16 len;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\t/* check we have at least a full Phonet header */\n\tif (!pskb_pull(skb, sizeof(struct phonethdr)))\n\t\tgoto out;\n\n\t/* check that the advertised length is correct */\n\tph = pn_hdr(skb);\n\tlen = get_unaligned_be16(&ph->pn_length);\n\tif (len < 2)\n\t\tgoto out;\n\tlen -= 2;\n\tif ((len > skb->len) || pskb_trim(skb, len))\n\t\tgoto out;\n\tskb_reset_transport_header(skb);\n\n\tpn_skb_get_dst_sockaddr(skb, &sa);\n\n\t/* check if this is broadcasted */\n\tif (pn_sockaddr_get_addr(&sa) == PNADDR_BROADCAST) {\n\t\tpn_deliver_sock_broadcast(net, skb);\n\t\tgoto out;\n\t}\n\n\t/* resource routing */\n\tif (pn_sockaddr_get_object(&sa) == 0) {\n\t\tstruct sock *sk = pn_find_sock_by_res(net, sa.spn_resource);\n	f
-603	4234	bnx2x_warpcore_set_sgmii_speed	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	val16	2	3	\N	\N	\tstruct bnx2x *bp = params->bp;\n\tu16 val16, digctrl_kx1, digctrl_kx2;\n\n\t/* Clear XFI clock comp in non-10G single lane mode. */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_RX66_CONTROL, ~(3<<13));\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\tif (always_autoneg || phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t/* SGMII Autoneg */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x1000);\n\t\tDP(NETIF_MSG_LINK, "set SGMII AUTONEG\\n");\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tval16 &= 0xcebf;\n\t\tswitch (phy->req_line_speed) {\n\t\tcase SPEED_10:\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval16 |= 0x2000;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval16 |= 0x0040;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   "Speed not supported: 0x%x\\n", phy->req_line_speed);\n\t\t\treturn;\n\t\t}\n\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tval16 |= 0x0100;\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n	f
31035	380	sm_metadata_count_is_more_than_one	drivers/md/persistent-data/dm-space-map-metadata.c	rc	1	13	\N	\N	\tint r, adjustment = 0;\n\tunsigned i;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\tuint32_t rc;\n\n\t/*\n\t * We may have some uncommitted adjustments to add.  This list\n\t * should always be really short.\n\t */\n\tfor (i = smm->uncommitted.begin;\n\t     i != smm->uncommitted.end;\n\t     i = brb_next(&smm->uncommitted, i)) {\n\n\t\tstruct block_op *op = smm->uncommitted.bops + i;\n\n\t\tif (op->block != b)\n\t\t\tcontinue;\n\n\t\tswitch (op->type) {\n\t\tcase BOP_INC:\n\t\t\tadjustment++;\n\t\t\tbreak;\n\n\t\tcase BOP_DEC:\n\t\t\tadjustment--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (adjustment > 1) {\n\t\t*result = 1;\n\t\treturn 0;\n\t}\n\n\tr = sm_ll_lookup_bitmap(&smm->ll, b, &rc);\n\tif (r)\n\t\treturn r;\n\n\tif (rc == 3)\n	f
54031	523	o2net_debugfs_init	fs/ocfs2/cluster/netdebug.c	o2net_debugfs_init_@nst_dentry $obj	0	13	\N	\N	\tumode_t mode = S_IFREG|S_IRUSR;\n\n\to2net_dentry = debugfs_create_dir(O2NET_DEBUG_DIR, NULL);\n\tif (o2net_dentry)\n\t\tnst_dentry = debugfs_create_file(NST_DEBUG_NAME, mode,\n\t\t\t\t\to2net_dentry, NULL, &nst_seq_fops);\n\tif (nst_dentry)\n	f
40108	1085	dir_split_leaf	fs/gfs2/dir.c	obh->b_data	1	13	\N	\N	\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x, moved = 0;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t/*  Get the old leaf block  */\n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1; /* can't split */\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t/*  Compute the start and len of leaf pointers in the hash table.  */\n\tlen = BIT(dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tpr_warn("i_depth %u lf_depth %u index %u\\n",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t/* Change the pointers.\n\t   Don't bother distinguishing stuffed from non-stuffed.\n\t   This code is complicated enough already. */\n\tlp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t/*  Change the pointers  */\n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t/*  Compute the divider  */\n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t/*  Copy the entries  */\n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n	f
50719	491	f2fs_symlink	fs/f2fs/namei.c	f2fs_symlink_$inode$obj$9$obj	0	13	\N	\N	\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tsize_t len = strlen(symname);\n\tstruct fscrypt_str disk_link = FSTR_INIT((char *)symname, len + 1);\n\tstruct fscrypt_symlink_data *sd = NULL;\n\tint err;\n\n\tif (f2fs_encrypted_inode(dir)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!fscrypt_has_encryption_key(dir))\n\t\t\treturn -ENOKEY;\n\n\t\tdisk_link.len = (fscrypt_fname_encrypted_size(dir, len) +\n\t\t\t\tsizeof(struct fscrypt_symlink_data));\n\t}\n\n\tif (disk_link.len > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (f2fs_encrypted_inode(inode))\n\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\telse\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n	f
50972	285	ingenic_uart_probe	drivers/tty/serial/8250/8250_ingenic.c	&uart	1	13	\N	\N	\tstruct uart_8250_port uart = {};\n\tstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tstruct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tstruct ingenic_uart_data *data;\n\tconst struct ingenic_uart_config *cdata;\n\tconst struct of_device_id *match;\n\tint err, line;\n\n\tmatch = of_match_device(of_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, "Error: No device match found\\n");\n\t\treturn -ENODEV;\n\t}\n\tcdata = match->data;\n\n\tif (!regs || !irq) {\n\t\tdev_err(&pdev->dev, "no registers/irq defined\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&uart.port.lock);\n\tuart.port.type = PORT_16550A;\n\tuart.port.flags = UPF_SKIP_TEST | UPF_IOREMAP | UPF_FIXED_TYPE;\n\tuart.port.iotype = UPIO_MEM;\n\tuart.port.mapbase = regs->start;\n\tuart.port.regshift = 2;\n\tuart.port.serial_out = ingenic_uart_serial_out;\n\tuart.port.serial_in = ingenic_uart_serial_in;\n\tuart.port.irq = irq->start;\n\tuart.port.dev = &pdev->dev;\n\tuart.port.fifosize = cdata->fifosize;\n\tuart.tx_loadsz = cdata->tx_loadsz;\n\tuart.capabilities = UART_CAP_FIFO | UART_CAP_RTOIE;\n\n\t/* Check for a fixed line number */\n\tline = of_alias_get_id(pdev->dev.of_node, "serial");\n\tif (line >= 0)\n\t\tuart.port.line = line;\n\n\tuart.port.membase = devm_ioremap(&pdev->dev, regs->start,\n\t\t\t\t\t resource_size(regs));\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata->clk_module = devm_clk_get(&pdev->dev, "module");\n\tif (IS_ERR(data->clk_module)) {\n\t\terr = PTR_ERR(data->clk_module);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"unable to get module clock: %d\\n", err);\n\t\treturn err;\n\t}\n\n\tdata->clk_baud = devm_clk_get(&pdev->dev, "baud");\n\tif (IS_ERR(data->clk_baud)) {\n\t\terr = PTR_ERR(data->clk_baud);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t"unable to get baud clock: %d\\n", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(data->clk_module);\n\tif (err) {\n\t\tdev_err(&pdev->dev, "could not enable module clock: %d\\n", err);\n\t\tgoto out;\n\t}\n\n\terr = clk_prepare_enable(data->clk_baud);\n\tif (err) {\n\t\tdev_err(&pdev->dev, "could not enable baud clock: %d\\n", err);\n\t\tgoto out_disable_moduleclk;\n\t}\n\tuart.port.uartclk = clk_get_rate(data->clk_baud);\n\n\tdata->line = serial8250_register_8250_port(&uart);\n	f
9416	184	vsock_auto_bind	net/vmw_vsock/af_vsock.c	&local_addr	1	13	\N	\N	\tstruct sock *sk = sk_vsock(vsk);\n\tstruct sockaddr_vm local_addr;\n\n\tif (vsock_addr_bound(&vsk->local_addr))\n\t\treturn 0;\n\tvsock_addr_init(&local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\treturn __vsock_bind(sk, &local_addr);\n	f
52443	1866	acer_wmi_enable_lm	drivers/platform/x86/acer-wmi.c	return_value.error_code	1	13	\N	\N	\tstruct func_return_value return_value;\n\tacpi_status status;\n\tstruct func_input_params params = {\n\t\t.function_num = 0x1,\n\t\t.commun_devices = 0xFFFF,\n\t\t.devices = 0xFFFF,\n\t\t.app_status = 0x01,            /* Launch Manager Active */\n\t\t.app_mask = 0x01,\n\t};\n\n\tstatus = wmid3_set_function_mode(&params, &return_value);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n	f
46111	1121	snd_dummy_probe	sound/drivers/dummy.c	snd_dummy_probe_$card$obj$4$0	0	13	\N	\N	\tstruct snd_card *card;\n\tstruct snd_dummy *dummy;\n\tstruct dummy_model *m = NULL, **mdl;\n\tint idx, err;\n\tint dev = devptr->id;\n\n\terr = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct snd_dummy), &card);\n\tif (err < 0)\n\t\treturn err;\n\tdummy = card->private_data;\n\tdummy->card = card;\n\tfor (mdl = dummy_models; *mdl && model[dev]; mdl++) {\n\t\tif (strcmp(model[dev], (*mdl)->name) == 0) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t"snd-dummy: Using model '%s' for card %i\\n",\n\t\t\t\t(*mdl)->name, card->number);\n\t\t\tm = dummy->model = *mdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {\n\t\tif (pcm_substreams[dev] < 1)\n\t\t\tpcm_substreams[dev] = 1;\n\t\tif (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)\n\t\t\tpcm_substreams[dev] = MAX_PCM_SUBSTREAMS;\n\t\terr = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev]);\n\t\tif (err < 0)\n\t\t\tgoto __nodev;\n\t}\n\n\tdummy->pcm_hw = dummy_pcm_hardware;\n\tif (m) {\n\t\tif (m->formats)\n\t\t\tdummy->pcm_hw.formats = m->formats;\n\t\tif (m->buffer_bytes_max)\n\t\t\tdummy->pcm_hw.buffer_bytes_max = m->buffer_bytes_max;\n\t\tif (m->period_bytes_min)\n\t\t\tdummy->pcm_hw.period_bytes_min = m->period_bytes_min;\n\t\tif (m->period_bytes_max)\n\t\t\tdummy->pcm_hw.period_bytes_max = m->period_bytes_max;\n\t\tif (m->periods_min)\n\t\t\tdummy->pcm_hw.periods_min = m->periods_min;\n\t\tif (m->periods_max)\n\t\t\tdummy->pcm_hw.periods_max = m->periods_max;\n\t\tif (m->rates)\n\t\t\tdummy->pcm_hw.rates = m->rates;\n\t\tif (m->rate_min)\n\t\t\tdummy->pcm_hw.rate_min = m->rate_min;\n\t\tif (m->rate_max)\n\t\t\tdummy->pcm_hw.rate_max = m->rate_max;\n\t\tif (m->channels_min)\n\t\t\tdummy->pcm_hw.channels_min = m->channels_min;\n\t\tif (m->channels_max)\n\t\t\tdummy->pcm_hw.channels_max = m->channels_max;\n\t}\n\n\terr = snd_card_dummy_new_mixer(dummy);\n\tif (err < 0)\n\t\tgoto __nodev;\n\tstrcpy(card->driver, "Dummy");\n\tstrcpy(card->shortname, "Dummy");\n\tsprintf(card->longname, "Dummy %i", dev + 1);\n	f
32007	783	qed_sp_vport_stop	drivers/net/ethernet/qlogic/qed/qed_l2.c	qed_sp_vport_stop_$p_ramrod$obj	0	13	\N	\N	\tstruct vport_stop_ramrod_data *p_ramrod;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tu8 abs_vport_id = 0;\n\tint rc;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn qed_vf_pf_vport_stop(p_hwfn);\n\n\trc = qed_fw_vport(p_hwfn, vport_id, &abs_vport_id);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qed_spq_get_cid(p_hwfn);\n\tinit_data.opaque_fid = opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ETH_RAMROD_VPORT_STOP,\n\t\t\t\t PROTOCOLID_ETH, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.vport_stop;\n\tp_ramrod->vport_id = abs_vport_id;\n	f
50748	650	audit_trim_trees	kernel/audit_tree.c	&path	1	13	\N	\N	\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n	f
57234	593	pci_endpoint_test_remove	drivers/misc/pci_endpoint_test.c	id	1	13	\N	\N	\tint id;\n\tenum pci_barno bar;\n\tstruct pci_endpoint_test *test = pci_get_drvdata(pdev);\n\tstruct miscdevice *misc_device = &test->miscdev;\n\n\tif (sscanf(misc_device->name, DRV_MODULE_NAME ".%d", &id) != 1)\n\t\treturn;\n\n\tmisc_deregister(&test->miscdev);\n\tida_simple_remove(&pci_endpoint_test_ida, id);\n	f
59437	104	lov_putref	drivers/staging/lustre/lustre/lov/lov_obd.c	lov_putref_$__mptr37$obj	0	13	\N	\N	\tstruct lov_obd *lov = &obd->u.lov;\n\n\tmutex_lock(&lov->lov_lock);\n\t/* ok to dec to 0 more than once -- ltd_exp's will be null */\n\tif (atomic_dec_and_test(&lov->lov_refcount) && lov->lov_death_row) {\n\t\tLIST_HEAD(kill);\n\t\tint i;\n\t\tstruct lov_tgt_desc *tgt, *n;\n\n\t\tCDEBUG(D_CONFIG, "destroying %d lov targets\\n",\n\t\t       lov->lov_death_row);\n\t\tfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\n\t\t\ttgt = lov->lov_tgts[i];\n\n\t\t\tif (!tgt || !tgt->ltd_reap)\n\t\t\t\tcontinue;\n\t\t\tlist_add(&tgt->ltd_kill, &kill);\n\t\t\t/* XXX - right now there is a dependency on ld_tgt_count\n\t\t\t * being the maximum tgt index for computing the\n\t\t\t * mds_max_easize. So we can't shrink it.\n\t\t\t */\n\t\t\tlov_ost_pool_remove(&lov->lov_packed, i);\n\t\t\tlov->lov_tgts[i] = NULL;\n\t\t\tlov->lov_death_row--;\n\t\t}\n\t\tmutex_unlock(&lov->lov_lock);\n\n\t\tlist_for_each_entry_safe(tgt, n, &kill, ltd_kill) {\n	f
4413	392	wcove_gpio_dbg_show	drivers/gpio/gpio-wcove.c	ctlo	1	13	\N	\N	\tunsigned int ctlo, ctli, irq_mask, irq_status;\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint gpio, offset, group, ret = 0;\n\n\tfor (gpio = 0; gpio < WCOVE_GPIO_NUM; gpio++) {\n\t\tgroup = gpio < GROUP0_NR_IRQS ? 0 : 1;\n\t\tret += regmap_read(wg->regmap, to_reg(gpio, CTRL_OUT), &ctlo);\n\t\tret += regmap_read(wg->regmap, to_reg(gpio, CTRL_IN), &ctli);\n\t\tret += regmap_read(wg->regmap, IRQ_MASK_BASE + group,\n\t\t\t\t\t\t\t&irq_mask);\n\t\tret += regmap_read(wg->regmap, IRQ_STATUS_BASE + group,\n\t\t\t\t\t\t\t&irq_status);\n\t\tif (ret) {\n\t\t\tpr_err("Failed to read registers: ctrl out/in or irq status/mask\\n");\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = gpio % 8;\n\t\tseq_printf(s, " gpio-%-2d %s %s %s %s ctlo=%2x,%s %s\\n",\n	f
9421	339	mid_power_off_one_device	arch/x86/pci/intel_mid_pci.c	dev	1	13	\N	\N	\tu16 pmcsr;\n\n\t/*\n\t * Update current state first, otherwise PCI core enforces PCI_D0 in\n\t * pci_set_power_state() for devices which status was PCI_UNKNOWN.\n\t */\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\tdev->current_state = (pci_power_t __force)(pmcsr & PCI_PM_CTRL_STATE_MASK);\n\n\tpci_set_power_state(dev, PCI_D3hot);\n	f
26906	424	usb_amradio_init	drivers/media/radio/radio-mr800.c	retval	1	13	\N	\N	\tint retval;\n\n\tretval = amradio_set_mute(radio, true);\n\tif (retval)\n	f
59320	1355	hfi1_dbg_ibdev_init	drivers/infiniband/hw/hfi1/debugfs.c	ibd->hfi1_ibdev_dbg	1	13	\N	\N	\tchar name[sizeof("port0counters") + 1];\n\tchar link[10];\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_pportdata *ppd;\n\tint unit = dd->unit;\n\tint i, j;\n\n\tif (!hfi1_dbg_root)\n\t\treturn;\n\tsnprintf(name, sizeof(name), "%s_%d", class_name(), unit);\n\tsnprintf(link, sizeof(link), "%d", unit);\n\tibd->hfi1_ibdev_dbg = debugfs_create_dir(name, hfi1_dbg_root);\n\tif (!ibd->hfi1_ibdev_dbg) {\n	f
36787	5532	nl80211_dump_mpp	net/wireless/nl80211.c	nl80211_dump_mpp_$wdev$obj$4	0	13	\N	\N	\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n	f
20299	2629	stable_node_chain_remove_range	mm/ksm.c	stable_node_chain_remove_range_$__mptr56$obj	0	13	\N	\N	\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\treturn stable_node_dup_remove_range(stable_node, start_pfn,\n\t\t\t\t\t\t    end_pfn);\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n	f
27311	864	btmrvl_sdio_write_to_clear	drivers/bluetooth/btmrvl_sdio.c	ireg	1	13	\N	\N	\tint ret;\n\n\t*ireg = sdio_readb(card->func, card->reg->host_intstatus, &ret);\n\tif (ret) {\n\t\tBT_ERR("sdio_readb: read int status failed: %d", ret);\n\t\treturn ret;\n\t}\n\n\tif (*ireg) {\n	f
23976	347	sync_file_ioctl_merge	drivers/dma-buf/sync_file.c	data.pad	1	13	\N	\N	\tint fd = get_unused_fd_flags(O_CLOEXEC);\n\tint err;\n\tstruct sync_file *fence2, *fence3;\n\tstruct sync_merge_data data;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (copy_from_user(&data, (void __user *)arg, sizeof(data))) {\n\t\terr = -EFAULT;\n\t\tgoto err_put_fd;\n\t}\n\n\tif (data.flags || data.pad) {\n	f
30441	206	perf_trace_ext4_drop_inode	fs/ext4/super.c	bg->bg_block_bitmap_lo	1	13	\N	\N	\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n	f
39967	1327	mtdswap_add_debugfs	drivers/mtd/mtdswap.c	dent	1	13	\N	\N	\tstruct dentry *root = d->mtd->dbg.dfs_dir;\n\tstruct dentry *dent;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tif (IS_ERR_OR_NULL(root))\n\t\treturn -1;\n\n\tdent = debugfs_create_file("mtdswap_stats", S_IRUSR, root, d,\n\t\t\t\t&mtdswap_fops);\n\tif (!dent) {\n	f
44777	924	mcp794xx_set_alarm	drivers/rtc/rtc-ds1307.c	regs[0]	1	13	\N	\N	\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tunsigned char regs[10];\n\tint ret;\n\n\tif (!test_bit(HAS_ALARM, &ds1307->flags))\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, "%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d "\n\t\t"enabled=%d pending=%d\\n", __func__,\n\t\tt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\n\t\tt->time.tm_wday, t->time.tm_mday, t->time.tm_mon,\n\t\tt->enabled, t->pending);\n\n\t/* Read control and alarm 0 registers. */\n\tret = regmap_bulk_read(ds1307->regmap, MCP794XX_REG_CONTROL, regs,\n\t\t\t       sizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\t/* Set alarm 0, using 24-hour and day-of-month modes. */\n\tregs[3] = bin2bcd(t->time.tm_sec);\n\tregs[4] = bin2bcd(t->time.tm_min);\n\tregs[5] = bin2bcd(t->time.tm_hour);\n\tregs[6] = bin2bcd(t->time.tm_wday + 1);\n\tregs[7] = bin2bcd(t->time.tm_mday);\n\tregs[8] = bin2bcd(t->time.tm_mon + 1);\n\n\t/* Clear the alarm 0 interrupt flag. */\n\tregs[6] &= ~MCP794XX_BIT_ALMX_IF;\n\t/* Set alarm match: second, minute, hour, day, date, month. */\n\tregs[6] |= MCP794XX_MSK_ALMX_MATCH;\n\t/* Disable interrupt. We will not enable until completely programmed */\n\tregs[0] &= ~MCP794XX_BIT_ALM0_EN;\n\n\tret = regmap_bulk_write(ds1307->regmap, MCP794XX_REG_CONTROL, regs,\n\t\t\t\tsizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!t->enabled)\n\t\treturn 0;\n\tregs[0] |= MCP794XX_BIT_ALM0_EN;\n\treturn regmap_write(ds1307->regmap, MCP794XX_REG_CONTROL, regs[0]);\n	f
50648	631	C_SYSC_fcntl64	fs/fcntl.c	&flock	1	13	\N	\N	\tstruct fd f = fdget_raw(fd);\n\tstruct flock flock;\n\tlong err = -EBADF;\n\n\tif (!f.file)\n\t\treturn err;\n\n\tif (unlikely(f.file->f_mode & FMODE_PATH)) {\n\t\tif (!check_fcntl_cmd(cmd))\n\t\t\tgoto out_put;\n\t}\n\n\terr = security_file_fcntl(f.file, cmd, arg);\n\tif (err)\n\t\tgoto out_put;\n\n\tswitch (cmd) {\n\tcase F_GETLK:\n\t\terr = get_compat_flock(&flock, compat_ptr(arg));\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fcntl_getlk(f.file, convert_fcntl_cmd(cmd), &flock);\n	f
60049	850	i40e_set_link_ksettings	drivers/net/ethernet/intel/i40e/i40e_ethtool.c	abilities.link_speed	1	13	\N	\N	\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_aq_set_phy_config config;\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct ethtool_link_ksettings safe_cmd;\n\tstruct ethtool_link_ksettings copy_cmd;\n\ti40e_status status = 0;\n\tbool change = false;\n\tint timeout = 50;\n\tint err = 0;\n\tu32 autoneg;\n\tu32 advertise;\n\tu32 tmp;\n\n\t/* Changing port settings is not supported if this isn't the\n\t * port's controlling PF\n\t */\n\tif (hw->partition_id != 1) {\n\t\ti40e_partition_setting_complaint(pf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vsi != pf->vsi[pf->lan_vsi])\n\t\treturn -EOPNOTSUPP;\n\n\tif (hw->phy.media_type != I40E_MEDIA_TYPE_BASET &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_FIBER &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_BACKPLANE &&\n\t    hw->phy.media_type != I40E_MEDIA_TYPE_DA &&\n\t    hw->phy.link_info.link_info & I40E_AQ_LINK_UP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hw->device_id == I40E_DEV_ID_KX_B ||\n\t    hw->device_id == I40E_DEV_ID_KX_C ||\n\t    hw->device_id == I40E_DEV_ID_20G_KR2 ||\n\t    hw->device_id == I40E_DEV_ID_20G_KR2_A) {\n\t\tnetdev_info(netdev, "Changing settings is not supported on backplane.\\n");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* copy the cmd to copy_cmd to avoid modifying the origin */\n\tmemcpy(&copy_cmd, cmd, sizeof(struct ethtool_link_ksettings));\n\n\t/* get our own copy of the bits to check against */\n\tmemset(&safe_cmd, 0, sizeof(struct ethtool_link_ksettings));\n\ti40e_get_link_ksettings(netdev, &safe_cmd);\n\n\t/* save autoneg and speed out of cmd */\n\tautoneg = cmd->base.autoneg;\n\tethtool_convert_link_mode_to_legacy_u32(&advertise,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\t/* set autoneg and speed back to what they currently are */\n\tcopy_cmd.base.autoneg = safe_cmd.base.autoneg;\n\tethtool_convert_link_mode_to_legacy_u32(\n\t\t&tmp, safe_cmd.link_modes.advertising);\n\tethtool_convert_legacy_u32_to_link_mode(\n\t\tcopy_cmd.link_modes.advertising, tmp);\n\n\tcopy_cmd.base.cmd = safe_cmd.base.cmd;\n\n\t/* If copy_cmd and safe_cmd are not the same now, then they are\n\t * trying to set something that we do not support\n\t */\n\tif (memcmp(&copy_cmd, &safe_cmd, sizeof(struct ethtool_link_ksettings)))\n\t\treturn -EOPNOTSUPP;\n\n\twhile (test_and_set_bit(__I40E_CONFIG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout)\n\t\t\treturn -EBUSY;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t/* Get the current phy config */\n\tstatus = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t      NULL);\n\tif (status) {\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\t/* Copy abilities to config in case autoneg is not\n\t * set below\n\t */\n\tmemset(&config, 0, sizeof(struct i40e_aq_set_phy_config));\n\tconfig.abilities = abilities.abilities;\n\n\t/* Check autoneg */\n\tif (autoneg == AUTONEG_ENABLE) {\n\t\t/* If autoneg was not already enabled */\n\t\tif (!(hw->phy.link_info.an_info & I40E_AQ_AN_COMPLETED)) {\n\t\t\t/* If autoneg is not supported, return error */\n\t\t\tif (!ethtool_link_ksettings_test_link_mode(\n\t\t\t\t    &safe_cmd, supported, Autoneg)) {\n\t\t\t\tnetdev_info(netdev, "Autoneg not supported on this phy\\n");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* Autoneg is allowed to change */\n\t\t\tconfig.abilities = abilities.abilities |\n\t\t\t\t\t   I40E_AQ_PHY_ENABLE_AN;\n\t\t\tchange = true;\n\t\t}\n\t} else {\n\t\t/* If autoneg is currently enabled */\n\t\tif (hw->phy.link_info.an_info & I40E_AQ_AN_COMPLETED) {\n\t\t\t/* If autoneg is supported 10GBASE_T is the only PHY\n\t\t\t * that can disable it, so otherwise return error\n\t\t\t */\n\t\t\tif (ethtool_link_ksettings_test_link_mode(\n\t\t\t\t    &safe_cmd, supported, Autoneg) &&\n\t\t\t    hw->phy.link_info.phy_type !=\n\t\t\t    I40E_PHY_TYPE_10GBASE_T) {\n\t\t\t\tnetdev_info(netdev, "Autoneg cannot be disabled on this phy\\n");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* Autoneg is allowed to change */\n\t\t\tconfig.abilities = abilities.abilities &\n\t\t\t\t\t   ~I40E_AQ_PHY_ENABLE_AN;\n\t\t\tchange = true;\n\t\t}\n\t}\n\n\tethtool_convert_link_mode_to_legacy_u32(&tmp,\n\t\t\t\t\t\tsafe_cmd.link_modes.supported);\n\tif (advertise & ~tmp) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (advertise & ADVERTISED_100baseT_Full)\n\t\tconfig.link_speed |= I40E_LINK_SPEED_100MB;\n\tif (advertise & ADVERTISED_1000baseT_Full ||\n\t    advertise & ADVERTISED_1000baseKX_Full)\n\t\tconfig.link_speed |= I40E_LINK_SPEED_1GB;\n\tif (advertise & ADVERTISED_10000baseT_Full ||\n\t    advertise & ADVERTISED_10000baseKX4_Full ||\n\t    advertise & ADVERTISED_10000baseKR_Full)\n\t\tconfig.link_speed |= I40E_LINK_SPEED_10GB;\n\tif (advertise & ADVERTISED_20000baseKR2_Full)\n\t\tconfig.link_speed |= I40E_LINK_SPEED_20GB;\n\tif (advertise & ADVERTISED_40000baseKR4_Full ||\n\t    advertise & ADVERTISED_40000baseCR4_Full ||\n\t    advertise & ADVERTISED_40000baseSR4_Full ||\n\t    advertise & ADVERTISED_40000baseLR4_Full)\n\t\tconfig.link_speed |= I40E_LINK_SPEED_40GB;\n\n\t/* If speed didn't get set, set it to what it currently is.\n\t * This is needed because if advertise is 0 (as it is when autoneg\n\t * is disabled) then speed won't get set.\n\t */\n\tif (!config.link_speed)\n\t\tconfig.link_speed = abilities.link_speed;\n\n\tif (change || (abilities.link_speed != config.link_speed)) {\n	f
63030	310	s5k6a3_probe	drivers/media/i2c/s5k6a3.c	s5k6a3_probe_	1	13	\N	\N	\tstruct device *dev = &client->dev;\n\tstruct s5k6a3 *sensor;\n\tstruct v4l2_subdev *sd;\n\tint gpio, i, ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sensor->lock);\n\tsensor->gpio_reset = -EINVAL;\n\tsensor->clock = ERR_PTR(-EINVAL);\n\tsensor->dev = dev;\n\n\tsensor->clock = devm_clk_get(sensor->dev, S5K6A3_CLK_NAME);\n\tif (IS_ERR(sensor->clock))\n\t\treturn PTR_ERR(sensor->clock);\n\n\tgpio = of_get_gpio_flags(dev->of_node, 0, NULL);\n\tif (!gpio_is_valid(gpio))\n\t\treturn gpio;\n\n\tret = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_LOW,\n\t\t\t\t\t\tS5K6A3_DRV_NAME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsensor->gpio_reset = gpio;\n\n\tif (of_property_read_u32(dev->of_node, "clock-frequency",\n	f
-501	1313	moxa_tiocmset	drivers/tty/moxa.c	rts	1000	3	\N	\N	\tstruct moxa_port *ch;\n\tint dtr, rts;\n\n\tmutex_lock(&moxa_openlock);\n\tch = tty->driver_data;\n\tif (!ch) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -EINVAL;\n\t}\n\n\tMoxaPortGetLineOut(ch, &dtr, &rts);\n\tif (set & TIOCM_RTS)\n\t\trts = 1;\n\tif (set & TIOCM_DTR)\n\t\tdtr = 1;\n\tif (clear & TIOCM_RTS)\n\t\trts = 0;\n\tif (clear & TIOCM_DTR)\n\t\tdtr = 0;\n\tMoxaPortLineCtrl(ch, dtr, rts);\n	f
30393	51	sdio_read_fbr	drivers/mmc/core/sdio.c	data	1	13	\N	\N	\tint ret;\n\tunsigned char data;\n\n\tif (mmc_card_nonstd_func_interface(func->card)) {\n\t\tfunc->class = SDIO_CLASS_NONE;\n\t\treturn 0;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, 0,\n\t\tSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);\n\tif (ret)\n\t\tgoto out;\n\n\tdata &= 0x0f;\n\n\tif (data == 0x0f) {\n	f
39060	2048	e1000_get_phy_info_ife	drivers/net/ethernet/intel/e1000e/phy.c	hw	1	13	\N	\N	\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!link) {\n\t\te_dbg("Phy info is only valid if link is up\\n");\n\t\treturn -E1000_ERR_CONFIG;\n\t}\n\n\tret_val = e1e_rphy(hw, IFE_PHY_SPECIAL_CONTROL, &data);\n\tif (ret_val)\n\t\treturn ret_val;\n\tphy->polarity_correction = !(data & IFE_PSC_AUTO_POLARITY_DISABLE);\n\n\tif (phy->polarity_correction) {\n\t\tret_val = e1000_check_polarity_ife(hw);\n	f
5079	168	tps65910_rtc_read_alarm	drivers/rtc/rtc-tps65910.c	int_val	1	13	\N	\N	\tunsigned char alarm_data[NUM_TIME_REGS];\n\tu32 int_val;\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tret = regmap_bulk_read(tps->regmap, TPS65910_SECONDS, alarm_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, "rtc_read_alarm error %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\talm->time.tm_sec = bcd2bin(alarm_data[0]);\n\talm->time.tm_min = bcd2bin(alarm_data[1]);\n\talm->time.tm_hour = bcd2bin(alarm_data[2]);\n\talm->time.tm_mday = bcd2bin(alarm_data[3]);\n\talm->time.tm_mon = bcd2bin(alarm_data[4]) - 1;\n\talm->time.tm_year = bcd2bin(alarm_data[5]) + 100;\n\n\tret = regmap_read(tps->regmap, TPS65910_RTC_INTERRUPTS, &int_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (int_val & TPS65910_RTC_INTERRUPTS_IT_ALARM)\n	f
41393	450	snd_cx231xx_capture_open	drivers/media/usb/cx231xx/cx231xx-audio.c	ret	1	13	\N	\N	\tstruct cx231xx *dev = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret = 0;\n\n\tdev_dbg(dev->dev,\n\t\t"opening device and trying to acquire exclusive lock\\n");\n\n\tif (dev->state & DEV_DISCONNECTED) {\n\t\tdev_err(dev->dev,\n\t\t\t"Can't open. the device was removed.\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/* set alternate setting for audio interface */\n\t/* 1 - 48000 samples per sec */\n\tmutex_lock(&dev->lock);\n\tif (dev->USE_ISO)\n\t\tret = cx231xx_set_alt_setting(dev, INDEX_AUDIO, 1);\n\telse\n\t\tret = cx231xx_set_alt_setting(dev, INDEX_AUDIO, 0);\n\tmutex_unlock(&dev->lock);\n\tif (ret < 0) {\n	f
54890	89	chacha20_simd	arch/x86/crypto/chacha20_glue.c	&walk	1	13	\N	\N	\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct chacha20_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tu32 *state, state_buf[16 + 2] __aligned(8);\n\tstruct skcipher_walk walk;\n\tint err;\n\n\tBUILD_BUG_ON(CHACHA20_STATE_ALIGN != 16);\n\tstate = PTR_ALIGN(state_buf + 0, CHACHA20_STATE_ALIGN);\n\n\tif (req->cryptlen <= CHACHA20_BLOCK_SIZE || !may_use_simd())\n\t\treturn crypto_chacha20_crypt(req);\n\n\terr = skcipher_walk_virt(&walk, req, true);\n\n\tcrypto_chacha20_init(state, ctx, walk.iv);\n\n\tkernel_fpu_begin();\n\n\twhile (walk.nbytes >= CHACHA20_BLOCK_SIZE) {\n\t\tchacha20_dosimd(state, walk.dst.virt.addr, walk.src.virt.addr,\n\t\t\t\trounddown(walk.nbytes, CHACHA20_BLOCK_SIZE));\n\t\terr = skcipher_walk_done(&walk,\n	f
-1063	3025	ilk_validate_pipe_wm	drivers/gpu/drm/i915/intel_pm.c	&max	2	3	\N	\N	\t/* LP0 watermark maximums depend on this pipe alone */\n\tconst struct intel_wm_config config = {\n\t\t.num_pipes_active = 1,\n\t\t.sprites_enabled = pipe_wm->sprites_enabled,\n\t\t.sprites_scaled = pipe_wm->sprites_scaled,\n\t};\n\tstruct ilk_wm_maximums max;\n\n\t/* LP0 watermarks always use 1/2 DDB partitioning */\n\tilk_compute_wm_maximums(dev, 0, &config, INTEL_DDB_PART_1_2, &max);\n\n\t/* At least LP0 must be valid */\n\tif (!ilk_validate_wm_level(0, &max, &pipe_wm->wm[0])) {\n	f
-1062	1043	set_pwm_auto_channels	drivers/hwmon/lm85.c	val	2	3	\N	\N	\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].config = (data->autofan[nr].config & (~0xe0))\n\t\t| ZONE_TO_REG(val);\n	f
-1000	2252	hv_pci_enter_d0	drivers/pci/host/pci-hyperv.c	comp_pkt.completion_status	40	2	var_name	\N	\tstruct hv_pcibus_device *hbus = hv_get_drvdata(hdev);\n\tstruct pci_bus_d0_entry *d0_entry;\n\tstruct hv_pci_compl comp_pkt;\n\tstruct pci_packet *pkt;\n\tint ret;\n\n\t/*\n\t * Tell the host that the bus is ready to use, and moved into the\n\t * powered-on state.  This includes telling the host which region\n\t * of memory-mapped I/O space has been chosen for configuration space\n\t * access.\n\t */\n\tpkt = kzalloc(sizeof(*pkt) + sizeof(*d0_entry), GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&comp_pkt.host_event);\n\tpkt->completion_func = hv_pci_generic_compl;\n\tpkt->compl_ctxt = &comp_pkt;\n\td0_entry = (struct pci_bus_d0_entry *)&pkt->message;\n\td0_entry->message_type.type = PCI_BUS_D0ENTRY;\n\td0_entry->mmio_base = hbus->mem_config->start;\n\n\tret = vmbus_sendpacket(hdev->channel, d0_entry, sizeof(*d0_entry),\n\t\t\t       (unsigned long)pkt, VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret)\n\t\tgoto exit;\n\n\twait_for_completion(&comp_pkt.host_event);\n\n\tif (comp_pkt.completion_status < 0) {\n	f
31655	201	describe_obj	drivers/gpu/drm/i915/i915_debugfs.c	engine->name	1	13	\N	\N	\tstruct drm_i915_private *dev_priv = to_i915(obj->base.dev);\n\tstruct intel_engine_cs *engine;\n\tstruct i915_vma *vma;\n\tunsigned int frontbuffer_bits;\n\tint pin_count = 0;\n\n\tlockdep_assert_held(&obj->base.dev->struct_mutex);\n\n\tseq_printf(m, "%pK: %c%c%c%c%c %8zdKiB %02x %02x %s%s%s",\n\t\t   &obj->base,\n\t\t   get_active_flag(obj),\n\t\t   get_pin_flag(obj),\n\t\t   get_tiling_flag(obj),\n\t\t   get_global_flag(obj),\n\t\t   get_pin_mapped_flag(obj),\n\t\t   obj->base.size / 1024,\n\t\t   obj->base.read_domains,\n\t\t   obj->base.write_domain,\n\t\t   i915_cache_level_str(dev_priv, obj->cache_level),\n\t\t   obj->mm.dirty ? " dirty" : "",\n\t\t   obj->mm.madv == I915_MADV_DONTNEED ? " purgeable" : "");\n\tif (obj->base.name)\n\t\tseq_printf(m, " (name: %d)", obj->base.name);\n\tlist_for_each_entry(vma, &obj->vma_list, obj_link) {\n\t\tif (i915_vma_is_pinned(vma))\n\t\t\tpin_count++;\n\t}\n\tseq_printf(m, " (pinned x %d)", pin_count);\n\tif (obj->pin_display)\n\t\tseq_printf(m, " (display)");\n\tlist_for_each_entry(vma, &obj->vma_list, obj_link) {\n\t\tif (!drm_mm_node_allocated(&vma->node))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, " (%sgtt offset: %08llx, size: %08llx",\n\t\t\t   i915_vma_is_ggtt(vma) ? "g" : "pp",\n\t\t\t   vma->node.start, vma->node.size);\n\t\tif (i915_vma_is_ggtt(vma)) {\n\t\t\tswitch (vma->ggtt_view.type) {\n\t\t\tcase I915_GGTT_VIEW_NORMAL:\n\t\t\t\tseq_puts(m, ", normal");\n\t\t\t\tbreak;\n\n\t\t\tcase I915_GGTT_VIEW_PARTIAL:\n\t\t\t\tseq_printf(m, ", partial [%08llx+%x]",\n\t\t\t\t\t   vma->ggtt_view.partial.offset << PAGE_SHIFT,\n\t\t\t\t\t   vma->ggtt_view.partial.size << PAGE_SHIFT);\n\t\t\t\tbreak;\n\n\t\t\tcase I915_GGTT_VIEW_ROTATED:\n\t\t\t\tseq_printf(m, ", rotated [(%ux%u, stride=%u, offset=%u), (%ux%u, stride=%u, offset=%u)]",\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[0].width,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[0].height,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[0].stride,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[0].offset,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[1].width,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[1].height,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[1].stride,\n\t\t\t\t\t   vma->ggtt_view.rotated.plane[1].offset);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tMISSING_CASE(vma->ggtt_view.type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (vma->fence)\n\t\t\tseq_printf(m, " , fence: %d%s",\n\t\t\t\t   vma->fence->id,\n\t\t\t\t   i915_gem_active_isset(&vma->last_fence) ? "*" : "");\n\t\tseq_puts(m, ")");\n\t}\n\tif (obj->stolen)\n\t\tseq_printf(m, " (stolen: %08llx)", obj->stolen->start);\n\n\tengine = i915_gem_object_last_write_engine(obj);\n\tif (engine)\n\t\tseq_printf(m, " (%s)", engine->name);\n	f
55501	339	ntfs_get_parent	fs/ntfs/namei.c	ntfs_get_parent_$attr$obj$1	0	13	\N	\N	\tstruct inode *vi = d_inode(child_dent);\n\tntfs_inode *ni = NTFS_I(vi);\n\tMFT_RECORD *mrec;\n\tntfs_attr_search_ctx *ctx;\n\tATTR_RECORD *attr;\n\tFILE_NAME_ATTR *fn;\n\tunsigned long parent_ino;\n\tint err;\n\n\tntfs_debug("Entering for inode 0x%lx.", vi->i_ino);\n\t/* Get the mft record of the inode belonging to the child dentry. */\n\tmrec = map_mft_record(ni);\n\tif (IS_ERR(mrec))\n\t\treturn (struct dentry *)mrec;\n\t/* Find the first file name attribute in the mft record. */\n\tctx = ntfs_attr_get_search_ctx(ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tunmap_mft_record(ni);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\ntry_next:\n\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, "Inode 0x%lx does not have a "\n\t\t\t\t\t"file name attribute.  Run chkdsk.",\n\t\t\t\t\tvi->i_ino);\n\t\treturn ERR_PTR(err);\n\t}\n\tattr = ctx->attr;\n\tif (unlikely(attr->non_resident))\n\t\tgoto try_next;\n\tfn = (FILE_NAME_ATTR *)((u8 *)attr +\n\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\tif (unlikely((u8 *)fn + le32_to_cpu(attr->data.resident.value_length) >\n	f
40203	725	stir_send	drivers/staging/irda/drivers/stir4200.c	stir_send_	1	13	\N	\N	\tunsigned wraplen;\n\tint first_frame = 0;\n\n\t/* if receiving, need to turnaround */\n\tif (stir->receiving) {\n\t\treceive_stop(stir);\n\t\tturnaround_delay(stir, irda_get_mtt(skb));\n\t\tfirst_frame = 1;\n\t}\n\n\tif (isfir(stir->speed))\n\t\twraplen = wrap_fir_skb(skb, stir->io_buf);\n\telse\n\t\twraplen = wrap_sir_skb(skb, stir->io_buf);\n\t\t\n\t/* check for space available in fifo */\n\tif (!first_frame)\n\t\tfifo_txwait(stir, wraplen);\n\n\tstir->netdev->stats.tx_packets++;\n\tstir->netdev->stats.tx_bytes += skb->len;\n\tnetif_trans_update(stir->netdev);\n\tpr_debug("send %d (%d)\\n", skb->len, wraplen);\n\n\tif (usb_bulk_msg(stir->usbdev, usb_sndbulkpipe(stir->usbdev, 1),\n	f
-615	158	acpi_smbus_transaction	drivers/acpi/sbshc.c	sz	2	3	\N	\N	\tint ret = -EFAULT, i;\n\tu8 temp, sz = 0;\n\n\tif (!hc) {\n\t\tprintk(KERN_ERR PREFIX "host controller is not configured\\n");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&hc->lock);\n\thc->done = false;\n\tif (smb_hc_read(hc, ACPI_SMB_PROTOCOL, &temp))\n\t\tgoto end;\n\tif (temp) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_COMMAND, command);\n\tif (!(protocol & 0x01)) {\n\t\tsmb_hc_write(hc, ACPI_SMB_BLOCK_COUNT, length);\n\t\tfor (i = 0; i < length; ++i)\n\t\t\tsmb_hc_write(hc, ACPI_SMB_DATA + i, data[i]);\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_ADDRESS, address << 1);\n\tsmb_hc_write(hc, ACPI_SMB_PROTOCOL, protocol);\n\t/*\n\t * Wait for completion. Save the status code, data size,\n\t * and data into the return package (if required by the protocol).\n\t */\n\tret = wait_transaction_complete(hc, 1000);\n\tif (ret || !(protocol & 0x01))\n\t\tgoto end;\n\tswitch (protocol) {\n\tcase SMBUS_RECEIVE_BYTE:\n\tcase SMBUS_READ_BYTE:\n\t\tsz = 1;\n\t\tbreak;\n\tcase SMBUS_READ_WORD:\n\t\tsz = 2;\n\t\tbreak;\n\tcase SMBUS_READ_BLOCK:\n\t\tif (smb_hc_read(hc, ACPI_SMB_BLOCK_COUNT, &sz)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto end;\n\t\t}\n\t\tsz &= 0x1f;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < sz; ++i)\n	f
20626	227	keyctl_dh_compute_kdf	security/keys/dh.c	ret	1	13	\N	\N	\tuint8_t *outbuf = NULL;\n\tint ret;\n\n\toutbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = kdf_ctr(sdesc, kbuf, kbuflen, outbuf, buflen, lzero);\n\tif (ret)\n	f
24801	224	fscrypt_has_permitted_context	fs/crypto/policy.c	child_ctx.flags	1	13	\N	\N	\tconst struct fscrypt_operations *cops = parent->i_sb->s_cop;\n\tconst struct fscrypt_info *parent_ci, *child_ci;\n\tstruct fscrypt_context parent_ctx, child_ctx;\n\tint res;\n\n\t/* No restrictions on file types which are never encrypted */\n\tif (!S_ISREG(child->i_mode) && !S_ISDIR(child->i_mode) &&\n\t    !S_ISLNK(child->i_mode))\n\t\treturn 1;\n\n\t/* No restrictions if the parent directory is unencrypted */\n\tif (!cops->is_encrypted(parent))\n\t\treturn 1;\n\n\t/* Encrypted directories must not contain unencrypted files */\n\tif (!cops->is_encrypted(child))\n\t\treturn 0;\n\n\t/*\n\t * Both parent and child are encrypted, so verify they use the same\n\t * encryption policy.  Compare the fscrypt_info structs if the keys are\n\t * available, otherwise retrieve and compare the fscrypt_contexts.\n\t *\n\t * Note that the fscrypt_context retrieval will be required frequently\n\t * when accessing an encrypted directory tree without the key.\n\t * Performance-wise this is not a big deal because we already don't\n\t * really optimize for file access without the key (to the extent that\n\t * such access is even possible), given that any attempted access\n\t * already causes a fscrypt_context retrieval and keyring search.\n\t *\n\t * In any case, if an unexpected error occurs, fall back to "forbidden".\n\t */\n\n\tres = fscrypt_get_encryption_info(parent);\n\tif (res)\n\t\treturn 0;\n\tres = fscrypt_get_encryption_info(child);\n\tif (res)\n\t\treturn 0;\n\tparent_ci = parent->i_crypt_info;\n\tchild_ci = child->i_crypt_info;\n\n\tif (parent_ci && child_ci) {\n\t\treturn memcmp(parent_ci->ci_master_key, child_ci->ci_master_key,\n\t\t\t      FS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t\t(parent_ci->ci_data_mode == child_ci->ci_data_mode) &&\n\t\t\t(parent_ci->ci_filename_mode ==\n\t\t\t child_ci->ci_filename_mode) &&\n\t\t\t(parent_ci->ci_flags == child_ci->ci_flags);\n\t}\n\n\tres = cops->get_context(parent, &parent_ctx, sizeof(parent_ctx));\n\tif (res != sizeof(parent_ctx))\n\t\treturn 0;\n\n\tres = cops->get_context(child, &child_ctx, sizeof(child_ctx));\n\tif (res != sizeof(child_ctx))\n\t\treturn 0;\n\n\treturn memcmp(parent_ctx.master_key_descriptor,\n\t\t      child_ctx.master_key_descriptor,\n\t\t      FS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t(parent_ctx.contents_encryption_mode ==\n\t\t child_ctx.contents_encryption_mode) &&\n\t\t(parent_ctx.filenames_encryption_mode ==\n\t\t child_ctx.filenames_encryption_mode) &&\n	f
-1057	435	da9052_adc_read_temp	drivers/mfd/da9052-core.c	tbat	2	3	\N	\N	\tint tbat;\n\n\ttbat = da9052_reg_read(da9052, DA9052_TBAT_RES_REG);\n\tif (tbat <= 0)\n	f
-1056	1443	store_temp_auto_boost	drivers/hwmon/lm93.c	val	2	3	\N	\N	\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->boost[nr] = LM93_TEMP_TO_REG(val);\n	f
-1053	52	nfcmrvl_i2c_read	drivers/nfc/nfcmrvl/i2c.c	nci_hdr.plen	2	3	\N	\N	\tint ret;\n\tstruct nci_ctrl_hdr nci_hdr;\n\n\t/* Read NCI header to know the payload size */\n\tret = i2c_master_recv(drv_data->i2c, (u8 *)&nci_hdr, NCI_CTRL_HDR_SIZE);\n\tif (ret != NCI_CTRL_HDR_SIZE) {\n\t\tnfc_err(&drv_data->i2c->dev, "cannot read NCI header\\n");\n\t\treturn -EBADMSG;\n\t}\n\n\tif (nci_hdr.plen > NCI_MAX_PAYLOAD_SIZE) {\n	f
-1052	307	prepare_exec_creds	kernel/cred.c	new->process_keyring	2	3	\N	\N	\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n	f
-1050	1067	aif1clk_ev	sound/soc/codecs/wm8994.c	val	2	3	\N	\N	\tstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\n\tstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint mask = WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA;\n\tint i;\n\tint dac;\n\tint adc;\n\tint val;\n\n\tswitch (control->type) {\n\tcase WM8994:\n\tcase WM8958:\n\t\tmask |= WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t/* Don't enable timeslot 2 if not in use */\n\t\tif (wm8994->channels[0] <= 2)\n\t\t\tmask &= ~(WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);\n\n\t\tval = snd_soc_read(codec, WM8994_AIF1_CONTROL_1);\n\t\tif ((val & WM8994_AIF1ADCL_SRC) &&\n	f
-1049	2268	psb_intel_sdvo_tv_create_property	drivers/gpu/drm/gma500/psb_intel_sdvo.c	format_map	2	3	\N	\N	\tstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\n\tstruct psb_intel_sdvo_tv_format format;\n\tuint32_t format_map, i;\n\n\tif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, type))\n\t\treturn false;\n\n\tBUILD_BUG_ON(sizeof(format) != 6);\n\tif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\n\t\t\t\t  SDVO_CMD_GET_SUPPORTED_TV_FORMATS,\n\t\t\t\t  &format, sizeof(format)))\n\t\treturn false;\n\n\tmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\n\n\tif (format_map == 0)\n	f
-1048	681	ov8858_g_comp_delay	drivers/staging/media/atomisp/i2c/ov8858.c	usec	2	3	\N	\N	\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov8858_device *dev = to_ov8858_sensor(sd);\n\tint ret = 0, exposure;\n\tu16 vts, data;\n\n\tif (dev->exposure == 0) {\n\t\tret = ov8858_read_reg(client, OV8858_16BIT,\n\t\t\t\t       OV8858_LONG_EXPO + 1, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\texposure = data;\n\t\texposure >>= 4;\n\t} else {\n\t\texposure = dev->exposure;\n\t}\n\n\tret = ov8858_read_reg(client, OV8858_16BIT, OV8858_TIMING_VTS, &vts);\n\tif (ret || vts == 0)\n\t\tvts = OV8858_DEPTH_VTS_CONST;\n\n\t*usec = (exposure * 33333 / vts);\n\tif (*usec >  OV8858_DEPTH_COMP_CONST)\n	f
-1043	388	mlx5_get_roce_udp_sport	drivers/infiniband/hw/mlx5/main.c	attr.gid_type	2	3	\N	\N	\tstruct ib_gid_attr attr;\n\tunion ib_gid gid;\n\n\tif (ib_get_cached_gid(&dev->ib_dev, port_num, index, &gid, &attr))\n\t\treturn 0;\n\n\tif (!attr.ndev)\n\t\treturn 0;\n\n\tdev_put(attr.ndev);\n\n\tif (attr.gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)\n	f
-1037	1299	spmi_regulator_init_slew_rate	drivers/regulator/qcom_spmi-regulator.c	ret	2	3	\N	\N	\tint ret;\n\tu8 reg = 0;\n\tint step, delay, slew_rate, step_delay;\n\tconst struct spmi_voltage_range *range;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);\n\tif (ret) {\n	f
-1030	4271	b43_nphy_tx_gain_table_upload	drivers/net/wireless/broadcom/b43/phy_n.c	rf_pwr_offset_table	2	3	\N	\N	\tstruct b43_phy *phy = &dev->phy;\n\n\tconst u32 *table = NULL;\n\tu32 rfpwr_offset;\n\tu8 pga_gain, pad_gain;\n\tint i;\n\tconst s16 *uninitialized_var(rf_pwr_offset_table);\n\n\ttable = b43_nphy_get_tx_gain_table(dev);\n\tif (!table)\n\t\treturn;\n\n\tb43_ntab_write_bulk(dev, B43_NTAB32(26, 192), 128, table);\n\tb43_ntab_write_bulk(dev, B43_NTAB32(27, 192), 128, table);\n\n\tif (phy->rev < 3)\n\t\treturn;\n\n#if 0\n\tnphy->gmval = (table[0] >> 16) & 0x7000;\n#endif\n\n\tif (phy->rev >= 19) {\n\t\treturn;\n\t} else if (phy->rev >= 7) {\n\t\trf_pwr_offset_table = b43_ntab_get_rf_pwr_offset_table(dev);\n\t\tif (!rf_pwr_offset_table)\n\t\t\treturn;\n\t\t/* TODO: Enable this once we have gains configured */\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 128; i++) {\n\t\tif (phy->rev >= 19) {\n\t\t\t/* TODO */\n\t\t\treturn;\n\t\t} else if (phy->rev >= 7) {\n\t\t\tpga_gain = (table[i] >> 24) & 0xf;\n\t\t\tpad_gain = (table[i] >> 19) & 0x1f;\n\t\t\tif (b43_current_band(dev->wl) == NL80211_BAND_2GHZ)\n\t\t\t\trfpwr_offset = rf_pwr_offset_table[pad_gain];\n	f
-1031	2432	intel_haswell_fixup_enable_dp12	sound/pci/hda/patch_hdmi.c	vendor_param	2	3	\N	\N	\tunsigned int vendor_param;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\n	f
-1028	530	max_write_buffer_kb_store	drivers/staging/comedi/comedi_fops.c	size	2	3	\N	\N	\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n	f
-1027	643	iomap_seek_data_actor	fs/iomap.c	offset	2	3	\N	\N	\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\treturn length;\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_DATA);\n\t\tif (offset < 0)\n	f
-1025	95	max77693_get_charge_type	drivers/power/supply/max77693_charger.c	data	2	3	\N	\N	\tint ret;\n\tunsigned int data;\n\n\tret = regmap_read(regmap, MAX77693_CHG_REG_CHG_DETAILS_01, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata &= CHG_DETAILS_01_CHG_MASK;\n\tdata >>= CHG_DETAILS_01_CHG_SHIFT;\n\n\tswitch (data) {\n	f
-1024	335	axp288_charger_is_online	drivers/power/supply/axp288_charger.c	val	2	3	\N	\N	\tint ret, online = 0;\n\tunsigned int val;\n\n\tret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & PS_STAT_VBUS_VALID)\n	f
-1023	989	smb347_usb_get_property	drivers/power/supply/smb347-charger.c	ret	2	3	\N	\N	\tstruct smb347_charger *smb = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = smb->usb_online;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = get_const_charge_voltage(smb);\n\t\tif (ret < 0)\n	f
-1022	77	axp20x_battery_get_max_voltage	drivers/power/supply/axp20x_battery.c	reg	2	3	\N	\N	\tint ret, reg;\n\n\tret = regmap_read(axp20x_batt->regmap, AXP20X_CHRG_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & AXP20X_CHRG_CTRL1_TGT_VOLT) {\n	f
-1012	97	ds1374_read_rtc	drivers/rtc/rtc-ds1374.c	ret	2	3	\N	\N	\tu8 buf[4];\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(nbytes > 4))\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, nbytes, buf);\n\n\tif (ret < 0)\n	f
-1010	109	mtk_rtc_irq_handler_thread	drivers/rtc/rtc-mt6397.c	irqsta	2	3	\N	\N	\tstruct mt6397_rtc *rtc = data;\n\tu32 irqsta, irqen;\n\tint ret;\n\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_IRQ_STA, &irqsta);\n\tif ((ret >= 0) && (irqsta & RTC_IRQ_STA_AL)) {\n	f
-1020	888	acpi_turn_off_unused_power_resources	drivers/acpi/power.c	state	2	3	\N	\N	\tstruct acpi_power_resource *resource;\n\n\tmutex_lock(&power_resource_list_lock);\n\n\tlist_for_each_entry_reverse(resource, &acpi_power_resource_list, list_node) {\n\t\tint result, state;\n\n\t\tmutex_lock(&resource->resource_lock);\n\n\t\tresult = acpi_power_get_state(resource->device.handle, &state);\n\t\tif (result) {\n\t\t\tmutex_unlock(&resource->resource_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state == ACPI_POWER_RESOURCE_STATE_ON\n	f
-1018	441	vl6180_init	drivers/iio/light/vl6180.c	ret	2	3	\N	\N	\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = vl6180_read_byte(client, VL6180_MODEL_ID);\n\tif (ret < 0)\n	f
-1014	252	wm831x_rtc_readalarm	drivers/rtc/rtc-wm831x.c	time	2	3	\N	\N	\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu16 data[2];\n\tu32 time;\n\n\tret = wm831x_bulk_read(wm831x_rtc->wm831x, WM831X_RTC_ALARM_1,\n\t\t\t       2, data);\n\tif (ret != 0) {\n\t\tdev_err(dev, "Failed to read alarm time: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\ttime = (data[0] << 16) | data[1];\n\n\trtc_time_to_tm(time, &alrm->time);\n	f
-1072	235	wep_encrypt	drivers/staging/wlan-ng/p80211wep.c	iv	2	3	\N	\N	\tu32 i, j, k, crc, keylen;\n\tu8 s[256], key[64];\n\n\t/* no point in WEPping an empty frame */\n\tif (len <= 0)\n\t\treturn -1;\n\n\t/* we need to have a real key.. */\n\tif (keynum >= NUM_WEPKEYS)\n\t\treturn -2;\n\tkeylen = wlandev->wep_keylens[keynum];\n\tif (keylen <= 0)\n\t\treturn -3;\n\n\t/* use a random IV.  And skip known weak ones. */\n\tget_random_bytes(iv, 3);\n\twhile ((iv[1] == 0xff) && (iv[0] >= 3) && (iv[0] < keylen))\n	f
-1006	2771	efx_farch_filter_table_restore	drivers/net/ethernet/sfc/farch.c	&filter	2	3	\N	\N	\tstruct efx_farch_filter_state *state = efx->filter_state;\n\tenum efx_farch_filter_table_id table_id;\n\tstruct efx_farch_filter_table *table;\n\tefx_oword_t filter;\n\tunsigned int filter_idx;\n\n\tspin_lock_bh(&efx->filter_lock);\n\n\tfor (table_id = 0; table_id < EFX_FARCH_FILTER_TABLE_COUNT; table_id++) {\n\t\ttable = &state->table[table_id];\n\n\t\t/* Check whether this is a regular register table */\n\t\tif (table->step == 0)\n\t\t\tcontinue;\n\n\t\tfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\n\t\t\tif (!test_bit(filter_idx, table->used_bitmap))\n\t\t\t\tcontinue;\n\t\t\tefx_farch_filter_build(&filter, &table->spec[filter_idx]);\n	f
-1004	821	arizona_of_get_core_pdata	drivers/mfd/arizona-core.c	ret	2	3	\N	\N	\tstruct arizona_pdata *pdata = &arizona->pdata;\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tu32 val;\n\tu32 pdm_val[ARIZONA_MAX_PDM_SPK];\n\tint ret, i;\n\tint count = 0;\n\n\tpdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);\n\tif (pdata->reset == -EPROBE_DEFER) {\n\t\treturn pdata->reset;\n\t} else if (pdata->reset < 0) {\n\t\tdev_err(arizona->dev, "Reset GPIO missing/malformed: %d\\n",\n\t\t\tpdata->reset);\n\n\t\tpdata->reset = 0;\n\t}\n\n\tret = of_property_read_u32_array(arizona->dev->of_node,\n\t\t\t\t\t "wlf,gpio-defaults",\n\t\t\t\t\t pdata->gpio_defaults,\n\t\t\t\t\t ARRAY_SIZE(pdata->gpio_defaults));\n\tif (ret >= 0) {\n	f
-519	3977	extent_write_cache_pages	fs/btrfs/extent_io.c	page->index	1000	3	\N	\N	\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n	f
-1001	1417	setup_crash_devices_work_queue	drivers/staging/unisys/visorbus/visorchipset.c	&local_crash_dev_msg	2	3	\N	\N	\tstruct controlvm_message local_crash_bus_msg;\n\tstruct controlvm_message local_crash_dev_msg;\n\tstruct controlvm_message msg;\n\tu32 local_crash_msg_offset;\n\tu16 local_crash_msg_count;\n\n\t/* send init chipset msg */\n\tmsg.hdr.id = CONTROLVM_CHIPSET_INIT;\n\tmsg.cmd.init_chipset.bus_count = 23;\n\tmsg.cmd.init_chipset.switch_count = 0;\n\n\tchipset_init(&msg);\n\n\t/* get saved message count */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      offsetof(struct visor_controlvm_channel,\n\t\t\t\t       saved_crash_message_count),\n\t\t\t      &local_crash_msg_count, sizeof(u16)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\tif (local_crash_msg_count != CONTROLVM_CRASHMSG_MAX) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"invalid count\\n");\n\t\treturn;\n\t}\n\n\t/* get saved crash message offset */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      offsetof(struct visor_controlvm_channel,\n\t\t\t\t       saved_crash_message_offset),\n\t\t\t      &local_crash_msg_offset, sizeof(u32)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* read create device message for storage bus offset */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      local_crash_msg_offset,\n\t\t\t      &local_crash_bus_msg,\n\t\t\t      sizeof(struct controlvm_message)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* read create device message for storage device */\n\tif (visorchannel_read(chipset_dev->controlvm_channel,\n\t\t\t      local_crash_msg_offset +\n\t\t\t      sizeof(struct controlvm_message),\n\t\t\t      &local_crash_dev_msg,\n\t\t\t      sizeof(struct controlvm_message)) < 0) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"failed to read channel\\n");\n\t\treturn;\n\t}\n\n\t/* reuse IOVM create bus message */\n\tif (!local_crash_bus_msg.cmd.create_bus.channel_addr) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"no valid create_bus message\\n");\n\t\treturn;\n\t}\n\tvisorbus_create(&local_crash_bus_msg);\n\n\t/* reuse create device message for storage device */\n\tif (!local_crash_dev_msg.cmd.create_device.channel_addr) {\n\t\tdev_err(&chipset_dev->acpi_device->dev,\n\t\t\t"no valid create_device message\\n");\n\t\treturn;\n\t}\n\tvisorbus_device_create(&local_crash_dev_msg);\n	f
39248	215	aa_restore_previous_label	security/apparmor/context.c	ctx->previous	1	13	\N	\N	\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (ctx->token != token) {\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\t/* ignore restores when there is no saved label */\n\tif (!ctx->previous) {\n	f
46887	4746	si_force_switch_to_arb_f0	drivers/gpu/drm/amd/amdgpu/si_dpm.c	tmp	1	13	\N	\N	\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tint ret;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev, si_pi->arb_table_start,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = (tmp >> 24) & 0xff;\n\n\tif (tmp == MC_CG_ARB_FREQ_F0)\n	f
58187	250	recv_buffer_fast_alloc	drivers/net/ethernet/cavium/liquidio/octeon_droq.c	conf6x	1	13	\N	\N	\tstruct octeon_droq *droq;\n\tu32 desc_ring_size = 0, c_num_descs = 0, c_buf_size = 0;\n\tu32 c_pkts_per_intr = 0, c_refill_threshold = 0;\n\tint numa_node = dev_to_node(&oct->pci_dev->dev);\n\n\tdev_dbg(&oct->pci_dev->dev, "%s[%d]\\n", __func__, q_no);\n\n\tdroq = oct->droq[q_no];\n\tmemset(droq, 0, OCT_DROQ_SIZE);\n\n\tdroq->oct_dev = oct;\n\tdroq->q_no = q_no;\n\tif (app_ctx)\n\t\tdroq->app_ctx = app_ctx;\n\telse\n\t\tdroq->app_ctx = (void *)(size_t)q_no;\n\n\tc_num_descs = num_descs;\n\tc_buf_size = desc_size;\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tstruct octeon_config *conf6x = CHIP_CONF(oct, cn6xxx);\n\n\t\tc_pkts_per_intr = (u32)CFG_GET_OQ_PKTS_PER_INTR(conf6x);\n\t\tc_refill_threshold =\n\t\t\t(u32)CFG_GET_OQ_REFILL_THRESHOLD(conf6x);\n	f
8685	264	xvtc_of_get	drivers/media/platform/xilinx/xilinx-vtc.c	xvtc_node	1	13	\N	\N	\tstruct device_node *xvtc_node;\n\tstruct xvtc_device *found = NULL;\n\tstruct xvtc_device *xvtc;\n\n\tif (!of_find_property(np, "xlnx,vtc", NULL))\n\t\treturn NULL;\n\n\txvtc_node = of_parse_phandle(np, "xlnx,vtc", 0);\n\tif (xvtc_node == NULL)\n	f
-1070	6267	ironlake_fdi_compute_config	drivers/gpu/drm/i915/intel_display.c	ret	2	3	\N	\N	\tstruct drm_device *dev = intel_crtc->base.dev;\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\n\tint lane, link_bw, fdi_dotclock, ret;\n\tbool needs_recompute = false;\n\nretry:\n\t/* FDI is a binary signal running at ~2.7GHz, encoding\n\t * each output octet as 10 bits. The actual frequency\n\t * is stored as a divider into a 100MHz clock, and the\n\t * mode pixel clock is stored in units of 1KHz.\n\t * Hence the bw of each lane in terms of the mode signal\n\t * is:\n\t */\n\tlink_bw = intel_fdi_link_freq(to_i915(dev), pipe_config);\n\n\tfdi_dotclock = adjusted_mode->crtc_clock;\n\n\tlane = ironlake_get_lanes_required(fdi_dotclock, link_bw,\n\t\t\t\t\t   pipe_config->pipe_bpp);\n\n\tpipe_config->fdi_lanes = lane;\n\n\tintel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,\n\t\t\t       link_bw, &pipe_config->fdi_m_n, false);\n\n\tret = ironlake_check_fdi_lanes(dev, intel_crtc->pipe, pipe_config);\n\tif (ret == -EINVAL && pipe_config->pipe_bpp > 6*3) {\n	f
-517	722	a3700_spi_transfer_one	drivers/spi/spi-armada-3700.c	val	1000	3	\N	\N	\tstruct a3700_spi *a3700_spi = spi_master_get_devdata(master);\n\tint ret = 0, timeout = A3700_SPI_TIMEOUT;\n\tunsigned int nbits = 0;\n\tu32 val;\n\n\ta3700_spi_transfer_setup(spi, xfer);\n\n\ta3700_spi->tx_buf  = xfer->tx_buf;\n\ta3700_spi->rx_buf  = xfer->rx_buf;\n\ta3700_spi->buf_len = xfer->len;\n\n\tif (xfer->tx_buf)\n\t\tnbits = xfer->tx_nbits;\n\telse if (xfer->rx_buf)\n\t\tnbits = xfer->rx_nbits;\n\n\ta3700_spi_pin_mode_set(a3700_spi, nbits, xfer->rx_buf ? true : false);\n\n\t/* Flush the FIFOs */\n\ta3700_spi_fifo_flush(a3700_spi);\n\n\t/* Transfer first bytes of data when buffer is not 4-byte aligned */\n\ta3700_spi_header_set(a3700_spi);\n\n\tif (xfer->rx_buf) {\n\t\t/* Set read data length */\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_DIN_CNT_REG,\n\t\t\t     a3700_spi->buf_len);\n\t\t/* Start READ transfer */\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval &= ~A3700_SPI_RW_EN;\n\t\tval |= A3700_SPI_XFER_START;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t} else if (xfer->tx_buf) {\n\t\t/* Start Write transfer */\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= (A3700_SPI_XFER_START | A3700_SPI_RW_EN);\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\t\t/*\n\t\t * If there are data to be written to the SPI device, xmit_data\n\t\t * flag is set true; otherwise the instruction in SPI_INSTR does\n\t\t * not require data to be written to the SPI device, then\n\t\t * xmit_data flag is set false.\n\t\t */\n\t\ta3700_spi->xmit_data = (a3700_spi->buf_len != 0);\n\t}\n\n\twhile (a3700_spi->buf_len) {\n\t\tif (a3700_spi->tx_buf) {\n\t\t\t/* Wait wfifo ready */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t"wait wfifo ready timed out\\n");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Fill up the wfifo */\n\t\t\tret = a3700_spi_fifo_write(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (a3700_spi->rx_buf) {\n\t\t\t/* Wait rfifo ready */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_RFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t"wait rfifo ready timed out\\n");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Drain out the rfifo */\n\t\t\tret = a3700_spi_fifo_read(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/*\n\t * Stop a write transfer in fifo mode:\n\t *\t- wait all the bytes in wfifo to be shifted out\n\t *\t - set XFER_STOP bit\n\t *\t- wait XFER_START bit clear\n\t *\t- clear XFER_STOP bit\n\t * Stop a read transfer in fifo mode:\n\t *\t- the hardware is to reset the XFER_START bit\n\t *\t   after the number of bytes indicated in DIN_CNT\n\t *\t   register\n\t *\t- just wait XFER_START bit clear\n\t */\n\tif (a3700_spi->tx_buf) {\n\t\tif (a3700_spi->xmit_data) {\n\t\t\t/*\n\t\t\t * If there are data written to the SPI device, wait\n\t\t\t * until SPI_WFIFO_EMPTY is 1 to wait for all data to\n\t\t\t * transfer out of write FIFO.\n\t\t\t */\n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_EMPTY)) {\n\t\t\t\tdev_err(&spi->dev, "wait wfifo empty timed out\\n");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\tif (!a3700_spi_transfer_wait(spi, A3700_SPI_XFER_RDY)) {\n\t\t\tdev_err(&spi->dev, "wait xfer ready timed out\\n");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= A3700_SPI_XFER_STOP;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t}\n\n\twhile (--timeout) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tif (!(val & A3700_SPI_XFER_START))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(&spi->dev, "wait transfer start clear timed out\\n");\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tval &= ~A3700_SPI_XFER_STOP;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n	f
35990	2741	wlc_lcnphy_tx_iqlo_cal	drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_lcn.c	hash	1	13	\N	\N	\n\tstruct lcnphy_txgains cal_gains, temp_gains;\n\tu16 hash;\n\tu8 band_idx;\n\tint j;\n\tu16 ncorr_override[5];\n\tu16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t\t\t      0x0000, 0x0000, 0x0000, 0x0000, 0x0000};\n\n\tu16 commands_fullcal[] = {\n\t\t0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234\n\t};\n\n\tu16 commands_recal[] = {\n\t\t0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234\n\t};\n\n\tu16 command_nums_fullcal[] = {\n\t\t0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97\n\t};\n\n\tu16 command_nums_recal[] = {\n\t\t0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97\n\t};\n\tu16 *command_nums = command_nums_fullcal;\n\n\tu16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;\n\tu16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;\n\tu16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;\n\tbool tx_gain_override_old;\n\tstruct lcnphy_txgains old_gains;\n\tuint i, n_cal_cmds = 0, n_cal_start = 0;\n\tu16 *values_to_save;\n\tstruct brcms_phy_lcnphy *pi_lcn = pi->u.pi_lcnphy;\n\n\tvalues_to_save = kmalloc(sizeof(u16) * 20, GFP_ATOMIC);\n\tif (NULL == values_to_save)\n\t\treturn;\n\n\tsave_sslpnRxFeClkEnCtrl = read_phy_reg(pi, 0x6db);\n\tsave_sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);\n\n\tor_phy_reg(pi, 0x6da, 0x40);\n\tor_phy_reg(pi, 0x6db, 0x3);\n\n\tswitch (cal_mode) {\n\tcase LCNPHY_CAL_FULL:\n\t\tstart_coeffs = syst_coeffs;\n\t\tcal_cmds = commands_fullcal;\n\t\tn_cal_cmds = ARRAY_SIZE(commands_fullcal);\n\t\tbreak;\n\n\tcase LCNPHY_CAL_RECAL:\n\t\tstart_coeffs = syst_coeffs;\n\t\tcal_cmds = commands_recal;\n\t\tn_cal_cmds = ARRAY_SIZE(commands_recal);\n\t\tcommand_nums = command_nums_recal;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\twlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,\n\t\t\t\t      start_coeffs, 11, 16, 64);\n\n\twrite_phy_reg(pi, 0x6da, 0xffff);\n\tmod_phy_reg(pi, 0x503, (0x1 << 3), (1) << 3);\n\n\ttx_pwr_ctrl_old = wlc_lcnphy_get_tx_pwr_ctrl(pi);\n\n\tmod_phy_reg(pi, 0x4a4, (0x1 << 12), (1) << 12);\n\n\twlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);\n\n\tsave_txpwrctrlrfctrl2 = read_phy_reg(pi, 0x4db);\n\n\tmod_phy_reg(pi, 0x4db, (0x3ff << 0), (0x2a6) << 0);\n\n\tmod_phy_reg(pi, 0x4db, (0x7 << 12), (2) << 12);\n\n\twlc_lcnphy_tx_iqlo_loopback(pi, values_to_save);\n\n\ttx_gain_override_old = wlc_lcnphy_tx_gain_override_enabled(pi);\n\tif (tx_gain_override_old)\n\t\twlc_lcnphy_get_tx_gain(pi, &old_gains);\n\n\tif (!target_gains) {\n\t\tif (!tx_gain_override_old)\n\t\t\twlc_lcnphy_set_tx_pwr_by_index(pi,\n\t\t\t\t\t\t       pi_lcn->lcnphy_tssi_idx);\n\t\twlc_lcnphy_get_tx_gain(pi, &temp_gains);\n\t\ttarget_gains = &temp_gains;\n\t}\n\n\thash = (target_gains->gm_gain << 8) |\n\t       (target_gains->pga_gain << 4) | (target_gains->pad_gain);\n\n\tband_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);\n\n\tcal_gains = *target_gains;\n\tmemset(ncorr_override, 0, sizeof(ncorr_override));\n\tfor (j = 0; j < iqcal_gainparams_numgains_lcnphy[band_idx]; j++) {\n\t\tif (hash == tbl_iqcal_gainparams_lcnphy[band_idx][j][0]) {\n	f
38746	342	xfs_dir2_sf_addname	fs/xfs/libxfs/xfs_dir2_sf.c	error	1	13	\N	\N	\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tincr_isize;\t/* total change in size */\n\tint\t\t\tnew_isize;\t/* di_size after adding name */\n\tint\t\t\tobjchange;\t/* changing to 8-byte inodes */\n\txfs_dir2_data_aoff_t\toffset = 0;\t/* offset for new entry */\n\tint\t\t\tpick;\t\t/* which algorithm to use */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_sf_entry_t\t*sfep = NULL;\t/* shortform entry */\n\n\ttrace_xfs_dir2_sf_addname(args);\n\n\tASSERT(xfs_dir2_sf_lookup(args) == -ENOENT);\n\tdp = args->dp;\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Make sure the shortform value has some of its header.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Compute entry (and change in) size.\n\t */\n\tincr_isize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tobjchange = 0;\n\n\t/*\n\t * Do we have to change to 8 byte inodes?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\t/*\n\t\t * Yes, adjust the inode size.  old count + (parent + new)\n\t\t */\n\t\tincr_isize += (sfp->count + 2) * XFS_INO64_DIFF;\n\t\tobjchange = 1;\n\t}\n\n\tnew_isize = (int)dp->i_d.di_size + incr_isize;\n\t/*\n\t * Won't fit as shortform any more (due to size),\n\t * or the pick routine says it won't (due to offset values).\n\t */\n\tif (new_isize > XFS_IFORK_DSIZE(dp) ||\n\t    (pick =\n\t     xfs_dir2_sf_addname_pick(args, objchange, &sfep, &offset)) == 0) {\n\t\t/*\n\t\t * Just checking or no space reservation, it doesn't fit.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to block form then add the name.\n\t\t */\n\t\terror = xfs_dir2_sf_to_block(args);\n\t\tif (error)\n	f
48923	1131	ieee80211_mesh_rx_probe_req	net/mac80211/mesh.c	hdr->frame_control	1	13	\N	\N	\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct sk_buff *presp;\n\tstruct beacon_data *bcn;\n\tstruct ieee80211_mgmt *hdr;\n\tstruct ieee802_11_elems elems;\n\tsize_t baselen;\n\tu8 *pos;\n\n\tpos = mgmt->u.probe_req.variable;\n\tbaselen = (u8 *) pos - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tieee802_11_parse_elems(pos, len - baselen, false, &elems);\n\n\tif (!elems.mesh_id)\n\t\treturn;\n\n\t/* 802.11-2012 10.1.4.3.2 */\n\tif ((!ether_addr_equal(mgmt->da, sdata->vif.addr) &&\n\t     !is_broadcast_ether_addr(mgmt->da)) ||\n\t    elems.ssid_len != 0)\n\t\treturn;\n\n\tif (elems.mesh_id_len != 0 &&\n\t    (elems.mesh_id_len != ifmsh->mesh_id_len ||\n\t     memcmp(elems.mesh_id, ifmsh->mesh_id, ifmsh->mesh_id_len)))\n\t\treturn;\n\n\trcu_read_lock();\n\tbcn = rcu_dereference(ifmsh->beacon);\n\n\tif (!bcn)\n\t\tgoto out;\n\n\tpresp = dev_alloc_skb(local->tx_headroom +\n\t\t\t      bcn->head_len + bcn->tail_len);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb_reserve(presp, local->tx_headroom);\n\tskb_put_data(presp, bcn->head, bcn->head_len);\n\tskb_put_data(presp, bcn->tail, bcn->tail_len);\n\thdr = (struct ieee80211_mgmt *) presp->data;\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n	f
51039	309	hostap_mgmt_start_xmit	drivers/net/wireless/intersil/hostap/hostap_80211_tx.c	skb	1	13	\N	\N	\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_DEBUG "%s: hostap_mgmt_start_xmit: short skb "\n\t\t       "(len=%d)\\n", dev->name, skb->len);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tiface->stats.tx_packets++;\n\tiface->stats.tx_bytes += skb->len;\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = iface;\n\n\tif (skb->len >= IEEE80211_DATA_HDR3_LEN + sizeof(rfc1042_header) + 2) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tfc = le16_to_cpu(hdr->frame_control);\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_DATA) {\n\t\t\tu8 *pos = &skb->data[IEEE80211_DATA_HDR3_LEN +\n\t\t\t\t\t     sizeof(rfc1042_header)];\n\t\t\tmeta->ethertype = (pos[0] << 8) | pos[1];\n\t\t}\n\t}\n\n\t/* Send IEEE 802.11 encapsulated frame using the master radio device */\n\tskb->dev = local->dev;\n\tdev_queue_xmit(skb);\n	f
55794	948	drm_syncobj_signal_ioctl	drivers/gpu/drm/drm_syncobj.c	syncobjs	1	13	\N	\N	\tstruct drm_syncobj_array *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tuint32_t i;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -ENODEV;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < args->count_handles; i++) {\n\t\tret = drm_syncobj_assign_null_handle(syncobjs[i]);\n	f
59266	82	nouveau_gem_prime_import_sg_table	drivers/gpu/drm/nouveau/nouveau_prime.c	&nvbo->gem	1	13	\N	\N	\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_bo *nvbo;\n\tstruct reservation_object *robj = attach->dmabuf->resv;\n\tu32 flags = 0;\n\tint ret;\n\n\tflags = TTM_PL_FLAG_TT;\n\n\tww_mutex_lock(&robj->lock, NULL);\n\tret = nouveau_bo_new(&drm->client, attach->dmabuf->size, 0, flags, 0, 0,\n\t\t\t     sg, robj, &nvbo);\n\tww_mutex_unlock(&robj->lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tnvbo->valid_domains = NOUVEAU_GEM_DOMAIN_GART;\n\n\t/* Initialize the embedded gem-object. We return a single gem-reference\n\t * to the caller, instead of a normal nouveau_bo ttm reference. */\n\tret = drm_gem_object_init(dev, &nvbo->gem, nvbo->bo.mem.size);\n	f
-521	896	mlxsw_sx_port_set_link_ksettings	drivers/net/ethernet/mellanox/mlxsw/switchx2.c	eth_proto_admin	1000	3	\N	\N	\tstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\n\tstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\n\tchar ptys_pl[MLXSW_REG_PTYS_LEN];\n\tu32 speed;\n\tu32 eth_proto_new;\n\tu32 eth_proto_cap;\n\tu32 eth_proto_admin;\n\tu32 advertising;\n\tbool is_up;\n\tint err;\n\n\tspeed = cmd->base.speed;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\teth_proto_new = cmd->base.autoneg == AUTONEG_ENABLE ?\n\t\tmlxsw_sx_to_ptys_advert_link(advertising) :\n\t\tmlxsw_sx_to_ptys_speed(speed);\n\n\tmlxsw_reg_ptys_eth_pack(ptys_pl, mlxsw_sx_port->local_port, 0);\n\terr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\n\tif (err) {\n\t\tnetdev_err(dev, "Failed to get proto");\n\t\treturn err;\n\t}\n\tmlxsw_reg_ptys_eth_unpack(ptys_pl, &eth_proto_cap, &eth_proto_admin,\n\t\t\t\t  NULL);\n\n\teth_proto_new = eth_proto_new & eth_proto_cap;\n\tif (!eth_proto_new) {\n\t\tnetdev_err(dev, "Not supported proto admin requested");\n\t\treturn -EINVAL;\n\t}\n\tif (eth_proto_new == eth_proto_admin)\n	f
-525	9514	nl80211_tx_mgmt	net/wireless/nl80211.c	&chandef	1000	3	\N	\N	\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n	f
28665	5536	lpfc_sli_probe_sriov_nr_virtfn	drivers/scsi/lpfc/lpfc_init.c	max_nr_vfn	1	13	\N	\N	\tstruct pci_dev *pdev = phba->pcidev;\n\tuint16_t max_nr_vfn;\n\tint rc;\n\n\tmax_nr_vfn = lpfc_sli_sriov_nr_virtfn_get(phba);\n\tif (nr_vfn > max_nr_vfn) {\n	f
-503	605	vmbus_close_internal	drivers/hv/channel.c	ret	1000	3	\N	\N	\tstruct vmbus_channel_close_channel *msg;\n\tint ret;\n\n\t/*\n\t * vmbus_on_event(), running in the per-channel tasklet, can race\n\t * with vmbus_close_internal() in the case of SMP guest, e.g., when\n\t * the former is accessing channel->inbound.ring_buffer, the latter\n\t * could be freeing the ring_buffer pages, so here we must stop it\n\t * first.\n\t */\n\ttasklet_disable(&channel->callback_event);\n\n\t/*\n\t * In case a device driver's probe() fails (e.g.,\n\t * util_probe() -> vmbus_open() returns -ENOMEM) and the device is\n\t * rescinded later (e.g., we dynamically disable an Integrated Service\n\t * in Hyper-V Manager), the driver's remove() invokes vmbus_close():\n\t * here we should skip most of the below cleanup work.\n\t */\n\tif (channel->state != CHANNEL_OPENED_STATE) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tchannel->state = CHANNEL_OPEN_STATE;\n\tchannel->sc_creation_callback = NULL;\n\t/* Stop callback and cancel the timer asap */\n\tif (channel->target_cpu != get_cpu()) {\n\t\tput_cpu();\n\t\tsmp_call_function_single(channel->target_cpu, reset_channel_cb,\n\t\t\t\t\t channel, true);\n\t} else {\n\t\treset_channel_cb(channel);\n\t\tput_cpu();\n\t}\n\n\t/* Send a closing message */\n\n\tmsg = &channel->close_msg.msg;\n\n\tmsg->header.msgtype = CHANNELMSG_CLOSECHANNEL;\n\tmsg->child_relid = channel->offermsg.child_relid;\n\n\tret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel),\n\t\t\t     true);\n\n\tif (ret) {\n\t\tpr_err("Close failed: close post msg return is %d\\n", ret);\n\t\t/*\n\t\t * If we failed to post the close msg,\n\t\t * it is perhaps better to leak memory.\n\t\t */\n\t\tgoto out;\n\t}\n\n\t/* Tear down the gpadl for the channel's ring buffer */\n\tif (channel->ringbuffer_gpadlhandle) {\n\t\tret = vmbus_teardown_gpadl(channel,\n\t\t\t\t\t   channel->ringbuffer_gpadlhandle);\n\t\tif (ret) {\n	f
35458	496	pt_ready_wait	drivers/block/paride/pt.c	p	1	13	\N	\N	\tchar tr_cmd[12] = { ATAPI_TEST_READY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tint k, p;\n\n\tk = 0;\n\twhile (k < tmo) {\n\t\ttape->last_sense = 0;\n\t\tpt_atapi(tape, tr_cmd, 0, NULL, DBMSG("test unit ready"));\n\t\tp = tape->last_sense;\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))\n	f
22950	1595	xfs_refcount_recover_extent	fs/xfs/libxfs/xfs_refcount.c	&rr->rr_rrec	1	13	\N	\N	\tstruct list_head\t\t*debris = priv;\n\tstruct xfs_refcount_recovery\t*rr;\n\n\tif (be32_to_cpu(rec->refc.rc_refcount) != 1)\n\t\treturn -EFSCORRUPTED;\n\n\trr = kmem_alloc(sizeof(struct xfs_refcount_recovery), KM_SLEEP);\n\txfs_refcount_btrec_to_irec(rec, &rr->rr_rrec);\n	f
36324	114	trace_event_raw_event_ocfs2__uint_int	fs/ocfs2/super.c	struct ocfs2_super *osb	1	13	\N	\N	\tunsigned long\tcommit_interval;\n\tunsigned long\tmount_opt;\n\tunsigned int\tatime_quantum;\n\tsigned short\tslot;\n\tint\t\tlocalalloc_opt;\n\tunsigned int\tresv_level;\n\tint\t\tdir_resv_level;\n\tchar\t\tcluster_stack[OCFS2_STACK_LABEL_LEN + 1];\n};\n\nstatic int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic int ocfs2_initialize_mem_caches(void);\nstatic void ocfs2_free_mem_caches(void);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\n	f
42835	190	f2fs_convert_inline_inode	fs/f2fs/inline.c	&dn	1	13	\N	\N	\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tif (!f2fs_has_inline_data(inode))\n\t\treturn 0;\n\n\tpage = f2fs_grab_cache_page(inode->i_mapping, 0, false);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\n	f
60301	593	mct_u232_read_int_callback	drivers/usb/serial/mct_u232.c	urb	1	13	\N	\N	\tstruct usb_serial_port *port = urb->context;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&port->dev, "%s - urb shutting down with status: %d\\n",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, "%s - nonzero urb status received: %d\\n",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\t/*\n\t * Work-a-round: handle the 'usual' bulk-in pipe here\n\t */\n\tif (urb->transfer_buffer_length > 2) {\n\t\tif (urb->actual_length) {\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\t\ttty_flip_buffer_push(&port->port);\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * The interrupt-in pipe signals exceptional conditions (modem line\n\t * signal changes and errors). data[0] holds MSR, data[1] holds LSR.\n\t */\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->last_msr = data[MCT_U232_MSR_INDEX];\n\n\t/* Record Control Line states */\n\tmct_u232_msr_to_state(port, &priv->control_state, priv->last_msr);\n\n\tmct_u232_msr_to_icount(&port->icount, priv->last_msr);\n\n#if 0\n\t/* Not yet handled. See belkin_sa.c for further information */\n\t/* Now to report any errors */\n\tpriv->last_lsr = data[MCT_U232_LSR_INDEX];\n\t/*\n\t * fill in the flip buffer here, but I do not know the relation\n\t * to the current/next receive buffer or characters.  I need\n\t * to look in to this before committing any code.\n\t */\n\tif (priv->last_lsr & MCT_U232_LSR_ERR) {\n\t\ttty = tty_port_tty_get(&port->port);\n\t\t/* Overrun Error */\n\t\tif (priv->last_lsr & MCT_U232_LSR_OE) {\n\t\t}\n\t\t/* Parity Error */\n\t\tif (priv->last_lsr & MCT_U232_LSR_PE) {\n\t\t}\n\t\t/* Framing Error */\n\t\tif (priv->last_lsr & MCT_U232_LSR_FE) {\n\t\t}\n\t\t/* Break Indicator */\n\t\tif (priv->last_lsr & MCT_U232_LSR_BI) {\n\t\t}\n\t\ttty_kref_put(tty);\n\t}\n#endif\n\twake_up_interruptible(&port->port.delta_msr_wait);\n\tspin_unlock_irqrestore(&priv->lock, flags);\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n	f
32992	146	gpio_wdt_probe	drivers/watchdog/gpio_wdt.c	hw_margin	1	13	\N	\N	\tstruct gpio_wdt_priv *priv;\n\tenum of_gpio_flags flags;\n\tunsigned int hw_margin;\n\tunsigned long f = 0;\n\tconst char *algo;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->gpio = of_get_gpio_flags(pdev->dev.of_node, 0, &flags);\n\tif (!gpio_is_valid(priv->gpio))\n\t\treturn priv->gpio;\n\n\tpriv->active_low = flags & OF_GPIO_ACTIVE_LOW;\n\n\tret = of_property_read_string(pdev->dev.of_node, "hw_algo", &algo);\n\tif (ret)\n\t\treturn ret;\n\tif (!strcmp(algo, "toggle")) {\n\t\tpriv->hw_algo = HW_ALGO_TOGGLE;\n\t\tf = GPIOF_IN;\n\t} else if (!strcmp(algo, "level")) {\n\t\tpriv->hw_algo = HW_ALGO_LEVEL;\n\t\tf = priv->active_low ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_gpio_request_one(&pdev->dev, priv->gpio, f,\n\t\t\t\t    dev_name(&pdev->dev));\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t   "hw_margin_ms", &hw_margin);\n\tif (ret)\n\t\treturn ret;\n\t/* Disallow values lower than 2 and higher than 65535 ms */\n\tif (hw_margin < 2 || hw_margin > 65535)\n	f
54766	721	__disable_runtime	kernel/sched/rt.c	__disable_runtime_$rt_rq$obj$29$obj	0	13	\N	\N	\tstruct root_domain *rd = rq->rd;\n\trt_rq_iter_t iter;\n\tstruct rt_rq *rt_rq;\n\n\tif (unlikely(!scheduler_running))\n\t\treturn;\n\n\tfor_each_rt_rq(rt_rq, iter, rq) {\n\t\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);\n\t\ts64 want;\n\t\tint i;\n\n\t\traw_spin_lock(&rt_b->rt_runtime_lock);\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * Either we're all inf and nobody needs to borrow, or we're\n\t\t * already disabled and thus have nothing to do, or we have\n\t\t * exactly the right amount of runtime to take out.\n\t\t */\n\t\tif (rt_rq->rt_runtime == RUNTIME_INF ||\n	f
-520	949	encrypted_read	security/keys/encrypted-keys/encrypted.c	&mkey->sem	1000	3	\N	\N	\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n	f
34815	2743	btrfs_ioctl_rm_dev	fs/btrfs/ioctl.c	ret	1	13	\N	\N	\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_and_set_bit(BTRFS_FS_EXCL_OP, &fs_info->flags)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out_drop_write;\n\t}\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tmutex_lock(&fs_info->volume_mutex);\n\tret = btrfs_rm_device(fs_info, vol_args->name, 0);\n\tmutex_unlock(&fs_info->volume_mutex);\n\n\tif (!ret)\n	f
41779	1411	idt_probe	drivers/misc/eeprom/idt_89hpesx.c	pdev	1	13	\N	\N	\tstruct idt_89hpesx_dev *pdev;\n\tint ret;\n\n\t/* Create driver data */\n\tpdev = idt_create_pdev(client);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\t/* Set SMBus operations */\n\tret = idt_set_smbus_ops(pdev);\n	f
48876	227	asoc_graph_card_parse_of	sound/soc/generic/audio-graph-card.c	ret	1	13	\N	\N	\tstruct of_phandle_iterator it;\n\tstruct device *dev = graph_priv_to_dev(priv);\n\tstruct snd_soc_card *card = graph_priv_to_card(priv);\n\tstruct device_node *node = dev->of_node;\n\tint rc, idx = 0;\n\tint ret;\n\n\tret = asoc_simple_card_of_parse_widgets(card, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_card_of_parse_routing(card, NULL, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * we need to consider "mclk-fs" around here\n\t * see simple-card\n\t */\n\n\tof_for_each_phandle(&it, rc, node, "dais", NULL, 0) {\n\t\tret = asoc_graph_card_dai_link_of(it.node, priv, idx++);\n\t\tif (ret < 0) {\n	f
54650	4685	ext4_alloc_file_blocks	fs/ext4/extents.c	ret	1	13	\N	\N	\tstruct inode *inode = file_inode(file);\n\thandle_t *handle;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint retries = 0;\n\tint depth = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits;\n\tloff_t epos;\n\n\tBUG_ON(!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS));\n\tmap.m_lblk = offset;\n\tmap.m_len = len;\n\t/*\n\t * Don't normalize the request if it can fit in one extent so\n\t * that it doesn't get unnecessarily split into multiple\n\t * extents.\n\t */\n\tif (len <= EXT_UNWRITTEN_MAX_LEN)\n\t\tflags |= EXT4_GET_BLOCKS_NO_NORMALIZE;\n\n\t/*\n\t * credits to insert 1 extent into extent tree\n\t */\n\tcredits = ext4_chunk_trans_blocks(inode, len);\n\tdepth = ext_depth(inode);\n\nretry:\n\twhile (ret >= 0 && len) {\n	f
41864	1804	register_jprobe	kernel/kprobes.c	offset	1	13	\N	\N	\tunsigned long addr, offset;\n\tstruct kprobe *kp = &jp->kp;\n\n\t/*\n\t * Verify probepoint as well as the jprobe handler are\n\t * valid function entry points.\n\t */\n\taddr = arch_deref_entry_point(jp->entry);\n\n\tif (kallsyms_lookup_size_offset(addr, NULL, &offset) && offset == 0 &&\n	f
8796	813	set_temp_min	drivers/hwmon/adm1026.c	set_temp_min_$__UNIQUE_ID_min1_167$obj	0	13	\N	\N	\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = TEMP_TO_REG(val);\n	f
47612	144	nf_sk_lookup_slow_v6	net/ipv6/netfilter/nf_socket_ipv6.c	sport	1	13	\N	\N	\t__be16 uninitialized_var(dport), uninitialized_var(sport);\n\tconst struct in6_addr *daddr = NULL, *saddr = NULL;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct sk_buff *data_skb = NULL;\n\tint doff = 0;\n\tint thoff = 0, tproto;\n\n\ttproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\n\tif (tproto < 0) {\n\t\tpr_debug("unable to find transport header in IPv6 packet, dropping\\n");\n\t\treturn NULL;\n\t}\n\n\tif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\n\t\tstruct udphdr _hdr, *hp;\n\n\t\thp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn NULL;\n\n\t\tsaddr = &iph->saddr;\n\t\tsport = hp->source;\n\t\tdaddr = &iph->daddr;\n\t\tdport = hp->dest;\n\t\tdata_skb = (struct sk_buff *)skb;\n\t\tdoff = tproto == IPPROTO_TCP ?\n\t\t\tthoff + __tcp_hdrlen((struct tcphdr *)hp) :\n\t\t\tthoff + sizeof(*hp);\n\n\t} else if (tproto == IPPROTO_ICMPV6) {\n\t\tstruct ipv6hdr ipv6_var;\n\n\t\tif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\n\t\t\t\t\t &sport, &dport, &ipv6_var))\n\t\t\treturn NULL;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\treturn nf_socket_get_sock_v6(net, data_skb, doff, tproto, saddr, daddr,\n	f
26697	708	twl4030_madc_set_current_generator	drivers/iio/adc/twl4030-madc.c	ret	1	13	\N	\N	\tint ret;\n\tint regmask;\n\tu8 regval;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t      &regval, TWL4030_BCI_BCICTL1);\n\tif (ret) {\n	f
53255	642	ncp_fill_cache	fs/ncpfs/dir.c	inode	1	13	\N	\N	\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = d_inode(dentry);\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (IS_ERR(newdent))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (d_really_is_negative(newdent)) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(dir)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = d_inode(newdent);\n\n\t\tinode_lock_nested(inode, I_MUTEX_CHILD);\n	f
55590	625	trace_event_raw_event_f2fs_gc_end	fs/f2fs/super.c	&fi->i_sem	1	13	\N	\N	\tstruct f2fs_inode_info *fi;\n\n\tfi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO);\n\tif (!fi)\n\t\treturn NULL;\n\n\tinit_once((void *) fi);\n\n\t/* Initialize f2fs-specific inode info */\n\tfi->vfs_inode.i_version = 1;\n\tatomic_set(&fi->dirty_pages, 0);\n\tfi->i_current_depth = 1;\n\tfi->i_advise = 0;\n\tinit_rwsem(&fi->i_sem);\n	f
60927	3735	t3_prep_adapter	drivers/net/ethernet/chelsio/cxgb3/t3_hw.c	adapter->params.vpd.port_type	1	13	\N	\N	\tint ret;\n\tunsigned int i, j = -1;\n\n\tget_pci_mode(adapter, &adapter->params.pci);\n\n\tadapter->params.info = ai;\n\tadapter->params.nports = ai->nports0 + ai->nports1;\n\tadapter->params.chan_map = (!!ai->nports0) | (!!ai->nports1 << 1);\n\tadapter->params.rev = t3_read_reg(adapter, A_PL_REV);\n\t/*\n\t * We used to only run the "adapter check task" once a second if\n\t * we had PHYs which didn't support interrupts (we would check\n\t * their link status once a second).  Now we check other conditions\n\t * in that routine which could potentially impose a very high\n\t * interrupt load on the system.  As such, we now always scan the\n\t * adapter state once a second ...\n\t */\n\tadapter->params.linkpoll_period = 10;\n\tadapter->params.stats_update_period = is_10G(adapter) ?\n\t    MAC_STATS_ACCUM_SECS : (MAC_STATS_ACCUM_SECS * 10);\n\tadapter->params.pci.vpd_cap_addr =\n\t    pci_find_capability(adapter->pdev, PCI_CAP_ID_VPD);\n\tret = get_vpd_params(adapter, &adapter->params.vpd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reset && t3_reset_adapter(adapter))\n\t\treturn -1;\n\n\tt3_sge_prep(adapter, &adapter->params.sge);\n\n\tif (adapter->params.vpd.mclk) {\n\t\tstruct tp_params *p = &adapter->params.tp;\n\n\t\tmc7_prep(adapter, &adapter->pmrx, MC7_PMRX_BASE_ADDR, "PMRX");\n\t\tmc7_prep(adapter, &adapter->pmtx, MC7_PMTX_BASE_ADDR, "PMTX");\n\t\tmc7_prep(adapter, &adapter->cm, MC7_CM_BASE_ADDR, "CM");\n\n\t\tp->nchan = adapter->params.chan_map == 3 ? 2 : 1;\n\t\tp->pmrx_size = t3_mc7_size(&adapter->pmrx);\n\t\tp->pmtx_size = t3_mc7_size(&adapter->pmtx);\n\t\tp->cm_size = t3_mc7_size(&adapter->cm);\n\t\tp->chan_rx_size = p->pmrx_size / 2;\t/* only 1 Rx channel */\n\t\tp->chan_tx_size = p->pmtx_size / p->nchan;\n\t\tp->rx_pg_size = 64 * 1024;\n\t\tp->tx_pg_size = is_10G(adapter) ? 64 * 1024 : 16 * 1024;\n\t\tp->rx_num_pgs = pm_num_pages(p->chan_rx_size, p->rx_pg_size);\n\t\tp->tx_num_pgs = pm_num_pages(p->chan_tx_size, p->tx_pg_size);\n\t\tp->ntimer_qs = p->cm_size >= (128 << 20) ||\n\t\t    adapter->params.rev > 0 ? 12 : 6;\n\t}\n\n\tadapter->params.offload = t3_mc7_size(&adapter->pmrx) &&\n\t\t\t\t  t3_mc7_size(&adapter->pmtx) &&\n\t\t\t\t  t3_mc7_size(&adapter->cm);\n\n\tif (is_offload(adapter)) {\n\t\tadapter->params.mc5.nservers = DEFAULT_NSERVERS;\n\t\tadapter->params.mc5.nfilters = adapter->params.rev > 0 ?\n\t\t    DEFAULT_NFILTERS : 0;\n\t\tadapter->params.mc5.nroutes = 0;\n\t\tt3_mc5_prep(adapter, &adapter->mc5, MC5_MODE_144_BIT);\n\n\t\tinit_mtus(adapter->params.mtus);\n\t\tinit_cong_ctrl(adapter->params.a_wnd, adapter->params.b_wnd);\n\t}\n\n\tearly_hw_init(adapter, ai);\n\tret = init_parity(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_port(adapter, i) {\n\t\tu8 hw_addr[6];\n\t\tconst struct port_type_info *pti;\n\t\tstruct port_info *p = adap2pinfo(adapter, i);\n\n\t\twhile (!adapter->params.vpd.port_type[++j])\n	f
-508	1097	bnxt_re_ib_reg	drivers/infiniband/hw/bnxt_re/main.c	&rdev->dev_attr	1000	3	\N	\N	\tint i, j, rc;\n\n\t/* Registered a new RoCE device instance to netdev */\n\trc = bnxt_re_register_netdev(rdev);\n\tif (rc) {\n\t\tpr_err("Failed to register with netedev: %#x\\n", rc);\n\t\treturn -EINVAL;\n\t}\n\tset_bit(BNXT_RE_FLAG_NETDEV_REGISTERED, &rdev->flags);\n\n\trc = bnxt_re_request_msix(rdev);\n\tif (rc) {\n\t\tpr_err("Failed to get MSI-X vectors: %#x\\n", rc);\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\tset_bit(BNXT_RE_FLAG_GOT_MSIX, &rdev->flags);\n\n\t/* Establish RCFW Communication Channel to initialize the context\n\t * memory for the function and all child VFs\n\t */\n\trc = bnxt_qplib_alloc_rcfw_channel(rdev->en_dev->pdev, &rdev->rcfw,\n\t\t\t\t\t   BNXT_RE_MAX_QPC_COUNT);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = bnxt_re_net_ring_alloc\n\t\t\t(rdev, rdev->rcfw.creq.pbl[PBL_LVL_0].pg_map_arr,\n\t\t\t rdev->rcfw.creq.pbl[rdev->rcfw.creq.level].pg_count,\n\t\t\t HWRM_RING_ALLOC_CMPL, BNXT_QPLIB_CREQE_MAX_CNT - 1,\n\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].ring_idx,\n\t\t\t &rdev->rcfw.creq_ring_id);\n\tif (rc) {\n\t\tpr_err("Failed to allocate CREQ: %#x\\n", rc);\n\t\tgoto free_rcfw;\n\t}\n\trc = bnxt_qplib_enable_rcfw_channel\n\t\t\t\t(rdev->en_dev->pdev, &rdev->rcfw,\n\t\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].vector,\n\t\t\t\t rdev->msix_entries[BNXT_RE_AEQ_IDX].db_offset,\n\t\t\t\t 0, &bnxt_re_aeq_handler);\n\tif (rc) {\n\t\tpr_err("Failed to enable RCFW channel: %#x\\n", rc);\n\t\tgoto free_ring;\n\t}\n\n\trc = bnxt_qplib_get_dev_attr(&rdev->rcfw, &rdev->dev_attr);\n	f
-516	1197	gtp_genl_get_pdp	drivers/net/gtp.c	skb2	1000	3	\N	\N	\tstruct pdp_ctx *pctx = NULL;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (!info->attrs[GTPA_VERSION])\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\n\tpctx = gtp_find_pdp(sock_net(skb->sk), info->attrs);\n\tif (IS_ERR(pctx)) {\n\t\terr = PTR_ERR(pctx);\n\t\tgoto err_unlock;\n\t}\n\n\tskb2 = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\terr = gtp_genl_fill_info(skb2, NETLINK_CB(skb).portid,\n	f
28906	977	ubifs_jnl_xrename	fs/ubifs/journal.c	err	1	13	\N	\N	\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent1, *dent2;\n\tint err, dlen1, dlen2, lnum, offs, len, plen = UBIFS_INO_NODE_SZ;\n\tint aligned_dlen1, aligned_dlen2;\n\tint twoparents = (fst_dir != snd_dir);\n\tvoid *p;\n\n\tubifs_assert(ubifs_inode(fst_dir)->data_len == 0);\n\tubifs_assert(ubifs_inode(snd_dir)->data_len == 0);\n\tubifs_assert(mutex_is_locked(&ubifs_inode(fst_dir)->ui_mutex));\n\tubifs_assert(mutex_is_locked(&ubifs_inode(snd_dir)->ui_mutex));\n\n\tdlen1 = UBIFS_DENT_NODE_SZ + fname_len(snd_nm) + 1;\n\tdlen2 = UBIFS_DENT_NODE_SZ + fname_len(fst_nm) + 1;\n\taligned_dlen1 = ALIGN(dlen1, 8);\n\taligned_dlen2 = ALIGN(dlen2, 8);\n\n\tlen = aligned_dlen1 + aligned_dlen2 + ALIGN(plen, 8);\n\tif (twoparents)\n\t\tlen += plen;\n\n\tdent1 = kzalloc(len, GFP_NOFS);\n\tif (!dent1)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n	f
29650	780	mxl111sf_attach_demod	drivers/media/usb/dvb-usb-v2/mxl111sf.c	mxl111sf_attach_demod_$tmp73$obj	0	13	\N	\N	\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug("%s()\\n", __func__);\n\n\t/* save a pointer to the dvb_usb_device in device state */\n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 1 : 2;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err("set interface failed");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_DVBT;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_SOC_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n	f
49859	508	xfs_compat_fssetdm_by_handle	fs/xfs/xfs_ioctl32.c	xfs_compat_fssetdm_by_handle_$4$obj$and$4	0	13	\N	\N	\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\tcompat_xfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {\n	f
4481	902	hfcsusb_rx_frame	drivers/isdn/hardware/mISDN/hfcsusb.c	hfcsusb_rx_frame_$rx_skb$obj$41$obj$0	0	13	\N	\N	\tstruct hfcsusb\t*hw = fifo->hw;\n\tstruct sk_buff\t*rx_skb = NULL;\n\tint\t\tmaxlen = 0;\n\tint\t\tfifon = fifo->fifonum;\n\tint\t\ti;\n\tint\t\thdlc = 0;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG "%s: %s: fifo(%i) len(%i) "\n\t\t       "dch(%p) bch(%p) ech(%p)\\n",\n\t\t       hw->name, __func__, fifon, len,\n\t\t       fifo->dch, fifo->bch, fifo->ech);\n\n\tif (!len)\n\t\treturn;\n\n\tif ((!!fifo->dch + !!fifo->bch + !!fifo->ech) != 1) {\n\t\tprintk(KERN_DEBUG "%s: %s: undefined channel\\n",\n\t\t       hw->name, __func__);\n\t\treturn;\n\t}\n\n\tspin_lock(&hw->lock);\n\tif (fifo->dch) {\n\t\trx_skb = fifo->dch->rx_skb;\n\t\tmaxlen = fifo->dch->maxlen;\n\t\thdlc = 1;\n\t}\n\tif (fifo->bch) {\n\t\tif (test_bit(FLG_RX_OFF, &fifo->bch->Flags)) {\n\t\t\tfifo->bch->dropcnt += len;\n\t\t\tspin_unlock(&hw->lock);\n\t\t\treturn;\n\t\t}\n\t\tmaxlen = bchannel_get_rxbuf(fifo->bch, len);\n\t\trx_skb = fifo->bch->rx_skb;\n\t\tif (maxlen < 0) {\n\t\t\tif (rx_skb)\n\t\t\t\tskb_trim(rx_skb, 0);\n\t\t\tpr_warning("%s.B%d: No bufferspace for %d bytes\\n",\n\t\t\t\t   hw->name, fifo->bch->nr, len);\n\t\t\tspin_unlock(&hw->lock);\n\t\t\treturn;\n\t\t}\n\t\tmaxlen = fifo->bch->maxlen;\n\t\thdlc = test_bit(FLG_HDLC, &fifo->bch->Flags);\n\t}\n\tif (fifo->ech) {\n\t\trx_skb = fifo->ech->rx_skb;\n\t\tmaxlen = fifo->ech->maxlen;\n\t\thdlc = 1;\n\t}\n\n\tif (fifo->dch || fifo->ech) {\n\t\tif (!rx_skb) {\n\t\t\trx_skb = mI_alloc_skb(maxlen, GFP_ATOMIC);\n\t\t\tif (rx_skb) {\n\t\t\t\tif (fifo->dch)\n\t\t\t\t\tfifo->dch->rx_skb = rx_skb;\n\t\t\t\tif (fifo->ech)\n\t\t\t\t\tfifo->ech->rx_skb = rx_skb;\n\t\t\t\tskb_trim(rx_skb, 0);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_DEBUG "%s: %s: No mem for rx_skb\\n",\n\t\t\t\t       hw->name, __func__);\n\t\t\t\tspin_unlock(&hw->lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* D/E-Channel SKB range check */\n\t\tif ((rx_skb->len + len) >= MAX_DFRAME_LEN_L1) {\n\t\t\tprintk(KERN_DEBUG "%s: %s: sbk mem exceeded "\n\t\t\t       "for fifo(%d) HFCUSB_D_RX\\n",\n\t\t\t       hw->name, __func__, fifon);\n\t\t\tskb_trim(rx_skb, 0);\n\t\t\tspin_unlock(&hw->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb_put_data(rx_skb, data, len);\n\n\tif (hdlc) {\n\t\t/* we have a complete hdlc packet */\n\t\tif (finish) {\n\t\t\tif ((rx_skb->len > 3) &&\n\t\t\t    (!(rx_skb->data[rx_skb->len - 1]))) {\n	f
6787	193	pcf8583_rtc_read_time	drivers/rtc/rtc-pcf8583.c	new_ctrl	1	13	\N	\N	\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char ctrl, year[2];\n\tstruct rtc_mem mem = {\n\t\t.loc = CMOS_YEAR,\n\t\t.nr = sizeof(year),\n\t\t.data = year\n\t};\n\tint real_year, year_offset, err;\n\n\t/*\n\t * Ensure that the RTC is running.\n\t */\n\tpcf8583_get_ctrl(client, &ctrl);\n\tif (ctrl & (CTRL_STOP | CTRL_HOLD)) {\n\t\tunsigned char new_ctrl = ctrl & ~(CTRL_STOP | CTRL_HOLD);\n\n\t\tdev_warn(dev, "resetting control %02x -> %02x\\n",\n	f
21833	63	roccat_common2_send	drivers/hid/hid-roccat-common.c	len	1	13	\N	\N	\tchar *buf;\n\tint len;\n\n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tlen = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\tHID_REQ_SET_REPORT,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\troccat_common2_feature_report(report_id),\n\t\t\t0, buf, size, USB_CTRL_SET_TIMEOUT);\n\n\tkfree(buf);\n\treturn ((len < 0) ? len : ((len != size) ? -EIO : 0));\n	f
23947	541	ds2760_battery_probe	drivers/power/supply/ds2760_battery.c	di	1	13	\N	\N	\tstruct power_supply_config psy_cfg = {};\n\tchar status;\n\tint retval = 0;\n\tstruct ds2760_device_info *di;\n\n\tdi = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);\n\tif (!di) {\n\t\tretval = -ENOMEM;\n\t\tgoto di_alloc_failed;\n\t}\n\n\tplatform_set_drvdata(pdev, di);\n\n\tdi->dev\t\t\t\t= &pdev->dev;\n\tdi->w1_dev\t\t\t= pdev->dev.parent;\n\tdi->bat_desc.name\t\t= dev_name(&pdev->dev);\n\tdi->bat_desc.type\t\t= POWER_SUPPLY_TYPE_BATTERY;\n\tdi->bat_desc.properties\t\t= ds2760_battery_props;\n\tdi->bat_desc.num_properties\t= ARRAY_SIZE(ds2760_battery_props);\n\tdi->bat_desc.get_property\t= ds2760_battery_get_property;\n\tdi->bat_desc.set_property\t= ds2760_battery_set_property;\n\tdi->bat_desc.property_is_writeable =\n\t\t\t\t  ds2760_battery_property_is_writeable;\n\tdi->bat_desc.set_charged\t= ds2760_battery_set_charged;\n\tdi->bat_desc.external_power_changed =\n\t\t\t\t  ds2760_battery_external_power_changed;\n\n\tpsy_cfg.drv_data\t\t= di;\n\n\tdi->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\t/* enable sleep mode feature */\n\tds2760_battery_read_status(di);\n	f
63338	633	inet6_netconf_get_devconf	net/ipv6/addrconf.c	tb	1	13	\N	\N	\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tstruct inet6_dev *in6_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv6_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n	f
-1059	3232	clear_caseopen	drivers/hwmon/nct6775.c	val	2	3	\N	\N	\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(attr)->index - INTRUSION_ALARM_BASE;\n\tunsigned long val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val) || val != 0)\n	f
-500	118	tps65090_try_enable_fet	drivers/regulator/tps65090-regulator.c	control	1000	3	\N	\N	\tunsigned int control;\n\tint ret, i;\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t rdev->desc->enable_mask,\n\t\t\t\t rdev->desc->enable_mask);\n\tif (ret < 0) {\n\t\tdev_err(&rdev->dev, "Error in updating reg %#x\\n",\n\t\t\trdev->desc->enable_reg);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MAX_CTRL_READ_TRIES; i++) {\n\t\tret = regmap_read(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  &control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(control & BIT(CTRL_TO_BIT)))\n	f
-515	3176	addrconf_addr_gen	net/ipv6/addrconf.c	&addr	1000	3	\N	\N	\tstruct in6_addr addr;\n\n\t/* no link local addresses on L3 master devices */\n\tif (netif_is_l3_master(idev->dev))\n\t\treturn;\n\n\tipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);\n	f
8019	3311	chunk_drange_filter	fs/btrfs/volumes.c	chunk_drange_filter_$and$128	0	13	\N	\N	\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tu64 stripe_offset;\n\tu64 stripe_length;\n\tint factor;\n\tint i;\n\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_DEVID))\n\t\treturn 0;\n\n\tif (btrfs_chunk_type(leaf, chunk) & (BTRFS_BLOCK_GROUP_DUP |\n\t     BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\tfactor = num_stripes / 2;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID5) {\n	f
27154	651	gigaset_isdn_icall	drivers/isdn/gigaset/capi.c	skb	1	13	\N	\N	\tstruct cardstate *cs = at_state->cs;\n\tstruct bc_state *bcs = at_state->bcs;\n\tstruct gigaset_capi_ctr *iif = cs->iif;\n\tstruct gigaset_capi_appl *ap;\n\tu32 actCIPmask;\n\tstruct sk_buff *skb;\n\tunsigned int msgsize;\n\tunsigned long flags;\n\tint i;\n\n\t/*\n\t * ToDo: signal calls without a free B channel, too\n\t * (requires a u8 handle for the at_state structure that can\n\t * be stored in the PLCI and used in the CONNECT_RESP message\n\t * handler to retrieve it)\n\t */\n\tif (!bcs)\n\t\treturn ICALL_IGNORE;\n\n\t/* prepare CONNECT_IND message, using B channel number as PLCI */\n\tcapi_cmsg_header(&iif->hcmsg, 0, CAPI_CONNECT, CAPI_IND, 0,\n\t\t\t iif->ctr.cnr | ((bcs->channel + 1) << 8));\n\n\t/* minimum size, all structs empty */\n\tmsgsize = CAPI_CONNECT_IND_BASELEN;\n\n\t/* Bearer Capability (mandatory) */\n\tif (at_state->str_var[STR_ZBC]) {\n\t\t/* pass on BC from Gigaset */\n\t\tif (encode_ie(at_state->str_var[STR_ZBC], iif->bc_buf,\n\t\t\t      MAX_BC_OCTETS) < 0) {\n\t\t\tdev_warn(cs->dev, "RING ignored - bad BC %s\\n",\n\t\t\t\t at_state->str_var[STR_ZBC]);\n\t\t\treturn ICALL_IGNORE;\n\t\t}\n\n\t\t/* look up corresponding CIP value */\n\t\tiif->hcmsg.CIPValue = 0;\t/* default if nothing found */\n\t\tfor (i = 0; i < ARRAY_SIZE(cip2bchlc); i++)\n\t\t\tif (cip2bchlc[i].bc != NULL &&\n\t\t\t    cip2bchlc[i].hlc == NULL &&\n\t\t\t    !strcmp(cip2bchlc[i].bc,\n\t\t\t\t    at_state->str_var[STR_ZBC])) {\n\t\t\t\tiif->hcmsg.CIPValue = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\t/* no BC (internal call): assume CIP 1 (speech, A-law) */\n\t\tiif->hcmsg.CIPValue = 1;\n\t\tencode_ie(cip2bchlc[1].bc, iif->bc_buf, MAX_BC_OCTETS);\n\t}\n\tiif->hcmsg.BC = iif->bc_buf;\n\tmsgsize += iif->hcmsg.BC[0];\n\n\t/* High Layer Compatibility (optional) */\n\tif (at_state->str_var[STR_ZHLC]) {\n\t\t/* pass on HLC from Gigaset */\n\t\tif (encode_ie(at_state->str_var[STR_ZHLC], iif->hlc_buf,\n\t\t\t      MAX_HLC_OCTETS) < 0) {\n\t\t\tdev_warn(cs->dev, "RING ignored - bad HLC %s\\n",\n\t\t\t\t at_state->str_var[STR_ZHLC]);\n\t\t\treturn ICALL_IGNORE;\n\t\t}\n\t\tiif->hcmsg.HLC = iif->hlc_buf;\n\t\tmsgsize += iif->hcmsg.HLC[0];\n\n\t\t/* look up corresponding CIP value */\n\t\t/* keep BC based CIP value if none found */\n\t\tif (at_state->str_var[STR_ZBC])\n\t\t\tfor (i = 0; i < ARRAY_SIZE(cip2bchlc); i++)\n\t\t\t\tif (cip2bchlc[i].hlc != NULL &&\n\t\t\t\t    !strcmp(cip2bchlc[i].hlc,\n\t\t\t\t\t    at_state->str_var[STR_ZHLC]) &&\n\t\t\t\t    !strcmp(cip2bchlc[i].bc,\n\t\t\t\t\t    at_state->str_var[STR_ZBC])) {\n\t\t\t\t\tiif->hcmsg.CIPValue = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t}\n\n\t/* Called Party Number (optional) */\n\tif (at_state->str_var[STR_ZCPN]) {\n\t\ti = strlen(at_state->str_var[STR_ZCPN]);\n\t\tif (i > MAX_NUMBER_DIGITS) {\n\t\t\tdev_warn(cs->dev, "RING ignored - bad number %s\\n",\n\t\t\t\t at_state->str_var[STR_ZBC]);\n\t\t\treturn ICALL_IGNORE;\n\t\t}\n\t\tiif->cdpty_buf[0] = i + 1;\n\t\tiif->cdpty_buf[1] = 0x80; /* type / numbering plan unknown */\n\t\tmemcpy(iif->cdpty_buf + 2, at_state->str_var[STR_ZCPN], i);\n\t\tiif->hcmsg.CalledPartyNumber = iif->cdpty_buf;\n\t\tmsgsize += iif->hcmsg.CalledPartyNumber[0];\n\t}\n\n\t/* Calling Party Number (optional) */\n\tif (at_state->str_var[STR_NMBR]) {\n\t\ti = strlen(at_state->str_var[STR_NMBR]);\n\t\tif (i > MAX_NUMBER_DIGITS) {\n\t\t\tdev_warn(cs->dev, "RING ignored - bad number %s\\n",\n\t\t\t\t at_state->str_var[STR_ZBC]);\n\t\t\treturn ICALL_IGNORE;\n\t\t}\n\t\tiif->cgpty_buf[0] = i + 2;\n\t\tiif->cgpty_buf[1] = 0x00; /* type / numbering plan unknown */\n\t\tiif->cgpty_buf[2] = 0x80; /* pres. allowed, not screened */\n\t\tmemcpy(iif->cgpty_buf + 3, at_state->str_var[STR_NMBR], i);\n\t\tiif->hcmsg.CallingPartyNumber = iif->cgpty_buf;\n\t\tmsgsize += iif->hcmsg.CallingPartyNumber[0];\n\t}\n\n\t/* remaining parameters (not supported, always left NULL):\n\t * - CalledPartySubaddress\n\t * - CallingPartySubaddress\n\t * - AdditionalInfo\n\t *   - BChannelinformation\n\t *   - Keypadfacility\n\t *   - Useruserdata\n\t *   - Facilitydataarray\n\t */\n\n\tgig_dbg(DEBUG_CMD, "icall: PLCI %x CIP %d BC %s",\n\t\tiif->hcmsg.adr.adrPLCI, iif->hcmsg.CIPValue,\n\t\tformat_ie(iif->hcmsg.BC));\n\tgig_dbg(DEBUG_CMD, "icall: HLC %s",\n\t\tformat_ie(iif->hcmsg.HLC));\n\tgig_dbg(DEBUG_CMD, "icall: CgPty %s",\n\t\tformat_ie(iif->hcmsg.CallingPartyNumber));\n\tgig_dbg(DEBUG_CMD, "icall: CdPty %s",\n\t\tformat_ie(iif->hcmsg.CalledPartyNumber));\n\n\t/* scan application list for matching listeners */\n\tspin_lock_irqsave(&bcs->aplock, flags);\n\tif (bcs->ap != NULL || bcs->apconnstate != APCONN_NONE) {\n\t\tdev_warn(cs->dev, "%s: channel not properly cleared (%p/%d)\\n",\n\t\t\t __func__, bcs->ap, bcs->apconnstate);\n\t\tbcs->ap = NULL;\n\t\tbcs->apconnstate = APCONN_NONE;\n\t}\n\tspin_unlock_irqrestore(&bcs->aplock, flags);\n\tactCIPmask = 1 | (1 << iif->hcmsg.CIPValue);\n\tlist_for_each_entry(ap, &iif->appls, ctrlist)\n\t\tif (actCIPmask & ap->listenCIPmask) {\n\t\t\t/* build CONNECT_IND message for this application */\n\t\t\tiif->hcmsg.ApplId = ap->id;\n\t\t\tiif->hcmsg.Messagenumber = ap->nextMessageNumber++;\n\n\t\t\tskb = alloc_skb(msgsize, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\tdev_err(cs->dev, "%s: out of memory\\n",\n\t\t\t\t\t__func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (capi_cmsg2message(&iif->hcmsg,\n\t\t\t\t\t      __skb_put(skb, msgsize))) {\n	f
2123	664	ingenic_pinconf_group_get	drivers/pinctrl/pinctrl-ingenic.c	pins	1	13	\N	\N	\tconst unsigned int *pins;\n\tunsigned int i, npins, old = 0;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tif (ingenic_pinconf_get(pctldev, pins[i], config))\n	f
29005	463	lgs8gxx_auto_detect	drivers/media/dvb-frontends/lgs8gxx.c	tmp_gi	1	13	\N	\N	\tint i, j;\n\tint err = 0;\n\tu8 locked = 0, tmp_gi;\n\n\tdprintk("%s\\n", __func__);\n\n\tlgs8gxx_set_mode_auto(priv);\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_write_reg(priv, 0x67, 0xAA);\n\t\tlgs8gxx_write_reg(priv, 0x6E, 0x3F);\n\t} else {\n\t\t/* Guard Interval */\n\t\tlgs8gxx_write_reg(priv, 0x03, 00);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\ttmp_gi = GI_945;\n\t\t\terr = lgs8gxx_autolock_gi(priv, GI_945, j, &locked);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (locked)\n\t\t\t\tgoto locked;\n\t\t}\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\ttmp_gi = GI_420;\n\t\t\terr = lgs8gxx_autolock_gi(priv, GI_420, j, &locked);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (locked)\n\t\t\t\tgoto locked;\n\t\t}\n\t\ttmp_gi = GI_595;\n\t\terr = lgs8gxx_autolock_gi(priv, GI_595, 1, &locked);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (locked)\n\t\t\tgoto locked;\n\t}\n\nlocked:\n\tif ((err == 0) && (locked == 1)) {\n\t\tu8 t;\n\n\t\tif (priv->config->prod != LGS8GXX_PROD_LGS8G75) {\n\t\t\tlgs8gxx_read_reg(priv, 0xA2, &t);\n\t\t\t*detected_param = t;\n\t\t} else {\n\t\t\tlgs8gxx_read_reg(priv, 0x1F, &t);\n\t\t\t*detected_param = t & 0x3F;\n\t\t}\n\n\t\tif (tmp_gi == GI_945)\n	f
36281	14595	nl80211_pmksa_candidate_notify	net/wireless/nl80211.c	msg	1	13	\N	\N	\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n	f
36903	324	get_mac_address	drivers/net/usb/ch9200.c	rd_mac_len	1	13	\N	\N	\tint err = 0;\n\tunsigned char mac_addr[0x06];\n\tint rd_mac_len = 0;\n\n\tnetdev_dbg(dev->net, "get_mac_address:\\n\\tusbnet VID:%0x PID:%0x\\n",\n\t\t   le16_to_cpu(dev->udev->descriptor.idVendor),\n\t\t   le16_to_cpu(dev->udev->descriptor.idProduct));\n\n\tmemset(mac_addr, 0, sizeof(mac_addr));\n\trd_mac_len = control_read(dev, REQUEST_READ, 0,\n\t\t\t\t  MAC_REG_STATION_L, mac_addr, 0x02,\n\t\t\t\t  CONTROL_TIMEOUT_MS);\n\trd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_M,\n\t\t\t\t   mac_addr + 2, 0x02, CONTROL_TIMEOUT_MS);\n\trd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_H,\n\t\t\t\t   mac_addr + 4, 0x02, CONTROL_TIMEOUT_MS);\n\tif (rd_mac_len != ETH_ALEN)\n	f
45987	151	mlx5_netdev_event	drivers/infiniband/hw/mlx5/main.c	port_state	1	13	\N	\N	\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct mlx5_ib_dev *ibdev = container_of(this, struct mlx5_ib_dev,\n\t\t\t\t\t\t roce.nb);\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_UNREGISTER:\n\t\twrite_lock(&ibdev->roce.netdev_lock);\n\t\tif (ndev->dev.parent == &ibdev->mdev->pdev->dev)\n\t\t\tibdev->roce.netdev = (event == NETDEV_UNREGISTER) ?\n\t\t\t\t\t     NULL : ndev;\n\t\twrite_unlock(&ibdev->roce.netdev_lock);\n\t\tbreak;\n\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN: {\n\t\tstruct net_device *lag_ndev = mlx5_lag_get_roce_netdev(ibdev->mdev);\n\t\tstruct net_device *upper = NULL;\n\n\t\tif (lag_ndev) {\n\t\t\tupper = netdev_master_upper_dev_get(lag_ndev);\n\t\t\tdev_put(lag_ndev);\n\t\t}\n\n\t\tif ((upper == ndev || (!upper && ndev == ibdev->roce.netdev))\n\t\t    && ibdev->ib_active) {\n\t\t\tstruct ib_event ibev = { };\n\t\t\tenum ib_port_state port_state;\n\n\t\t\tif (get_port_state(&ibdev->ib_dev, 1, &port_state))\n\t\t\t\treturn NOTIFY_DONE;\n\n\t\t\tif (ibdev->roce.last_port_state == port_state)\n	f
53185	242	trace_event_raw_event_f2fs_sync_fs	fs/f2fs/super.c	sb	1	13	\N	\N	\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n	f
-1065	235	nv04_update_arb	drivers/gpu/drm/nouveau/dispnv04/arb.c	fifo_data.burst	2	3	\N	\N	\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nv_fifo_info fifo_data;\n\tstruct nv_sim_state sim_data;\n\tint MClk = nouveau_hw_get_clock(dev, PLL_MEMORY);\n\tint NVClk = nouveau_hw_get_clock(dev, PLL_CORE);\n\tuint32_t cfg1 = nvif_rd32(device, NV04_PFB_CFG1);\n\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tsim_data.bpp = bpp;\n\tsim_data.two_heads = nv_two_heads(dev);\n\tif ((dev->pdev->device & 0xffff) == 0x01a0 /*CHIPSET_NFORCE*/ ||\n\t    (dev->pdev->device & 0xffff) == 0x01f0 /*CHIPSET_NFORCE2*/) {\n\t\tuint32_t type;\n\n\t\tpci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);\n\n\t\tsim_data.memory_type = (type >> 12) & 1;\n\t\tsim_data.memory_width = 64;\n\t\tsim_data.mem_latency = 3;\n\t\tsim_data.mem_page_miss = 10;\n\t} else {\n\t\tsim_data.memory_type = nvif_rd32(device, NV04_PFB_CFG0) & 0x1;\n\t\tsim_data.memory_width = (nvif_rd32(device, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;\n\t\tsim_data.mem_latency = cfg1 & 0xf;\n\t\tsim_data.mem_page_miss = ((cfg1 >> 4) & 0xf) + ((cfg1 >> 31) & 0x1);\n\t}\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT)\n\t\tnv04_calc_arb(&fifo_data, &sim_data);\n\telse\n\t\tnv10_calc_arb(&fifo_data, &sim_data);\n\n\t*burst = ilog2(fifo_data.burst >> 4);\n	f
48268	673	vfat_add_entry	fs/fat/namei_vfat.c	err	1	13	\N	\N	\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n	f
42565	3075	ath6kl_wmi_set_tx_pwr_cmd	drivers/net/wireless/ath/ath6kl/wmi.c	ath6kl_wmi_set_tx_pwr_cmd_$cmd$obj	0	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct wmi_set_tx_pwr_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_tx_pwr_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_tx_pwr_cmd *) skb->data;\n\tcmd->dbM = dbM;\n	f
2275	566	acpi_pci_get_power_state	drivers/pci/pci-acpi.c	state	1	13	\N	\N	\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\tstatic const pci_power_t state_conv[] = {\n\t\t[ACPI_STATE_D0]      = PCI_D0,\n\t\t[ACPI_STATE_D1]      = PCI_D1,\n\t\t[ACPI_STATE_D2]      = PCI_D2,\n\t\t[ACPI_STATE_D3_HOT]  = PCI_D3hot,\n\t\t[ACPI_STATE_D3_COLD] = PCI_D3cold,\n\t};\n\tint state;\n\n\tif (!adev || !acpi_device_power_manageable(adev))\n\t\treturn PCI_UNKNOWN;\n\n\tif (acpi_device_get_power(adev, &state) || state == ACPI_STATE_UNKNOWN)\n	f
5140	57	ds1672_get_datetime	drivers/rtc/rtc-ds1672.c	buf	1	13	\N	\N	\tunsigned long time;\n\tunsigned char addr = DS1672_REG_CNT_BASE;\n\tunsigned char buf[4];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{/* setup read ptr */\n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t},\n\t\t{/* read date */\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 4,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\t/* read date registers */\n\tif ((i2c_transfer(client->adapter, &msgs[0], 2)) != 2) {\n\t\tdev_err(&client->dev, "%s: read error\\n", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev,\n	f
20059	581	hub_ext_port_status	drivers/usb/core/hub.c	ret	1	13	\N	\N	\tint ret;\n\tint len = 4;\n\n\tif (type != HUB_PORT_STATUS)\n\t\tlen = 8;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port, type, len);\n\tif (ret < len) {\n	f
60986	1064	user_cluster_connect	fs/ocfs2/stack_user.c	rc	1	13	\N	\N	\tdlm_lockspace_t *fsdlm;\n\tstruct ocfs2_live_connection *lc;\n\tint rc, ops_rv;\n\n\tBUG_ON(conn == NULL);\n\n\tlc = kzalloc(sizeof(struct ocfs2_live_connection), GFP_KERNEL);\n\tif (!lc)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&lc->oc_wait);\n\tinit_completion(&lc->oc_sync_wait);\n\tatomic_set(&lc->oc_this_node, 0);\n\tconn->cc_private = lc;\n\tlc->oc_type = NO_CONTROLD;\n\n\trc = dlm_new_lockspace(conn->cc_name, conn->cc_cluster_name,\n\t\t\t       DLM_LSFL_FS | DLM_LSFL_NEWEXCL, DLM_LVB_LEN,\n\t\t\t       &ocfs2_ls_ops, conn, &ops_rv, &fsdlm);\n\tif (rc) {\n\t\tif (rc == -EEXIST || rc == -EPROTO)\n\t\t\tprintk(KERN_ERR "ocfs2: Unable to create the "\n\t\t\t\t"lockspace %s (%d), because a ocfs2-tools "\n\t\t\t\t"program is running on this file system "\n\t\t\t\t"with the same name lockspace\\n",\n\t\t\t\tconn->cc_name, rc);\n\t\tgoto out;\n\t}\n\n\tif (ops_rv == -EOPNOTSUPP) {\n\t\tlc->oc_type = WITH_CONTROLD;\n\t\tprintk(KERN_NOTICE "ocfs2: You seem to be using an older "\n\t\t\t\t"version of dlm_controld and/or ocfs2-tools."\n\t\t\t\t" Please consider upgrading.\\n");\n\t} else if (ops_rv) {\n\t\trc = ops_rv;\n\t\tgoto out;\n\t}\n\tconn->cc_lockspace = fsdlm;\n\n\trc = ocfs2_live_connection_attach(conn, lc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (lc->oc_type == NO_CONTROLD) {\n\t\trc = get_protocol_version(conn);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR "ocfs2: Could not determine"\n\t\t\t\t\t" locking version\\n");\n\t\t\tuser_cluster_disconnect(conn);\n\t\t\tgoto out;\n\t\t}\n\t\twait_event(lc->oc_wait, (atomic_read(&lc->oc_this_node) > 0));\n\t}\n\n\t/*\n\t * running_proto must have been set before we allowed any mounts\n\t * to proceed.\n\t */\n\tif (fs_protocol_compare(&running_proto, &conn->cc_version)) {\n\t\tprintk(KERN_ERR\n\t\t       "Unable to mount with fs locking protocol version "\n\t\t       "%u.%u because negotiated protocol is %u.%u\\n",\n\t\t       conn->cc_version.pv_major, conn->cc_version.pv_minor,\n\t\t       running_proto.pv_major, running_proto.pv_minor);\n\t\trc = -EPROTO;\n\t\tocfs2_live_connection_drop(lc);\n\t\tlc = NULL;\n\t}\n\nout:\n\tif (rc)\n	f
62728	290	mt7601u_probe	drivers/net/wireless/mediatek/mt7601u/usb.c	ret	1	13	\N	\N	\tstruct usb_device *usb_dev = interface_to_usbdev(usb_intf);\n\tstruct mt7601u_dev *dev;\n\tu32 asic_rev, mac_rev;\n\tint ret;\n\n\tdev = mt7601u_alloc_device(&usb_intf->dev);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tusb_dev = usb_get_dev(usb_dev);\n\tusb_reset_device(usb_dev);\n\n\tusb_set_intfdata(usb_intf, dev);\n\n\tdev->vend_buf = devm_kmalloc(dev->dev, MT_VEND_BUF, GFP_KERNEL);\n\tif (!dev->vend_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = mt7601u_assign_pipes(usb_intf, dev);\n\tif (ret)\n\t\tgoto err;\n\tret = mt7601u_wait_asic_ready(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tasic_rev = mt7601u_rr(dev, MT_ASIC_VERSION);\n\tmac_rev = mt7601u_rr(dev, MT_MAC_CSR0);\n\tdev_info(dev->dev, "ASIC revision: %08x MAC revision: %08x\\n",\n\t\t asic_rev, mac_rev);\n\n\t/* Note: vendor driver skips this check for MT7601U */\n\tif (!(mt7601u_rr(dev, MT_EFUSE_CTRL) & MT_EFUSE_CTRL_SEL))\n\t\tdev_warn(dev->dev, "Warning: eFUSE not present\\n");\n\n\tret = mt7601u_init_hardware(dev);\n\tif (ret)\n	f
28207	789	create_cq_user	drivers/infiniband/hw/mlx5/cq.c	*inlen	1	13	\N	\N	\tstruct mlx5_ib_create_cq ucmd = {};\n\tsize_t ucmdlen;\n\tint page_shift;\n\t__be64 *pas;\n\tint npages;\n\tint ncont;\n\tvoid *cqc;\n\tint err;\n\n\tucmdlen = udata->inlen < sizeof(ucmd) ?\n\t\t  (sizeof(ucmd) - sizeof(ucmd.reserved)) : sizeof(ucmd);\n\n\tif (ib_copy_from_udata(&ucmd, udata, ucmdlen))\n\t\treturn -EFAULT;\n\n\tif (ucmdlen == sizeof(ucmd) &&\n\t    ucmd.reserved != 0)\n\t\treturn -EINVAL;\n\n\tif (ucmd.cqe_size != 64 && ucmd.cqe_size != 128)\n\t\treturn -EINVAL;\n\n\t*cqe_size = ucmd.cqe_size;\n\n\tcq->buf.umem = ib_umem_get(context, ucmd.buf_addr,\n\t\t\t\t   entries * ucmd.cqe_size,\n\t\t\t\t   IB_ACCESS_LOCAL_WRITE, 1);\n\tif (IS_ERR(cq->buf.umem)) {\n\t\terr = PTR_ERR(cq->buf.umem);\n\t\treturn err;\n\t}\n\n\terr = mlx5_ib_db_map_user(to_mucontext(context), ucmd.db_addr,\n\t\t\t\t  &cq->db);\n\tif (err)\n\t\tgoto err_umem;\n\n\tmlx5_ib_cont_pages(cq->buf.umem, ucmd.buf_addr, 0, &npages, &page_shift,\n\t\t\t   &ncont, NULL);\n\tmlx5_ib_dbg(dev, "addr 0x%llx, size %u, npages %d, page_shift %d, ncont %d\\n",\n\t\t    ucmd.buf_addr, entries * ucmd.cqe_size, npages, page_shift, ncont);\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_cq_in, pas[0]) * ncont;\n\t*cqb = kvzalloc(*inlen, GFP_KERNEL);\n	f
1353	115	snd_opl3_init_seq_oss	sound/drivers/opl3/opl3_oss.c	snd_opl3_init_seq_oss_$dev$obj	0	13	\N	\N	\tstruct snd_seq_oss_reg *arg;\n\tstruct snd_seq_device *dev;\n\n\tif (snd_seq_device_new(opl3->card, 0, SNDRV_SEQ_DEV_ID_OSS,\n\t\t\t       sizeof(struct snd_seq_oss_reg), &dev) < 0)\n\t\treturn;\n\n\topl3->oss_seq_dev = dev;\n\tstrlcpy(dev->name, name, sizeof(dev->name));\n	f
38276	364	rsi_sdio_check_buffer_status	drivers/net/wireless/rsi/rsi_91x_sdio_ops.c	buf_status	1	13	\N	\N	\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_91x_sdiodev *dev =\n\t\t(struct rsi_91x_sdiodev *)adapter->rsi_dev;\n\tu8 buf_status = 0;\n\tint status = 0;\n\tstatic int counter = 4;\n\n\tif (!dev->buff_status_updated && counter) {\n\t\tcounter--;\n\t\tgoto out;\n\t}\n\n\tdev->buff_status_updated = false;\n\tstatus = rsi_sdio_read_register(common->priv,\n\t\t\t\t\tRSI_DEVICE_BUFFER_STATUS_REGISTER,\n\t\t\t\t\t&buf_status);\n\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t"%s: Failed to read status register\\n", __func__);\n\t\treturn -1;\n\t}\n\n\tif (buf_status & (BIT(PKT_MGMT_BUFF_FULL))) {\n\t\tif (!dev->rx_info.mgmt_buffer_full)\n\t\t\tdev->rx_info.mgmt_buf_full_counter++;\n\t\tdev->rx_info.mgmt_buffer_full = true;\n\t} else {\n\t\tdev->rx_info.mgmt_buffer_full = false;\n\t}\n\n\tif (buf_status & (BIT(PKT_BUFF_FULL))) {\n	f
23118	552	xfs_refcount_find_left_extents	fs/xfs/libxfs/xfs_refcount.c	xfs_refcount_find_left_extents_$fs_is_ok$obj	0	13	\N	\N	\tstruct xfs_refcount_irec\ttmp;\n\tint\t\t\t\terror;\n\tint\t\t\t\tfound_rec;\n\n\tleft->rc_startblock = cleft->rc_startblock = NULLAGBLOCK;\n\terror = xfs_refcount_lookup_le(cur, agbno - 1, &found_rec);\n\tif (error)\n\t\tgoto out_error;\n\tif (!found_rec)\n\t\treturn 0;\n\n\terror = xfs_refcount_get_rec(cur, &tmp, &found_rec);\n\tif (error)\n\t\tgoto out_error;\n\tXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\n	f
56853	984	ftrace_profile_write	kernel/trace/ftrace.c	val	1	13	\N	\N	\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n	f
59660	738	rxrpc_create	net/rxrpc/af_rxrpc.c	sk	1	13	\N	\N	\tstruct rxrpc_sock *rx;\n\tstruct sock *sk;\n\n\t_enter("%p,%d", sock, protocol);\n\n\t/* we support transport protocol UDP/UDP6 only */\n\tif (protocol != PF_INET &&\n\t    IS_ENABLED(CONFIG_AF_RXRPC_IPV6) && protocol != PF_INET6)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rxrpc_rpc_ops;\n\tsock->state = SS_UNCONNECTED;\n\n\tsk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n	f
61360	157	perf_trace_snd_soc_dapm_path	sound/soc/soc-core.c	codec	1	13	\N	\N	\tint i, step = 1;\n\tint wordsize, regsize;\n\tint len;\n\tsize_t total = 0;\n\tloff_t p = 0;\n\n\twordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;\n\tregsize = codec->driver->reg_word_size * 2;\n\n\tlen = wordsize + regsize + 2 + 1;\n\n\tif (!codec->driver->reg_cache_size)\n\t\treturn 0;\n\n\tif (codec->driver->reg_cache_step)\n\t\tstep = codec->driver->reg_cache_step;\n\n\tfor (i = 0; i < codec->driver->reg_cache_size; i += step) {\n\t\t/* only support larger than PAGE_SIZE bytes debugfs\n\t\t * entries for the default case */\n\t\tif (p >= pos) {\n\t\t\tif (total + len >= count - 1)\n\t\t\t\tbreak;\n\t\t\tformat_register_str(codec, i, buf + total, len);\n	f
-1067	1698	ssi_buffer_mgr_map_hash_request_update	drivers/staging/ccree/ssi_buffer_mgr.c	&sg_data	2	3	\N	\N	\tstruct ahash_req_ctx *areq_ctx = (struct ahash_req_ctx *)ctx;\n\tstruct device *dev = &drvdata->plat_dev->dev;\n\tu8 *curr_buff = areq_ctx->buff_index ? areq_ctx->buff1 :\n\t\t\tareq_ctx->buff0;\n\tu32 *curr_buff_cnt = areq_ctx->buff_index ? &areq_ctx->buff1_cnt :\n\t\t\t&areq_ctx->buff0_cnt;\n\tu8 *next_buff = areq_ctx->buff_index ? areq_ctx->buff0 :\n\t\t\tareq_ctx->buff1;\n\tu32 *next_buff_cnt = areq_ctx->buff_index ? &areq_ctx->buff0_cnt :\n\t\t\t&areq_ctx->buff1_cnt;\n\tstruct mlli_params *mlli_params = &areq_ctx->mlli_params;\n\tunsigned int update_data_len;\n\tu32 total_in_len = nbytes + *curr_buff_cnt;\n\tstruct buffer_array sg_data;\n\tstruct buff_mgr_handle *buff_mgr = drvdata->buff_mgr_handle;\n\tunsigned int swap_index = 0;\n\tu32 dummy = 0;\n\tu32 mapped_nents = 0;\n\n\tSSI_LOG_DEBUG(" update params : curr_buff=%pK "\n\t\t     "curr_buff_cnt=0x%X nbytes=0x%X "\n\t\t     "src=%pK curr_index=%u\\n",\n\t\t     curr_buff, *curr_buff_cnt, nbytes,\n\t\t     src, areq_ctx->buff_index);\n\t/* Init the type of the dma buffer */\n\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_NULL;\n\tmlli_params->curr_pool = NULL;\n\tareq_ctx->curr_sg = NULL;\n\tsg_data.num_of_buffers = 0;\n\tareq_ctx->in_nents = 0;\n\n\tif (unlikely(total_in_len < block_size)) {\n\t\tSSI_LOG_DEBUG(" less than one block: curr_buff=%pK "\n\t\t\t     "*curr_buff_cnt=0x%X copy_to=%pK\\n",\n\t\t\tcurr_buff, *curr_buff_cnt,\n\t\t\t&curr_buff[*curr_buff_cnt]);\n\t\tareq_ctx->in_nents =\n\t\t\tssi_buffer_mgr_get_sgl_nents(src,\n\t\t\t\t\t\t     nbytes,\n\t\t\t\t\t\t     &dummy, NULL);\n\t\tsg_copy_to_buffer(src, areq_ctx->in_nents,\n\t\t\t\t  &curr_buff[*curr_buff_cnt], nbytes);\n\t\t*curr_buff_cnt += nbytes;\n\t\treturn 1;\n\t}\n\n\t/* Calculate the residue size*/\n\t*next_buff_cnt = total_in_len & (block_size - 1);\n\t/* update data len */\n\tupdate_data_len = total_in_len - *next_buff_cnt;\n\n\tSSI_LOG_DEBUG(" temp length : *next_buff_cnt=0x%X "\n\t\t     "update_data_len=0x%X\\n",\n\t\t*next_buff_cnt, update_data_len);\n\n\t/* Copy the new residue to next buffer */\n\tif (*next_buff_cnt != 0) {\n\t\tSSI_LOG_DEBUG(" handle residue: next buff %pK skip data %u"\n\t\t\t     " residue %u\\n", next_buff,\n\t\t\t     (update_data_len - *curr_buff_cnt),\n\t\t\t     *next_buff_cnt);\n\t\tssi_buffer_mgr_copy_scatterlist_portion(next_buff, src,\n\t\t\t\t\t\t\t(update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t\tnbytes, SSI_SG_TO_BUF);\n\t\t/* change the buffer index for next operation */\n\t\tswap_index = 1;\n\t}\n\n\tif (*curr_buff_cnt != 0) {\n\t\tif (ssi_ahash_handle_curr_buf(dev, areq_ctx, curr_buff,\n\t\t\t\t\t      *curr_buff_cnt, &sg_data) != 0) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/* change the buffer index for next operation */\n\t\tswap_index = 1;\n\t}\n\n\tif (update_data_len > *curr_buff_cnt) {\n\t\tif (unlikely(ssi_buffer_mgr_map_scatterlist(dev, src,\n\t\t\t\t\t\t\t    (update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t\t    DMA_TO_DEVICE,\n\t\t\t\t\t\t\t    &areq_ctx->in_nents,\n\t\t\t\t\t\t\t    LLI_MAX_NUM_OF_DATA_ENTRIES,\n\t\t\t\t\t\t\t    &dummy,\n\t\t\t\t\t\t\t    &mapped_nents))){\n\t\t\tgoto unmap_curr_buff;\n\t\t}\n\t\tif ((mapped_nents == 1)\n\t\t     && (areq_ctx->data_dma_buf_type == SSI_DMA_BUF_NULL)) {\n\t\t\t/* only one entry in the SG and no previous data */\n\t\t\tmemcpy(areq_ctx->buff_sg, src,\n\t\t\t       sizeof(struct scatterlist));\n\t\t\tareq_ctx->buff_sg->length = update_data_len;\n\t\t\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_DLLI;\n\t\t\tareq_ctx->curr_sg = areq_ctx->buff_sg;\n\t\t} else {\n\t\t\tareq_ctx->data_dma_buf_type = SSI_DMA_BUF_MLLI;\n\t\t}\n\t}\n\n\tif (unlikely(areq_ctx->data_dma_buf_type == SSI_DMA_BUF_MLLI)) {\n\t\tmlli_params->curr_pool = buff_mgr->mlli_buffs_pool;\n\t\t/* add the src data to the sg_data */\n\t\tssi_buffer_mgr_add_scatterlist_entry(&sg_data,\n\t\t\t\t\t\t     areq_ctx->in_nents,\n\t\t\t\t\t\t     src,\n\t\t\t\t\t\t     (update_data_len - *curr_buff_cnt),\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     true,\n\t\t\t\t\t\t     &areq_ctx->mlli_nents);\n\t\tif (unlikely(ssi_buffer_mgr_generate_mlli(dev, &sg_data,\n	f
37987	927	intel_fake_agp_insert_entries	drivers/char/agp/intel-gtt.c	&st	1	13	\N	\N	\tint ret = -EINVAL;\n\n\tif (intel_private.clear_fake_agp) {\n\t\tint start = intel_private.stolen_size / PAGE_SIZE;\n\t\tint end = intel_private.gtt_mappable_entries;\n\t\tintel_gtt_clear_range(start, end - start);\n\t\tintel_private.clear_fake_agp = false;\n\t}\n\n\tif (INTEL_GTT_GEN == 1 && type == AGP_DCACHE_MEMORY)\n\t\treturn i810_insert_dcache_entries(mem, pg_start, type);\n\n\tif (mem->page_count == 0)\n\t\tgoto out;\n\n\tif (pg_start + mem->page_count > intel_private.gtt_total_entries)\n\t\tgoto out_err;\n\n\tif (type != mem->type)\n\t\tgoto out_err;\n\n\tif (!intel_private.driver->check_flags(type))\n\t\tgoto out_err;\n\n\tif (!mem->is_flushed)\n\t\tglobal_cache_flush();\n\n\tif (intel_private.needs_dmar) {\n\t\tstruct sg_table st;\n\n\t\tret = intel_gtt_map_memory(mem->pages, mem->page_count, &st);\n	f
24139	1028	update_pcm_format	sound/pci/hda/hda_codec.c	oldval	1	13	\N	\N	\tunsigned int oldval;\n\n\tif (p->format_id != format) {\n\t\toldval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_GET_STREAM_FORMAT, 0);\n\t\tif (oldval != format) {\n	f
595	760	acpi_ds_create_operands	drivers/acpi/acpica/dsutils.c	walk_state	1	13	\N	\N	\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *arg;\n\tunion acpi_parse_object *arguments[ACPI_OBJ_NUM_OPERANDS];\n\tu32 arg_count = 0;\n\tu32 index = walk_state->num_operands;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_create_operands, first_arg);\n\n\t/* Get all arguments in the list */\n\n\targ = first_arg;\n\twhile (arg) {\n\t\tif (index >= ACPI_OBJ_NUM_OPERANDS) {\n\t\t\treturn_ACPI_STATUS(AE_BAD_DATA);\n\t\t}\n\n\t\targuments[index] = arg;\n\t\twalk_state->operands[index] = NULL;\n\n\t\t/* Move on to next argument, if any */\n\n\t\targ = arg->common.next;\n\t\targ_count++;\n\t\tindex++;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  "NumOperands %d, ArgCount %d, Index %d\\n",\n\t\t\t  walk_state->num_operands, arg_count, index));\n\n\t/* Create the interpreter arguments, in reverse order */\n\n\tindex--;\n\tfor (i = 0; i < arg_count; i++) {\n\t\targ = arguments[index];\n\t\twalk_state->operand_index = (u8)index;\n\n\t\tstatus = acpi_ds_create_operand(walk_state, arg, index);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  "Created Arg #%u (%p) %u args total\\n",\n\t\t\t\t  index, arg, arg_count));\n\t\tindex--;\n\t}\n\n\treturn_ACPI_STATUS(status);\n\ncleanup:\n\t/*\n\t * We must undo everything done above; meaning that we must\n\t * pop everything off of the operand stack and delete those\n\t * objects\n\t */\n\tacpi_ds_obj_stack_pop_and_delete(arg_count, walk_state);\n	f
48138	4385	atomisp_css_start_acc_pipe	drivers/staging/media/atomisp/pci/atomisp2/atomisp_compat_css20.c	atomisp_css_start_acc_pipe_	1	13	\N	\N	\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_stream_env *stream_env =\n\t\t&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstruct ia_css_pipe_config *pipe_config =\n\t\t\t&stream_env->pipe_configs[IA_CSS_PIPE_ID_ACC];\n\n\tif (ia_css_pipe_create(pipe_config,\n\t\t&stream_env->pipes[IA_CSS_PIPE_ID_ACC]) != IA_CSS_SUCCESS) {\n\t\tdev_err(isp->dev, "%s: ia_css_pipe_create failed\\n",\n\t\t\t\t__func__);\n\t\treturn -EBADE;\n\t}\n\n\tmemset(&stream_env->acc_stream_config, 0,\n\t\tsizeof(struct ia_css_stream_config));\n\tif (ia_css_stream_create(&stream_env->acc_stream_config, 1,\n\t\t\t\t&stream_env->pipes[IA_CSS_PIPE_ID_ACC],\n\t\t\t\t&stream_env->acc_stream) != IA_CSS_SUCCESS) {\n\t\tdev_err(isp->dev, "%s: create acc_stream error.\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\tstream_env->acc_stream_state = CSS_STREAM_CREATED;\n\n\tinit_completion(&asd->acc.acc_done);\n\tasd->acc.pipeline = stream_env->pipes[IA_CSS_PIPE_ID_ACC];\n\n\tatomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX, false);\n\n\tif (ia_css_start_sp() != IA_CSS_SUCCESS) {\n\t\tdev_err(isp->dev, "start sp error.\\n");\n\t\treturn -EIO;\n\t}\n\n\tif (ia_css_stream_start(stream_env->acc_stream)\n	f
61367	162	drm_of_component_probe	drivers/gpu/drm/drm_of.c	remote->parent	1	13	\N	\N	\tstruct device_node *ep, *port, *remote;\n\tstruct component_match *match = NULL;\n\tint i;\n\n\tif (!dev->of_node)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Bind the crtc's ports first, so that drm_of_find_possible_crtcs()\n\t * called from encoder's .bind callbacks works as expected\n\t */\n\tfor (i = 0; ; i++) {\n\t\tport = of_parse_phandle(dev->of_node, "ports", i);\n\t\tif (!port)\n\t\t\tbreak;\n\n\t\tif (!of_device_is_available(port->parent)) {\n\t\t\tof_node_put(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_of_component_match_add(dev, &match, compare_of, port);\n\t\tof_node_put(port);\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(dev, "missing 'ports' property\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!match) {\n\t\tdev_err(dev, "no available port\\n");\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * For bound crtcs, bind the encoders attached to their remote endpoint\n\t */\n\tfor (i = 0; ; i++) {\n\t\tport = of_parse_phandle(dev->of_node, "ports", i);\n\t\tif (!port)\n\t\t\tbreak;\n\n\t\tif (!of_device_is_available(port->parent)) {\n\t\t\tof_node_put(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_child_of_node(port, ep) {\n\t\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\t\tif (!remote || !of_device_is_available(remote)) {\n\t\t\t\tof_node_put(remote);\n\t\t\t\tcontinue;\n\t\t\t} else if (!of_device_is_available(remote->parent)) {\n	f
62910	187	ipv4_ping_group_range	net/ipv4/sysctl_net_ipv4.c	urange[0]	1	13	\N	\N	\tstruct user_namespace *user_ns = current_user_ns();\n\tint ret;\n\tgid_t urange[2];\n\tkgid_t low, high;\n\tstruct ctl_table tmp = {\n\t\t.data = &urange,\n\t\t.maxlen = sizeof(urange),\n\t\t.mode = table->mode,\n\t\t.extra1 = &ip_ping_group_range_min,\n\t\t.extra2 = &ip_ping_group_range_max,\n\t};\n\n\tinet_get_ping_group_range_table(table, &low, &high);\n\turange[0] = from_kgid_munged(user_ns, low);\n\turange[1] = from_kgid_munged(user_ns, high);\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0) {\n\t\tlow = make_kgid(user_ns, urange[0]);\n	f
246	1625	drm_atomic_check_only	drivers/gpu/drm/drm_atomic.c	crtc->base.id	1	13	\N	\N	\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tint i, ret = 0;\n\n\tDRM_DEBUG_ATOMIC("checking %p\\n", state);\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tret = drm_atomic_plane_check(plane, plane_state);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_ATOMIC("[PLANE:%d:%s] atomic core check failed\\n",\n\t\t\t\t\t plane->base.id, plane->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tret = drm_atomic_crtc_check(crtc, crtc_state);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_ATOMIC("[CRTC:%d:%s] atomic core check failed\\n",\n	f
321	859	map_smb_to_linux_error	fs/cifs/netmisc.c	smberrclass	1	13	\N	\N	\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\tunsigned int i;\n\tint rc = -EIO;\t/* if transport error smb error may not be set */\n\t__u8 smberrclass;\n\t__u16 smberrcode;\n\n\t/* BB if NT Status codes - map NT BB */\n\n\t/* old style smb error codes */\n\tif (smb->Status.CifsError == 0)\n\t\treturn 0;\n\n\tif (smb->Flags2 & SMBFLG2_ERR_STATUS) {\n\t\t/* translate the newer STATUS codes to old style SMB errors\n\t\t * and then to POSIX errors */\n\t\t__u32 err = le32_to_cpu(smb->Status.CifsError);\n\t\tif (logErr && (err != (NT_STATUS_MORE_PROCESSING_REQUIRED)))\n\t\t\tcifs_print_status(err);\n\t\telse if (cifsFYI & CIFS_RC)\n\t\t\tcifs_print_status(err);\n\t\tntstatus_to_dos(err, &smberrclass, &smberrcode);\n\t} else {\n\t\tsmberrclass = smb->Status.DosError.ErrorClass;\n\t\tsmberrcode = le16_to_cpu(smb->Status.DosError.Error);\n\t}\n\n\t/* old style errors */\n\n\t/* DOS class smb error codes - map DOS */\n\tif (smberrclass == ERRDOS) {\n	f
408	704	show_master_fader	drivers/leds/leds-lp5523.c	val	1	13	\N	\N	\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&chip->lock);\n\tret = lp55xx_read(chip, LP5523_REG_MASTER_FADER_BASE + nr - 1, &val);\n\tmutex_unlock(&chip->lock);\n\n\tif (ret == 0)\n\t\tret = sprintf(buf, "%u\\n", val);\n	f
413	190	si476x_core_parse_and_nag_about_error	drivers/mfd/si476x-cmd.c	buffer	1	13	\N	\N	\tint err;\n\tchar *cause;\n\tu8 buffer[2];\n\n\tif (core->revision != SI476X_REVISION_A10) {\n\t\terr = si476x_core_i2c_xfer(core, SI476X_I2C_RECV,\n\t\t\t\t\t   buffer, sizeof(buffer));\n\t\tif (err == sizeof(buffer)) {\n\t\t\tswitch (buffer[1]) {\n	f
448	1078	context_read_and_validate	security/selinux/ss/policydb.c	c)	1	13	\N	\N	\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR "SELinux: context truncated\\n");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR "SELinux: error reading MLS range of context\\n");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n	f
456	2018	genfs_read	security/selinux/ss/policydb.c	len	1	13	\N	\N	\tint i, j, rc;\n\tu32 nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n	f
511	194	__aafs_setup_d_inode	security/apparmor/apparmorfs.c	inode	1	13	\N	\N	\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n	f
102	4855	show_free_areas	mm/page_alloc.c	nr	1	13	\N	\N	\tunsigned long free_pcp = 0;\n\tint cpu;\n\tstruct zone *zone;\n\tpg_data_t *pgdat;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\t}\n\n\tprintk("active_anon:%lu inactive_anon:%lu isolated_anon:%lu\\n"\n\t\t" active_file:%lu inactive_file:%lu isolated_file:%lu\\n"\n\t\t" unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\\n"\n\t\t" slab_reclaimable:%lu slab_unreclaimable:%lu\\n"\n\t\t" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\\n"\n\t\t" free:%lu free_pcp:%lu free_cma:%lu\\n",\n\t\tglobal_node_page_state(NR_ACTIVE_ANON),\n\t\tglobal_node_page_state(NR_INACTIVE_ANON),\n\t\tglobal_node_page_state(NR_ISOLATED_ANON),\n\t\tglobal_node_page_state(NR_ACTIVE_FILE),\n\t\tglobal_node_page_state(NR_INACTIVE_FILE),\n\t\tglobal_node_page_state(NR_ISOLATED_FILE),\n\t\tglobal_node_page_state(NR_UNEVICTABLE),\n\t\tglobal_node_page_state(NR_FILE_DIRTY),\n\t\tglobal_node_page_state(NR_WRITEBACK),\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS),\n\t\tglobal_node_page_state(NR_SLAB_RECLAIMABLE),\n\t\tglobal_node_page_state(NR_SLAB_UNRECLAIMABLE),\n\t\tglobal_node_page_state(NR_FILE_MAPPED),\n\t\tglobal_node_page_state(NR_SHMEM),\n\t\tglobal_zone_page_state(NR_PAGETABLE),\n\t\tglobal_zone_page_state(NR_BOUNCE),\n\t\tglobal_zone_page_state(NR_FREE_PAGES),\n\t\tfree_pcp,\n\t\tglobal_zone_page_state(NR_FREE_CMA_PAGES));\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tif (show_mem_node_skip(filter, pgdat->node_id, nodemask))\n\t\t\tcontinue;\n\n\t\tprintk("Node %d"\n\t\t\t" active_anon:%lukB"\n\t\t\t" inactive_anon:%lukB"\n\t\t\t" active_file:%lukB"\n\t\t\t" inactive_file:%lukB"\n\t\t\t" unevictable:%lukB"\n\t\t\t" isolated(anon):%lukB"\n\t\t\t" isolated(file):%lukB"\n\t\t\t" mapped:%lukB"\n\t\t\t" dirty:%lukB"\n\t\t\t" writeback:%lukB"\n\t\t\t" shmem:%lukB"\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t" shmem_thp: %lukB"\n\t\t\t" shmem_pmdmapped: %lukB"\n\t\t\t" anon_thp: %lukB"\n#endif\n\t\t\t" writeback_tmp:%lukB"\n\t\t\t" unstable:%lukB"\n\t\t\t" all_unreclaimable? %s"\n\t\t\t"\\n",\n\t\t\tpgdat->node_id,\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_UNEVICTABLE)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_MAPPED)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_DIRTY)),\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK)),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM)),\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)\n\t\t\t\t\t* HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),\n#endif\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\n\t\t\tK(node_page_state(pgdat, NR_UNSTABLE_NFS)),\n\t\t\tpgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?\n\t\t\t\t"yes" : "no");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tint i;\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfree_pcp = 0;\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT\n\t\t\t"%s"\n\t\t\t" free:%lukB"\n\t\t\t" min:%lukB"\n\t\t\t" low:%lukB"\n\t\t\t" high:%lukB"\n\t\t\t" active_anon:%lukB"\n\t\t\t" inactive_anon:%lukB"\n\t\t\t" active_file:%lukB"\n\t\t\t" inactive_file:%lukB"\n\t\t\t" unevictable:%lukB"\n\t\t\t" writepending:%lukB"\n\t\t\t" present:%lukB"\n\t\t\t" managed:%lukB"\n\t\t\t" mlocked:%lukB"\n\t\t\t" kernel_stack:%lukB"\n\t\t\t" pagetables:%lukB"\n\t\t\t" bounce:%lukB"\n\t\t\t" free_pcp:%lukB"\n\t\t\t" local_pcp:%ukB"\n\t\t\t" free_cma:%lukB"\n\t\t\t"\\n",\n\t\t\tzone->name,\n\t\t\tK(zone_page_state(zone, NR_FREE_PAGES)),\n\t\t\tK(min_wmark_pages(zone)),\n\t\t\tK(low_wmark_pages(zone)),\n\t\t\tK(high_wmark_pages(zone)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),\n\t\t\tK(zone->present_pages),\n\t\t\tK(zone->managed_pages),\n\t\t\tK(zone_page_state(zone, NR_MLOCK)),\n\t\t\tzone_page_state(zone, NR_KERNEL_STACK_KB),\n\t\t\tK(zone_page_state(zone, NR_PAGETABLE)),\n\t\t\tK(zone_page_state(zone, NR_BOUNCE)),\n\t\t\tK(free_pcp),\n\t\t\tK(this_cpu_read(zone->pageset->pcp.count)),\n\t\t\tK(zone_page_state(zone, NR_FREE_CMA_PAGES)));\n\t\tprintk("lowmem_reserve[]:");\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\t\tprintk(KERN_CONT " %ld", zone->lowmem_reserve[i]);\n\t\tprintk(KERN_CONT "\\n");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int order;\n\t\tunsigned long nr[MAX_ORDER], flags, total = 0;\n\t\tunsigned char types[MAX_ORDER];\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT "%s: ", zone->name);\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &zone->free_area[order];\n\t\t\tint type;\n\n\t\t\tnr[order] = area->nr_free;\n\t\t\ttotal += nr[order] << order;\n\n\t\t\ttypes[order] = 0;\n\t\t\tfor (type = 0; type < MIGRATE_TYPES; type++) {\n\t\t\t\tif (!list_empty(&area->free_list[type]))\n\t\t\t\t\ttypes[order] |= 1 << type;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tprintk(KERN_CONT "%lu*%lukB ",\n	f
733	790	pci_bridge_check_ranges	drivers/pci/setup-bus.c	tmp	1	13	\N	\N	\tu16 io;\n\tu32 pmem;\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *b_res;\n\n\tb_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\n\tb_res[1].flags |= IORESOURCE_MEM;\n\n\tpci_read_config_word(bridge, PCI_IO_BASE, &io);\n\tif (!io) {\n\t\tpci_write_config_word(bridge, PCI_IO_BASE, 0xe0f0);\n\t\tpci_read_config_word(bridge, PCI_IO_BASE, &io);\n\t\tpci_write_config_word(bridge, PCI_IO_BASE, 0x0);\n\t}\n\tif (io)\n\t\tb_res[0].flags |= IORESOURCE_IO;\n\n\t/*  DECchip 21050 pass 2 errata: the bridge may miss an address\n\t    disconnect boundary by one PCI data phase.\n\t    Workaround: do not use prefetching on this device. */\n\tif (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)\n\t\treturn;\n\n\tpci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\n\tif (!pmem) {\n\t\tpci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,\n\t\t\t\t\t       0xffe0fff0);\n\t\tpci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\n\t\tpci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);\n\t}\n\tif (pmem) {\n\t\tb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tif ((pmem & PCI_PREF_RANGE_TYPE_MASK) ==\n\t\t    PCI_PREF_RANGE_TYPE_64) {\n\t\t\tb_res[2].flags |= IORESOURCE_MEM_64;\n\t\t\tb_res[2].flags |= PCI_PREF_RANGE_TYPE_64;\n\t\t}\n\t}\n\n\t/* double check if bridge does support 64 bit pref */\n\tif (b_res[2].flags & IORESOURCE_MEM_64) {\n\t\tu32 mem_base_hi, tmp;\n\t\tpci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32,\n\t\t\t\t\t &mem_base_hi);\n\t\tpci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\n\t\t\t\t\t       0xffffffff);\n\t\tpci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);\n\t\tif (!tmp)\n	f
752	1212	sci_port_add_phy	drivers/scsi/isci/port.c	port_sas_address.low	1	13	\N	\N	\tenum sci_status status;\n\tenum sci_port_states state;\n\n\tsci_port_bcn_enable(iport);\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_STOPPED: {\n\t\tstruct sci_sas_address port_sas_address;\n\n\t\t/* Read the port assigned SAS Address if there is one */\n\t\tsci_port_get_sas_address(iport, &port_sas_address);\n\n\t\tif (port_sas_address.high != 0 && port_sas_address.low != 0) {\n	f
772	180	drm_reset_vblank_timestamp	drivers/gpu/drm/drm_vblank.c	&t_vblank	1	13	\N	\N	\tu32 cur_vblank;\n\tbool rc;\n\tstruct timeval t_vblank;\n\tint count = DRM_TIMESTAMP_MAXRETRIES;\n\n\tspin_lock(&dev->vblank_time_lock);\n\n\t/*\n\t * sample the current counter to avoid random jumps\n\t * when drm_vblank_enable() applies the diff\n\t */\n\tdo {\n\t\tcur_vblank = __get_vblank_counter(dev, pipe);\n\t\trc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, false);\n\t} while (cur_vblank != __get_vblank_counter(dev, pipe) && --count > 0);\n\n\t/*\n\t * Only reinitialize corresponding vblank timestamp if high-precision query\n\t * available and didn't fail. Otherwise reinitialize delayed at next vblank\n\t * interrupt and assign 0 for now, to mark the vblanktimestamp as invalid.\n\t */\n\tif (!rc)\n\t\tt_vblank = (struct timeval) {0, 0};\n\n\t/*\n\t * +1 to make sure user will never see the same\n\t * vblank counter value before and after a modeset\n\t */\n\tstore_vblank(dev, pipe, 1, &t_vblank, cur_vblank);\n	f
790	590	power_supply_get_battery_info	drivers/power/supply/power_supply_core.c	value)	1	13	\N	\N	\tstruct device_node *battery_np;\n\tconst char *value;\n\tint err;\n\n\tinfo->energy_full_design_uwh         = -EINVAL;\n\tinfo->charge_full_design_uah         = -EINVAL;\n\tinfo->voltage_min_design_uv          = -EINVAL;\n\tinfo->precharge_current_ua           = -EINVAL;\n\tinfo->charge_term_current_ua         = -EINVAL;\n\tinfo->constant_charge_current_max_ua = -EINVAL;\n\tinfo->constant_charge_voltage_max_uv = -EINVAL;\n\n\tif (!psy->of_node) {\n\t\tdev_warn(&psy->dev, "%s currently only supports devicetree\\n",\n\t\t\t __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tbattery_np = of_parse_phandle(psy->of_node, "monitored-battery", 0);\n\tif (!battery_np)\n\t\treturn -ENODEV;\n\n\terr = of_property_read_string(battery_np, "compatible", &value);\n\tif (err)\n\t\treturn err;\n\n\tif (strcmp("simple-battery", value))\n	f
825	160	da9150_charger_battery_status	drivers/power/supply/da9150-charger.c	reg	1	13	\N	\N	\tu8 reg;\n\n\t/* Check to see if battery is discharging */\n\treg = da9150_reg_read(charger->da9150, DA9150_STATUS_H);\n\n\tif (((reg & DA9150_VBUS_STAT_MASK) == DA9150_VBUS_STAT_OFF) ||\n\t    ((reg & DA9150_VBUS_STAT_MASK) == DA9150_VBUS_STAT_WAIT)) {\n\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t\treturn 0;\n\t}\n\n\treg = da9150_reg_read(charger->da9150, DA9150_STATUS_J);\n\n\t/* Now check for other states */\n\tswitch (reg & DA9150_CHG_STAT_MASK) {\n	f
860	183	max14577_get_battery_health	drivers/power/supply/max14577_charger.c	chg_type	1	13	\N	\N	\tstruct regmap *rmap = chg->max14577->regmap;\n\tint ret;\n\tu8 reg_data;\n\tenum max14577_muic_charger_type chg_type;\n\n\tret = max14577_read_reg(rmap, MAX14577_MUIC_REG_STATUS2, &reg_data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treg_data = ((reg_data & STATUS2_CHGTYP_MASK) >> STATUS2_CHGTYP_SHIFT);\n\tchg_type = maxim_get_charger_type(chg->max14577->dev_type, reg_data);\n\tif (chg_type == MAX14577_CHARGER_TYPE_DEAD_BATTERY) {\n	f
869	1317	bq2415x_sysfs_print_reg	drivers/power/supply/bq2415x_charger.c	ret	1	13	\N	\N	\tint ret = bq2415x_i2c_read(bq, reg);\n\n\tif (ret < 0)\n	f
938	321	NFTL_formatblock	drivers/mtd/nftlmount.c	erase_mark	1	13	\N	\N	\tsize_t retlen;\n\tunsigned int nb_erases, erase_mark;\n\tstruct nftl_uci1 uci;\n\tstruct erase_info *instr = &nftl->instr;\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\n\t/* Read the Unit Control Information #1 for Wear-Leveling */\n\tif (nftl_read_oob(mtd, block * nftl->EraseSize + SECTORSIZE + 8,\n\t\t\t  8, &retlen, (char *)&uci) < 0)\n\t\tgoto default_uci1;\n\n\terase_mark = le16_to_cpu ((uci.EraseMark | uci.EraseMark1));\n\tif (erase_mark != ERASE_MARK) {\n	f
988	446	adv7511_irq_process	drivers/gpu/drm/bridge/adv7511/adv7511_drv.c	irq0	1	13	\N	\N	\tunsigned int irq0, irq1;\n\tint ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_INT(0), &irq0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_INT(1), &irq1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_INT(0), irq0);\n	f
1068	308	tc35876x_regr	drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c	value	1	13	\N	\N	\tint r;\n\tu8 tx_data[] = {\n\t\t(reg >> 8) & 0xff,\n\t\treg & 0xff,\n\t};\n\tu8 rx_data[4];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = tx_data,\n\t\t\t.len = ARRAY_SIZE(tx_data),\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = rx_data,\n\t\t\t.len = ARRAY_SIZE(rx_data),\n\t\t },\n\t};\n\n\tr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (r < 0) {\n\t\tdev_err(&client->dev, "%s: reg 0x%04x error %d\\n", __func__,\n\t\t\treg, r);\n\t\treturn r;\n\t}\n\n\tif (r < ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, "%s: reg 0x%04x msgs %d\\n", __func__,\n\t\t\treg, r);\n\t\treturn -EAGAIN;\n\t}\n\n\t*value = rx_data[0] << 24 | rx_data[1] << 16 |\n\t\trx_data[2] << 8 | rx_data[3];\n\n\tdev_dbg(&client->dev, "%s: reg 0x%04x value 0x%08x\\n", __func__,\n	f
1336	1161	spacc_spacc_complete	drivers/crypto/picoxcell_crypto.c	req	1	13	\N	\N	\tstruct spacc_engine *engine = (struct spacc_engine *)data;\n\tstruct spacc_req *req, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(completed);\n\n\tspin_lock_irqsave(&engine->hw_lock, flags);\n\n\tlist_splice_init(&engine->completed, &completed);\n\tspacc_push(engine);\n\tif (engine->in_flight)\n\t\tmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\n\n\tspin_unlock_irqrestore(&engine->hw_lock, flags);\n\n\tlist_for_each_entry_safe(req, tmp, &completed, list) {\n	f
1084	636	mlx4_eq_int	drivers/net/ethernet/mellanox/mlx4/eq.c	gen_event	1	13	\N	\N	\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_eqe *eqe;\n\tint cqn;\n\tint eqes_found = 0;\n\tint set_ci = 0;\n\tint port;\n\tint slave = 0;\n\tint ret;\n\tu32 flr_slave;\n\tu8 update_slave_state;\n\tint i;\n\tenum slave_port_gen_event gen_event;\n\tunsigned long flags;\n\tstruct mlx4_vport_state *s_info;\n\tint eqe_size = dev->caps.eqe_size;\n\n\twhile ((eqe = next_eqe_sw(eq, dev->caps.eqe_factor, eqe_size))) {\n\t\t/*\n\t\t * Make sure we read EQ entry contents after we've\n\t\t * checked the ownership bit.\n\t\t */\n\t\tdma_rmb();\n\n\t\tswitch (eqe->type) {\n\t\tcase MLX4_EVENT_TYPE_COMP:\n\t\t\tcqn = be32_to_cpu(eqe->event.comp.cqn) & 0xffffff;\n\t\t\tmlx4_cq_completion(dev, cqn);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_PATH_MIG:\n\t\tcase MLX4_EVENT_TYPE_COMM_EST:\n\t\tcase MLX4_EVENT_TYPE_SQ_DRAINED:\n\t\tcase MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE:\n\t\tcase MLX4_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\tcase MLX4_EVENT_TYPE_PATH_MIG_FAILED:\n\t\tcase MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\tcase MLX4_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\t\tmlx4_dbg(dev, "event %d arrived\\n", eqe->type);\n\t\t\tif (mlx4_is_master(dev)) {\n\t\t\t\t/* forward only to slave owning the QP */\n\t\t\t\tret = mlx4_get_slave_from_resource_id(dev,\n\t\t\t\t\t\tRES_QP,\n\t\t\t\t\t\tbe32_to_cpu(eqe->event.qp.qpn)\n\t\t\t\t\t\t& 0xffffff, &slave);\n\t\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\t\tmlx4_dbg(dev, "QP event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\\n",\n\t\t\t\t\t\t eqe->type, eqe->subtype,\n\t\t\t\t\t\t eq->eqn, eq->cons_index, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!ret && slave != dev->caps.function) {\n\t\t\t\t\tmlx4_slave_event(dev, slave, eqe);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tmlx4_qp_event(dev, be32_to_cpu(eqe->event.qp.qpn) &\n\t\t\t\t      0xffffff, eqe->type);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_SRQ_LIMIT:\n\t\t\tmlx4_dbg(dev, "%s: MLX4_EVENT_TYPE_SRQ_LIMIT. srq_no=0x%x, eq 0x%x\\n",\n\t\t\t\t __func__, be32_to_cpu(eqe->event.srq.srqn),\n\t\t\t\t eq->eqn);\n\t\tcase MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:\n\t\t\tif (mlx4_is_master(dev)) {\n\t\t\t\t/* forward only to slave owning the SRQ */\n\t\t\t\tret = mlx4_get_slave_from_resource_id(dev,\n\t\t\t\t\t\tRES_SRQ,\n\t\t\t\t\t\tbe32_to_cpu(eqe->event.srq.srqn)\n\t\t\t\t\t\t& 0xffffff,\n\t\t\t\t\t\t&slave);\n\t\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\t\tmlx4_warn(dev, "SRQ event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\\n",\n\t\t\t\t\t\t  eqe->type, eqe->subtype,\n\t\t\t\t\t\t  eq->eqn, eq->cons_index, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (eqe->type ==\n\t\t\t\t    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)\n\t\t\t\t\tmlx4_warn(dev, "%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\\n",\n\t\t\t\t\t\t  __func__, slave,\n\t\t\t\t\t\t  be32_to_cpu(eqe->event.srq.srqn),\n\t\t\t\t\t\t  eqe->type, eqe->subtype);\n\n\t\t\t\tif (!ret && slave != dev->caps.function) {\n\t\t\t\t\tif (eqe->type ==\n\t\t\t\t\t    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)\n\t\t\t\t\t\tmlx4_warn(dev, "%s: sending event %02x(%02x) to slave:%d\\n",\n\t\t\t\t\t\t\t  __func__, eqe->type,\n\t\t\t\t\t\t\t  eqe->subtype, slave);\n\t\t\t\t\tmlx4_slave_event(dev, slave, eqe);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlx4_srq_event(dev, be32_to_cpu(eqe->event.srq.srqn) &\n\t\t\t\t       0xffffff, eqe->type);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_CMD:\n\t\t\tmlx4_cmd_event(dev,\n\t\t\t\t       be16_to_cpu(eqe->event.cmd.token),\n\t\t\t\t       eqe->event.cmd.status,\n\t\t\t\t       be64_to_cpu(eqe->event.cmd.out_param));\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_PORT_CHANGE: {\n\t\t\tstruct mlx4_slaves_pport slaves_port;\n\t\t\tport = be32_to_cpu(eqe->event.port_change.port) >> 28;\n\t\t\tslaves_port = mlx4_phys_to_slaves_pport(dev, port);\n\t\t\tif (eqe->subtype == MLX4_PORT_CHANGE_SUBTYPE_DOWN) {\n\t\t\t\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_PORT_DOWN,\n\t\t\t\t\t\t    port);\n\t\t\t\tmlx4_priv(dev)->sense.do_sense_port[port] = 1;\n\t\t\t\tif (!mlx4_is_master(dev))\n\t\t\t\t\tbreak;\n\t\t\t\tfor (i = 0; i < dev->persist->num_vfs + 1;\n\t\t\t\t     i++) {\n\t\t\t\t\tint reported_port = mlx4_is_bonded(dev) ? 1 : mlx4_phys_to_slave_port(dev, i, port);\n\n\t\t\t\t\tif (!test_bit(i, slaves_port.slaves) && !mlx4_is_bonded(dev))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH) {\n\t\t\t\t\t\tif (i == mlx4_master_func_num(dev))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tmlx4_dbg(dev, "%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\\n",\n\t\t\t\t\t\t\t __func__, i, port);\n\t\t\t\t\t\ts_info = &priv->mfunc.master.vf_oper[i].vport[port].state;\n\t\t\t\t\t\tif (IFLA_VF_LINK_STATE_AUTO == s_info->link_state) {\n\t\t\t\t\t\t\teqe->event.port_change.port =\n\t\t\t\t\t\t\t\tcpu_to_be32(\n\t\t\t\t\t\t\t\t(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\n\t\t\t\t\t\t\t\t| (reported_port << 28));\n\t\t\t\t\t\t\tmlx4_slave_event(dev, i, eqe);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {  /* IB port */\n\t\t\t\t\t\tset_and_calc_slave_port_state(dev, i, port,\n\t\t\t\t\t\t\t\t\t      MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN,\n\t\t\t\t\t\t\t\t\t      &gen_event);\n\t\t\t\t\t\t/*we can be in pending state, then do not send port_down event*/\n\t\t\t\t\t\tif (SLAVE_PORT_GEN_EVENT_DOWN ==  gen_event) {\n	f
1145	311	ft_send_resp_status	drivers/target/tcm_fc/tfc_cmd.c	fp	1	13	\N	\N	\tstruct fc_frame *fp;\n\tstruct fc_seq *sp;\n\tconst struct fc_frame_header *fh;\n\tsize_t len;\n\tstruct fcp_resp_with_ext *fcp;\n\tstruct fcp_resp_rsp_info *info;\n\n\tfh = fc_frame_header_get(rx_fp);\n\tpr_debug("FCP error response: did %x oxid %x status %x code %x\\n",\n\t\t  ntoh24(fh->fh_s_id), ntohs(fh->fh_ox_id), status, code);\n\tlen = sizeof(*fcp);\n\tif (status == SAM_STAT_GOOD)\n\t\tlen += sizeof(*info);\n\tfp = fc_frame_alloc(lport, len);\n\tif (!fp)\n\t\treturn;\n\tfcp = fc_frame_payload_get(fp, len);\n	f
5	412	picolcd_set_par	drivers/hid/hid-picolcd_fb.c	tmp_fb	1	13	\N	\N	\tstruct picolcd_fb_data *fbdata = info->par;\n\tu8 *tmp_fb, *o_fb;\n\tif (info->var.bits_per_pixel == fbdata->bpp)\n\t\treturn 0;\n\t/* switch between 1/8 bit depths */\n\tif (info->var.bits_per_pixel != 1 && info->var.bits_per_pixel != 8)\n\t\treturn -EINVAL;\n\n\to_fb   = fbdata->bitmap;\n\ttmp_fb = kmalloc(PICOLCDFB_SIZE*info->var.bits_per_pixel, GFP_KERNEL);\n\tif (!tmp_fb)\n\t\treturn -ENOMEM;\n\n\t/* translate FB content to new bits-per-pixel */\n\tif (info->var.bits_per_pixel == 1) {\n\t\tint i, b;\n\t\tfor (i = 0; i < PICOLCDFB_SIZE; i++) {\n\t\t\tu8 p = 0;\n\t\t\tfor (b = 0; b < 8; b++) {\n\t\t\t\tp <<= 1;\n\t\t\t\tp |= o_fb[i*8+b] ? 0x01 : 0x00;\n\t\t\t}\n\t\t\ttmp_fb[i] = p;\n\t\t}\n\t\tmemcpy(o_fb, tmp_fb, PICOLCDFB_SIZE);\n	f
1226	918	ubi_scan_fastmap	drivers/mtd/ubi/fastmap.c	fmsb->version	1	13	\N	\N	\tstruct ubi_fm_sb *fmsb, *fmsb2;\n\tstruct ubi_vid_io_buf *vb;\n\tstruct ubi_vid_hdr *vh;\n\tstruct ubi_ec_hdr *ech;\n\tstruct ubi_fastmap_layout *fm;\n\tstruct ubi_ainf_peb *aeb;\n\tint i, used_blocks, pnum, fm_anchor, ret = 0;\n\tsize_t fm_size;\n\t__be32 crc, tmp_crc;\n\tunsigned long long sqnum = 0;\n\n\tfm_anchor = find_fm_anchor(scan_ai);\n\tif (fm_anchor < 0)\n\t\treturn UBI_NO_FASTMAP;\n\n\t/* Copy all (possible) fastmap blocks into our new attach structure. */\n\tlist_for_each_entry(aeb, &scan_ai->fastmap, u.list) {\n\t\tstruct ubi_ainf_peb *new;\n\n\t\tnew = clone_aeb(ai, aeb);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\tlist_add(&new->u.list, &ai->fastmap);\n\t}\n\n\tdown_write(&ubi->fm_protect);\n\tmemset(ubi->fm_buf, 0, ubi->fm_size);\n\n\tfmsb = kmalloc(sizeof(*fmsb), GFP_KERNEL);\n\tif (!fmsb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfm = kzalloc(sizeof(*fm), GFP_KERNEL);\n\tif (!fm) {\n\t\tret = -ENOMEM;\n\t\tkfree(fmsb);\n\t\tgoto out;\n\t}\n\n\tret = ubi_io_read_data(ubi, fmsb, fm_anchor, 0, sizeof(*fmsb));\n\tif (ret && ret != UBI_IO_BITFLIPS)\n\t\tgoto free_fm_sb;\n\telse if (ret == UBI_IO_BITFLIPS)\n\t\tfm->to_be_tortured[0] = 1;\n\n\tif (be32_to_cpu(fmsb->magic) != UBI_FM_SB_MAGIC) {\n\t\tubi_err(ubi, "bad super block magic: 0x%x, expected: 0x%x",\n\t\t\tbe32_to_cpu(fmsb->magic), UBI_FM_SB_MAGIC);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_fm_sb;\n\t}\n\n\tif (fmsb->version != UBI_FM_FMT_VERSION) {\n	f
1231	791	hid_sensor_custom_probe	drivers/hid/hid-sensor-custom.c	sensor_inst	1	13	\N	\N	\tstruct hid_sensor_custom *sensor_inst;\n\tstruct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;\n\tint ret;\n\n\tsensor_inst = devm_kzalloc(&pdev->dev, sizeof(*sensor_inst),\n\t\t\t\t   GFP_KERNEL);\n\tif (!sensor_inst)\n\t\treturn -ENOMEM;\n\n\tsensor_inst->callbacks.capture_sample = hid_sensor_capture_sample;\n\tsensor_inst->callbacks.send_event = hid_sensor_send_event;\n\tsensor_inst->callbacks.pdev = pdev;\n\tsensor_inst->hsdev = hsdev;\n\tsensor_inst->pdev = pdev;\n\tmutex_init(&sensor_inst->mutex);\n\tplatform_set_drvdata(pdev, sensor_inst);\n\tret = sensor_hub_register_callback(hsdev, hsdev->usage,\n\t\t\t\t\t   &sensor_inst->callbacks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, "callback reg failed\\n");\n\t\treturn ret;\n\t}\n\n\tret = sysfs_create_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t\t &enable_sensor_attr_group);\n\tif (ret)\n\t\tgoto err_remove_callback;\n\n\tret = hid_sensor_custom_add_attributes(sensor_inst);\n	f
1236	1378	pn533_poll_dep	drivers/nfc/pn533/pn533.c	skb	1	13	\N	\N	\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tint rc, skb_len;\n\tu8 *next, nfcid3[NFC_NFCID3_MAXSIZE];\n\tu8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};\n\n\tdev_dbg(dev->dev, "%s", __func__);\n\n\tif (!dev->gb) {\n\t\tdev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);\n\n\t\tif (!dev->gb || !dev->gb_len) {\n\t\t\tdev->poll_dep = 0;\n\t\t\tqueue_work(dev->wq, &dev->rf_work);\n\t\t}\n\t}\n\n\tskb_len = 3 + dev->gb_len; /* ActPass + BR + Next */\n\tskb_len += PASSIVE_DATA_LEN;\n\n\t/* NFCID3 */\n\tskb_len += NFC_NFCID3_MAXSIZE;\n\tnfcid3[0] = 0x1;\n\tnfcid3[1] = 0xfe;\n\tget_random_bytes(nfcid3 + 2, 6);\n\n\tskb = pn533_alloc_skb(dev, skb_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x01);  /* Active */\n	f
1276	183	stm32_pwm_disable	drivers/pwm/pwm-stm32.c	stm32_pwm_disable_	1	13	\N	\N	\tu32 mask;\n\n\t/* Disable channel */\n\tmask = TIM_CCER_CC1E << (ch * 4);\n\tif (priv->have_complementary_output)\n\t\tmask |= TIM_CCER_CC1NE << (ch * 4);\n\n\tregmap_update_bits(priv->regmap, TIM_CCER, mask, 0);\n\n\t/* When all channels are disabled, we can disable the controller */\n\tif (!active_channels(priv))\n	f
1333	660	spacc_aead_setup	drivers/crypto/picoxcell_crypto.c	err	1	13	\N	\N	\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct spacc_engine *engine = to_spacc_aead(alg)->engine;\n\tstruct spacc_req *dev_req = aead_request_ctx(req);\n\tint err;\n\tunsigned long flags;\n\n\tdev_req->req\t\t= &req->base;\n\tdev_req->is_encrypt\t= is_encrypt;\n\tdev_req->result\t\t= -EBUSY;\n\tdev_req->engine\t\t= engine;\n\tdev_req->complete\t= spacc_aead_complete;\n\n\tif (unlikely(spacc_aead_need_fallback(req) ||\n\t\t     ((err = spacc_aead_make_ddts(req)) == -E2BIG)))\n\t\treturn spacc_aead_do_fallback(req, alg_type, is_encrypt);\n\n\tif (err)\n	f
1356	922	ioat_timer_event	drivers/dma/ioat/dma.c	phys_complete	1	13	\N	\N	\tstruct ioatdma_chan *ioat_chan = to_ioat_chan((void *)data);\n\tdma_addr_t phys_complete;\n\tu64 status;\n\n\tstatus = ioat_chansts(ioat_chan);\n\n\t/* when halted due to errors check for channel\n\t * programming errors before advancing the completion state\n\t */\n\tif (is_ioat_halted(status)) {\n\t\tu32 chanerr;\n\n\t\tchanerr = readl(ioat_chan->reg_base + IOAT_CHANERR_OFFSET);\n\t\tdev_err(to_dev(ioat_chan), "%s: Channel halted (%x)\\n",\n\t\t\t__func__, chanerr);\n\t\tdev_err(to_dev(ioat_chan), "Errors:\\n");\n\t\tioat_print_chanerrs(ioat_chan, chanerr);\n\n\t\tif (test_bit(IOAT_RUN, &ioat_chan->state)) {\n\t\t\tspin_lock_bh(&ioat_chan->cleanup_lock);\n\t\t\tspin_lock_bh(&ioat_chan->prep_lock);\n\t\t\tset_bit(IOAT_CHAN_DOWN, &ioat_chan->state);\n\t\t\tspin_unlock_bh(&ioat_chan->prep_lock);\n\n\t\t\tioat_abort_descs(ioat_chan);\n\t\t\tdev_warn(to_dev(ioat_chan), "Reset channel...\\n");\n\t\t\tioat_reset_hw(ioat_chan);\n\t\t\tdev_warn(to_dev(ioat_chan), "Restart channel...\\n");\n\t\t\tioat_restart_channel(ioat_chan);\n\n\t\t\tspin_lock_bh(&ioat_chan->prep_lock);\n\t\t\tclear_bit(IOAT_CHAN_DOWN, &ioat_chan->state);\n\t\t\tspin_unlock_bh(&ioat_chan->prep_lock);\n\t\t\tspin_unlock_bh(&ioat_chan->cleanup_lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ioat_chan->cleanup_lock);\n\n\t/* handle the no-actives case */\n\tif (!ioat_ring_active(ioat_chan)) {\n\t\tspin_lock_bh(&ioat_chan->prep_lock);\n\t\tcheck_active(ioat_chan);\n\t\tspin_unlock_bh(&ioat_chan->prep_lock);\n\t\tspin_unlock_bh(&ioat_chan->cleanup_lock);\n\t\treturn;\n\t}\n\n\t/* if we haven't made progress and we have already\n\t * acknowledged a pending completion once, then be more\n\t * forceful with a restart\n\t */\n\tif (ioat_cleanup_preamble(ioat_chan, &phys_complete))\n\t\t__cleanup(ioat_chan, phys_complete);\n	f
1510	199	vlsi_proc_ndev	drivers/staging/irda/drivers/vlsi_ir.c	byte	1	13	\N	\N	\tvlsi_irda_dev_t *idev = netdev_priv(ndev);\n\tu8 byte;\n\tu16 word;\n\ts32 sec, usec;\n\tunsigned iobase = ndev->base_addr;\n\n\tseq_printf(seq, "\\n%s link state: %s / %s / %s / %s\\n", ndev->name,\n\t\tnetif_device_present(ndev) ? "attached" : "detached", \n\t\tnetif_running(ndev) ? "running" : "not running",\n\t\tnetif_carrier_ok(ndev) ? "carrier ok" : "no carrier",\n\t\tnetif_queue_stopped(ndev) ? "queue stopped" : "queue running");\n\n\tif (!netif_running(ndev))\n\t\treturn;\n\n\tseq_printf(seq, "\\nhw-state:\\n");\n\tpci_read_config_byte(idev->pdev, VLSI_PCI_IRMISC, &byte);\n\tseq_printf(seq, "IRMISC:%s%s%s uart%s",\n\t\t(byte&IRMISC_IRRAIL) ? " irrail" : "",\n	f
1638	2038	bcm2048_fm_deemphasis_write	drivers/staging/media/bcm2048/radio-bcm2048.c	unsigned	1	13	\N	\N	\tstruct bcm2048_device *bdev = dev;\n\n\tdev_dbg(&bdev->client->dev, "IRQ called, queuing work\\n");\n\tif (bdev->power_state)\n\t\tschedule_work(&bdev->work);\n\n\treturn IRQ_HANDLED;\n}\n\n/*\n *\tBCM2048 sysfs interface definitions\n */\n#define property_write(prop, type, mask, check)\t\t\t\t\\\nstatic ssize_t bcm2048_##prop##_write(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tconst char *buf,\t\t\\\n\t\t\t\t\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bcm2048_device *bdev = dev_get_drvdata(dev);\t\t\\\n\ttype value;\t\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!bdev)\t\t\t\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sscanf(buf, mask, &value) != 1)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (check)\t\t\t\t\t\t\t\\\n\t\treturn -EDOM;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = bcm2048_set_##prop(bdev, value);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn err < 0 ? err : count;\t\t\t\t\t\\\n}\n\n#define property_read(prop, size, mask)\t\t\t\t\t\\\nstatic ssize_t bcm2048_##prop##_read(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bcm2048_device *bdev = dev_get_drvdata(dev);\t\t\\\n\tint value;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!bdev)\t\t\t\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tvalue = bcm2048_get_##prop(bdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (value >= 0)\t\t\t\t\t\t\t\\\n\t\tvalue = sprintf(buf, mask "\\n", value);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn value;\t\t\t\t\t\t\t\\\n}\n\n#define property_signed_read(prop, size, mask)\t\t\t\t\\\nstatic ssize_t bcm2048_##prop##_read(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bcm2048_device *bdev = dev_get_drvdata(dev);\t\t\\\n\tsize value;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!bdev)\t\t\t\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tvalue = bcm2048_get_##prop(bdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, mask "\\n", value);\t\t\t\t\\\n}\n\n#define DEFINE_SYSFS_PROPERTY(prop, signal, size, mask, check)\t\t\\\nproperty_write(prop, signal size, mask, check)\t\t\t\t\\\nproperty_read(prop, size, mask)\n\n#define property_str_read(prop, size)\t\t\t\t\t\\\nstatic ssize_t bcm2048_##prop##_read(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bcm2048_device *bdev = dev_get_drvdata(dev);\t\t\\\n\tint count;\t\t\t\t\t\t\t\\\n\tu8 *out;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!bdev)\t\t\t\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tout = kzalloc((size) + 1, GFP_KERNEL);\t\t\t\t\\\n\tif (!out)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tbcm2048_get_##prop(bdev, out);\t\t\t\t\t\\\n\tcount = sprintf(buf, "%s\\n", out);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tkfree(out);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nDEFINE_SYSFS_PROPERTY(power_state, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(mute, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(audio_route, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(dac_output, unsigned, int, "%u", 0)\n\nDEFINE_SYSFS_PROPERTY(fm_hi_lo_injection, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(fm_frequency, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(fm_af_frequency, unsigned, int, "%u", 0)\nDEFINE_SYSFS_PROPERTY(fm_deemphasis, unsigned, int, "%u", 0)\n	f
1645	1034	ov5693_q_focus_abs	drivers/staging/media/atomisp/i2c/ov5693/ov5693.c	val	1	13	\N	\N	\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\ts32 val;\n\n\tov5693_q_focus_status(sd, &val);\n\n\tif (val & ATOMISP_FOCUS_STATUS_MOVING)\n	f
1714	323	isp_subdev_propagate	drivers/staging/media/atomisp/pci/atomisp2/atomisp_subdev.c	ffmt	1	13	\N	\N	\tstruct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];\n\tstruct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],\n\t\t*comp[ATOMISP_SUBDEV_PADS_NUM];\n\n\tif (flags & V4L2_SEL_FLAG_KEEP_CONFIG)\n\t\treturn;\n\n\tisp_get_fmt_rect(sd, cfg, which, ffmt, crop, comp);\n\n\tswitch (pad) {\n\tcase ATOMISP_SUBDEV_PAD_SINK: {\n\t\tstruct v4l2_rect r = {0};\n\n\t\t/* Only crop target supported on sink pad. */\n\t\tr.width = ffmt[pad]->width;\n\t\tr.height = ffmt[pad]->height;\n	f
1749	266	lnet_shuffle_seed	drivers/staging/lustre/lnet/lnet/router.c	ts.tv_sec ^ seed[0]	1	13	\N	\N	\tstatic int seeded;\n\t__u32 lnd_type, seed[2];\n\tstruct timespec64 ts;\n\tstruct lnet_ni *ni;\n\tstruct list_head *tmp;\n\n\tif (seeded)\n\t\treturn;\n\n\tcfs_get_random_bytes(seed, sizeof(seed));\n\n\t/*\n\t * Nodes with small feet have little entropy\n\t * the NID for this node gives the most entropy in the low bits\n\t */\n\tlist_for_each(tmp, &the_lnet.ln_nis) {\n\t\tni = list_entry(tmp, struct lnet_ni, ni_list);\n\t\tlnd_type = LNET_NETTYP(LNET_NIDNET(ni->ni_nid));\n\n\t\tif (lnd_type != LOLND)\n\t\t\tseed[0] ^= (LNET_NIDADDR(ni->ni_nid) | lnd_type);\n\t}\n\n\tktime_get_ts64(&ts);\n\tcfs_srand(ts.tv_sec ^ seed[0], ts.tv_nsec ^ seed[1]);\n	f
1815	159	rs5c_get_regs	drivers/rtc/rtc-rs5c372.c	rs5c_get_regs_	1	13	\N	\N	\tstruct i2c_client\t*client = rs5c->client;\n\tstruct i2c_msg\t\tmsgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(rs5c->buf),\n\t\t\t.buf = rs5c->buf\n\t\t},\n\t};\n\n\t/* This implements the third reading method from the datasheet, using\n\t * an internal address that's reset after each transaction (by STOP)\n\t * to 0x0f ... so we read extra registers, and skip the first one.\n\t *\n\t * The first method doesn't work with the iop3xx adapter driver, on at\n\t * least 80219 chips; this works around that bug.\n\t *\n\t * The third method on the other hand doesn't work for the SMBus-only\n\t * configurations, so we use the the first method there, stripping off\n\t * the extra register in the process.\n\t */\n\tif (rs5c->smbus) {\n\t\tint addr = RS5C_ADDR(RS5C372_REG_SECS);\n\t\tint size = sizeof(rs5c->buf) - 1;\n\n\t\tif (i2c_smbus_read_i2c_block_data(client, addr, size,\n	f
1854	144	__ip_options_echo	net/ipv4/ip_options.c	__ip_options_echo_	1	13	\N	\N	\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tif (sopt->optlen == 0)\n\t\treturn 0;\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(net, addr) != RTN_UNICAST) {\n	f
2035	507	__clk_rcg_set_rate	drivers/clk/qcom/clk-rcg.c	ctl	1	13	\N	\N	\tu32 ns, md, ctl;\n\tstruct mn *mn = &rcg->mn;\n\tu32 mask = 0;\n\tunsigned int reset_reg;\n\n\tif (rcg->mn.reset_in_cc)\n\t\treset_reg = rcg->clkr.enable_reg;\n\telse\n\t\treset_reg = rcg->ns_reg;\n\n\tif (rcg->mn.width) {\n\t\tmask = BIT(mn->mnctr_reset_bit);\n\t\tregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, mask);\n\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\n\t\tmd = mn_to_md(mn, f->m, f->n, md);\n\t\tregmap_write(rcg->clkr.regmap, rcg->md_reg, md);\n\n\t\tregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\t\t/* MN counter mode is in hw.enable_reg sometimes */\n\t\tif (rcg->clkr.enable_reg != rcg->ns_reg) {\n\t\t\tregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\n\t\t\tctl = mn_to_reg(mn, f->m, f->n, ctl);\n\t\t\tregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\n	f
2056	168	charger_state_show	drivers/power/supply/wm8350_power.c	state	1	13	\N	\N	\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tchar *charge;\n\tint state;\n\n\tstate = wm8350_reg_read(wm8350, WM8350_BATTERY_CHARGER_CONTROL_2) &\n\t    WM8350_CHG_STS_MASK;\n\tswitch (state) {\n	f
2181	823	cbr_dll2	drivers/gpu/drm/ast/ast_post.c	dllmin	1	13	\N	\N	\tu32 dllmin[2], dllmax[2], dlli, data, passcnt, retry = 0;\n\tbool status = false;\n\n\tfinetuneDQSI(ast);\n\tif (finetuneDQI_L(ast, param) == false)\n\t\treturn status;\n\nCBR_START2:\n\tdllmin[0] = dllmin[1] = 0xff;\n\tdllmax[0] = dllmax[1] = 0x0;\n\tpasscnt = 0;\n\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\tast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\n\t\tast_moutdwm(ast, 0x1E6E0074, CBR_SIZE2);\n\t\tdata = cbr_scan(ast);\n\t\tif (data != 0) {\n\t\t\tif (data & 0x1) {\n\t\t\t\tif (dllmin[0] > dlli) {\n	f
2254	239	dw_pcie_prog_inbound_atu_unroll	drivers/pci/dwc/pcie-designware.c	val	1	13	\N	\N	\tint type;\n\tu32 retries, val;\n\n\tdw_pcie_writel_ib_unroll(pci, index, PCIE_ATU_UNR_LOWER_TARGET,\n\t\t\t\t lower_32_bits(cpu_addr));\n\tdw_pcie_writel_ib_unroll(pci, index, PCIE_ATU_UNR_UPPER_TARGET,\n\t\t\t\t upper_32_bits(cpu_addr));\n\n\tswitch (as_type) {\n\tcase DW_PCIE_AS_MEM:\n\t\ttype = PCIE_ATU_TYPE_MEM;\n\t\tbreak;\n\tcase DW_PCIE_AS_IO:\n\t\ttype = PCIE_ATU_TYPE_IO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdw_pcie_writel_ib_unroll(pci, index, PCIE_ATU_UNR_REGION_CTRL1, type);\n\tdw_pcie_writel_ib_unroll(pci, index, PCIE_ATU_UNR_REGION_CTRL2,\n\t\t\t\t PCIE_ATU_ENABLE |\n\t\t\t\t PCIE_ATU_BAR_MODE_ENABLE | (bar << 8));\n\n\t/*\n\t * Make sure ATU enable takes effect before any subsequent config\n\t * and I/O accesses.\n\t */\n\tfor (retries = 0; retries < LINK_WAIT_MAX_IATU_RETRIES; retries++) {\n\t\tval = dw_pcie_readl_ib_unroll(pci, index,\n\t\t\t\t\t      PCIE_ATU_UNR_REGION_CTRL2);\n\t\tif (val & PCIE_ATU_ENABLE)\n	f
2273	145	lm3533_led_get	drivers/leds/leds-lm3533.c	val	1	13	\N	\N	\tstruct lm3533_led *led = to_lm3533_led(cdev);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_ctrlbank_get_brightness(&led->cb, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(led->cdev.dev, "%s - %u\\n", __func__, val);\n	f
2274	4501	PrimeIocFifos	drivers/message/fusion/mptbase.c	alloc_dma	1	13	\N	\N	\tMPT_FRAME_HDR *mf;\n\tunsigned long flags;\n\tdma_addr_t alloc_dma;\n\tu8 *mem;\n\tint i, reply_sz, sz, total_size, num_chain;\n\tu64\tdma_mask;\n\n\tdma_mask = 0;\n\n\t/*  Prime reply FIFO...  */\n\n\tif (ioc->reply_frames == NULL) {\n\t\tif ( (num_chain = initChainBuffers(ioc)) < 0)\n\t\t\treturn -1;\n\t\t/*\n\t\t * 1078 errata workaround for the 36GB limitation\n\t\t */\n\t\tif (ioc->pcidev->device == MPI_MANUFACTPAGE_DEVID_SAS1078 &&\n\t\t    ioc->dma_mask > DMA_BIT_MASK(35)) {\n\t\t\tif (!pci_set_dma_mask(ioc->pcidev, DMA_BIT_MASK(32))\n\t\t\t    && !pci_set_consistent_dma_mask(ioc->pcidev,\n\t\t\t    DMA_BIT_MASK(32))) {\n\t\t\t\tdma_mask = DMA_BIT_MASK(35);\n\t\t\t\td36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t    "setting 35 bit addressing for "\n\t\t\t\t    "Request/Reply/Chain and Sense Buffers\\n",\n\t\t\t\t    ioc->name));\n\t\t\t} else {\n\t\t\t\t/*Reseting DMA mask to 64 bit*/\n\t\t\t\tpci_set_dma_mask(ioc->pcidev,\n\t\t\t\t\tDMA_BIT_MASK(64));\n\t\t\t\tpci_set_consistent_dma_mask(ioc->pcidev,\n\t\t\t\t\tDMA_BIT_MASK(64));\n\n\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t    "failed setting 35 bit addressing for "\n\t\t\t\t    "Request/Reply/Chain and Sense Buffers\\n",\n\t\t\t\t    ioc->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ttotal_size = reply_sz = (ioc->reply_sz * ioc->reply_depth);\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffer sz=%d bytes, ReplyDepth=%d\\n",\n\t\t\t \tioc->name, ioc->reply_sz, ioc->reply_depth));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffer sz=%d[%x] bytes\\n",\n\t\t\t \tioc->name, reply_sz, reply_sz));\n\n\t\tsz = (ioc->req_sz * ioc->req_depth);\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestBuffer sz=%d bytes, RequestDepth=%d\\n",\n\t\t\t \tioc->name, ioc->req_sz, ioc->req_depth));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestBuffer sz=%d[%x] bytes\\n",\n\t\t\t \tioc->name, sz, sz));\n\t\ttotal_size += sz;\n\n\t\tsz = num_chain * ioc->req_sz; /* chain buffer pool size */\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainBuffer sz=%d bytes, ChainDepth=%d\\n",\n\t\t\t \tioc->name, ioc->req_sz, num_chain));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainBuffer sz=%d[%x] bytes num_chain=%d\\n",\n\t\t\t \tioc->name, sz, sz, num_chain));\n\n\t\ttotal_size += sz;\n\t\tmem = pci_alloc_consistent(ioc->pcidev, total_size, &alloc_dma);\n\t\tif (mem == NULL) {\n\t\t\tprintk(MYIOC_s_ERR_FMT "Unable to allocate Reply, Request, Chain Buffers!\\n",\n\t\t\t\tioc->name);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Total alloc @ %p[%p], sz=%d[%x] bytes\\n",\n	f
2324	347	exynos_ppmu_v2_disable	drivers/devfreq/event/exynos-ppmu.c	pmnc	1	13	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint ret;\n\tu32 pmnc, clear;\n\n\t/* Disable all counters */\n\tclear = (PPMU_CCNT_MASK | PPMU_PMCNT0_MASK | PPMU_PMCNT1_MASK\n\t\t| PPMU_PMCNT2_MASK | PPMU_PMCNT3_MASK);\n\tret = regmap_write(info->regmap, PPMU_V2_FLAG, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_INTENC, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENC, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNT_RESET, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG0, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG1, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG2, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_RESULT, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNT_AUTO, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV0_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV1_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV2_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV3_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_ID_V, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_ID_A, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_OTHERS_V, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_OTHERS_A, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_INTERRUPT_RESET, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Disable PPMU */\n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~PPMU_PMNC_ENABLE_MASK;\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n	f
2359	124	ds1343_show_glitchfilter	drivers/rtc/rtc-ds1343.c	glitch_filt_status	1	13	\N	\N	\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\tint glitch_filt_status, data;\n\n\tregmap_read(priv->map, DS1343_CONTROL_REG, &data);\n\n\tglitch_filt_status = !!(data & DS1343_EGFIL);\n\n\tif (glitch_filt_status)\n	f
2501	376	cmos_validate_alarm	drivers/rtc/rtc-cmos.c	t_max_date	1	13	\N	\N	\tstruct cmos_rtc *cmos = dev_get_drvdata(dev);\n\tstruct rtc_time now;\n\n\tcmos_read_time(dev, &now);\n\n\tif (!cmos->day_alrm) {\n\t\ttime64_t t_max_date;\n\t\ttime64_t t_alrm;\n\n\t\tt_max_date = rtc_tm_to_time64(&now);\n\t\tt_max_date += 24 * 60 * 60 - 1;\n\t\tt_alrm = rtc_tm_to_time64(&t->time);\n\t\tif (t_alrm > t_max_date) {\n\t\t\tdev_err(dev,\n\t\t\t\t"Alarms can be up to one day in the future\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!cmos->mon_alrm) {\n\t\tstruct rtc_time max_date = now;\n\t\ttime64_t t_max_date;\n\t\ttime64_t t_alrm;\n\t\tint max_mday;\n\n\t\tif (max_date.tm_mon == 11) {\n\t\t\tmax_date.tm_mon = 0;\n\t\t\tmax_date.tm_year += 1;\n\t\t} else {\n\t\t\tmax_date.tm_mon += 1;\n\t\t}\n\t\tmax_mday = rtc_month_days(max_date.tm_mon, max_date.tm_year);\n\t\tif (max_date.tm_mday > max_mday)\n\t\t\tmax_date.tm_mday = max_mday;\n\n\t\tt_max_date = rtc_tm_to_time64(&max_date);\n\t\tt_max_date -= 1;\n\t\tt_alrm = rtc_tm_to_time64(&t->time);\n\t\tif (t_alrm > t_max_date) {\n	f
2545	200	iadc_status_show	drivers/iio/adc/qcom-spmi-iadc.c	chan	1	13	\N	\N	\tu8 mode, sta1, chan, dig, en, req;\n\tint ret;\n\n\tret = iadc_read(iadc, IADC_MODE_CTL, &mode);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_DIG_PARAM, &dig);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_CH_SEL_CTL, &chan);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_CONV_REQ, &req);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_STATUS1, &sta1);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_EN_CTL1, &en);\n\tif (ret < 0)\n\t\treturn;\n\n\tdev_err(iadc->dev,\n	f
2607	540	bmg160_get_axis	drivers/iio/gyro/bmg160_core.c	ret	1	13	\N	\N	\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__le16 raw_val;\n\n\tmutex_lock(&data->mutex);\n\tret = bmg160_set_power_state(data, true);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, BMG160_AXIS_TO_REG(axis), &raw_val,\n\t\t\t       sizeof(raw_val));\n\tif (ret < 0) {\n	f
2608	576	hmc5843_init	drivers/iio/magnetometer/hmc5843_core.c	ret	1	13	\N	\N	\tint ret;\n\tu8 id[3];\n\n\tret = regmap_bulk_read(data->regmap, HMC5843_ID_REG,\n\t\t\t       id, ARRAY_SIZE(id));\n\tif (ret < 0)\n	f
2740	422	wm8350_dcdc_set_suspend_disable	drivers/regulator/wm8350-regulator.c	val | WM8350_DCDC_HIB_MODE_DIS	1	13	\N	\N	\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER);\n\t\twm8350->pmic.dcdc1_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC1_LOW_POWER,\n	f
2811	499	max8997_set_voltage_ldobuck	drivers/regulator/max8997-regulator.c	reg	1	13	\N	\N	\tstruct max8997_data *max8997 = rdev_get_drvdata(rdev);\n\tstruct i2c_client *i2c = max8997->iodev->i2c;\n\tconst struct voltage_map_desc *desc;\n\tint rid = rdev_get_id(rdev);\n\tint i, reg, shift, mask, ret;\n\n\tswitch (rid) {\n\tcase MAX8997_LDO1 ... MAX8997_LDO21:\n\t\tbreak;\n\tcase MAX8997_BUCK1 ... MAX8997_BUCK5:\n\t\tbreak;\n\tcase MAX8997_BUCK6:\n\t\treturn -EINVAL;\n\tcase MAX8997_BUCK7:\n\t\tbreak;\n\tcase MAX8997_CHARGER:\n\t\tbreak;\n\tcase MAX8997_CHARGER_TOPOFF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdesc = reg_voltage_map[rid];\n\n\ti = max8997_get_voltage_proper_val(desc, min_uV, max_uV);\n\tif (i < 0)\n\t\treturn i;\n\n\tret = max8997_get_voltage_register(rdev, &reg, &shift, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max8997_update_reg(i2c, reg, i << shift, mask << shift);\n	f
2833	1072	set_pwm_auto_pwm_min	drivers/hwmon/lm85.c	min_pwm	1	13	\N	\N	\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].min_pwm = PWM_TO_REG(val);\n	f
2898	71	cache_setup_of_node	drivers/base/cacheinfo.c	np	1	13	\N	\N	\tstruct device_node *np;\n\tstruct cacheinfo *this_leaf;\n\tstruct device *cpu_dev = get_cpu_device(cpu);\n\tstruct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);\n\tunsigned int index = 0;\n\n\t/* skip if of_node is already populated */\n\tif (this_cpu_ci->info_list->of_node)\n\t\treturn 0;\n\n\tif (!cpu_dev) {\n\t\tpr_err("No cpu device for CPU %d\\n", cpu);\n\t\treturn -ENODEV;\n\t}\n\tnp = cpu_dev->of_node;\n\tif (!np) {\n\t\tpr_err("Failed to find cpu%d device node\\n", cpu);\n\t\treturn -ENOENT;\n\t}\n\n\twhile (index < cache_leaves(cpu)) {\n\t\tthis_leaf = this_cpu_ci->info_list + index;\n\t\tif (this_leaf->level != 1)\n\t\t\tnp = of_find_next_cache_node(np);\n	f
2922	863	cx25840_std_setup	drivers/media/i2c/cx25840/cx25840-core.c	pll	1	13	\N	\N	\tstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\n\tv4l2_std_id std = state->std;\n\tint hblank, hactive, burst, vblank, vactive, sc;\n\tint vblank656, src_decimation;\n\tint luma_lpf, uv_lpf, comb;\n\tu32 pll_int, pll_frac, pll_post;\n\n\t/* datasheet startup, step 8d */\n\tif (std & ~V4L2_STD_NTSC)\n\t\tcx25840_write(client, 0x49f, 0x11);\n\telse\n\t\tcx25840_write(client, 0x49f, 0x14);\n\n\tif (std & V4L2_STD_625_50) {\n\t\thblank = 132;\n\t\thactive = 720;\n\t\tburst = 93;\n\t\tvblank = 36;\n\t\tvactive = 580;\n\t\tvblank656 = 40;\n\t\tsrc_decimation = 0x21f;\n\t\tluma_lpf = 2;\n\n\t\tif (std & V4L2_STD_SECAM) {\n\t\t\tuv_lpf = 0;\n\t\t\tcomb = 0;\n\t\t\tsc = 0x0a425f;\n\t\t} else if (std == V4L2_STD_PAL_Nc) {\n\t\t\tuv_lpf = 1;\n\t\t\tcomb = 0x20;\n\t\t\tsc = 556453;\n\t\t} else {\n\t\t\tuv_lpf = 1;\n\t\t\tcomb = 0x20;\n\t\t\tsc = 688739;\n\t\t}\n\t} else {\n\t\thactive = 720;\n\t\thblank = 122;\n\t\tvactive = 487;\n\t\tluma_lpf = 1;\n\t\tuv_lpf = 1;\n\n\t\tsrc_decimation = 0x21f;\n\t\tif (std == V4L2_STD_PAL_60) {\n\t\t\tvblank = 26;\n\t\t\tvblank656 = 26;\n\t\t\tburst = 0x5b;\n\t\t\tluma_lpf = 2;\n\t\t\tcomb = 0x20;\n\t\t\tsc = 688739;\n\t\t} else if (std == V4L2_STD_PAL_M) {\n\t\t\tvblank = 20;\n\t\t\tvblank656 = 24;\n\t\t\tburst = 0x61;\n\t\t\tcomb = 0x20;\n\t\t\tsc = 555452;\n\t\t} else {\n\t\t\tvblank = 26;\n\t\t\tvblank656 = 26;\n\t\t\tburst = 0x5b;\n\t\t\tcomb = 0x66;\n\t\t\tsc = 556063;\n\t\t}\n\t}\n\n\t/* DEBUG: Displays configured PLL frequency */\n\tif (!is_cx231xx(state)) {\n\t\tpll_int = cx25840_read(client, 0x108);\n\t\tpll_frac = cx25840_read4(client, 0x10c) & 0x1ffffff;\n\t\tpll_post = cx25840_read(client, 0x109);\n\t\tv4l_dbg(1, cx25840_debug, client,\n\t\t\t"PLL regs = int: %u, frac: %u, post: %u\\n",\n\t\t\tpll_int, pll_frac, pll_post);\n\n\t\tif (pll_post) {\n\t\t\tint fin, fsc;\n\t\t\tint pll = (28636363L * ((((u64)pll_int) << 25L) + pll_frac)) >> 25L;\n\n\t\t\tpll /= pll_post;\n\t\t\tv4l_dbg(1, cx25840_debug, client, "PLL = %d.%06d MHz\\n",\n	f
2980	787	do_set_mempolicy	mm/mempolicy.c	new->mode	1	13	\N	\N	\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n	f
2986	644	i40iw_create_ccq	drivers/infiniband/hw/i40iw/i40iw_main.c	&mem	1	13	\N	\N	\tstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\n\tstruct i40iw_dma_mem mem;\n\tenum i40iw_status_code status;\n\tstruct i40iw_ccq_init_info info;\n\tstruct i40iw_ccq *ccq = &iwdev->ccq;\n\n\tmemset(&info, 0, sizeof(info));\n\tdev->ccq = &ccq->sc_cq;\n\tdev->ccq->dev = dev;\n\tinfo.dev = dev;\n\tccq->shadow_area.size = sizeof(struct i40iw_cq_shadow_area);\n\tccq->mem_cq.size = sizeof(struct i40iw_cqe) * IW_CCQ_SIZE;\n\tstatus = i40iw_allocate_dma_mem(dev->hw, &ccq->mem_cq,\n\t\t\t\t\tccq->mem_cq.size, I40IW_CQ0_ALIGNMENT);\n\tif (status)\n\t\tgoto exit;\n\tstatus = i40iw_obj_aligned_mem(iwdev, &mem, ccq->shadow_area.size,\n	f
3107	590	s5m8767_pmic_dt_parse_pdata	drivers/regulator/s5m8767.c	s5m8767_pmic_dt_parse_pdata_	1	13	\N	\N	\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *pmic_np, *regulators_np, *reg_np;\n\tstruct sec_regulator_data *rdata;\n\tstruct sec_opmode_data *rmode;\n\tunsigned int i, dvs_voltage_nr = 8, ret;\n\n\tpmic_np = iodev->dev->of_node;\n\tif (!pmic_np) {\n\t\tdev_err(iodev->dev, "could not find pmic sub-node\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tregulators_np = of_get_child_by_name(pmic_np, "regulators");\n\tif (!regulators_np) {\n\t\tdev_err(iodev->dev, "could not find regulators sub-node\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* count the number of regulators to be supported in pmic */\n\tpdata->num_regulators = of_get_child_count(regulators_np);\n\n\trdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *\n\t\t\t\tpdata->num_regulators, GFP_KERNEL);\n\tif (!rdata)\n\t\treturn -ENOMEM;\n\n\trmode = devm_kzalloc(&pdev->dev, sizeof(*rmode) *\n\t\t\t\tpdata->num_regulators, GFP_KERNEL);\n\tif (!rmode)\n\t\treturn -ENOMEM;\n\n\tpdata->regulators = rdata;\n\tpdata->opmode = rmode;\n\tfor_each_child_of_node(regulators_np, reg_np) {\n\t\tfor (i = 0; i < ARRAY_SIZE(regulators); i++)\n\t\t\tif (!of_node_cmp(reg_np->name, regulators[i].name))\n\t\t\t\tbreak;\n\n\t\tif (i == ARRAY_SIZE(regulators)) {\n\t\t\tdev_warn(iodev->dev,\n\t\t\t"don't know how to configure regulator %s\\n",\n\t\t\treg_np->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trdata->ext_control_gpio = of_get_named_gpio(reg_np,\n\t\t\t"s5m8767,pmic-ext-control-gpios", 0);\n\n\t\trdata->id = i;\n\t\trdata->initdata = of_get_regulator_init_data(\n\t\t\t\t\t\t&pdev->dev, reg_np,\n\t\t\t\t\t\t&regulators[i]);\n\t\trdata->reg_node = reg_np;\n\t\trdata++;\n\t\trmode->id = i;\n\t\tif (of_property_read_u32(reg_np, "op_mode",\n	f
3200	728	check_qp_movement_and_print	drivers/infiniband/ulp/ipoib/ipoib_ib.c	qp_attr.qp_state	1	13	\N	\N	\tstruct ib_qp_attr qp_attr;\n\tstruct ib_qp_init_attr query_init_attr;\n\tint ret;\n\n\tret = ib_query_qp(qp, &qp_attr, IB_QP_STATE, &query_init_attr);\n\tif (ret) {\n\t\tipoib_warn(priv, "%s: Failed to query QP\\n", __func__);\n\t\treturn;\n\t}\n\t/* print according to the new-state and the previous state.*/\n\tif (new_state == IB_QPS_ERR && qp_attr.qp_state == IB_QPS_RESET)\n	f
3285	562	cx25840_ir_irq_handler	drivers/media/i2c/cx25840/cx25840-ir.c	roe	1	13	\N	\N	\tstruct cx25840_state *state = to_state(sd);\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c = NULL;\n\tunsigned long flags;\n\n\tunion cx25840_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\n\tunsigned int i, j, k;\n\tu32 events, v;\n\tint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\n\tu32 cntrl, irqen, stats;\n\n\t*handled = false;\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tc = ir_state->c;\n\n\t/* Only support the IR controller for the CX2388[57] AV Core for now */\n\tif (!(is_cx23885(state) || is_cx23887(state)))\n\t\treturn -ENODEV;\n\n\tcntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\n\tirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tirqen ^= IRQEN_MSK;\n\tstats = cx25840_read4(c, CX25840_IR_STATS_REG);\n\n\ttsr = stats & STATS_TSR; /* Tx FIFO Service Request */\n\trsr = stats & STATS_RSR; /* Rx FIFO Service Request */\n\trto = stats & STATS_RTO; /* Rx Pulse Width Timer Time Out */\n\tror = stats & STATS_ROR; /* Rx FIFO Over Run */\n\n\ttse = irqen & IRQEN_TSE; /* Tx FIFO Service Request IRQ Enable */\n\trse = irqen & IRQEN_RSE; /* Rx FIFO Service Reuqest IRQ Enable */\n\trte = irqen & IRQEN_RTE; /* Rx Pulse Width Timer Time Out IRQ Enable */\n\troe = irqen & IRQEN_ROE; /* Rx FIFO Over Run IRQ Enable */\n\n\tv4l2_dbg(2, ir_debug, sd, "IR IRQ Status:  %s %s %s %s %s %s\\n",\n\t\t tsr ? "tsr" : "   ", rsr ? "rsr" : "   ",\n\t\t rto ? "rto" : "   ", ror ? "ror" : "   ",\n\t\t stats & STATS_TBY ? "tby" : "   ",\n\t\t stats & STATS_RBY ? "rby" : "   ");\n\n\tv4l2_dbg(2, ir_debug, sd, "IR IRQ Enables: %s %s %s %s\\n",\n	f
3305	670	smiapp_get_limits	drivers/media/i2c/smiapp/smiapp-core.c	val	1	13	\N	\N	\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tunsigned int i;\n\tu32 val;\n\tint rval;\n\n\tfor (i = 0; i < n; i++) {\n\t\trval = smiapp_read(\n\t\t\tsensor, smiapp_reg_limits[limit[i]].addr, &val);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tsensor->limits[limit[i]] = val;\n\t\tdev_dbg(&client->dev, "0x%8.8x \\"%s\\" = %u, 0x%x\\n",\n	f
3330	341	adv_smbus_write_byte_data	drivers/media/i2c/adv7842.c	err	1	13	\N	\N	\tunion i2c_smbus_data data;\n\tint err;\n\tint i;\n\n\tdata.byte = value;\n\tfor (i = 0; i < 3; i++) {\n\t\terr = i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t\t     client->flags,\n\t\t\t\t     I2C_SMBUS_WRITE, command,\n\t\t\t\t     I2C_SMBUS_BYTE_DATA, &data);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\tif (err < 0)\n	f
3467	4563	init_agc	drivers/media/dvb-frontends/drx39xyj/drxj.c	agc_ki	1	13	\N	\N	\tstruct i2c_device_addr *dev_addr = NULL;\n\tstruct drx_common_attr *common_attr = NULL;\n\tstruct drxj_data *ext_attr = NULL;\n\tstruct drxj_cfg_agc *p_agc_rf_settings = NULL;\n\tstruct drxj_cfg_agc *p_agc_if_settings = NULL;\n\tint rc;\n\tu16 ingain_tgt_max = 0;\n\tu16 clp_dir_to = 0;\n\tu16 sns_sum_max = 0;\n\tu16 clp_sum_max = 0;\n\tu16 sns_dir_to = 0;\n\tu16 ki_innergain_min = 0;\n\tu16 agc_ki = 0;\n\tu16 ki_max = 0;\n\tu16 if_iaccu_hi_tgt_min = 0;\n\tu16 data = 0;\n\tu16 agc_ki_dgain = 0;\n\tu16 ki_min = 0;\n\tu16 clp_ctrl_mode = 0;\n\tu16 agc_rf = 0;\n\tu16 agc_if = 0;\n\n\tdev_addr = demod->my_i2c_dev_addr;\n\tcommon_attr = (struct drx_common_attr *) demod->my_common_attr;\n\text_attr = (struct drxj_data *) demod->my_ext_attr;\n\n\tswitch (ext_attr->standard) {\n\tcase DRX_STANDARD_8VSB:\n\t\tclp_sum_max = 1023;\n\t\tclp_dir_to = (u16) (-9);\n\t\tsns_sum_max = 1023;\n\t\tsns_dir_to = (u16) (-9);\n\t\tki_innergain_min = (u16) (-32768);\n\t\tki_max = 0x032C;\n\t\tagc_ki_dgain = 0xC;\n\t\tif_iaccu_hi_tgt_min = 2047;\n\t\tki_min = 0x0117;\n\t\tingain_tgt_max = 16383;\n\t\tclp_ctrl_mode = 0;\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_SUM__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_CYCCNT__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_DIR_WD__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_DIR_STP__A, 1, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_SUM__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_CYCCNT__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_DIR_WD__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_DIR_STP__A, 1, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_INGAIN__A, 1024, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_VSB_AGC_POW_TGT__A, 22600, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_INGAIN_TGT__A, 13200, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\tp_agc_if_settings = &(ext_attr->vsb_if_agc_cfg);\n\t\tp_agc_rf_settings = &(ext_attr->vsb_rf_agc_cfg);\n\t\tbreak;\n#ifndef DRXJ_VSB_ONLY\n\tcase DRX_STANDARD_ITU_A:\n\tcase DRX_STANDARD_ITU_C:\n\tcase DRX_STANDARD_ITU_B:\n\t\tingain_tgt_max = 5119;\n\t\tclp_sum_max = 1023;\n\t\tclp_dir_to = (u16) (-5);\n\t\tsns_sum_max = 127;\n\t\tsns_dir_to = (u16) (-3);\n\t\tki_innergain_min = 0;\n\t\tki_max = 0x0657;\n\t\tif_iaccu_hi_tgt_min = 2047;\n\t\tagc_ki_dgain = 0x7;\n\t\tki_min = 0x0117;\n\t\tclp_ctrl_mode = 0;\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_SUM__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_CYCCNT__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_DIR_WD__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_CLP_DIR_STP__A, 1, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_SUM__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_CYCCNT__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_DIR_WD__A, 0, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_SNS_DIR_STP__A, 1, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\tp_agc_if_settings = &(ext_attr->qam_if_agc_cfg);\n\t\tp_agc_rf_settings = &(ext_attr->qam_rf_agc_cfg);\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_INGAIN_TGT__A, p_agc_if_settings->top, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\n\t\trc = drxj_dap_read_reg16(dev_addr, SCU_RAM_AGC_KI__A, &agc_ki, 0);\n\t\tif (rc != 0) {\n\t\t\tpr_err("error %d\\n", rc);\n\t\t\tgoto rw_error;\n\t\t}\n\t\tagc_ki &= 0xf000;\n\t\trc = drxj_dap_write_reg16(dev_addr, SCU_RAM_AGC_KI__A, agc_ki, 0);\n	f
3468	5155	set_agc_if	drivers/media/dvb-frontends/drx39xyj/drxj.c	data	1	13	\N	\N	\tstruct i2c_device_addr *dev_addr = NULL;\n\tstruct drxj_data *ext_attr = NULL;\n\tstruct drxj_cfg_agc *p_agc_settings = NULL;\n\tstruct drx_common_attr *common_attr = NULL;\n\tdrx_write_reg16func_t scu_wr16 = NULL;\n\tdrx_read_reg16func_t scu_rr16 = NULL;\n\tint rc;\n\n\tcommon_attr = (struct drx_common_attr *) demod->my_common_attr;\n\tdev_addr = demod->my_i2c_dev_addr;\n\text_attr = (struct drxj_data *) demod->my_ext_attr;\n\n\tif (atomic) {\n\t\tscu_rr16 = drxj_dap_scu_atomic_read_reg16;\n\t\tscu_wr16 = drxj_dap_scu_atomic_write_reg16;\n\t} else {\n\t\tscu_rr16 = drxj_dap_read_reg16;\n\t\tscu_wr16 = drxj_dap_write_reg16;\n\t}\n\n\t/* Configure AGC only if standard is currently active */\n\tif ((ext_attr->standard == agc_settings->standard) ||\n\t    (DRXJ_ISQAMSTD(ext_attr->standard) &&\n\t     DRXJ_ISQAMSTD(agc_settings->standard)) ||\n\t    (DRXJ_ISATVSTD(ext_attr->standard) &&\n\t     DRXJ_ISATVSTD(agc_settings->standard))) {\n\t\tu16 data = 0;\n\n\t\tswitch (agc_settings->ctrl_mode) {\n\t\tcase DRX_AGC_CTRL_AUTO:\n\t\t\t/* Enable IF AGC DAC */\n\t\t\trc = drxj_dap_read_reg16(dev_addr, IQM_AF_STDBY__A, &data, 0);\n\t\t\tif (rc != 0) {\n\t\t\t\tpr_err("error %d\\n", rc);\n\t\t\t\tgoto rw_error;\n\t\t\t}\n\t\t\tdata |= IQM_AF_STDBY_STDBY_TAGC_IF_A2_ACTIVE;\n\t\t\trc = drxj_dap_write_reg16(dev_addr, IQM_AF_STDBY__A, data, 0);\n	f
3495	228	ec100_read_ber	drivers/media/dvb-frontends/ec100.c	ber2	1	13	\N	\N	\tstruct ec100_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 tmp, tmp2;\n\tu16 ber2;\n\n\t*ber = 0;\n\n\tret = ec100_read_reg(state, 0x65, &tmp);\n\tif (ret)\n\t\tgoto error;\n\tret = ec100_read_reg(state, 0x66, &tmp2);\n\tif (ret)\n\t\tgoto error;\n\n\tber2 = (tmp2 << 8) | tmp;\n\n\t/* if counter overflow or clear */\n\tif (ber2 < state->ber)\n	f
3529	718	stv090x_read_reg	drivers/media/dvb-frontends/stv090x.c	buf	1	13	\N	\N	\tconst struct stv090x_config *config = state->config;\n\tint ret;\n\n\tu8 b0[] = { reg >> 8, reg & 0xff };\n\tu8 buf;\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr\t= config->address, .flags\t= 0, \t\t.buf = b0,   .len = 2 },\n\t\t{ .addr\t= config->address, .flags\t= I2C_M_RD,\t.buf = &buf, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tdprintk(FE_ERROR, 1,\n\t\t\t\t"Read error, Reg=[0x%02x], Status=%d",\n\t\t\t\treg, ret);\n\n\t\treturn ret < 0 ? ret : -EREMOTEIO;\n\t}\n\tif (unlikely(*state->verbose >= FE_DEBUGREG))\n\t\tdprintk(FE_ERROR, 1, "Reg=[0x%02x], data=%02x",\n	f
3644	327	stb6100_get_frequency	drivers/media/dvb-frontends/stb6100.c	nint	1	13	\N	\N	\tint rc;\n\tu32 nint, nfrac, fvco;\n\tint psd2, odiv;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\tu8 regs[STB6100_NUMREGS];\n\n\trc = stb6100_read_regs(state, regs);\n\tif (rc < 0)\n\t\treturn rc;\n\n\todiv = (regs[STB6100_VCO] & STB6100_VCO_ODIV) >> STB6100_VCO_ODIV_SHIFT;\n\tpsd2 = (regs[STB6100_K] & STB6100_K_PSD2) >> STB6100_K_PSD2_SHIFT;\n\tnint = regs[STB6100_NI];\n\tnfrac = ((regs[STB6100_K] & STB6100_K_NF_MSB) << 8) | regs[STB6100_NF_LSB];\n\tfvco = (nfrac * state->reference >> (9 - psd2)) + (nint * state->reference << psd2);\n\t*frequency = state->frequency = fvco >> (odiv + 1);\n\n\tdprintk(verbose, FE_DEBUG, 1,\n	f
3738	914	cxd2841er_set_ts_clock_mode	drivers/media/dvb-frontends/cxd2841er.c	ts_in_off	1	13	\N	\N	\tu8 serial_ts, ts_rate_ctrl_off, ts_in_off;\n\n\tdev_dbg(&priv->i2c->dev, "%s()\\n", __func__);\n\t/* Set SLV-T Bank : 0x00 */\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);\n\tdev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\\n",\n	f
3857	425	ivtv_process_vbi_data	drivers/media/pci/ivtv/ivtv-vbi.c	&itv->vbi.sliced_data[0]	1	13	\N	\N	\tu8 *p = (u8 *) buf->buf;\n\tu32 size = buf->bytesused;\n\tint y;\n\n\t/* Raw VBI data */\n\tif (streamtype == IVTV_ENC_STREAM_TYPE_VBI && ivtv_raw_vbi(itv)) {\n\t\tu8 type;\n\n\t\tivtv_buf_swap(buf);\n\n\t\ttype = p[3];\n\n\t\tsize = buf->bytesused = compress_raw_buf(itv, p, size);\n\n\t\t/* second field of the frame? */\n\t\tif (type == itv->vbi.raw_decoder_sav_even_field) {\n\t\t\t/* Dirty hack needed for backwards\n\t\t\t   compatibility of old VBI software. */\n\t\t\tp += size - 4;\n\t\t\tmemcpy(p, &itv->vbi.frame, 4);\n\t\t\titv->vbi.frame++;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Sliced VBI data with data insertion */\n\tif (streamtype == IVTV_ENC_STREAM_TYPE_VBI) {\n\t\tint lines;\n\n\t\tivtv_buf_swap(buf);\n\n\t\t/* first field */\n\t\tlines = compress_sliced_buf(itv, 0, p, size / 2,\n\t\t\titv->vbi.sliced_decoder_sav_odd_field);\n\t\t/* second field */\n\t\t/* experimentation shows that the second half does not always begin\n\t\t   at the exact address. So start a bit earlier (hence 32). */\n\t\tlines = compress_sliced_buf(itv, lines, p + size / 2 - 32, size / 2 + 32,\n\t\t\titv->vbi.sliced_decoder_sav_even_field);\n\t\t/* always return at least one empty line */\n\t\tif (lines == 0) {\n\t\t\titv->vbi.sliced_data[0].id = 0;\n\t\t\titv->vbi.sliced_data[0].line = 0;\n\t\t\titv->vbi.sliced_data[0].field = 0;\n\t\t\tlines = 1;\n\t\t}\n\t\tbuf->bytesused = size = lines * sizeof(itv->vbi.sliced_data[0]);\n\t\tmemcpy(p, &itv->vbi.sliced_data[0], size);\n	f
3862	2700	stv0367cab_get_rf_lvl	drivers/media/dvb-frontends/stv0367.c	IfAgcPwm	1	13	\N	\N	\ts32 rfLevel = 0;\n\ts32 RfAgcPwm = 0, IfAgcPwm = 0;\n\tu8 i;\n\n\tstv0367_writebits(state, F367CAB_STDBY_ADCGP, 0x0);\n\n\tRfAgcPwm =\n\t\t(stv0367_readbits(state, F367CAB_RF_AGC1_LEVEL_LO) & 0x03) +\n\t\t(stv0367_readbits(state, F367CAB_RF_AGC1_LEVEL_HI) << 2);\n\tRfAgcPwm = 100 * RfAgcPwm / 1023;\n\n\tIfAgcPwm =\n\t\tstv0367_readbits(state, F367CAB_AGC_IF_PWMCMD_LO) +\n\t\t(stv0367_readbits(state, F367CAB_AGC_IF_PWMCMD_HI) << 8);\n\tif (IfAgcPwm >= 2048)\n	f
3933	5203	wq_numa_store	kernel/workqueue.c	v	1	13	\N	\N	\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint v, ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (sscanf(buf, "%d", &v) == 1) {\n\t\tattrs->no_numa = !v;\n	f
3994	213	mx25_tcq_fifo_reset	drivers/input/touchscreen/fsl-imx25-tcq.c	tcqcr	1	13	\N	\N	\tu32 tcqcr;\n\n\tregmap_read(priv->regs, MX25_ADCQ_CR, &tcqcr);\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST,\n\t\t\t   MX25_ADCQ_CR_FRST);\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST, 0);\n\tregmap_write(priv->regs, MX25_ADCQ_CR, tcqcr);\n	f
4072	684	tda8290_probe	drivers/media/tuners/tda8290.c	id	1	13	\N	\N	#define TDA8290_ID 0x89\n\tu8 reg = 0x1f, id;\n\tstruct i2c_msg msg_read[] = {\n\t\t{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\n\t};\n\n\t/* detect tda8290 */\n\tif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\n\t\tprintk(KERN_WARNING "%s: couldn't read register 0x%02x\\n",\n\t\t\t       __func__, reg);\n\t\treturn -ENODEV;\n\t}\n\n\tif (id == TDA8290_ID) {\n	f
4091	315	usbhid_quirks_init	drivers/hid/usbhid/hid-quirks.c	idVendor	1	13	\N	\N	\tu16 idVendor, idProduct;\n\tu32 quirks;\n\tint n = 0, m;\n\n\tfor (; n < MAX_USBHID_BOOT_QUIRKS && quirks_param[n]; n++) {\n\n\t\tm = sscanf(quirks_param[n], "0x%hx:0x%hx:0x%x",\n\t\t\t\t&idVendor, &idProduct, &quirks);\n\n\t\tif (m != 3 ||\n\t\t    usbhid_modify_dquirk(idVendor, idProduct, quirks) != 0) {\n	f
4097	136	tracefs_get_inode	fs/tracefs/inode.c	inode	1	13	\N	\N	\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n	f
4120	743	clk_pixel_set_rate	drivers/clk/qcom/clk-rcg2.c	cfg	1	13	\N	\N	\tstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\n\tstruct freq_tbl f = { 0 };\n\tconst struct frac_entry *frac = frac_table_pixel;\n\tunsigned long request;\n\tint delta = 100000;\n\tu32 mask = BIT(rcg->hid_width) - 1;\n\tu32 hid_div, cfg;\n\tint i, num_parents = clk_hw_get_num_parents(hw);\n\n\tregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\n\tcfg &= CFG_SRC_SEL_MASK;\n\tcfg >>= CFG_SRC_SEL_SHIFT;\n\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (cfg == rcg->parent_map[i].cfg) {\n	f
4199	589	ipw2100_get_ordinal	drivers/net/wireless/intel/ipw2x00/ipw2100.c	total_length	1	13	\N	\N	\tstruct ipw2100_ordinals *ordinals = &priv->ordinals;\n\tu32 addr;\n\tu32 field_info;\n\tu16 field_len;\n\tu16 field_count;\n\tu32 total_length;\n\n\tif (ordinals->table1_addr == 0) {\n\t\tprintk(KERN_WARNING DRV_NAME ": attempt to use fw ordinals "\n\t\t       "before they have been loaded.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\n\t\tif (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {\n\t\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       ": ordinal buffer length too small, need %zd\\n",\n\t\t\t       IPW_ORD_TAB_1_ENTRY_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table1_addr + (ord << 2), &addr);\n\t\tread_nic_dword(priv->net_dev, addr, val);\n\n\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tif (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {\n\n\t\tord -= IPW_START_ORD_TAB_2;\n\n\t\t/* get the address of statistic */\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3), &addr);\n\n\t\t/* get the second DW of statistics ;\n\t\t * two 16-bit words - first is length, second is count */\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3) + sizeof(u32),\n\t\t\t       &field_info);\n\n\t\t/* get each entry length */\n\t\tfield_len = *((u16 *) & field_info);\n\n\t\t/* get number of entries */\n\t\tfield_count = *(((u16 *) & field_info) + 1);\n\n\t\t/* abort if no enough memory */\n\t\ttotal_length = field_len * field_count;\n\t\tif (total_length > *len) {\n	f
4353	4122	get_dvbt_lock_status	drivers/media/dvb-frontends/drxk_hard.c	sc_ra_ram_lock	1	13	\N	\N	\tint status;\n\tconst u16 mpeg_lock_mask = (OFDM_SC_RA_RAM_LOCK_MPEG__M |\n\t\t\t\t    OFDM_SC_RA_RAM_LOCK_FEC__M);\n\tconst u16 fec_lock_mask = (OFDM_SC_RA_RAM_LOCK_FEC__M);\n\tconst u16 demod_lock_mask = OFDM_SC_RA_RAM_LOCK_DEMOD__M;\n\n\tu16 sc_ra_ram_lock = 0;\n\tu16 sc_comm_exec = 0;\n\n\tdprintk(1, "\\n");\n\n\t*p_lock_status = NOT_LOCKED;\n\t/* driver 0.9.0 */\n\t/* Check if SC is running */\n\tstatus = read16(state, OFDM_SC_COMM_EXEC__A, &sc_comm_exec);\n\tif (status < 0)\n\t\tgoto end;\n\tif (sc_comm_exec == OFDM_SC_COMM_EXEC_STOP)\n\t\tgoto end;\n\n\tstatus = read16(state, OFDM_SC_RA_RAM_LOCK__A, &sc_ra_ram_lock);\n\tif (status < 0)\n\t\tgoto end;\n\n\tif ((sc_ra_ram_lock & mpeg_lock_mask) == mpeg_lock_mask)\n	f
5141	63	ds1672_get_datetime	drivers/rtc/rtc-ds1672.c	time	1	13	\N	\N	\tunsigned long time;\n\tunsigned char addr = DS1672_REG_CNT_BASE;\n\tunsigned char buf[4];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{/* setup read ptr */\n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t},\n\t\t{/* read date */\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 4,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\t/* read date registers */\n\tif ((i2c_transfer(client->adapter, &msgs[0], 2)) != 2) {\n\t\tdev_err(&client->dev, "%s: read error\\n", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t"%s: raw read data - counters=%02x,%02x,%02x,%02x\\n",\n\t\t__func__, buf[0], buf[1], buf[2], buf[3]);\n\n\ttime = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\n\n\trtc_time_to_tm(time, tm);\n	f
4357	1016	mmc_sd_init_card	drivers/mmc/core/sd.c	card->scr.bus_widths	1	13	\N	\N	\tstruct mmc_card *card;\n\tint err;\n\tu32 cid[4];\n\tu32 rocr = 0;\n\n\tWARN_ON(!host->claimed);\n\n\terr = mmc_sd_get_cid(host, ocr, cid, &rocr);\n\tif (err)\n\t\treturn err;\n\n\tif (oldcard) {\n\t\tif (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)\n\t\t\treturn -ENOENT;\n\n\t\tcard = oldcard;\n\t} else {\n\t\t/*\n\t\t * Allocate card structure.\n\t\t */\n\t\tcard = mmc_alloc_card(host, &sd_type);\n\t\tif (IS_ERR(card))\n\t\t\treturn PTR_ERR(card);\n\n\t\tcard->ocr = ocr;\n\t\tcard->type = MMC_TYPE_SD;\n\t\tmemcpy(card->raw_cid, cid, sizeof(card->raw_cid));\n\t}\n\n\t/*\n\t * Call the optional HC's init_card function to handle quirks.\n\t */\n\tif (host->ops->init_card)\n\t\thost->ops->init_card(host, card);\n\n\t/*\n\t * For native busses:  get card RCA and quit open drain mode.\n\t */\n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_send_relative_addr(host, &card->rca);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\tif (!oldcard) {\n\t\terr = mmc_sd_get_csd(host, card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t\tmmc_decode_cid(card);\n\t}\n\n\t/*\n\t * handling only for cards supporting DSR and hosts requesting\n\t * DSR configuration\n\t */\n\tif (card->csd.dsr_imp && host->dsr_req)\n\t\tmmc_set_dsr(host);\n\n\t/*\n\t * Select card, as all following commands rely on that.\n\t */\n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_select_card(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\terr = mmc_sd_setup_card(host, card, oldcard != NULL);\n\tif (err)\n\t\tgoto free_card;\n\n\t/* Initialization sequence for UHS-I cards */\n\tif (rocr & SD_ROCR_S18A) {\n\t\terr = mmc_sd_init_uhs_card(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t} else {\n\t\t/*\n\t\t * Attempt to change to high-speed (if supported)\n\t\t */\n\t\terr = mmc_sd_switch_hs(card);\n\t\tif (err > 0)\n\t\t\tmmc_set_timing(card->host, MMC_TIMING_SD_HS);\n\t\telse if (err)\n\t\t\tgoto free_card;\n\n\t\t/*\n\t\t * Set bus speed.\n\t\t */\n\t\tmmc_set_clock(host, mmc_sd_get_max_clock(card));\n\n\t\t/*\n\t\t * Switch to wider bus (if supported).\n\t\t */\n\t\tif ((host->caps & MMC_CAP_4_BIT_DATA) &&\n\t\t\t(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\n	f
4428	227	i2c_smbus_read_block_data	drivers/i2c/i2c-core-smbus.c	values	1	13	\N	\N	\tunion i2c_smbus_data data;\n\tint status;\n\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, command,\n\t\t\t\tI2C_SMBUS_BLOCK_DATA, &data);\n\tif (status)\n\t\treturn status;\n\n\tmemcpy(values, &data.block[1], data.block[0]);\n	f
4440	589	atk_sitm	drivers/hwmon/asus_atk0110.c	&ret	1	13	\N	\N	\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct acpi_object_list params;\n\tunion acpi_object tmp;\n\tstruct acpi_buffer ret;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\ttmp.type = ACPI_TYPE_BUFFER;\n\ttmp.buffer.pointer = (u8 *)buf;\n\ttmp.buffer.length = sizeof(*buf);\n\n\tparams.count = 1;\n\tparams.pointer = &tmp;\n\n\tret.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->write_handle, NULL, &params,\n	f
4556	500	fan1_off_store	drivers/hwmon/gl520sm.c	v	1	13	\N	\N	\tstruct gl520_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 r;\n\tunsigned long v;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\tr = (v ? 1 : 0);\n	f
4558	496	temp1_alarm_show	drivers/hwmon/sht3x.c	buffer	1	13	\N	\N	\tchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\n\tint ret;\n\n\tret = status_register_read(dev, attr, buffer,\n\t\t\t\t   SHT3X_WORD_LEN + SHT3X_CRC8_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scnprintf(buf, PAGE_SIZE, "%d\\n", !!(buffer[0] & 0x04));\n	f
4578	137	lm95245_read_conversion_rate	drivers/hwmon/lm95245.c	rate	1	13	\N	\N	\tunsigned int rate;\n\tint ret;\n\n\tret = regmap_read(data->regmap, LM95245_REG_RW_CONVERS_RATE, &rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (rate) {\n	f
4748	243	viafb_dvi_sense	drivers/video/fbdev/via/dvi.c	data	1	13	\N	\N	\tu8 RegSR1E = 0, RegSR3E = 0, RegCR6B = 0, RegCR91 = 0,\n\t\tRegCR93 = 0, RegCR9B = 0, data;\n\tint ret = false;\n\n\tDEBUG_MSG(KERN_INFO "viafb_dvi_sense!!\\n");\n\n\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {\n\t\t/* DI1 Pad on */\n\t\tRegSR1E = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg(SR1E, VIASR, RegSR1E | 0x30);\n\n\t\t/* CR6B[0]VCK Input Selection: 1 = External clock. */\n\t\tRegCR6B = viafb_read_reg(VIACR, CR6B);\n\t\tviafb_write_reg(CR6B, VIACR, RegCR6B | 0x08);\n\n\t\t/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off\n\t\t   [0] Software Control Power Sequence */\n\t\tRegCR91 = viafb_read_reg(VIACR, CR91);\n\t\tviafb_write_reg(CR91, VIACR, 0x1D);\n\n\t\t/* CR93[7] DI1 Data Source Selection: 1 = DSP2.\n\t\t   CR93[5] DI1 Clock Source: 1 = internal.\n\t\t   CR93[4] DI1 Clock Polarity.\n\t\t   CR93[3:1] DI1 Clock Adjust. CR93[0] DI1 enable */\n\t\tRegCR93 = viafb_read_reg(VIACR, CR93);\n\t\tviafb_write_reg(CR93, VIACR, 0x01);\n\t} else {\n\t\t/* DVP0/DVP1 Pad on */\n\t\tRegSR1E = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg(SR1E, VIASR, RegSR1E | 0xF0);\n\n\t\t/* SR3E[1]Multi-function selection:\n\t\t   0 = Emulate I2C and DDC bus by GPIO2/3/4. */\n\t\tRegSR3E = viafb_read_reg(VIASR, SR3E);\n\t\tviafb_write_reg(SR3E, VIASR, RegSR3E & (~0x20));\n\n\t\t/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off\n\t\t   [0] Software Control Power Sequence */\n\t\tRegCR91 = viafb_read_reg(VIACR, CR91);\n\t\tviafb_write_reg(CR91, VIACR, 0x1D);\n\n\t\t/*CR9B[4] DVP1 Data Source Selection: 1 = From secondary\n\t\tdisplay.CR9B[2:0] DVP1 Clock Adjust */\n\t\tRegCR9B = viafb_read_reg(VIACR, CR9B);\n\t\tviafb_write_reg(CR9B, VIACR, 0x01);\n\t}\n\n\tdata = (u8) tmds_register_read(0x09);\n\tif (data & 0x04)\n	f
4908	266	da9052_bat_check_status	drivers/power/supply/da9052-battery.c	chg_end_current	1	13	\N	\N	\tu8 v[2] = {0, 0};\n\tu8 bat_status;\n\tu8 chg_end;\n\tint ret;\n\tint chg_current;\n\tint chg_end_current;\n\tbool dcinsel;\n\tbool dcindet;\n\tbool vbussel;\n\tbool vbusdet;\n\tbool dc;\n\tbool vbus;\n\n\tret = da9052_group_read(bat->da9052, DA9052_STATUS_A_REG, 2, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbat_status = v[0];\n\tchg_end = v[1];\n\n\tdcinsel = bat_status & DA9052_STATUSA_DCINSEL;\n\tdcindet = bat_status & DA9052_STATUSA_DCINDET;\n\tvbussel = bat_status & DA9052_STATUSA_VBUSSEL;\n\tvbusdet = bat_status & DA9052_STATUSA_VBUSDET;\n\tdc = dcinsel && dcindet;\n\tvbus = vbussel && vbusdet;\n\n\t/* Preference to WALL(DCIN) charger unit */\n\tif (dc || vbus) {\n\t\tbat->charger_type = DA9052_CHARGER;\n\n\t\t/* If charging end flag is set and Charging current is greater\n\t\t * than charging end limit then battery is charging\n\t\t*/\n\t\tif ((chg_end & DA9052_STATUSB_CHGEND) != 0) {\n\t\t\tret = da9052_read_chg_current(bat, &chg_current);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = da9052_read_chgend_current(bat, &chg_end_current);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (chg_current >= chg_end_current)\n	f
4914	401	gm20b_pllg_program_mnp	drivers/gpu/drm/nouveau/nvkm/subdev/clk/gm20b.c	&cur_pll.base	1	13	\N	\N	\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gm20b_pll cur_pll;\n\tu32 n_int, sdm_din;\n\t/* if we only change pdiv, we can do a glitchless transition */\n\tbool pdiv_only;\n\tint ret;\n\n\tgm20b_dvfs_calc_ndiv(clk, pll->n, &n_int, &sdm_din);\n\tgm20b_pllg_read_mnp(clk, &cur_pll);\n\tpdiv_only = cur_pll.base.n == n_int && cur_pll.sdm_din == sdm_din &&\n\t\t    cur_pll.base.m == pll->m;\n\n\t/* need full sequence if clock not enabled yet */\n\tif (!gk20a_pllg_is_enabled(&clk->base))\n\t\tpdiv_only = false;\n\n\t/* split VCO-to-bypass jump in half by setting out divider 1:2 */\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\t/* Intentional 2nd write to assure linear divider operation */\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\tnvkm_rd32(device, GPC2CLK_OUT);\n\tudelay(2);\n\n\tif (pdiv_only) {\n\t\tu32 old = cur_pll.base.pl;\n\t\tu32 new = pll->pl;\n\n\t\t/*\n\t\t * we can do a glitchless transition only if the old and new PL\n\t\t * parameters share at least one bit set to 1. If this is not\n\t\t * the case, calculate and program an interim PL that will allow\n\t\t * us to respect that rule.\n\t\t */\n\t\tif ((old & new) == 0) {\n\t\t\tcur_pll.base.pl = min(old | BIT(ffs(new) - 1),\n\t\t\t\t\t      new | BIT(ffs(old) - 1));\n\t\t\tgk20a_pllg_write_mnp(&clk->base, &cur_pll.base);\n	f
20264	113	ll_iget	drivers/staging/lustre/lustre/llite/namei.c	inode	1	13	\N	\N	\tstruct inode\t *inode;\n\tint rc = 0;\n\n\tLASSERT(hash != 0);\n\tinode = iget5_locked(sb, hash, ll_test_inode, ll_set_inode, md);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\trc = ll_read_inode2(inode, md);\n	f
5173	3103	ilk_compute_pipe_wm	drivers/gpu/drm/i915/intel_pm.c	&max	1	13	\N	\N	\tstruct drm_atomic_state *state = cstate->base.state;\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);\n\tstruct intel_pipe_wm *pipe_wm;\n\tstruct drm_device *dev = state->dev;\n\tconst struct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_plane *plane;\n\tconst struct drm_plane_state *plane_state;\n\tconst struct intel_plane_state *pristate = NULL;\n\tconst struct intel_plane_state *sprstate = NULL;\n\tconst struct intel_plane_state *curstate = NULL;\n\tint level, max_level = ilk_wm_max_level(dev_priv), usable_level;\n\tstruct ilk_wm_maximums max;\n\n\tpipe_wm = &cstate->wm.ilk.optimal;\n\n\tdrm_atomic_crtc_state_for_each_plane_state(plane, plane_state, &cstate->base) {\n\t\tconst struct intel_plane_state *ps = to_intel_plane_state(plane_state);\n\n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tpristate = ps;\n\t\telse if (plane->type == DRM_PLANE_TYPE_OVERLAY)\n\t\t\tsprstate = ps;\n\t\telse if (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcurstate = ps;\n\t}\n\n\tpipe_wm->pipe_enabled = cstate->base.active;\n\tif (sprstate) {\n\t\tpipe_wm->sprites_enabled = sprstate->base.visible;\n\t\tpipe_wm->sprites_scaled = sprstate->base.visible &&\n\t\t\t(drm_rect_width(&sprstate->base.dst) != drm_rect_width(&sprstate->base.src) >> 16 ||\n\t\t\t drm_rect_height(&sprstate->base.dst) != drm_rect_height(&sprstate->base.src) >> 16);\n\t}\n\n\tusable_level = max_level;\n\n\t/* ILK/SNB: LP2+ watermarks only w/o sprites */\n\tif (INTEL_GEN(dev_priv) <= 6 && pipe_wm->sprites_enabled)\n\t\tusable_level = 1;\n\n\t/* ILK/SNB/IVB: LP1+ watermarks only w/o scaling */\n\tif (pipe_wm->sprites_scaled)\n\t\tusable_level = 0;\n\n\tmemset(&pipe_wm->wm, 0, sizeof(pipe_wm->wm));\n\tilk_compute_wm_level(dev_priv, intel_crtc, 0, cstate,\n\t\t\t     pristate, sprstate, curstate, &pipe_wm->wm[0]);\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\tpipe_wm->linetime = hsw_compute_linetime_wm(cstate);\n\n\tif (!ilk_validate_pipe_wm(dev, pipe_wm))\n\t\treturn -EINVAL;\n\n\tilk_compute_wm_reg_maximums(dev_priv, 1, &max);\n\n\tfor (level = 1; level <= usable_level; level++) {\n\t\tstruct intel_wm_level *wm = &pipe_wm->wm[level];\n\n\t\tilk_compute_wm_level(dev_priv, intel_crtc, level, cstate,\n\t\t\t\t     pristate, sprstate, curstate, wm);\n\n\t\t/*\n\t\t * Disable any watermark level that exceeds the\n\t\t * register maximums since such watermarks are\n\t\t * always invalid.\n\t\t */\n\t\tif (!ilk_validate_wm_level(level, &max, wm)) {\n	f
5212	88	nvkm_gpio_set	drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c	func.log	1	13	\N	\N	\tstruct dcb_gpio_func func;\n\tint ret;\n\n\tret = nvkm_gpio_find(gpio, idx, tag, line, &func);\n\tif (ret == 0) {\n\t\tint dir = !!(func.log[state] & 0x02);\n\t\tint out = !!(func.log[state] & 0x01);\n	f
5318	277	__free_insn_slot	kernel/kprobes.c	idx	1	13	\N	\N	\tstruct kprobe_insn_page *kip;\n\tlong idx;\n\n\tmutex_lock(&c->mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tidx = ((long)slot - (long)kip->insns) /\n\t\t\t(c->insn_size * sizeof(kprobe_opcode_t));\n\t\tif (idx >= 0 && idx < slots_per_page(c))\n\t\t\tgoto out;\n\t}\n\t/* Could not find this slot. */\n\tWARN_ON(1);\n\tkip = NULL;\nout:\n\trcu_read_unlock();\n\t/* Mark and sweep: this may sleep */\n\tif (kip) {\n\t\t/* Check double free */\n\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);\n\t\tif (dirty) {\n\t\t\tkip->slot_used[idx] = SLOT_DIRTY;\n\t\t\tkip->ngarbage++;\n\t\t\tif (++c->nr_garbage > slots_per_page(c))\n\t\t\t\tcollect_garbage_slots(c);\n\t\t} else {\n\t\t\tcollect_one_slot(kip, idx);\n	f
5495	555	gk20a_clk_fini	drivers/gpu/drm/nouveau/nvkm/subdev/clk/gk20a.c	n_lo	1	13	\N	\N	\tstruct nvkm_device *device = base->subdev.device;\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\n\t/* slide to VCO min */\n\tif (gk20a_pllg_is_enabled(clk)) {\n\t\tstruct gk20a_pll pll;\n\t\tu32 n_lo;\n\n\t\tgk20a_pllg_read_mnp(clk, &pll);\n\t\tn_lo = gk20a_pllg_n_lo(clk, &pll);\n\t\tgk20a_pllg_slide(clk, n_lo);\n	f
5981	1665	ast_post_chip_2300	drivers/gpu/drm/ast/ast_post.c	&param	1	13	\N	\N	\tstruct ast_private *ast = dev->dev_private;\n\tstruct ast2300_dram_param param;\n\tu32 temp;\n\tu8 reg;\n\n\treg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\tif ((reg & 0x80) == 0) {/* vga only */\n\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\tast_write32(ast, 0xf000, 0x1);\n\t\tast_write32(ast, 0x12000, 0x1688a8a8);\n\t\tdo {\n\t\t\t;\n\t\t} while (ast_read32(ast, 0x12000) != 0x1);\n\n\t\tast_write32(ast, 0x10000, 0xfc600309);\n\t\tdo {\n\t\t\t;\n\t\t} while (ast_read32(ast, 0x10000) != 0x1);\n\n\t\t/* Slow down CPU/AHB CLK in VGA only mode */\n\t\ttemp = ast_read32(ast, 0x12008);\n\t\ttemp |= 0x73;\n\t\tast_write32(ast, 0x12008, temp);\n\n\t\tparam.dram_freq = 396;\n\t\tparam.dram_type = AST_DDR3;\n\t\ttemp = ast_mindwm(ast, 0x1e6e2070);\n\t\tif (temp & 0x01000000)\n\t\t\tparam.dram_type = AST_DDR2;\n                switch (temp & 0x18000000) {\n\t\tcase 0:\n\t\t\tparam.dram_chipid = AST_DRAM_512Mx16;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 0x08000000:\n\t\t\tparam.dram_chipid = AST_DRAM_1Gx16;\n\t\t\tbreak;\n\t\tcase 0x10000000:\n\t\t\tparam.dram_chipid = AST_DRAM_2Gx16;\n\t\t\tbreak;\n\t\tcase 0x18000000:\n\t\t\tparam.dram_chipid = AST_DRAM_4Gx16;\n\t\t\tbreak;\n\t\t}\n                switch (temp & 0x0c) {\n                default:\n\t\tcase 0x00:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_8M;\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_16M;\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_32M;\n\t\t\tbreak;\n\n\t\tcase 0x0c:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_64M;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (param.dram_type == AST_DDR3) {\n\t\t\tget_ddr3_info(ast, &param);\n\t\t\tddr3_init(ast, &param);\n	f
6570	55	nvbios_npdeTp	drivers/gpu/drm/nouveau/nvkm/subdev/bios/npde.c	data + 0x08	1	13	\N	\N	\tu32 data = nvbios_npdeTe(bios, base);\n\tmemset(info, 0x00, sizeof(*info));\n\tif (data) {\n\t\tinfo->image_size = nvbios_rd16(bios, data + 0x08) * 512;\n	f
6985	3682	ath5k_hw_txpower	drivers/net/wireless/ath/ath5k/phy.c	ah	1	13	\N	\N	\tstruct ath5k_rate_pcal_info rate_info;\n\tstruct ieee80211_channel *curr_channel = ah->ah_current_channel;\n\tint ee_mode;\n\tu8 type;\n\tint ret;\n\n\tif (txpower > AR5K_TUNE_MAX_TXPOWER) {\n\t\tATH5K_ERR(ah, "invalid tx power: %u\\n", txpower);\n\t\treturn -EINVAL;\n\t}\n\n\tee_mode = ath5k_eeprom_mode_from_channel(ah, channel);\n\n\t/* Initialize TX power table */\n\tswitch (ah->ah_radio) {\n\tcase AR5K_RF5110:\n\t\t/* TODO */\n\t\treturn 0;\n\tcase AR5K_RF5111:\n\t\ttype = AR5K_PWRTABLE_PWR_TO_PCDAC;\n\t\tbreak;\n\tcase AR5K_RF5112:\n\t\ttype = AR5K_PWRTABLE_LINEAR_PCDAC;\n\t\tbreak;\n\tcase AR5K_RF2413:\n\tcase AR5K_RF5413:\n\tcase AR5K_RF2316:\n\tcase AR5K_RF2317:\n\tcase AR5K_RF2425:\n\t\ttype = AR5K_PWRTABLE_PWR_TO_PDADC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If we don't change channel/mode skip tx powertable calculation\n\t * and use the cached one.\n\t */\n\tif (!ah->ah_txpower.txp_setup ||\n\t    (channel->hw_value != curr_channel->hw_value) ||\n\t    (channel->center_freq != curr_channel->center_freq)) {\n\t\t/* Reset TX power values but preserve requested\n\t\t * tx power from above */\n\t\tint requested_txpower = ah->ah_txpower.txp_requested;\n\n\t\tmemset(&ah->ah_txpower, 0, sizeof(ah->ah_txpower));\n\n\t\t/* Restore TPC setting and requested tx power */\n\t\tah->ah_txpower.txp_tpc = AR5K_TUNE_TPC_TXPOWER;\n\n\t\tah->ah_txpower.txp_requested = requested_txpower;\n\n\t\t/* Calculate the powertable */\n\t\tret = ath5k_setup_channel_powertable(ah, channel,\n\t\t\t\t\t\t\tee_mode, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Write table on hw */\n\tath5k_write_channel_powertable(ah, ee_mode, type);\n\n\t/* Limit max power if we have a CTL available */\n\tath5k_get_max_ctl_power(ah, channel);\n\n\t/* FIXME: Antenna reduction stuff */\n\n\t/* FIXME: Limit power on turbo modes */\n\n\t/* FIXME: TPC scale reduction */\n\n\t/* Get surrounding channels for per-rate power table\n\t * calibration */\n\tath5k_get_rate_pcal_data(ah, channel, &rate_info);\n\n\t/* Setup rate power table */\n\tath5k_setup_rate_powertable(ah, txpower, &rate_info, ee_mode);\n	f
7179	485	verify_xattr_ref	fs/jffs2/xattr.c	ref->xseqno	1	13	\N	\N	\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING("jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t/* obsolete node */\n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR("node CRC failed at %#08x, read=%#08x, calc=%#08x\\n",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR("inconsistent xref at %#08x, magic=%#04x/%#04x, "\n\t\t\t    "nodetype=%#04x/%#04x, totlen=%u/%zu\\n",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n	f
20462	89	wl1251_ps_elp_wakeup	drivers/net/wireless/ti/wl1251/ps.c	elp_reg	1	13	\N	\N	\tunsigned long timeout, start;\n\tu32 elp_reg;\n\n\tcancel_delayed_work(&wl->elp_work);\n\n\tif (!wl->elp)\n\t\treturn 0;\n\n\twl1251_debug(DEBUG_PSM, "waking up chip from elp");\n\n\tstart = jiffies;\n\ttimeout = jiffies + msecs_to_jiffies(WL1251_WAKEUP_TIMEOUT);\n\n\twl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);\n\n\telp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\n\n\t/*\n\t * FIXME: we should wait for irq from chip but, as a temporary\n\t * solution to simplify locking, let's poll instead\n\t */\n\twhile (!(elp_reg & ELPCTRL_WLAN_READY)) {\n	f
7350	972	charger_get_property	drivers/power/supply/charger-manager.c	uV	1	13	\N	\N	\tstruct charger_manager *cm = power_supply_get_drvdata(psy);\n\tstruct charger_desc *desc = cm->desc;\n\tstruct power_supply *fuel_gauge = NULL;\n\tint ret = 0;\n\tint uV;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (is_charging(cm))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (is_ext_pwr_online(cm))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (cm->emergency_stop > 0)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (cm->emergency_stop < 0)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_COLD;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tif (is_batt_present(cm))\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = get_batt_uV(cm, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!fuel_gauge) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_CURRENT_NOW, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT:\n\t\treturn cm_get_battery_temperature(cm, &val->intval);\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (!is_batt_present(cm)) {\n\t\t\t/* There is no battery. Assume 100% */\n\t\t\tval->intval = 100;\n\t\t\tbreak;\n\t\t}\n\n\t\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!fuel_gauge) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\t\tPOWER_SUPPLY_PROP_CAPACITY, val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (val->intval > 100) {\n\t\t\tval->intval = 100;\n\t\t\tbreak;\n\t\t}\n\t\tif (val->intval < 0)\n\t\t\tval->intval = 0;\n\n\t\t/* Do not adjust SOC when charging: voltage is overrated */\n\t\tif (is_charging(cm))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If the capacity value is inconsistent, calibrate it base on\n\t\t * the battery voltage values and the thresholds given as desc\n\t\t */\n\t\tret = get_batt_uV(cm, &uV);\n\t\tif (ret) {\n\t\t\t/* Voltage information not available. No calibration */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->fullbatt_uV > 0 && uV >= desc->fullbatt_uV &&\n	f
7468	132	ttm_read_trylock	drivers/gpu/drm/ttm/ttm_lock.c	locked	1	13	\N	\N	\tint ret = 0;\n\tbool locked;\n\n\tif (interruptible)\n\t\tret = wait_event_interruptible\n\t\t\t(lock->queue, __ttm_read_trylock(lock, &locked));\n\telse\n\t\twait_event(lock->queue, __ttm_read_trylock(lock, &locked));\n\n\tif (unlikely(ret != 0)) {\n\t\tBUG_ON(locked);\n	f
7494	232	lp5562_update_firmware	drivers/leds/leds-lp5562.c	offset	1	13	\N	\N	\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tu8 pattern[LP5562_PROGRAM_LENGTH] = {0};\n\tstatic const u8 addr[] = {\n\t\t[LP55XX_ENGINE_1] = LP5562_REG_PROG_MEM_ENG1,\n\t\t[LP55XX_ENGINE_2] = LP5562_REG_PROG_MEM_ENG2,\n\t\t[LP55XX_ENGINE_3] = LP5562_REG_PROG_MEM_ENG3,\n\t};\n\tunsigned cmd;\n\tchar c[3];\n\tint program_size;\n\tint nrchars;\n\tint offset = 0;\n\tint ret;\n\tint i;\n\n\t/* clear program memory before updating */\n\tfor (i = 0; i < LP5562_PROGRAM_LENGTH; i++)\n\t\tlp55xx_write(chip, addr[idx] + i, 0);\n\n\ti = 0;\n\twhile ((offset < size - 1) && (i < LP5562_PROGRAM_LENGTH)) {\n	f
7623	2237	store_temp_type	drivers/hwmon/nct6775.c	val	1	13	\N	\N	\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu8 vbat, diode, vbit, dbit;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val != 1 && val != 3 && val != 4)\n	f
7690	1147	cx25840_ir_log_status	drivers/media/i2c/cx25840/cx25840-ir.c	cntrl	1	13	\N	\N	\tstruct cx25840_state *state = to_state(sd);\n\tstruct i2c_client *c = state->c;\n\tchar *s;\n\tint i, j;\n\tu32 cntrl, txclk, rxclk, cduty, stats, irqen, filtr;\n\n\t/* The CX23888 chip doesn't have an IR controller on the A/V core */\n\tif (is_cx23888(state))\n\t\treturn 0;\n\n\tcntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\n\ttxclk = cx25840_read4(c, CX25840_IR_TXCLK_REG) & TXCLK_TCD;\n\trxclk = cx25840_read4(c, CX25840_IR_RXCLK_REG) & RXCLK_RCD;\n\tcduty = cx25840_read4(c, CX25840_IR_CDUTY_REG) & CDUTY_CDC;\n\tstats = cx25840_read4(c, CX25840_IR_STATS_REG);\n\tirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tirqen ^= IRQEN_MSK;\n\tfiltr = cx25840_read4(c, CX25840_IR_FILTR_REG) & FILTR_LPF;\n\n\tv4l2_info(sd, "IR Receiver:\\n");\n\tv4l2_info(sd, "\\tEnabled:                           %s\\n",\n\t\t  cntrl & CNTRL_RXE ? "yes" : "no");\n\tv4l2_info(sd, "\\tDemodulation from a carrier:       %s\\n",\n\t\t  cntrl & CNTRL_DMD ? "enabled" : "disabled");\n\tv4l2_info(sd, "\\tFIFO:                              %s\\n",\n\t\t  cntrl & CNTRL_RFE ? "enabled" : "disabled");\n\tswitch (cntrl & CNTRL_EDG) {\n\tcase CNTRL_EDG_NONE:\n\t\ts = "disabled";\n\t\tbreak;\n\tcase CNTRL_EDG_FALL:\n\t\ts = "falling edge";\n\t\tbreak;\n\tcase CNTRL_EDG_RISE:\n\t\ts = "rising edge";\n\t\tbreak;\n\tcase CNTRL_EDG_BOTH:\n\t\ts = "rising & falling edges";\n\t\tbreak;\n\tdefault:\n\t\ts = "??? edge";\n\t\tbreak;\n\t}\n\tv4l2_info(sd, "\\tPulse timers' start/stop trigger:  %s\\n", s);\n\tv4l2_info(sd, "\\tFIFO data on pulse timer overflow: %s\\n",\n\t\t  cntrl & CNTRL_R ? "not loaded" : "overflow marker");\n\tv4l2_info(sd, "\\tFIFO interrupt watermark:          %s\\n",\n\t\t  cntrl & CNTRL_RIC ? "not empty" : "half full or greater");\n\tv4l2_info(sd, "\\tLoopback mode:                     %s\\n",\n\t\t  cntrl & CNTRL_LBM ? "loopback active" : "normal receive");\n\tif (cntrl & CNTRL_DMD) {\n\t\tv4l2_info(sd, "\\tExpected carrier (16 clocks):      %u Hz\\n",\n\t\t\t  clock_divider_to_carrier_freq(rxclk));\n\t\tswitch (cntrl & CNTRL_WIN) {\n\t\tcase CNTRL_WIN_3_3:\n\t\t\ti = 3;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_3:\n\t\t\ti = 4;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_3_4:\n\t\t\ti = 3;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_4:\n\t\t\ti = 4;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_info(sd, "\\tNext carrier edge window:\t    16 clocks -%1d/+%1d, %u to %u Hz\\n",\n\t\t\t  i, j,\n\t\t\t  clock_divider_to_freq(rxclk, 16 + j),\n\t\t\t  clock_divider_to_freq(rxclk, 16 - i));\n\t}\n\tv4l2_info(sd, "\\tMax measurable pulse width:        %u us, %llu ns\\n",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, rxclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, rxclk));\n\tv4l2_info(sd, "\\tLow pass filter:                   %s\\n",\n\t\t  filtr ? "enabled" : "disabled");\n\tif (filtr)\n\t\tv4l2_info(sd, "\\tMin acceptable pulse width (LPF):  %u us, %u ns\\n",\n\t\t\t  lpf_count_to_us(filtr),\n\t\t\t  lpf_count_to_ns(filtr));\n\tv4l2_info(sd, "\\tPulse width timer timed-out:       %s\\n",\n\t\t  stats & STATS_RTO ? "yes" : "no");\n\tv4l2_info(sd, "\\tPulse width timer time-out intr:   %s\\n",\n\t\t  irqen & IRQEN_RTE ? "enabled" : "disabled");\n\tv4l2_info(sd, "\\tFIFO overrun:                      %s\\n",\n\t\t  stats & STATS_ROR ? "yes" : "no");\n\tv4l2_info(sd, "\\tFIFO overrun interrupt:            %s\\n",\n\t\t  irqen & IRQEN_ROE ? "enabled" : "disabled");\n\tv4l2_info(sd, "\\tBusy:                              %s\\n",\n\t\t  stats & STATS_RBY ? "yes" : "no");\n\tv4l2_info(sd, "\\tFIFO service requested:            %s\\n",\n\t\t  stats & STATS_RSR ? "yes" : "no");\n\tv4l2_info(sd, "\\tFIFO service request interrupt:    %s\\n",\n\t\t  irqen & IRQEN_RSE ? "enabled" : "disabled");\n\n\tv4l2_info(sd, "IR Transmitter:\\n");\n\tv4l2_info(sd, "\\tEnabled:                           %s\\n",\n\t\t  cntrl & CNTRL_TXE ? "yes" : "no");\n\tv4l2_info(sd, "\\tModulation onto a carrier:         %s\\n",\n\t\t  cntrl & CNTRL_MOD ? "enabled" : "disabled");\n\tv4l2_info(sd, "\\tFIFO:                              %s\\n",\n\t\t  cntrl & CNTRL_TFE ? "enabled" : "disabled");\n\tv4l2_info(sd, "\\tFIFO interrupt watermark:          %s\\n",\n	f
8160	1172	smiapp_setup_flash_strobe	drivers/media/i2c/smiapp/smiapp-core.c	rval	1	13	\N	\N	\tstruct smiapp_flash_strobe_parms *strobe_setup;\n\tunsigned int ext_freq = sensor->hwcfg->ext_clk;\n\tu32 tmp;\n\tu32 strobe_adjustment;\n\tu32 strobe_width_high_rs;\n\tint rval;\n\n\tstrobe_setup = sensor->hwcfg->strobe_setup;\n\n\t/*\n\t * How to calculate registers related to strobe length. Please\n\t * do not change, or if you do at least know what you're\n\t * doing. :-)\n\t *\n\t * Sakari Ailus <sakari.ailus@iki.fi> 2010-10-25\n\t *\n\t * flash_strobe_length [us] / 10^6 = (tFlash_strobe_width_ctrl\n\t *\t/ EXTCLK freq [Hz]) * flash_strobe_adjustment\n\t *\n\t * tFlash_strobe_width_ctrl E N, [1 - 0xffff]\n\t * flash_strobe_adjustment E N, [1 - 0xff]\n\t *\n\t * The formula above is written as below to keep it on one\n\t * line:\n\t *\n\t * l / 10^6 = w / e * a\n\t *\n\t * Let's mark w * a by x:\n\t *\n\t * x = w * a\n\t *\n\t * Thus, we get:\n\t *\n\t * x = l * e / 10^6\n\t *\n\t * The strobe width must be at least as long as requested,\n\t * thus rounding upwards is needed.\n\t *\n\t * x = (l * e + 10^6 - 1) / 10^6\n\t * -----------------------------\n\t *\n\t * Maximum possible accuracy is wanted at all times. Thus keep\n\t * a as small as possible.\n\t *\n\t * Calculate a, assuming maximum w, with rounding upwards:\n\t *\n\t * a = (x + (2^16 - 1) - 1) / (2^16 - 1)\n\t * -------------------------------------\n\t *\n\t * Thus, we also get w, with that a, with rounding upwards:\n\t *\n\t * w = (x + a - 1) / a\n\t * -------------------\n\t *\n\t * To get limits:\n\t *\n\t * x E [1, (2^16 - 1) * (2^8 - 1)]\n\t *\n\t * Substituting maximum x to the original formula (with rounding),\n\t * the maximum l is thus\n\t *\n\t * (2^16 - 1) * (2^8 - 1) * 10^6 = l * e + 10^6 - 1\n\t *\n\t * l = (10^6 * (2^16 - 1) * (2^8 - 1) - 10^6 + 1) / e\n\t * --------------------------------------------------\n\t *\n\t * flash_strobe_length must be clamped between 1 and\n\t * (10^6 * (2^16 - 1) * (2^8 - 1) - 10^6 + 1) / EXTCLK freq.\n\t *\n\t * Then,\n\t *\n\t * flash_strobe_adjustment = ((flash_strobe_length *\n\t *\tEXTCLK freq + 10^6 - 1) / 10^6 + (2^16 - 1) - 1) / (2^16 - 1)\n\t *\n\t * tFlash_strobe_width_ctrl = ((flash_strobe_length *\n\t *\tEXTCLK freq + 10^6 - 1) / 10^6 +\n\t *\tflash_strobe_adjustment - 1) / flash_strobe_adjustment\n\t */\n\ttmp = div_u64(1000000ULL * ((1 << 16) - 1) * ((1 << 8) - 1) -\n\t\t      1000000 + 1, ext_freq);\n\tstrobe_setup->strobe_width_high_us =\n\t\tclamp_t(u32, strobe_setup->strobe_width_high_us, 1, tmp);\n\n\ttmp = div_u64(((u64)strobe_setup->strobe_width_high_us * (u64)ext_freq +\n\t\t\t1000000 - 1), 1000000ULL);\n\tstrobe_adjustment = (tmp + (1 << 16) - 1 - 1) / ((1 << 16) - 1);\n\tstrobe_width_high_rs = (tmp + strobe_adjustment - 1) /\n\t\t\t\tstrobe_adjustment;\n\n\trval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_MODE_RS,\n\t\t\t    strobe_setup->mode);\n\tif (rval < 0)\n	f
8183	451	aac_expose_phy_device	drivers/scsi/aacraid/aachba.c	inq_data	1	13	\N	\N	\tchar inq_data;\n\tscsi_sg_copy_to_buffer(scsicmd,  &inq_data, sizeof(inq_data));\n\tif ((inq_data & 0x20) && (inq_data & 0x1f) == TYPE_DISK) {\n	f
8217	559	adm8211_rf_write_syn_al2210l	drivers/net/wireless/admtek/adm8211.c	al2210l	1	13	\N	\N	#define ADM8211_INT(x)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(stsr & ADM8211_STSR_ ## x))\t\t\\\n\t\twiphy_debug(dev->wiphy, "%s\\n", #x);\t\t\\\n} while (0)\n\n\tstruct ieee80211_hw *dev = dev_id;\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 stsr = ADM8211_CSR_READ(STSR);\n\tADM8211_CSR_WRITE(STSR, stsr);\n\tif (stsr == 0xffffffff)\n\t\treturn IRQ_HANDLED;\n\n\tif (!(stsr & (ADM8211_STSR_NISS | ADM8211_STSR_AISS)))\n\t\treturn IRQ_HANDLED;\n\n\tif (stsr & ADM8211_STSR_RCI)\n\t\tadm8211_interrupt_rci(dev);\n\tif (stsr & ADM8211_STSR_TCI)\n\t\tadm8211_interrupt_tci(dev);\n\n\tADM8211_INT(PCF);\n\tADM8211_INT(BCNTC);\n\tADM8211_INT(GPINT);\n\tADM8211_INT(ATIMTC);\n\tADM8211_INT(TSFTF);\n\tADM8211_INT(TSCZ);\n\tADM8211_INT(SQL);\n\tADM8211_INT(WEPTD);\n\tADM8211_INT(ATIME);\n\tADM8211_INT(TEIS);\n\tADM8211_INT(FBE);\n\tADM8211_INT(REIS);\n\tADM8211_INT(GPTT);\n\tADM8211_INT(RPS);\n\tADM8211_INT(RDU);\n\tADM8211_INT(TUF);\n\tADM8211_INT(TPS);\n\n\treturn IRQ_HANDLED;\n\n#undef ADM8211_INT\n}\n\n#define WRITE_SYN(name,v_mask,v_shift,a_mask,a_shift,bits,prewrite,postwrite)\\\nstatic void adm8211_rf_write_syn_ ## name (struct ieee80211_hw *dev,\t     \\\n\t\t\t\t\t   u16 addr, u32 value) {\t     \\\n\tstruct adm8211_priv *priv = dev->priv;\t\t\t\t     \\\n\tunsigned int i;\t\t\t\t\t\t\t     \\\n\tu32 reg, bitbuf;\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tvalue &= v_mask;\t\t\t\t\t\t     \\\n\taddr &= a_mask;\t\t\t\t\t\t\t     \\\n\tbitbuf = (value << v_shift) | (addr << a_shift);\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_IF_SELECT_1);\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_IF_SELECT_0);\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tif (prewrite) {\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_WRITE_SYNDATA_0);     \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tfor (i = 0; i <= bits; i++) {\t\t\t\t\t     \\\n\t\tif (bitbuf & (1 << (bits - i)))\t\t\t\t     \\\n\t\t\treg = ADM8211_SYNRF_WRITE_SYNDATA_1;\t\t     \\\n\t\telse\t\t\t\t\t\t\t     \\\n\t\t\treg = ADM8211_SYNRF_WRITE_SYNDATA_0;\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg);\t\t\t\t     \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_WRITE_CLOCK_1); \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_WRITE_CLOCK_0); \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tif (postwrite == 1) {\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_IF_SELECT_0);   \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\tif (postwrite == 2) {\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_IF_SELECT_1);   \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, 0);\t\t\t\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n}\n\nWRITE_SYN(max2820,  0x00FFF, 0, 0x0F, 12, 15, 1, 1)\nWRITE_SYN(al2210l,  0xFFFFF, 4, 0x0F,  0, 23, 1, 1)\n	f
8254	379	wm831x_bat_check_type	drivers/power/supply/wm831x_power.c	ret	1	13	\N	\N	\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & WM831X_CHG_STATE_MASK) {\n	f
20497	1927	filename_trans_read	security/selinux/ss/policydb.c	nel	1	13	\N	\N	\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n	f
8368	3331	skge_error_irq	drivers/net/ethernet/marvell/skge.c	pci_cmd	1	13	\N	\N	\tstruct pci_dev *pdev = hw->pdev;\n\tu32 hwstatus = skge_read32(hw, B0_HWE_ISRC);\n\n\tif (is_genesis(hw)) {\n\t\t/* clear xmac errors */\n\t\tif (hwstatus & (IS_NO_STAT_M1|IS_NO_TIST_M1))\n\t\t\tskge_write16(hw, RX_MFF_CTRL1, MFF_CLR_INSTAT);\n\t\tif (hwstatus & (IS_NO_STAT_M2|IS_NO_TIST_M2))\n\t\t\tskge_write16(hw, RX_MFF_CTRL2, MFF_CLR_INSTAT);\n\t} else {\n\t\t/* Timestamp (unused) overflow */\n\t\tif (hwstatus & IS_IRQ_TIST_OV)\n\t\t\tskge_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_CLR_IRQ);\n\t}\n\n\tif (hwstatus & IS_RAM_RD_PAR) {\n\t\tdev_err(&pdev->dev, "Ram read data parity error\\n");\n\t\tskge_write16(hw, B3_RI_CTRL, RI_CLR_RD_PERR);\n\t}\n\n\tif (hwstatus & IS_RAM_WR_PAR) {\n\t\tdev_err(&pdev->dev, "Ram write data parity error\\n");\n\t\tskge_write16(hw, B3_RI_CTRL, RI_CLR_WR_PERR);\n\t}\n\n\tif (hwstatus & IS_M1_PAR_ERR)\n\t\tskge_mac_parity(hw, 0);\n\n\tif (hwstatus & IS_M2_PAR_ERR)\n\t\tskge_mac_parity(hw, 1);\n\n\tif (hwstatus & IS_R1_PAR_ERR) {\n\t\tdev_err(&pdev->dev, "%s: receive queue parity error\\n",\n\t\t\thw->dev[0]->name);\n\t\tskge_write32(hw, B0_R1_CSR, CSR_IRQ_CL_P);\n\t}\n\n\tif (hwstatus & IS_R2_PAR_ERR) {\n\t\tdev_err(&pdev->dev, "%s: receive queue parity error\\n",\n\t\t\thw->dev[1]->name);\n\t\tskge_write32(hw, B0_R2_CSR, CSR_IRQ_CL_P);\n\t}\n\n\tif (hwstatus & (IS_IRQ_MST_ERR|IS_IRQ_STAT)) {\n\t\tu16 pci_status, pci_cmd;\n\n\t\tpci_read_config_word(pdev, PCI_COMMAND, &pci_cmd);\n\t\tpci_read_config_word(pdev, PCI_STATUS, &pci_status);\n\n\t\tdev_err(&pdev->dev, "PCI error cmd=%#x status=%#x\\n",\n	f
8514	2228	btc8192e2ant_action_pan_hs	drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8192e2ant.c	wifi_bw	1	13	\N	\N	\tu8 wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;\n\tu32 wifi_bw;\n\n\twifi_rssi_state = btc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15, 0);\n\tbt_rssi_state = btc8192e2ant_bt_rssi_state(btcoexist, 3, 34, 42);\n\n\tbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);\n\tbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);\n\n\tbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);\n\n\tbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);\n\n\tif ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||\n\t    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);\n\t} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||\n\t\t   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);\n\t} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||\n\t\t   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {\n\t\tbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);\n\t}\n\tbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);\n\tif (BTC_WIFI_BW_HT40 == wifi_bw) {\n	f
8551	1092	gc0310_detect	drivers/staging/media/atomisp/i2c/gc0310.c	id	1	13	\N	\N	\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 high, low;\n\tint ret;\n\tu16 id;\n\n\tpr_info("%s S\\n", __func__);\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tret = gc0310_read_reg(client, GC0310_8BIT,\n\t\t\t\t\tGC0310_SC_CMMN_CHIP_ID_H, &high);\n\tif (ret) {\n\t\tdev_err(&client->dev, "read sensor_id_high failed\\n");\n\t\treturn -ENODEV;\n\t}\n\tret = gc0310_read_reg(client, GC0310_8BIT,\n\t\t\t\t\tGC0310_SC_CMMN_CHIP_ID_L, &low);\n\tif (ret) {\n\t\tdev_err(&client->dev, "read sensor_id_low failed\\n");\n\t\treturn -ENODEV;\n\t}\n\tid = ((((u16) high) << 8) | (u16) low);\n\tpr_info("sensor ID = 0x%x\\n", id);\n	f
8713	1044	quicktest1	drivers/misc/sgi-gru/grukservices.c	m	1	13	\N	\N	\tstruct gru_message_queue_desc mqd;\n\tvoid *p, *mq;\n\tint i, ret = -EIO;\n\tchar mes[GRU_CACHE_LINE_BYTES], *m;\n\n\t/* Need  1K cacheline aligned that does not cross page boundary */\n\tp = kmalloc(4096, 0);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\tmq = ALIGNUP(p, 1024);\n\tmemset(mes, 0xee, sizeof(mes));\n\n\tgru_create_message_queue(&mqd, mq, 8 * GRU_CACHE_LINE_BYTES, 0, 0, 0);\n\tfor (i = 0; i < 6; i++) {\n\t\tmes[8] = i;\n\t\tdo {\n\t\t\tret = gru_send_message_gpa(&mqd, mes, sizeof(mes));\n\t\t} while (ret == MQE_CONGESTION);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tif (ret != MQE_QUEUE_FULL || i != 4) {\n\t\tprintk(KERN_DEBUG "GRU:%d quicktest1: unexpect status %d, i %d\\n",\n\t\t       smp_processor_id(), ret, i);\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tm = gru_get_next_message(&mqd);\n\t\tif (!m || m[8] != i)\n\t\t\tbreak;\n\t\tgru_free_message(&mqd, m);\n\t}\n\tif (i != 4) {\n\t\tprintk(KERN_DEBUG "GRU:%d quicktest2: bad message, i %d, m %p, m8 %d\\n",\n\t\t\tsmp_processor_id(), i, m, m ? m[8] : -1);\n	f
8715	133	usbmisc_get_init_data	drivers/usb/chipidea/ci_hdrc_imx.c	args.np	1	13	\N	\N	\tstruct platform_device *misc_pdev;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct imx_usbmisc_data *data;\n\tint ret;\n\n\t/*\n\t * In case the fsl,usbmisc property is not present this device doesn't\n\t * need usbmisc. Return NULL (which is no error here)\n\t */\n\tif (!of_get_property(np, "fsl,usbmisc", NULL))\n\t\treturn NULL;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = of_parse_phandle_with_args(np, "fsl,usbmisc", "#index-cells",\n\t\t\t\t\t0, &args);\n\tif (ret) {\n\t\tdev_err(dev, "Failed to parse property fsl,usbmisc, errno %d\\n",\n\t\t\tret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdata->index = args.args[0];\n\n\tmisc_pdev = of_find_device_by_node(args.np);\n	f
8753	657	NFTL_mount	drivers/mtd/nftlmount.c	is_first_block	1	13	\N	\N	\tint i;\n\tunsigned int first_logical_block, logical_block, rep_block, nb_erases, erase_mark;\n\tunsigned int block, first_block, is_first_block;\n\tint chain_length, do_format_chain;\n\tstruct nftl_uci0 h0;\n\tstruct nftl_uci1 h1;\n\tstruct mtd_info *mtd = s->mbd.mtd;\n\tsize_t retlen;\n\n\t/* search for NFTL MediaHeader and Spare NFTL Media Header */\n\tif (find_boot_record(s) < 0) {\n\t\tprintk("Could not find valid boot record\\n");\n\t\treturn -1;\n\t}\n\n\t/* init the logical to physical table */\n\tfor (i = 0; i < s->nb_blocks; i++) {\n\t\ts->EUNtable[i] = BLOCK_NIL;\n\t}\n\n\t/* first pass : explore each block chain */\n\tfirst_logical_block = 0;\n\tfor (first_block = 0; first_block < s->nb_blocks; first_block++) {\n\t\t/* if the block was not already explored, we can look at it */\n\t\tif (s->ReplUnitTable[first_block] == BLOCK_NOTEXPLORED) {\n\t\t\tblock = first_block;\n\t\t\tchain_length = 0;\n\t\t\tdo_format_chain = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\t/* read the block header. If error, we format the chain */\n\t\t\t\tif (nftl_read_oob(mtd,\n\t\t\t\t\t\t  block * s->EraseSize + 8, 8,\n\t\t\t\t\t\t  &retlen, (char *)&h0) < 0 ||\n\t\t\t\t    nftl_read_oob(mtd,\n\t\t\t\t\t\t  block * s->EraseSize +\n\t\t\t\t\t\t  SECTORSIZE + 8, 8,\n\t\t\t\t\t\t  &retlen, (char *)&h1) < 0) {\n\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlogical_block = le16_to_cpu ((h0.VirtUnitNum | h0.SpareVirtUnitNum));\n\t\t\t\trep_block = le16_to_cpu ((h0.ReplUnitNum | h0.SpareReplUnitNum));\n\t\t\t\tnb_erases = le32_to_cpu (h1.WearInfo);\n\t\t\t\terase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));\n\n\t\t\t\tis_first_block = !(logical_block >> 15);\n\t\t\t\tlogical_block = logical_block & 0x7fff;\n\n\t\t\t\t/* invalid/free block test */\n\t\t\t\tif (erase_mark != ERASE_MARK || logical_block >= s->nb_blocks) {\n\t\t\t\t\tif (chain_length == 0) {\n\t\t\t\t\t\t/* if not currently in a chain, we can handle it safely */\n\t\t\t\t\t\tif (check_and_mark_free_block(s, block) < 0) {\n\t\t\t\t\t\t\t/* not really free: format it */\n\t\t\t\t\t\t\tprintk("Formatting block %d\\n", block);\n\t\t\t\t\t\t\tif (NFTL_formatblock(s, block) < 0) {\n\t\t\t\t\t\t\t\t/* could not format: reserve the block */\n\t\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_RESERVED;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_FREE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* free block: mark it */\n\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_FREE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* directly examine the next block. */\n\t\t\t\t\t\tgoto examine_ReplUnitTable;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* the block was in a chain : this is bad. We\n\t\t\t\t\t\t   must format all the chain */\n\t\t\t\t\t\tprintk("Block %d: free but referenced in chain %d\\n",\n\t\t\t\t\t\t       block, first_block);\n\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* we accept only first blocks here */\n\t\t\t\tif (chain_length == 0) {\n\t\t\t\t\t/* this block is not the first block in chain :\n\t\t\t\t\t   ignore it, it will be included in a chain\n\t\t\t\t\t   later, or marked as not explored */\n\t\t\t\t\tif (!is_first_block)\n	f
8887	304	csum_tree_block	fs/btrfs/disk-io.c	kaddr	1	13	\N	\N	\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n	f
9136	526	dccp_send_reset	net/dccp/output.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\t/*\n\t * FIXME: what if rebuild_header fails?\n\t * Should we be doing a rebuild_header here?\n\t */\n\tint err = inet_csk(sk)->icsk_af_ops->rebuild_header(sk);\n\n\tif (err != 0)\n\t\treturn err;\n\n\tskb = sock_wmalloc(sk, sk->sk_prot->max_header, 1, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOBUFS;\n\n\t/* Reserve space for headers and prepare control bits. */\n\tskb_reserve(skb, sk->sk_prot->max_header);\n	f
9305	3342	btc8723b2ant_action_hid_a2dp_pan_edr	drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c	wifi_bw	1	13	\N	\N	\tu8 wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;\n\tu32 wifi_bw;\n\tu8 tmp = BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -\n\t\t\tcoex_dm->switch_thres_offset;\n\n\twifi_rssi_state = btc8723b2ant_wifi_rssi_state(btcoexist, 0, 2, 15, 0);\n\twifi_rssi_state1 = btc8723b2ant_wifi_rssi_state(btcoexist, 1, 2,\n\t\t\t\t\t\t\ttmp, 0);\n\ttmp = BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -\n\t\t\tcoex_dm->switch_thres_offset;\n\tbt_rssi_state = btc8723b2ant_bt_rssi_state(btcoexist, 2, tmp, 0);\n\n\tbtcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);\n\n\tbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);\n\tbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);\n\n\tif (BTC_RSSI_HIGH(bt_rssi_state))\n\t\tbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);\n\telse\n\t\tbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);\n\n\tif (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {\n\t\tbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);\n\t\tbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,\n\t\t\t\t\t      0x0, 0x0);\n\t} else {\n\t\tbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 14);\n\t\tbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,\n\t\t\t\t\t      0x4);\n\t}\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);\n\n\n\tif ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||\n\t    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {\n\t\tif (BTC_WIFI_BW_HT40 == wifi_bw)\n	f
9341	913	mtrr_trim_uncached_memory	arch/x86/kernel/cpu/mtrr/cleanup.c	highest_pfn	1	13	\N	\N	\tunsigned long i, base, size, highest_pfn = 0, def, dummy;\n\tmtrr_type type;\n\tu64 total_trim_size;\n\t/* extra one for all 0 */\n\tint num[MTRR_NUM_TYPES + 1];\n\n\t/*\n\t * Make sure we only trim uncachable memory on machines that\n\t * support the Intel MTRR architecture:\n\t */\n\tif (!is_cpu(INTEL) || disable_mtrr_trim)\n\t\treturn 0;\n\n\trdmsr(MSR_MTRRdefType, def, dummy);\n\tdef &= 0xff;\n\tif (def != MTRR_TYPE_UNCACHABLE)\n\t\treturn 0;\n\n\t/* Get it and store it aside: */\n\tmemset(range_state, 0, sizeof(range_state));\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\tmtrr_if->get(i, &base, &size, &type);\n\t\trange_state[i].base_pfn = base;\n\t\trange_state[i].size_pfn = size;\n\t\trange_state[i].type = type;\n\t}\n\n\t/* Find highest cached pfn: */\n\tfor (i = 0; i < num_var_ranges; i++) {\n\t\ttype = range_state[i].type;\n\t\tif (type != MTRR_TYPE_WRBACK)\n\t\t\tcontinue;\n\t\tbase = range_state[i].base_pfn;\n\t\tsize = range_state[i].size_pfn;\n\t\tif (highest_pfn < base + size)\n	f
9464	573	cyttsp_parse_properties	drivers/input/touchscreen/cyttsp_core.c	dt_value	1	13	\N	\N	\tstruct device *dev = ts->dev;\n\tu32 dt_value;\n\tint ret;\n\n\tts->bl_keys = devm_kzalloc(dev, CY_NUM_BL_KEYS, GFP_KERNEL);\n\tif (!ts->bl_keys)\n\t\treturn -ENOMEM;\n\n\t/* Set some default values */\n\tts->use_hndshk = false;\n\tts->act_dist = CY_ACT_DIST_DFLT;\n\tts->act_intrvl = CY_ACT_INTRVL_DFLT;\n\tts->tch_tmout = CY_TCH_TMOUT_DFLT;\n\tts->lp_intrvl = CY_LP_INTRVL_DFLT;\n\n\tret = device_property_read_u8_array(dev, "bootloader-key",\n\t\t\t\t\t    ts->bl_keys, CY_NUM_BL_KEYS);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t"bootloader-key property could not be retrieved\\n");\n\t\treturn ret;\n\t}\n\n\tts->use_hndshk = device_property_present(dev, "use-handshake");\n\n\tif (!device_property_read_u32(dev, "active-distance", &dt_value)) {\n\t\tif (dt_value > 15) {\n	f
9912	2320	pfkey_spdadd	net/key/af_key.c	&c	1	13	\N	\N	\tstruct net *net = sock_net(sk);\n\tint err = 0;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\n\t\treturn -EINVAL;\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\txp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tif (xp == NULL)\n\t\treturn -ENOBUFS;\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\txp->priority = pol->sadb_x_policy_priority;\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\txp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\n\txp->selector.family = xp->family;\n\txp->selector.prefixlen_s = sa->sadb_address_prefixlen;\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\txp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.sport)\n\t\txp->selector.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\n\txp->selector.prefixlen_d = sa->sadb_address_prefixlen;\n\n\t/* Amusing, we set this twice.  KAME apps appear to set same value\n\t * in both addresses.\n\t */\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\n\txp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.dport)\n\t\txp->selector.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = security_xfrm_policy_alloc(&xp->security, uctx, GFP_KERNEL);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\n\t\txp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\n\t\txp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (err = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\terr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\n\t\t\t\t hdr->sadb_msg_type != SADB_X_SPDUPDATE);\n\n\txfrm_audit_policy_add(xp, err ? 0 : 1, true);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\n\t\tc.event = XFRM_MSG_UPDPOLICY;\n\telse\n\t\tc.event = XFRM_MSG_NEWPOLICY;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n	f
9952	217	m41t80_get_datetime	drivers/rtc/rtc-m41t80.c	err	1	13	\N	\N	\tunsigned char buf[8];\n\tint err, flags;\n\n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (flags & M41T80_FLAGS_OF) {\n\t\tdev_err(&client->dev, "Oscillator failure, data is invalid.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\terr = i2c_smbus_read_i2c_block_data(client, M41T80_REG_SSEC,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err < 0) {\n	f
9954	868	calc_seckey	fs/cifs/cifsencrypt.c	sec_key	1	13	\N	\N	\tint rc;\n\tstruct crypto_skcipher *tfm_arc4;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tunsigned char *sec_key;\n\n\tsec_key = kmalloc(CIFS_SESS_KEY_SIZE, GFP_KERNEL);\n\tif (sec_key == NULL)\n\t\treturn -ENOMEM;\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\ttfm_arc4 = crypto_alloc_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_arc4)) {\n\t\trc = PTR_ERR(tfm_arc4);\n\t\tcifs_dbg(VFS, "could not allocate crypto API arc4\\n");\n\t\tgoto out;\n\t}\n\n\trc = crypto_skcipher_setkey(tfm_arc4, ses->auth_key.response,\n\t\t\t\t\tCIFS_SESS_KEY_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, "%s: Could not set response as a key\\n",\n\t\t\t __func__);\n\t\tgoto out_free_cipher;\n\t}\n\n\treq = skcipher_request_alloc(tfm_arc4, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, "could not allocate crypto API arc4 request\\n");\n\t\tgoto out_free_cipher;\n\t}\n\n\tsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\n\tsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, CIFS_CPHTXT_SIZE, NULL);\n\n\trc = crypto_skcipher_encrypt(req);\n\tskcipher_request_free(req);\n\tif (rc) {\n\t\tcifs_dbg(VFS, "could not encrypt session key rc: %d\\n", rc);\n\t\tgoto out_free_cipher;\n\t}\n\n\t/* make secondary_key/nonce as session key */\n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n	f
10161	605	l3_1tr6_t305	drivers/isdn/hisax/l3_1tr6.c	skb	1	13	\N	\N	\tstruct sk_buff *skb;\n\tu_char tmp[16];\n\tu_char *p = tmp;\n\tint l;\n\tu_char cause = 0x90;\n\tu_char clen = 1;\n\n\tL3DelTimer(&pc->timer);\n\tif (pc->para.cause != NO_CAUSE)\n\t\tcause = pc->para.cause;\n\t/* Map DSS1 causes */\n\tswitch (cause & 0x7f) {\n\tcase 0x10:\n\t\tclen = 0;\n\t\tbreak;\n\tcase 0x15:\n\t\tcause = CAUSE_CallRejected;\n\t\tbreak;\n\t}\n\tMsgHead(p, pc->callref, MT_N1_REL, PROTO_DIS_N1);\n\t*p++ = WE0_cause;\n\t*p++ = clen;\t\t/* Laenge */\n\tif (clen)\n\t\t*p++ = cause;\n\tnewl3state(pc, 19);\n\tl = p - tmp;\n\tif (!(skb = l3_alloc_skb(l)))\n\t\treturn;\n\tskb_put_data(skb, tmp, l);\n	f
20137	131	amdgpu_virt_kiq_rreg	drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c	f	1	13	\N	\N	\tsigned long r;\n\tuint32_t val;\n\tstruct dma_fence *f;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq;\n\tstruct amdgpu_ring *ring = &kiq->ring;\n\n\tBUG_ON(!ring->funcs->emit_rreg);\n\n\tmutex_lock(&kiq->ring_mutex);\n\tamdgpu_ring_alloc(ring, 32);\n\tamdgpu_ring_emit_rreg(ring, reg);\n\tamdgpu_fence_emit(ring, &f);\n\tamdgpu_ring_commit(ring);\n\tmutex_unlock(&kiq->ring_mutex);\n\n\tr = dma_fence_wait_timeout(f, false, msecs_to_jiffies(MAX_KIQ_REG_WAIT));\n	f
20503	1964	filename_trans_read	security/selinux/ss/policydb.c	ft->ttype	1	13	\N	\N	\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\totype = NULL;\n\t\tname = NULL;\n\n\t\trc = -ENOMEM;\n\t\tft = kzalloc(sizeof(*ft), GFP_KERNEL);\n\t\tif (!ft)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\totype = kmalloc(sizeof(*otype), GFP_KERNEL);\n\t\tif (!otype)\n\t\t\tgoto out;\n\n\t\t/* length of the path component string */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t/* path component string */\n\t\trc = str_read(&name, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->name = name;\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->stype = le32_to_cpu(buf[0]);\n\t\tft->ttype = le32_to_cpu(buf[1]);\n\t\tft->tclass = le32_to_cpu(buf[2]);\n\n\t\totype->otype = le32_to_cpu(buf[3]);\n\n\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\n	f
20513	1343	class_read	security/selinux/ss/policydb.c	len	1	13	\N	\N	\tchar *key = NULL;\n\tstruct class_datum *cladatum;\n\t__le32 buf[6];\n\tu32 len, len2, ncons, nel;\n\tint i, rc;\n\n\tcladatum = kzalloc(sizeof(*cladatum), GFP_KERNEL);\n\tif (!cladatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof(u32)*6);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlen2 = le32_to_cpu(buf[1]);\n\tcladatum->value = le32_to_cpu(buf[2]);\n\n\trc = symtab_init(&cladatum->permissions, PERM_SYMTAB_SIZE);\n\tif (rc)\n\t\tgoto bad;\n\tcladatum->permissions.nprim = le32_to_cpu(buf[3]);\n\tnel = le32_to_cpu(buf[4]);\n\n\tncons = le32_to_cpu(buf[5]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n	f
20560	867	bcm_probe	drivers/bluetooth/hci_bcm.c	dev	1	13	\N	\N	\tstruct bcm_device *dev;\n\tint ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->pdev = pdev;\n\n\tif (has_acpi_companion(&pdev->dev))\n\t\tret = bcm_acpi_probe(dev);\n\telse\n\t\tret = bcm_platform_probe(dev);\n	f
20665	767	handle_transaction_done	drivers/char/ipmi/ipmi_si_intf.c	msg	1	13	\N	\N	\tstruct ipmi_smi_msg *msg;\n\n\tdebug_timestamp("Done");\n\tswitch (smi_info->si_state) {\n\tcase SI_NORMAL:\n\t\tif (!smi_info->curr_msg)\n\t\t\tbreak;\n\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tdeliver_recv_msg(smi_info, msg);\n\t\tbreak;\n\n\tcase SI_GETTING_FLAGS:\n\t{\n\t\tunsigned char msg[4];\n\t\tunsigned int  len;\n\n\t\t/* We got the flags from the SMI, now handle them. */\n\t\tlen = smi_info->handlers->get_result(smi_info->si_sm, msg, 4);\n\t\tif (msg[2] != 0) {\n\t\t\t/* Error fetching flags, just give up for now. */\n\t\t\tsmi_info->si_state = SI_NORMAL;\n\t\t} else if (len < 4) {\n\t\t\t/*\n\t\t\t * Hmm, no flags.  That's technically illegal, but\n\t\t\t * don't use uninitialized data.\n\t\t\t */\n\t\t\tsmi_info->si_state = SI_NORMAL;\n\t\t} else {\n\t\t\tsmi_info->msg_flags = msg[3];\n\t\t\thandle_flags(smi_info);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_CLEARING_FLAGS:\n\t{\n\t\tunsigned char msg[3];\n\n\t\t/* We cleared the flags. */\n\t\tsmi_info->handlers->get_result(smi_info->si_sm, msg, 3);\n\t\tif (msg[2] != 0) {\n\t\t\t/* Error clearing flags */\n\t\t\tdev_warn(smi_info->dev,\n\t\t\t\t "Error clearing flags: %2.2x\\n", msg[2]);\n\t\t}\n\t\tsmi_info->si_state = SI_NORMAL;\n\t\tbreak;\n\t}\n\n\tcase SI_GETTING_EVENTS:\n\t{\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tif (msg->rsp[2] != 0) {\n\t\t\t/* Error getting event, probably done. */\n\t\t\tmsg->done(msg);\n\n\t\t\t/* Take off the event flag. */\n\t\t\tsmi_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\n\t\t\thandle_flags(smi_info);\n\t\t} else {\n\t\t\tsmi_inc_stat(smi_info, events);\n\n\t\t\t/*\n\t\t\t * Do this before we deliver the message\n\t\t\t * because delivering the message releases the\n\t\t\t * lock and something else can mess with the\n\t\t\t * state.\n\t\t\t */\n\t\t\thandle_flags(smi_info);\n\n\t\t\tdeliver_recv_msg(smi_info, msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_GETTING_MESSAGES:\n\t{\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tif (msg->rsp[2] != 0) {\n\t\t\t/* Error getting event, probably done. */\n\t\t\tmsg->done(msg);\n\n\t\t\t/* Take off the msg flag. */\n\t\t\tsmi_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\n\t\t\thandle_flags(smi_info);\n\t\t} else {\n\t\t\tsmi_inc_stat(smi_info, incoming_messages);\n\n\t\t\t/*\n\t\t\t * Do this before we deliver the message\n\t\t\t * because delivering the message releases the\n\t\t\t * lock and something else can mess with the\n\t\t\t * state.\n\t\t\t */\n\t\t\thandle_flags(smi_info);\n\n\t\t\tdeliver_recv_msg(smi_info, msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SI_CHECKING_ENABLES:\n\t{\n\t\tunsigned char msg[4];\n\t\tu8 enables;\n\t\tbool irq_on;\n\n\t\t/* We got the flags from the SMI, now handle them. */\n\t\tsmi_info->handlers->get_result(smi_info->si_sm, msg, 4);\n\t\tif (msg[2] != 0) {\n	f
20666	652	handle_transaction_done	drivers/char/ipmi/ipmi_si_intf.c	msg	1	13	\N	\N	\tstruct ipmi_smi_msg *msg;\n\n\tdebug_timestamp("Done");\n\tswitch (smi_info->si_state) {\n\tcase SI_NORMAL:\n\t\tif (!smi_info->curr_msg)\n\t\t\tbreak;\n\n\t\tsmi_info->curr_msg->rsp_size\n\t\t\t= smi_info->handlers->get_result(\n\t\t\t\tsmi_info->si_sm,\n\t\t\t\tsmi_info->curr_msg->rsp,\n\t\t\t\tIPMI_MAX_MSG_LENGTH);\n\n\t\t/*\n\t\t * Do this here becase deliver_recv_msg() releases the\n\t\t * lock, and a new message can be put in during the\n\t\t * time the lock is released.\n\t\t */\n\t\tmsg = smi_info->curr_msg;\n\t\tsmi_info->curr_msg = NULL;\n\t\tdeliver_recv_msg(smi_info, msg);\n\t\tbreak;\n\n\tcase SI_GETTING_FLAGS:\n\t{\n\t\tunsigned char msg[4];\n\t\tunsigned int  len;\n\n\t\t/* We got the flags from the SMI, now handle them. */\n\t\tlen = smi_info->handlers->get_result(smi_info->si_sm, msg, 4);\n\t\tif (msg[2] != 0) {\n	f
20693	211	ieee80211_DELBA	drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c	skb	1	13	\N	\N	\tDELBA_PARAM_SET\tDelbaParamSet;\n\tstruct sk_buff *skb = NULL;\n\t struct rtl_80211_hdr_3addr *Delba = NULL;\n\tu8 *tag = NULL;\n\t//len = head len + DELBA Parameter Set(2) + Reason Code(2)\n\tu16 len = 6 + ieee->tx_headroom;\n\n\tif (net_ratelimit())\n\tIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\\n", __func__, ReasonCode, dst);\n\n\tmemset(&DelbaParamSet, 0, 2);\n\n\tDelbaParamSet.field.Initiator\t= (TxRxSelect==TX_DIR)?1:0;\n\tDelbaParamSet.field.TID\t= pBA->BaParamSet.field.TID;\n\n\tskb = dev_alloc_skb(len + sizeof( struct rtl_80211_hdr_3addr)); //need to add something others? FIXME\n\tif (!skb) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't alloc skb for ADDBA_REQ\\n");\n\t\treturn NULL;\n\t}\n//\tmemset(skb->data, 0, len+sizeof( struct rtl_80211_hdr_3addr));\n\tskb_reserve(skb, ieee->tx_headroom);\n	f
20700	177	radeon_sync_rings	drivers/gpu/drm/radeon/radeon_sync.c	semaphore)	1	13	\N	\N	\tunsigned count = 0;\n\tint i, r;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tstruct radeon_fence *fence = sync->sync_to[i];\n\t\tstruct radeon_semaphore *semaphore;\n\n\t\t/* check if we really need to sync */\n\t\tif (!radeon_fence_need_sync(fence, ring))\n\t\t\tcontinue;\n\n\t\t/* prevent GPU deadlocks */\n\t\tif (!rdev->ring[i].ready) {\n\t\t\tdev_err(rdev->dev, "Syncing to a disabled ring!");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (count >= RADEON_NUM_SYNCS) {\n\t\t\t/* not enough room, wait manually */\n\t\t\tr = radeon_fence_wait(fence, false);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\t\t}\n\t\tr = radeon_semaphore_create(rdev, &semaphore);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tsync->semaphores[count++] = semaphore;\n\n\t\t/* allocate enough space for sync command */\n\t\tr = radeon_ring_alloc(rdev, &rdev->ring[i], 16);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\t/* emit the signal semaphore */\n\t\tif (!radeon_semaphore_emit_signal(rdev, i, semaphore)) {\n	f
20707	270	radeon_uvd_suspend	drivers/gpu/drm/radeon/radeon_uvd.c	fence	1	13	\N	\N	\tint i, r;\n\n\tif (rdev->uvd.vcpu_bo == NULL)\n\t\treturn 0;\n\n\tfor (i = 0; i < rdev->uvd.max_handles; ++i) {\n\t\tuint32_t handle = atomic_read(&rdev->uvd.handles[i]);\n\t\tif (handle != 0) {\n\t\t\tstruct radeon_fence *fence;\n\n\t\t\tradeon_uvd_note_usage(rdev);\n\n\t\t\tr = radeon_uvd_get_destroy_msg(rdev,\n\t\t\t\tR600_RING_TYPE_UVD_INDEX, handle, &fence);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR("Error destroying UVD (%d)!\\n", r);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tradeon_fence_wait(fence, false);\n	f
20735	620	acpi_ex_store_direct_to_node	drivers/acpi/acpica/exstore.c	new_desc	1	13	\N	\N	\tacpi_status status;\n\tunion acpi_operand_object *new_desc;\n\n\tACPI_FUNCTION_TRACE(ex_store_direct_to_node);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  "Storing [%s] (%p) directly into node [%s] (%p)"\n\t\t\t  " with no implicit conversion\\n",\n\t\t\t  acpi_ut_get_object_type_name(source_desc),\n\t\t\t  source_desc, acpi_ut_get_type_name(node->type),\n\t\t\t  node));\n\n\t/* Copy the source object to a new object */\n\n\tstatus =\n\t    acpi_ut_copy_iobject_to_iobject(source_desc, &new_desc, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Attach the new object to the node */\n\n\tstatus = acpi_ns_attach_object(node, new_desc, new_desc->common.type);\n	f
20793	237	acpi_ds_initialize_objects	drivers/acpi/acpica/dsinit.c	table->signature	1	13	\N	\N	\tacpi_status status;\n\tstruct acpi_init_walk_info info;\n\tstruct acpi_table_header *table;\n\tacpi_owner_id owner_id;\n\n\tACPI_FUNCTION_TRACE(ds_initialize_objects);\n\n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  "**** Starting initialization of namespace objects ****\\n"));\n\n\t/* Set all init info to zero */\n\n\tmemset(&info, 0, sizeof(struct acpi_init_walk_info));\n\n\tinfo.owner_id = owner_id;\n\tinfo.table_index = table_index;\n\n\t/* Walk entire namespace from the supplied root */\n\n\t/*\n\t * We don't use acpi_walk_namespace since we do not want to acquire\n\t * the namespace reader lock.\n\t */\n\tstatus =\n\t    acpi_ns_walk_namespace(ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,\n\t\t\t\t   ACPI_NS_WALK_NO_UNLOCK,\n\t\t\t\t   acpi_ds_init_one_object, NULL, &info, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, "During WalkNamespace"));\n\t}\n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* DSDT is always the first AML table */\n\n\tif (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT)) {\n	f
20799	237	acpi_ds_initialize_objects	drivers/acpi/acpica/dsinit.c	table->signature	1	13	\N	\N	\tacpi_status status;\n\tstruct acpi_init_walk_info info;\n\tstruct acpi_table_header *table;\n\tacpi_owner_id owner_id;\n\n\tACPI_FUNCTION_TRACE(ds_initialize_objects);\n\n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  "**** Starting initialization of namespace objects ****\\n"));\n\n\t/* Set all init info to zero */\n\n\tmemset(&info, 0, sizeof(struct acpi_init_walk_info));\n\n\tinfo.owner_id = owner_id;\n\tinfo.table_index = table_index;\n\n\t/* Walk entire namespace from the supplied root */\n\n\t/*\n\t * We don't use acpi_walk_namespace since we do not want to acquire\n\t * the namespace reader lock.\n\t */\n\tstatus =\n\t    acpi_ns_walk_namespace(ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,\n\t\t\t\t   ACPI_NS_WALK_NO_UNLOCK,\n\t\t\t\t   acpi_ds_init_one_object, NULL, &info, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, "During WalkNamespace"));\n\t}\n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* DSDT is always the first AML table */\n\n\tif (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT)) {\n	f
20855	141	acpi_ns_execute_table	drivers/acpi/acpica/nsparse.c	method_obj	1	13	\N	\N	\tacpi_status status;\n\tstruct acpi_table_header *table;\n\tacpi_owner_id owner_id;\n\tstruct acpi_evaluate_info *info = NULL;\n\tu32 aml_length;\n\tu8 *aml_start;\n\tunion acpi_operand_object *method_obj = NULL;\n\n\tACPI_FUNCTION_TRACE(ns_execute_table);\n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Table must consist of at least a complete header */\n\n\tif (table->length < sizeof(struct acpi_table_header)) {\n\t\treturn_ACPI_STATUS(AE_BAD_HEADER);\n\t}\n\n\taml_start = (u8 *)table + sizeof(struct acpi_table_header);\n\taml_length = table->length - sizeof(struct acpi_table_header);\n\n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Create, initialize, and link a new temporary method object */\n\n\tmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\n\tif (!method_obj) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t/* Allocate the evaluation information block */\n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  "Create table code block: %p\\n", method_obj));\n\n\tmethod_obj->method.aml_start = aml_start;\n\tmethod_obj->method.aml_length = aml_length;\n\tmethod_obj->method.owner_id = owner_id;\n\tmethod_obj->method.info_flags |= ACPI_METHOD_MODULE_LEVEL;\n\n\tinfo->pass_number = ACPI_IMODE_EXECUTE;\n\tinfo->node = start_node;\n\tinfo->obj_desc = method_obj;\n\tinfo->node_flags = info->node->flags;\n\tinfo->full_pathname = acpi_ns_get_normalized_pathname(info->node, TRUE);\n\tif (!info->full_pathname) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\tstatus = acpi_ps_execute_table(info);\n\ncleanup:\n\tif (info) {\n\t\tACPI_FREE(info->full_pathname);\n\t\tinfo->full_pathname = NULL;\n\t}\n\tACPI_FREE(info);\n\tacpi_ut_remove_reference(method_obj);\n	f
20881	400	acpi_ds_resolve_operands	drivers/acpi/acpica/dsutils.c	status	1	13	\N	\N	\tu32 i;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_resolve_operands, walk_state);\n\n\t/*\n\t * Attempt to resolve each of the valid operands\n\t * Method arguments are passed by reference, not by value. This means\n\t * that the actual objects are passed, not copies of the objects.\n\t */\n\tfor (i = 0; i < walk_state->num_operands; i++) {\n\t\tstatus =\n\t\t    acpi_ex_resolve_to_value(&walk_state->operands[i],\n\t\t\t\t\t     walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n	f
21081	961	acpi_video_init_brightness	drivers/acpi/acpi_video.c	level	1	13	\N	\N	\tint i, max_level = 0;\n\tunsigned long long level, level_old;\n\tstruct acpi_video_device_brightness *br = NULL;\n\tint result = -EINVAL;\n\n\tresult = acpi_video_get_levels(device->dev, &br, &max_level);\n\tif (result)\n\t\treturn result;\n\tdevice->brightness = br;\n\n\t/* _BQC uses INDEX while _BCL uses VALUE in some laptops */\n\tbr->curr = level = max_level;\n\n\tif (!device->cap._BQC)\n\t\tgoto set_level;\n\n\tresult = acpi_video_device_lcd_get_level_current(device,\n\t\t\t\t\t\t\t &level_old, true);\n\tif (result)\n\t\tgoto out_free_levels;\n\n\tresult = acpi_video_bqc_quirk(device, max_level, level_old);\n\tif (result)\n\t\tgoto out_free_levels;\n\t/*\n\t * cap._BQC may get cleared due to _BQC is found to be broken\n\t * in acpi_video_bqc_quirk, so check again here.\n\t */\n\tif (!device->cap._BQC)\n\t\tgoto set_level;\n\n\tlevel = acpi_video_bqc_value_to_level(device, level_old);\n\t/*\n\t * On some buggy laptops, _BQC returns an uninitialized\n\t * value when invoked for the first time, i.e.\n\t * level_old is invalid (no matter whether it's a level\n\t * or an index). Set the backlight to max_level in this case.\n\t */\n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < br->count; i++)\n\t\tif (level == br->levels[i])\n	f
21281	155	max17042_get_status	drivers/power/supply/max17042_battery.c	charge_full	1	13	\N	\N	\tint ret, charge_full, charge_now;\n\n\tret = power_supply_am_i_supplied(chip->battery);\n\tif (ret < 0) {\n\t\t*status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\treturn 0;\n\t}\n\tif (ret == 0) {\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The MAX170xx has builtin end-of-charge detection and will update\n\t * FullCAP to match RepCap when it detects end of charging.\n\t *\n\t * When this cycle the battery gets charged to a higher (calculated)\n\t * capacity then the previous cycle then FullCAP will get updated\n\t * contineously once end-of-charge detection kicks in, so allow the\n\t * 2 to differ a bit.\n\t */\n\n\tret = regmap_read(chip->regmap, MAX17042_FullCAP, &charge_full);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(chip->regmap, MAX17042_RepCap, &charge_now);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((charge_full - charge_now) <= MAX17042_FULL_THRESHOLD)\n	f
23852	566	ext4_xattr_ibody_get	fs/ext4/xattr.c	header	1	13	\N	\N	\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n	f
21421	1616	atmel_spi_probe	drivers/spi/spi-atmel.c	atmel_spi_probe_	1	13	\N	\N	\tstruct resource\t\t*regs;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tint\t\t\tret;\n\tstruct spi_master\t*master;\n\tstruct atmel_spi\t*as;\n\n\t/* Select default pin state */\n\tpinctrl_pm_select_default_state(&pdev->dev);\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn -ENXIO;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tclk = devm_clk_get(&pdev->dev, "spi_clk");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\t/* setup spi core then atmel-specific driver state */\n\tret = -ENOMEM;\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*as));\n\tif (!master)\n\t\tgoto out_free;\n\n\t/* the spi->mode bits understood by this driver: */\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->bus_num = pdev->id;\n\tmaster->num_chipselect = master->dev.of_node ? 0 : 4;\n\tmaster->setup = atmel_spi_setup;\n\tmaster->flags = (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX);\n\tmaster->transfer_one_message = atmel_spi_transfer_one_message;\n\tmaster->cleanup = atmel_spi_cleanup;\n\tmaster->auto_runtime_pm = true;\n\tmaster->max_dma_len = SPI_MAX_DMA_XFER;\n\tmaster->can_dma = atmel_spi_can_dma;\n\tplatform_set_drvdata(pdev, master);\n\n\tas = spi_master_get_devdata(master);\n\n\tspin_lock_init(&as->lock);\n\n\tas->pdev = pdev;\n\tas->regs = devm_ioremap_resource(&pdev->dev, regs);\n\tif (IS_ERR(as->regs)) {\n\t\tret = PTR_ERR(as->regs);\n\t\tgoto out_unmap_regs;\n\t}\n\tas->phybase = regs->start;\n\tas->irq = irq;\n\tas->clk = clk;\n\n\tinit_completion(&as->xfer_completion);\n\n\tatmel_get_caps(as);\n\n\tas->use_cs_gpios = true;\n\tif (atmel_spi_is_v2(as) &&\n\t    pdev->dev.of_node &&\n\t    !of_get_property(pdev->dev.of_node, "cs-gpios", NULL)) {\n\t\tas->use_cs_gpios = false;\n\t\tmaster->num_chipselect = 4;\n\t}\n\n\tret = atmel_spi_gpio_cs(pdev);\n\tif (ret)\n\t\tgoto out_unmap_regs;\n\n\tas->use_dma = false;\n\tas->use_pdc = false;\n\tif (as->caps.has_dma_support) {\n\t\tret = atmel_spi_configure_dma(master, as);\n\t\tif (ret == 0) {\n\t\t\tas->use_dma = true;\n\t\t} else if (ret == -EPROBE_DEFER) {\n\t\t\treturn ret;\n\t\t}\n\t} else if (as->caps.has_pdc_support) {\n\t\tas->use_pdc = true;\n\t}\n\n\tif (as->caps.has_dma_support && !as->use_dma)\n\t\tdev_info(&pdev->dev, "Atmel SPI Controller using PIO only\\n");\n\n\tif (as->use_pdc) {\n\t\tret = devm_request_irq(&pdev->dev, irq, atmel_spi_pdc_interrupt,\n\t\t\t\t\t0, dev_name(&pdev->dev), master);\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, irq, atmel_spi_pio_interrupt,\n\t\t\t\t\t0, dev_name(&pdev->dev), master);\n\t}\n\tif (ret)\n\t\tgoto out_unmap_regs;\n\n\t/* Initialize the hardware */\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tas->spi_clk = clk_get_rate(clk);\n\n\tas->fifo_size = 0;\n\tif (!of_property_read_u32(pdev->dev.of_node, "atmel,fifo-size",\n	f
21534	763	iov_iter_zero	lib/iov_iter.c	bytes	1	13	\N	\N	\tif (unlikely(i->type & ITER_PIPE))\n\t\treturn pipe_zero(bytes, i);\n\titerate_and_advance(i, bytes, v,\n	f
21543	521	drm_legacy_rmmap_locked	drivers/gpu/drm/drm_bufs.c	master	1	13	\N	\N	\tstruct drm_map_list *r_list = NULL, *list_t;\n\tdrm_dma_handle_t dmah;\n\tint found = 0;\n\tstruct drm_master *master;\n\n\t/* Find the list entry for the map and remove it */\n\tlist_for_each_entry_safe(r_list, list_t, &dev->maplist, head) {\n\t\tif (r_list->map == map) {\n\t\t\tmaster = r_list->master;\n\t\t\tlist_del(&r_list->head);\n\t\t\tdrm_ht_remove_key(&dev->map_hash,\n\t\t\t\t\t  r_list->user_token >> PAGE_SHIFT);\n\t\t\tkfree(r_list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\tswitch (map->type) {\n\tcase _DRM_REGISTERS:\n\t\tiounmap(map->handle);\n\t\t/* FALLTHROUGH */\n\tcase _DRM_FRAME_BUFFER:\n\t\tarch_phys_wc_del(map->mtrr);\n\t\tbreak;\n\tcase _DRM_SHM:\n\t\tvfree(map->handle);\n\t\tif (master) {\n	f
21836	89	roccat_common2_receive_control_status	drivers/hid/hid-roccat-common.c	control.value	1	13	\N	\N	\tint retval;\n\tstruct roccat_common2_control control;\n\n\tdo {\n\t\tmsleep(50);\n\t\tretval = roccat_common2_receive(usb_dev,\n\t\t\t\tROCCAT_COMMON_COMMAND_CONTROL,\n\t\t\t\t&control, sizeof(struct roccat_common2_control));\n\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tswitch (control.value) {\n	f
21896	229	__nci_spi_read	net/nfc/nci/spi.c	rx_len	1	13	\N	\N	\tstruct sk_buff *skb;\n\tstruct spi_message m;\n\tunsigned char req[2], resp_hdr[2];\n\tstruct spi_transfer tx, rx;\n\tunsigned short rx_len = 0;\n\tint ret;\n\n\tspi_message_init(&m);\n\n\tmemset(&tx, 0, sizeof(struct spi_transfer));\n\treq[0] = NCI_SPI_DIRECT_READ;\n\treq[1] = nspi->acknowledge_mode;\n\ttx.tx_buf = req;\n\ttx.len = 2;\n\ttx.cs_change = 0;\n\ttx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&tx, &m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = resp_hdr;\n\trx.len = 2;\n\trx.cs_change = 1;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\trx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +\n\t\t\t\tresp_hdr[1] + NCI_SPI_CRC_LEN;\n\telse\n\t\trx_len = (resp_hdr[0] << 8) | resp_hdr[1];\n\n\tskb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tspi_message_init(&m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = skb_put(skb, rx_len);\n	f
21915	316	nci_spi_read	net/nfc/nci/spi.c	skb->len	1	13	\N	\N	\tstruct sk_buff *skb;\n\n\t/* Retrieve frame from SPI */\n\tskb = __nci_spi_read(nspi);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tif (!nci_spi_check_crc(skb)) {\n\t\t\tsend_acknowledge(nspi, ACKNOWLEDGE_NACK);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* In case of acknowledged mode: if ACK or NACK received,\n\t\t * unblock completion of latest frame sent.\n\t\t */\n\t\tnspi->req_result = nci_spi_get_ack(skb);\n\t\tif (nspi->req_result)\n\t\t\tcomplete(&nspi->req_completion);\n\t}\n\n\t/* If there is no payload (ACK/NACK only frame),\n\t * free the socket buffer\n\t */\n\tif (!skb->len) {\n	f
22092	635	atmel_tdes_handle_queue	drivers/crypto/atmel-tdes.c	dd	1	13	\N	\N	\tstruct crypto_async_request *async_req, *backlog;\n\tstruct atmel_tdes_ctx *ctx;\n\tstruct atmel_tdes_reqctx *rctx;\n\tunsigned long flags;\n\tint err, ret = 0;\n\n\tspin_lock_irqsave(&dd->lock, flags);\n\tif (req)\n\t\tret = ablkcipher_enqueue_request(&dd->queue, req);\n\tif (dd->flags & TDES_FLAGS_BUSY) {\n\t\tspin_unlock_irqrestore(&dd->lock, flags);\n\t\treturn ret;\n\t}\n\tbacklog = crypto_get_backlog(&dd->queue);\n\tasync_req = crypto_dequeue_request(&dd->queue);\n\tif (async_req)\n\t\tdd->flags |= TDES_FLAGS_BUSY;\n\tspin_unlock_irqrestore(&dd->lock, flags);\n\n\tif (!async_req)\n\t\treturn ret;\n\n\tif (backlog)\n\t\tbacklog->complete(backlog, -EINPROGRESS);\n\n\treq = ablkcipher_request_cast(async_req);\n\n\t/* assign new request to device */\n\tdd->req = req;\n\tdd->total = req->nbytes;\n\tdd->in_offset = 0;\n\tdd->in_sg = req->src;\n\tdd->out_offset = 0;\n\tdd->out_sg = req->dst;\n\n\trctx = ablkcipher_request_ctx(req);\n\tctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));\n\trctx->mode &= TDES_FLAGS_MODE_MASK;\n\tdd->flags = (dd->flags & ~TDES_FLAGS_MODE_MASK) | rctx->mode;\n\tdd->ctx = ctx;\n\tctx->dd = dd;\n\n\terr = atmel_tdes_write_ctrl(dd);\n\tif (!err)\n\t\terr = atmel_tdes_crypt_start(dd);\n	f
22146	522	V2_minix_iget	fs/minix/inode.c	bh	1	13	\N	\N	\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n	f
22527	1114	xfs_qm_quotacheck_dqadjust	fs/xfs/xfs_qm.c	dqp->q_core.d_id	1	13	\N	\N	\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget(mp, ip, id, type,\n\t\t\t     XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\n\tif (error) {\n\t\t/*\n\t\t * Shouldn't be able to turn off quotas here.\n\t\t */\n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t/*\n\t * Adjust the inode count and the block count to reflect this inode's\n\t * resource usage.\n\t */\n\tbe64_add_cpu(&dqp->q_core.d_icount, 1);\n\tdqp->q_res_icount++;\n\tif (nblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\n\t\tdqp->q_res_bcount += nblks;\n\t}\n\tif (rtblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\n\t\tdqp->q_res_rtbcount += rtblks;\n\t}\n\n\t/*\n\t * Set default limits, adjust timers (since we changed usages)\n\t *\n\t * There are no timers for the default values set in the root dquot.\n\t */\n\tif (dqp->q_core.d_id) {\n	f
23256	318	cramfs_fill_super	fs/cramfs/inode.c	super.flags	1	13	\N	\N	\tint i;\n\tstruct cramfs_super super;\n\tunsigned long root_offset;\n\tstruct cramfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tsb->s_flags |= MS_RDONLY;\n\n\tsbi = kzalloc(sizeof(struct cramfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\t/* Invalidate the read buffers on mount: think disk change.. */\n\tmutex_lock(&read_mutex);\n\tfor (i = 0; i < READ_BUFFERS; i++)\n\t\tbuffer_blocknr[i] = -1;\n\n\t/* Read the first block and get the superblock from it */\n\tmemcpy(&super, cramfs_read(sb, 0, sizeof(super)), sizeof(super));\n\tmutex_unlock(&read_mutex);\n\n\t/* Do sanity checks on the superblock */\n\tif (super.magic != CRAMFS_MAGIC) {\n\t\t/* check for wrong endianness */\n\t\tif (super.magic == CRAMFS_MAGIC_WEND) {\n\t\t\tif (!silent)\n\t\t\t\tpr_err("wrong endianness\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check at 512 byte offset */\n\t\tmutex_lock(&read_mutex);\n\t\tmemcpy(&super, cramfs_read(sb, 512, sizeof(super)), sizeof(super));\n\t\tmutex_unlock(&read_mutex);\n\t\tif (super.magic != CRAMFS_MAGIC) {\n\t\t\tif (super.magic == CRAMFS_MAGIC_WEND && !silent)\n\t\t\t\tpr_err("wrong endianness\\n");\n\t\t\telse if (!silent)\n\t\t\t\tpr_err("wrong magic\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* get feature flags first */\n\tif (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {\n\t\tpr_err("unsupported filesystem features\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check that the root inode is in a sane state */\n\tif (!S_ISDIR(super.root.mode)) {\n\t\tpr_err("root is not a directory\\n");\n\t\treturn -EINVAL;\n\t}\n\t/* correct strange, hard-coded permissions of mkcramfs */\n\tsuper.root.mode |= (S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\n\troot_offset = super.root.offset << 2;\n\tif (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {\n	f
23277	2205	f2fs_scan_devices	fs/f2fs/super.c	f2fs_scan_devices_	1	13	\N	\N	\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tunsigned int max_devices = MAX_DEVICES;\n\tint i;\n\n\t/* Initialize single device information */\n\tif (!RDEV(0).path[0]) {\n\t\tif (!bdev_is_zoned(sbi->sb->s_bdev))\n\t\t\treturn 0;\n\t\tmax_devices = 1;\n\t}\n\n\t/*\n\t * Initialize multiple devices information, or single\n\t * zoned block device information.\n\t */\n\tsbi->devs = kcalloc(max_devices, sizeof(struct f2fs_dev_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!sbi->devs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_devices; i++) {\n\n\t\tif (i > 0 && !RDEV(i).path[0])\n\t\t\tbreak;\n\n\t\tif (max_devices == 1) {\n\t\t\t/* Single zoned block device mount */\n\t\t\tFDEV(0).bdev =\n\t\t\t\tblkdev_get_by_dev(sbi->sb->s_bdev->bd_dev,\n\t\t\t\t\tsbi->sb->s_mode, sbi->sb->s_type);\n\t\t} else {\n\t\t\t/* Multi-device mount */\n\t\t\tmemcpy(FDEV(i).path, RDEV(i).path, MAX_PATH_LEN);\n\t\t\tFDEV(i).total_segments =\n\t\t\t\tle32_to_cpu(RDEV(i).total_segments);\n\t\t\tif (i == 0) {\n\t\t\t\tFDEV(i).start_blk = 0;\n\t\t\t\tFDEV(i).end_blk = FDEV(i).start_blk +\n\t\t\t\t    (FDEV(i).total_segments <<\n\t\t\t\t    sbi->log_blocks_per_seg) - 1 +\n\t\t\t\t    le32_to_cpu(raw_super->segment0_blkaddr);\n\t\t\t} else {\n\t\t\t\tFDEV(i).start_blk = FDEV(i - 1).end_blk + 1;\n\t\t\t\tFDEV(i).end_blk = FDEV(i).start_blk +\n\t\t\t\t\t(FDEV(i).total_segments <<\n\t\t\t\t\tsbi->log_blocks_per_seg) - 1;\n\t\t\t}\n\t\t\tFDEV(i).bdev = blkdev_get_by_path(FDEV(i).path,\n\t\t\t\t\tsbi->sb->s_mode, sbi->sb->s_type);\n\t\t}\n\t\tif (IS_ERR(FDEV(i).bdev))\n\t\t\treturn PTR_ERR(FDEV(i).bdev);\n\n\t\t/* to release errored devices */\n\t\tsbi->s_ndevs = i + 1;\n\n#ifdef CONFIG_BLK_DEV_ZONED\n\t\tif (bdev_zoned_model(FDEV(i).bdev) == BLK_ZONED_HM &&\n\t\t\t\t!f2fs_sb_mounted_blkzoned(sbi->sb)) {\n\t\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\t"Zoned block device feature not enabled\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (bdev_zoned_model(FDEV(i).bdev) != BLK_ZONED_NONE) {\n\t\t\tif (init_blkz_info(sbi, i)) {\n	f
23282	2570	f2fs_fill_super	fs/f2fs/super.c	sb->s_root	1	13	\N	\N	\tstruct f2fs_sb_info *sbi;\n\tstruct f2fs_super_block *raw_super;\n\tstruct inode *root;\n\tint err;\n\tbool retry = true, need_fsck = false;\n\tchar *options = NULL;\n\tint recovery, i, valid_super_block;\n\tstruct curseg_info *seg_i;\n\ntry_onemore:\n\terr = -EINVAL;\n\traw_super = NULL;\n\tvalid_super_block = -1;\n\trecovery = 0;\n\n\t/* allocate memory for f2fs-specific super block info */\n\tsbi = kzalloc(sizeof(struct f2fs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->sb = sb;\n\n\t/* Load the checksum driver */\n\tsbi->s_chksum_driver = crypto_alloc_shash("crc32", 0, 0);\n\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\tf2fs_msg(sb, KERN_ERR, "Cannot load crc32 driver.");\n\t\terr = PTR_ERR(sbi->s_chksum_driver);\n\t\tsbi->s_chksum_driver = NULL;\n\t\tgoto free_sbi;\n\t}\n\n\t/* set a block size */\n\tif (unlikely(!sb_set_blocksize(sb, F2FS_BLKSIZE))) {\n\t\tf2fs_msg(sb, KERN_ERR, "unable to set blocksize");\n\t\tgoto free_sbi;\n\t}\n\n\terr = read_raw_super_block(sbi, &raw_super, &valid_super_block,\n\t\t\t\t\t\t\t\t&recovery);\n\tif (err)\n\t\tgoto free_sbi;\n\n\tsb->s_fs_info = sbi;\n\tsbi->raw_super = raw_super;\n\n\t/* precompute checksum seed for metadata */\n\tif (f2fs_sb_has_inode_chksum(sb))\n\t\tsbi->s_chksum_seed = f2fs_chksum(sbi, ~0, raw_super->uuid,\n\t\t\t\t\t\tsizeof(raw_super->uuid));\n\n\t/*\n\t * The BLKZONED feature indicates that the drive was formatted with\n\t * zone alignment optimization. This is optional for host-aware\n\t * devices, but mandatory for host-managed zoned block devices.\n\t */\n#ifndef CONFIG_BLK_DEV_ZONED\n\tif (f2fs_sb_mounted_blkzoned(sb)) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t "Zoned block device support is not enabled\\n");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto free_sb_buf;\n\t}\n#endif\n\tdefault_options(sbi);\n\t/* parse mount options */\n\toptions = kstrdup((const char *)data, GFP_KERNEL);\n\tif (data && !options) {\n\t\terr = -ENOMEM;\n\t\tgoto free_sb_buf;\n\t}\n\n\terr = parse_options(sb, options);\n\tif (err)\n\t\tgoto free_options;\n\n\tsbi->max_file_blocks = max_file_blocks();\n\tsb->s_maxbytes = sbi->max_file_blocks <<\n\t\t\t\tle32_to_cpu(raw_super->log_blocksize);\n\tsb->s_max_links = F2FS_LINK_MAX;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &f2fs_quota_operations;\n\tsb->s_qcop = &f2fs_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\n\tsb->s_op = &f2fs_sops;\n\tsb->s_cop = &f2fs_cryptops;\n\tsb->s_xattr = f2fs_xattr_handlers;\n\tsb->s_export_op = &f2fs_export_ops;\n\tsb->s_magic = F2FS_SUPER_MAGIC;\n\tsb->s_time_gran = 1;\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sbi, POSIX_ACL) ? MS_POSIXACL : 0);\n\tmemcpy(&sb->s_uuid, raw_super->uuid, sizeof(raw_super->uuid));\n\n\t/* init f2fs-specific super block info */\n\tsbi->valid_super_block = valid_super_block;\n\tmutex_init(&sbi->gc_mutex);\n\tmutex_init(&sbi->cp_mutex);\n\tinit_rwsem(&sbi->node_write);\n\tinit_rwsem(&sbi->node_change);\n\n\t/* disallow all the data/node/meta page writes */\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\tspin_lock_init(&sbi->stat_lock);\n\n\t/* init iostat info */\n\tspin_lock_init(&sbi->iostat_lock);\n\tsbi->iostat_enable = false;\n\n\tfor (i = 0; i < NR_PAGE_TYPE; i++) {\n\t\tint n = (i == META) ? 1: NR_TEMP_TYPE;\n\t\tint j;\n\n\t\tsbi->write_io[i] = kmalloc(n * sizeof(struct f2fs_bio_info),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!sbi->write_io[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_options;\n\t\t}\n\n\t\tfor (j = HOT; j < n; j++) {\n\t\t\tinit_rwsem(&sbi->write_io[i][j].io_rwsem);\n\t\t\tsbi->write_io[i][j].sbi = sbi;\n\t\t\tsbi->write_io[i][j].bio = NULL;\n\t\t\tspin_lock_init(&sbi->write_io[i][j].io_lock);\n\t\t\tINIT_LIST_HEAD(&sbi->write_io[i][j].io_list);\n\t\t}\n\t}\n\n\tinit_rwsem(&sbi->cp_rwsem);\n\tinit_waitqueue_head(&sbi->cp_wait);\n\tinit_sb_info(sbi);\n\n\terr = init_percpu_info(sbi);\n\tif (err)\n\t\tgoto free_options;\n\n\tif (F2FS_IO_SIZE(sbi) > 1) {\n\t\tsbi->write_io_dummy =\n\t\t\tmempool_create_page_pool(2 * (F2FS_IO_SIZE(sbi) - 1), 0);\n\t\tif (!sbi->write_io_dummy) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_options;\n\t\t}\n\t}\n\n\t/* get an inode for meta space */\n\tsbi->meta_inode = f2fs_iget(sb, F2FS_META_INO(sbi));\n\tif (IS_ERR(sbi->meta_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, "Failed to read F2FS meta data inode");\n\t\terr = PTR_ERR(sbi->meta_inode);\n\t\tgoto free_io_dummy;\n\t}\n\n\terr = get_valid_checkpoint(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR, "Failed to get valid F2FS checkpoint");\n\t\tgoto free_meta_inode;\n\t}\n\n\t/* Initialize device list */\n\terr = f2fs_scan_devices(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR, "Failed to find devices");\n\t\tgoto free_devices;\n\t}\n\n\tsbi->total_valid_node_count =\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_node_count);\n\tpercpu_counter_set(&sbi->total_valid_inode_count,\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_inode_count));\n\tsbi->user_block_count = le64_to_cpu(sbi->ckpt->user_block_count);\n\tsbi->total_valid_block_count =\n\t\t\t\tle64_to_cpu(sbi->ckpt->valid_block_count);\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->reserved_blocks = 0;\n\n\tfor (i = 0; i < NR_INODE_TYPE; i++) {\n\t\tINIT_LIST_HEAD(&sbi->inode_list[i]);\n\t\tspin_lock_init(&sbi->inode_lock[i]);\n\t}\n\n\tinit_extent_cache_info(sbi);\n\n\tinit_ino_entry_info(sbi);\n\n\t/* setup f2fs internal modules */\n\terr = build_segment_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t"Failed to initialize F2FS segment manager");\n\t\tgoto free_sm;\n\t}\n\terr = build_node_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t"Failed to initialize F2FS node manager");\n\t\tgoto free_nm;\n\t}\n\n\t/* For write statistics */\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->sectors_written_start =\n\t\t\t(u64)part_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Read accumulated write IO statistics if exists */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_NODE);\n\tif (__exist_node_summaries(sbi))\n\t\tsbi->kbytes_written =\n\t\t\tle64_to_cpu(seg_i->journal->info.kbytes_written);\n\n\tbuild_gc_manager(sbi);\n\n\t/* get an inode for node space */\n\tsbi->node_inode = f2fs_iget(sb, F2FS_NODE_INO(sbi));\n\tif (IS_ERR(sbi->node_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, "Failed to read node inode");\n\t\terr = PTR_ERR(sbi->node_inode);\n\t\tgoto free_nm;\n\t}\n\n\tf2fs_join_shrinker(sbi);\n\n\terr = f2fs_build_stats(sbi);\n\tif (err)\n\t\tgoto free_nm;\n\n\t/* read root inode and dentry */\n\troot = f2fs_iget(sb, F2FS_ROOT_INO(sbi));\n\tif (IS_ERR(root)) {\n\t\tf2fs_msg(sb, KERN_ERR, "Failed to read root inode");\n\t\terr = PTR_ERR(root);\n\t\tgoto free_node_inode;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\terr = -EINVAL;\n\t\tgoto free_node_inode;\n\t}\n\n\tsb->s_root = d_make_root(root); /* allocate root dentry */\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto free_root_inode;\n\t}\n\n\terr = f2fs_register_sysfs(sbi);\n\tif (err)\n\t\tgoto free_root_inode;\n\n\t/* if there are nt orphan nodes free them */\n\terr = recover_orphan_inodes(sbi);\n\tif (err)\n\t\tgoto free_sysfs;\n\n\t/* recover fsynced data */\n\tif (!test_opt(sbi, DISABLE_ROLL_FORWARD)) {\n\t\t/*\n\t\t * mount should be failed, when device has readonly mode, and\n\t\t * previous checkpoint was not done by clean system shutdown.\n\t\t */\n\t\tif (bdev_read_only(sb->s_bdev) &&\n\t\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto free_meta;\n\t\t}\n\n\t\tif (need_fsck)\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\t\tif (!retry)\n\t\t\tgoto skip_recovery;\n\n\t\terr = recover_fsync_data(sbi, false);\n\t\tif (err < 0) {\n\t\t\tneed_fsck = true;\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t"Cannot recover all fsync data errno=%d", err);\n\t\t\tgoto free_meta;\n\t\t}\n\t} else {\n\t\terr = recover_fsync_data(sbi, true);\n\n\t\tif (!f2fs_readonly(sb) && err > 0) {\n\t\t\terr = -EINVAL;\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t"Need to recover fsync data");\n\t\t\tgoto free_sysfs;\n\t\t}\n\t}\nskip_recovery:\n\t/* recover_fsync_data() cleared this already */\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\n\t/*\n\t * If filesystem is not mounted as read-only then\n\t * do start the gc_thread.\n\t */\n\tif (test_opt(sbi, BG_GC) && !f2fs_readonly(sb)) {\n\t\t/* After POR, we can run background GC thread.*/\n\t\terr = start_gc_thread(sbi);\n\t\tif (err)\n\t\t\tgoto free_meta;\n\t}\n\tkfree(options);\n\n\t/* recover broken superblock */\n\tif (recovery) {\n\t\terr = f2fs_commit_super(sbi, true);\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t"Try to recover %dth superblock, ret: %d",\n\t\t\tsbi->valid_super_block ? 1 : 2, err);\n\t}\n\n\tf2fs_msg(sbi->sb, KERN_NOTICE, "Mounted with checkpoint version = %llx",\n\t\t\t\tcur_cp_version(F2FS_CKPT(sbi)));\n\tf2fs_update_time(sbi, CP_TIME);\n\tf2fs_update_time(sbi, REQ_TIME);\n\treturn 0;\n\nfree_meta:\n\tf2fs_sync_inode_meta(sbi);\n\t/*\n\t * Some dirty meta pages can be produced by recover_orphan_inodes()\n\t * failed by EIO. Then, iput(node_inode) can trigger balance_fs_bg()\n\t * followed by write_checkpoint() through f2fs_write_node_pages(), which\n\t * falls into an infinite loop in sync_meta_pages().\n\t */\n\ttruncate_inode_pages_final(META_MAPPING(sbi));\nfree_sysfs:\n\tf2fs_unregister_sysfs(sbi);\nfree_root_inode:\n\tdput(sb->s_root);\n	f
23302	170	recover_dentry	fs/f2fs/recovery.c	page	1	13	\N	\N	\tstruct f2fs_inode *raw_inode = F2FS_INODE(ipage);\n\tnid_t pino = le32_to_cpu(raw_inode->i_pino);\n\tstruct f2fs_dir_entry *de;\n\tstruct fscrypt_name fname;\n\tstruct page *page;\n\tstruct inode *dir, *einode;\n\tstruct fsync_inode_entry *entry;\n\tint err = 0;\n\tchar *name;\n\n\tentry = get_fsync_inode(dir_list, pino);\n\tif (!entry) {\n\t\tentry = add_fsync_inode(F2FS_I_SB(inode), dir_list,\n\t\t\t\t\t\t\tpino, false);\n\t\tif (IS_ERR(entry)) {\n\t\t\tdir = ERR_CAST(entry);\n\t\t\terr = PTR_ERR(entry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdir = entry->inode;\n\n\tmemset(&fname, 0, sizeof(struct fscrypt_name));\n\tfname.disk_name.len = le32_to_cpu(raw_inode->i_namelen);\n\tfname.disk_name.name = raw_inode->i_name;\n\n\tif (unlikely(fname.disk_name.len > F2FS_NAME_LEN)) {\n\t\tWARN_ON(1);\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\nretry:\n\tde = __f2fs_find_entry(dir, &fname, &page);\n\tif (de && inode->i_ino == le32_to_cpu(de->ino))\n\t\tgoto out_unmap_put;\n\n\tif (de) {\n\t\teinode = f2fs_iget_retry(inode->i_sb, le32_to_cpu(de->ino));\n\t\tif (IS_ERR(einode)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = PTR_ERR(einode);\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EEXIST;\n\t\t\tgoto out_unmap_put;\n\t\t}\n\n\t\terr = dquot_initialize(einode);\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\n\t\terr = acquire_orphan_inode(F2FS_I_SB(inode));\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\tf2fs_delete_entry(de, page, dir, einode);\n	f
23335	1028	ocfs2_fill_super	fs/ocfs2/super.c	&stats	1	13	\N	\N	\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, "superblock probe failed!\\n");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n	f
23359	383	omfs_get_imap	fs/omfs/inode.c	sbi->s_imap	1	13	\N	\N	\tunsigned int bitmap_size, array_size;\n\tint count;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmalloc(sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tmemcpy(*ptr, bh->b_data, sb->s_blocksize);\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n	f
23848	564	ext4_xattr_ibody_get	fs/ext4/xattr.c	raw_inode	1	13	\N	\N	\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n	f
23886	3972	__ext4_block_zero_page_range	fs/ext4/inode.c	__ext4_block_zero_page_range_	1	13	\N	\N	\text4_fsblk_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_SHIFT,\n\t\t\t\t   mapping_gfp_constraint(mapping, ~__GFP_FS));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains "offset" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, "freed: skip");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, "unmapped");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, "still unmapped");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    ext4_encrypted_inode(inode)) {\n\t\t\t/* We expect the key to be set. */\n\t\t\tBUG_ON(!fscrypt_has_encryption_key(inode));\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tWARN_ON_ONCE(fscrypt_decrypt_page(page->mapping->host,\n\t\t\t\t\t\tpage, PAGE_SIZE, 0, page->index));\n\t\t}\n\t}\n\tif (ext4_should_journal_data(inode)) {\n	f
23903	1807	handle_mount_opt	fs/ext4/super.c	path.dentry	1	13	\N	\N	\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, "3.5");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, "Ignoring removed %s option", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= SB_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, "Unrecognized mount option \\"%s\\" "\n\t\t\t "or missing value", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Mount option \\"%s\\" incompatible with ext2", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Mount option \\"%s\\" incompatible with ext3", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT) {\n\t\tif (m->mount_opt & EXT4_MOUNT_DELALLOC) {\n\t\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\t\t} else if (m->mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) {\n\t\t\tset_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM);\n\t\t} else\n\t\t\treturn -1;\n\t}\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, "Cannot change quota "\n\t\t\t "options when quota turned on");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, "%s option not supported", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_debug_want_extra_isize) {\n\t\tsbi->s_want_extra_isize = arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "EXT4-fs: inode_readahead_blks must be "\n\t\t\t\t "0 or a power of 2 smaller than 2^31");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, "Invalid uid value %d", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, "Invalid gid value %d", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Cannot specify journal on remount");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Cannot specify journal on remount");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, "error: could not dup "\n\t\t\t\t"journal device string");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, "error: could not find "\n\t\t\t\t"journal device path: error %d", error);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tjournal_inode = d_inode(path.dentry);\n	f
23921	64	hpfs_read_inode	fs/hpfs/inode.c	ea_size	1	13	\N	\N	\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, "UID", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n	f
24403	258	__wmi_send	drivers/net/wireless/ath/wil6210/wmi.c	d_head.sync	1	13	\N	\N	\tstruct {\n\t\tstruct wil6210_mbox_hdr hdr;\n\t\tstruct wmi_cmd_hdr wmi;\n\t} __packed cmd = {\n\t\t.hdr = {\n\t\t\t.type = WIL_MBOX_HDR_TYPE_WMI,\n\t\t\t.flags = 0,\n\t\t\t.len = cpu_to_le16(sizeof(cmd.wmi) + len),\n\t\t},\n\t\t.wmi = {\n\t\t\t.mid = 0,\n\t\t\t.command_id = cpu_to_le16(cmdid),\n\t\t},\n\t};\n\tstruct wil6210_mbox_ring *r = &wil->mbox_ctl.tx;\n\tstruct wil6210_mbox_ring_desc d_head;\n\tu32 next_head;\n\tvoid __iomem *dst;\n\tvoid __iomem *head = wmi_addr(wil, r->head);\n\tuint retry;\n\tint rc = 0;\n\n\tif (sizeof(cmd) + len > r->entry_size) {\n\t\twil_err(wil, "WMI size too large: %d bytes, max is %d\\n",\n\t\t\t(int)(sizeof(cmd) + len), r->entry_size);\n\t\treturn -ERANGE;\n\t}\n\n\tmight_sleep();\n\n\tif (!test_bit(wil_status_fwready, wil->status)) {\n\t\twil_err(wil, "WMI: cannot send command while FW not ready\\n");\n\t\treturn -EAGAIN;\n\t}\n\n\t/* Allow sending only suspend / resume commands during susepnd flow */\n\tif ((test_bit(wil_status_suspending, wil->status) ||\n\t     test_bit(wil_status_suspended, wil->status) ||\n\t     test_bit(wil_status_resuming, wil->status)) &&\n\t     ((cmdid != WMI_TRAFFIC_SUSPEND_CMDID) &&\n\t      (cmdid != WMI_TRAFFIC_RESUME_CMDID))) {\n\t\twil_err(wil, "WMI: reject send_command during suspend\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!head) {\n\t\twil_err(wil, "WMI head is garbage: 0x%08x\\n", r->head);\n\t\treturn -EINVAL;\n\t}\n\n\twil_halp_vote(wil);\n\n\t/* read Tx head till it is not busy */\n\tfor (retry = 5; retry > 0; retry--) {\n\t\twil_memcpy_fromio_32(&d_head, head, sizeof(d_head));\n\t\tif (d_head.sync == 0)\n	f
24414	345	__swap_writepage	mm/page_io.c	bio	1	13	\N	\N	\tstruct bio *bio;\n\tint ret;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tif (sis->flags & SWP_FILE) {\n\t\tstruct kiocb kiocb;\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\t\tstruct bio_vec bv = {\n\t\t\t.bv_page = page,\n\t\t\t.bv_len  = PAGE_SIZE,\n\t\t\t.bv_offset = 0\n\t\t};\n\t\tstruct iov_iter from;\n\n\t\tiov_iter_bvec(&from, ITER_BVEC | WRITE, &bv, 1, PAGE_SIZE);\n\t\tinit_sync_kiocb(&kiocb, swap_file);\n\t\tkiocb.ki_pos = page_file_offset(page);\n\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tret = mapping->a_ops->direct_IO(&kiocb, &from);\n\t\tif (ret == PAGE_SIZE) {\n\t\t\tcount_vm_event(PSWPOUT);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * In the case of swap-over-nfs, this can be a\n\t\t\t * temporary failure if the system has limited\n\t\t\t * memory for allocating transmit buffers.\n\t\t\t * Mark the page dirty and avoid\n\t\t\t * rotate_reclaimable_page but rate-limit the\n\t\t\t * messages but do not flag PageError like\n\t\t\t * the normal direct-to-bio case as it could\n\t\t\t * be temporary.\n\t\t\t */\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t\tpr_err_ratelimited("Write error on dio swapfile (%llu)\\n",\n\t\t\t\t\t   page_file_offset(page));\n\t\t}\n\t\tend_page_writeback(page);\n\t\treturn ret;\n\t}\n\n\tret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\n\tif (!ret) {\n\t\tcount_swpout_vm_event(page);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_NOIO, page, end_write_func);\n\tif (bio == NULL) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio->bi_opf = REQ_OP_WRITE | wbc_to_write_flags(wbc);\n\tcount_swpout_vm_event(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tsubmit_bio(bio);\n	f
24436	2412	intel_haswell_enable_all_pins	sound/pci/hda/patch_hdmi.c	vendor_param	1	13	\N	\N	\tunsigned int vendor_param;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)\n	f
24649	3872	sh_css_param_update_isp_params	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css_params.c	err	1	13	\N	\N	\tenum ia_css_err err = IA_CSS_SUCCESS;\n\thrt_vaddress cpy;\n\tint i;\n\tunsigned int raw_bit_depth = 10;\n\tunsigned int isp_pipe_version = SH_CSS_ISP_PIPE_VERSION_1;\n\tbool acc_cluster_params_changed = false;\n\tunsigned int thread_id, pipe_num;\n\n\t(void)acc_cluster_params_changed;\n\n\tassert(curr_pipe != NULL);\n\n\tIA_CSS_ENTER_PRIVATE("pipe=%p, isp_parameters_id=%d", pipe_in, params->isp_parameters_id);\n\traw_bit_depth = ia_css_stream_input_format_bits_per_pixel(curr_pipe->stream);\n\n\t/* now make the map available to the sp */\n\tif (!commit) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\t/* enqueue a copies of the mem_map to\n\t   the designated pipelines */\n\tfor (i = 0; i < curr_pipe->stream->num_pipes; i++) {\n\t\tstruct ia_css_pipe *pipe;\n\t\tstruct sh_css_ddr_address_map *cur_map;\n\t\tstruct sh_css_ddr_address_map_size *cur_map_size;\n\t\tstruct ia_css_isp_parameter_set_info isp_params_info;\n\t\tstruct ia_css_pipeline *pipeline;\n\t\tstruct ia_css_pipeline_stage *stage;\n\n\t\tenum sh_css_queue_id queue_id;\n\n\t\t(void)stage;\n\t\tpipe = curr_pipe->stream->pipes[i];\n\t\tpipeline = ia_css_pipe_get_pipeline(pipe);\n\t\tpipe_num = ia_css_pipe_get_pipe_num(pipe);\n\t\tisp_pipe_version = ia_css_pipe_get_isp_pipe_version(pipe);\n\t\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\n#if defined(SH_CSS_ENABLE_PER_FRAME_PARAMS)\n\t\tia_css_query_internal_queue_id(params->output_frame\n\t\t\t\t\t\t? IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET\n\t\t\t\t\t\t: IA_CSS_BUFFER_TYPE_PARAMETER_SET,\n\t\t\t\t\t\tthread_id, &queue_id);\n#else\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_PARAMETER_SET, thread_id, &queue_id);\n#endif\n\t\tif (!sh_css_sp_is_running()) {\n\t\t\t/* SP is not running. The queues are not valid */\n\t\t\terr = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;\n\t\t\tbreak;\n\t\t}\n\t\tcur_map = &params->pipe_ddr_ptrs[pipeline->pipe_id];\n\t\tcur_map_size = &params->pipe_ddr_ptrs_size[pipeline->pipe_id];\n\n\t\t/* TODO: Normally, zoom and motion parameters shouldn't\n\t\t * be part of "isp_params" as it is resolution/pipe dependant\n\t\t * Therefore, move the zoom config elsewhere (e.g. shading\n\t\t * table can be taken as an example! @GC\n\t\t * */\n\t\t{\n\t\t\t/* we have to do this per pipeline because */\n\t\t\t/* the processing is a.o. resolution dependent */\n\t\t\terr = ia_css_process_zoom_and_motion(params,\n\t\t\t\t\tpipeline->stages);\n\t\t\tif (err != IA_CSS_SUCCESS)\n\t\t\t    return err;\n\t\t}\n\t\t/* check if to actually update the parameters for this pipe */\n\t\t/* When API change is implemented making good distinction between\n\t\t* stream config and pipe config this skipping code can be moved out of the #ifdef */\n\t\tif (pipe_in && (pipe != pipe_in)) {\n\t\t\tIA_CSS_LOG("skipping pipe %p", pipe);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BZ 125915, should be moved till after "update other buff" */\n\t\t/* update the other buffers to the pipe specific copies */\n\t\tfor (stage = pipeline->stages; stage; stage = stage->next) {\n\t\t\tunsigned mem;\n\n\t\t\tif (!stage || !stage->binary)\n\t\t\t\tcontinue;\n\n\t\t\tprocess_kernel_parameters(pipeline->pipe_id,\n\t\t\t\t\tstage, params,\n\t\t\t\t\tisp_pipe_version, raw_bit_depth);\n\n\t\t\terr = sh_css_params_write_to_ddr_internal(\n\t\t\t\t\tpipe,\n\t\t\t\t\tpipeline->pipe_id,\n\t\t\t\t\tparams,\n\t\t\t\t\tstage,\n\t\t\t\t\tcur_map,\n\t\t\t\t\tcur_map_size);\n\n\t\t\tif (err != IA_CSS_SUCCESS)\n	f
24665	8309	capture_start	drivers/staging/media/atomisp/pci/atomisp2/css2400/sh_css.c	copy_ovrd	1	13	\N	\N	\tstruct ia_css_pipeline *me;\n\n\tenum ia_css_err err = IA_CSS_SUCCESS;\n\tenum sh_css_pipe_config_override copy_ovrd;\n\n\tIA_CSS_ENTER_PRIVATE("pipe = %p", pipe);\n\tif (pipe == NULL) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);\n\t\treturn IA_CSS_ERR_INVALID_ARGUMENTS;\n\t}\n\n\tme = &pipe->pipeline;\n\n\tif ((pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW   ||\n\t     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER   ) &&\n\t\t(pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {\n\t\tif (copy_on_sp(pipe)) {\n\t\t\terr = start_copy_on_sp(pipe, &me->out_frame[0]);\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n#if defined(USE_INPUT_SYSTEM_VERSION_2)\n\t/* old isys: need to send_mipi_frames() in all pipe modes */\n\terr = send_mipi_frames(pipe);\n\tif (err != IA_CSS_SUCCESS) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n#elif defined(USE_INPUT_SYSTEM_VERSION_2401)\n\tif (pipe->config.mode != IA_CSS_PIPE_MODE_COPY) {\n\t\terr = send_mipi_frames(pipe);\n\t\tif (err != IA_CSS_SUCCESS) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n#endif\n\n\t{\n\t\tunsigned int thread_id;\n\n\t\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\t\tcopy_ovrd = 1 << thread_id;\n\n\t}\n\tstart_pipe(pipe, copy_ovrd, pipe->stream->config.mode);\n	f
24789	52	print_pin_widget	sound/pci/lola/lola_proc.c	val	1	13	\N	\N	\tunsigned int val;\n\n\tlola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tsnd_iprintf(buffer, "Node 0x%02x %s wcaps 0x%x\\n", nid, name, val);\n\tif (val == 0x00400200)\n\t\treturn;\n\tlola_read_param(chip, nid, ampcap, &val);\n\tsnd_iprintf(buffer, "  Amp-Caps: 0x%x\\n", val);\n\tsnd_iprintf(buffer, "    mute=%d, step-size=%d, steps=%d, ofs=%d\\n",\n	f
24810	582	atomisp_isr	drivers/staging/media/atomisp/pci/atomisp2/atomisp_cmd.c	rx_infos	1	13	\N	\N	\tstruct atomisp_device *isp = (struct atomisp_device *)dev;\n\tstruct atomisp_sub_device *asd;\n\tstruct atomisp_css_event eof_event;\n\tunsigned int irq_infos = 0;\n\tunsigned long flags;\n\tunsigned int i;\n\tint err;\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\tif (isp->sw_contex.power_state != ATOM_ISP_POWER_UP ||\n\t    isp->css_initialized == false) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\terr = atomisp_css_irq_translate(isp, &irq_infos);\n\tif (err) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_dbg(isp->dev, "irq:0x%x\\n", irq_infos);\n\n\tclear_irq_reg(isp);\n\n\tif (!atomisp_streaming_count(isp) && !atomisp_is_acc_enabled(isp))\n\t\tgoto out_nowake;\n\n\tfor (i = 0; i < isp->num_of_streams; i++) {\n\t\tasd = &isp->asd[i];\n\n\t\tif (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Current SOF only support one stream, so the SOF only valid\n\t\t * either solely one stream is running\n\t\t */\n\t\tif (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_SOF) {\n\t\t\tatomic_inc(&asd->sof_count);\n\t\t\tatomisp_sof_event(asd);\n\n\t\t\t/* If sequence_temp and sequence are the same\n\t\t\t * there where no frames lost so we can increase\n\t\t\t * sequence_temp.\n\t\t\t * If not then processing of frame is still in progress\n\t\t\t * and driver needs to keep old sequence_temp value.\n\t\t\t * NOTE: There is assumption here that ISP will not\n\t\t\t * start processing next frame from sensor before old\n\t\t\t * one is completely done. */\n\t\t\tif (atomic_read(&asd->sequence) == atomic_read(\n\t\t\t\t\t\t&asd->sequence_temp))\n\t\t\t\tatomic_set(&asd->sequence_temp,\n\t\t\t\t\t\tatomic_read(&asd->sof_count));\n\t\t}\n\t\tif (irq_infos & CSS_IRQ_INFO_EVENTS_READY)\n\t\t\tatomic_set(&asd->sequence,\n\t\t\t\t   atomic_read(&asd->sequence_temp));\n\t}\n\n\tif (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_SOF)\n\t\tirq_infos &= ~CSS_IRQ_INFO_CSS_RECEIVER_SOF;\n\n\tif ((irq_infos & CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||\n\t    (irq_infos & CSS_IRQ_INFO_IF_ERROR)) {\n\t\t/* handle mipi receiver error */\n\t\tu32 rx_infos;\n\t\tenum ia_css_csi2_port port;\n\n\t\tfor (port = IA_CSS_CSI2_PORT0; port <= IA_CSS_CSI2_PORT2;\n\t\t     port++) {\n\t\t\tprint_csi_rx_errors(port, isp);\n\t\t\tatomisp_css_rx_get_irq_info(port, &rx_infos);\n\t\t\tatomisp_css_rx_clear_irq_info(port, rx_infos);\n	f
24823	1068	recvbuf2recvframe	drivers/staging/rtl8712/rtl8712_recv.c	&precvframe->u.hdr.list	1	13	\N	\N	\tu8 *pbuf, shift_sz = 0;\n\tu8\tfrag, mf;\n\tuint\tpkt_len;\n\tu32 transfer_len;\n\tstruct recv_stat *prxstat;\n\tu16\tpkt_cnt, drvinfo_sz, pkt_offset, tmp_len, alloc_sz;\n\tstruct  __queue *pfree_recv_queue;\n\t_pkt  *pkt_copy = NULL;\n\tunion recv_frame *precvframe = NULL;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\tpfree_recv_queue = &(precvpriv->free_recv_queue);\n\tpbuf = pskb->data;\n\tprxstat = (struct recv_stat *)pbuf;\n\tpkt_cnt = (le32_to_cpu(prxstat->rxdw2) >> 16) & 0xff;\n\tpkt_len =  le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\n\ttransfer_len = pskb->len;\n\t/* Test throughput with Netgear 3700 (No security) with Chariot 3T3R\n\t * pairs. The packet count will be a big number so that the containing\n\t * packet will effect the Rx reordering.\n\t */\n\tif (transfer_len < pkt_len) {\n\t\t/* In this case, it means the MAX_RECVBUF_SZ is too small to\n\t\t * get the data from 8712u.\n\t\t */\n\t\treturn _FAIL;\n\t}\n\tdo {\n\t\tprxstat = (struct recv_stat *)pbuf;\n\t\tpkt_len =  le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\n\t\t/* more fragment bit */\n\t\tmf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;\n\t\t/* ragmentation number */\n\t\tfrag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;\n\t\t/* uint 2^3 = 8 bytes */\n\t\tdrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\n\t\tdrvinfo_sz <<= 3;\n\t\tif (pkt_len <= 0)\n\t\t\tgoto  _exit_recvbuf2recvframe;\n\t\t/* Qos data, wireless lan header length is 26 */\n\t\tif ((le32_to_cpu(prxstat->rxdw0) >> 23) & 0x01)\n\t\t\tshift_sz = 2;\n\t\tprecvframe = r8712_alloc_recvframe(pfree_recv_queue);\n\t\tif (!precvframe)\n\t\t\tgoto  _exit_recvbuf2recvframe;\n\t\tINIT_LIST_HEAD(&precvframe->u.hdr.list);\n	f
26149	484	soc_init_card_debugfs	sound/soc/soc-core.c	card->debugfs_pop_time	1	13	\N	\N	\tif (!snd_soc_debugfs_root)\n\t\treturn;\n\n\tcard->debugfs_card_root = debugfs_create_dir(card->name,\n\t\t\t\t\t\t     snd_soc_debugfs_root);\n\tif (!card->debugfs_card_root) {\n\t\tdev_warn(card->dev,\n\t\t\t "ASoC: Failed to create card debugfs directory\\n");\n\t\treturn;\n\t}\n\n\tcard->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,\n\t\t\t\t\t\t    card->debugfs_card_root,\n\t\t\t\t\t\t    &card->pop_time);\n\tif (!card->debugfs_pop_time)\n	f
24917	286	lnet_parse_networks	drivers/staging/lustre/lnet/lnet/config.c	lnet_parse_networks_	1	13	\N	\N	\tstruct cfs_expr_list *el = NULL;\n\tint tokensize;\n\tchar *tokens;\n\tchar *str;\n\tchar *tmp;\n\tstruct lnet_ni *ni;\n\t__u32 net;\n\tint nnets = 0;\n\tstruct list_head *temp_node;\n\n\tif (!networks) {\n\t\tCERROR("networks string is undefined\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (strlen(networks) > LNET_SINGLE_TEXTBUF_NOB) {\n\t\t/* _WAY_ conservative */\n\t\tLCONSOLE_ERROR_MSG(0x112,\n\t\t\t\t   "Can't parse networks: string too long\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ttokensize = strlen(networks) + 1;\n\n\tLIBCFS_ALLOC(tokens, tokensize);\n\tif (!tokens) {\n\t\tCERROR("Can't allocate net tokens\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(tokens, networks, tokensize);\n\ttmp = tokens;\n\tstr = tokens;\n\n\twhile (str && *str) {\n\t\tchar *comma = strchr(str, ',');\n\t\tchar *bracket = strchr(str, '(');\n\t\tchar *square = strchr(str, '[');\n\t\tchar *iface;\n\t\tint niface;\n\t\tint rc;\n\n\t\t/*\n\t\t * NB we don't check interface conflicts here; it's the LNDs\n\t\t * responsibility (if it cares at all)\n\t\t */\n\t\tif (square && (!comma || square < comma)) {\n\t\t\t/*\n\t\t\t * i.e: o2ib0(ib0)[1,2], number between square\n\t\t\t * brackets are CPTs this NI needs to be bond\n\t\t\t */\n\t\t\tif (bracket && bracket > square) {\n\t\t\t\ttmp = square;\n\t\t\t\tgoto failed_syntax;\n\t\t\t}\n\n\t\t\ttmp = strchr(square, ']');\n\t\t\tif (!tmp) {\n\t\t\t\ttmp = square;\n\t\t\t\tgoto failed_syntax;\n\t\t\t}\n\n\t\t\trc = cfs_expr_list_parse(square, tmp - square + 1,\n\t\t\t\t\t\t 0, LNET_CPT_NUMBER - 1, &el);\n\t\t\tif (rc) {\n\t\t\t\ttmp = square;\n\t\t\t\tgoto failed_syntax;\n\t\t\t}\n\n\t\t\twhile (square <= tmp)\n\t\t\t\t*square++ = ' ';\n\t\t}\n\n\t\tif (!bracket || (comma && comma < bracket)) {\n\t\t\t/* no interface list specified */\n\n\t\t\tif (comma)\n\t\t\t\t*comma++ = 0;\n\t\t\tnet = libcfs_str2net(cfs_trimwhite(str));\n\n\t\t\tif (net == LNET_NIDNET(LNET_NID_ANY)) {\n\t\t\t\tLCONSOLE_ERROR_MSG(0x113,\n\t\t\t\t\t\t   "Unrecognised network type\\n");\n\t\t\t\ttmp = str;\n\t\t\t\tgoto failed_syntax;\n\t\t\t}\n\n\t\t\tif (LNET_NETTYP(net) != LOLND && /* LO is implicit */\n	f
25508	253	manage_bandwidth	drivers/firewire/core-iso.c	manage_bandwidth_	1	13	\N	\N	\tint try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;\n\t__be32 data[2];\n\n\t/*\n\t * On a 1394a IRM with low contention, try < 1 is enough.\n\t * On a 1394-1995 IRM, we need at least try < 2.\n\t * Let's just do try < 5.\n\t */\n\tfor (try = 0; try < 5; try++) {\n\t\tnew = allocate ? old - bandwidth : old + bandwidth;\n\t\tif (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)\n\t\t\treturn -EBUSY;\n\n\t\tdata[0] = cpu_to_be32(old);\n\t\tdata[1] = cpu_to_be32(new);\n\t\tswitch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\n	f
25558	109	mdio_mux_init	drivers/net/phy/mdio-mux.c	parent_bus_node	1	13	\N	\N	\tstruct device_node *parent_bus_node;\n\tstruct device_node *child_bus_node;\n\tint r, ret_val;\n\tstruct mii_bus *parent_bus;\n\tstruct mdio_mux_parent_bus *pb;\n\tstruct mdio_mux_child_bus *cb;\n\n\tif (!mux_node)\n\t\treturn -ENODEV;\n\n\tif (!mux_bus) {\n\t\tparent_bus_node = of_parse_phandle(mux_node,\n\t\t\t\t\t\t   "mdio-parent-bus", 0);\n\n\t\tif (!parent_bus_node)\n	f
25578	888	rtllib_probe_resp	drivers/staging/rtl8192e/rtllib_softmac.c	skb	1	13	\N	\N	\tu8 *tag;\n\tint beacon_size;\n\tstruct rtllib_probe_response *beacon_buf;\n\tstruct sk_buff *skb = NULL;\n\tint encrypt;\n\tint atim_len, erp_len;\n\tstruct lib80211_crypt_data *crypt;\n\n\tchar *ssid = ieee->current_network.ssid;\n\tint ssid_len = ieee->current_network.ssid_len;\n\tint rate_len = ieee->current_network.rates_len+2;\n\tint rate_ex_len = ieee->current_network.rates_ex_len;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tu8 erpinfo_content = 0;\n\n\tu8 *tmp_ht_cap_buf = NULL;\n\tu8 tmp_ht_cap_len = 0;\n\tu8 *tmp_ht_info_buf = NULL;\n\tu8 tmp_ht_info_len = 0;\n\tstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\n\tu8 *tmp_generic_ie_buf = NULL;\n\tu8 tmp_generic_ie_len = 0;\n\n\tif (rate_ex_len > 0)\n\t\trate_ex_len += 2;\n\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\n\t\tatim_len = 4;\n\telse\n\t\tatim_len = 0;\n\n\tif ((ieee->current_network.mode == IEEE_G) ||\n\t   (ieee->current_network.mode == IEEE_N_24G &&\n\t   ieee->pHTInfo->bCurSuppCCK)) {\n\t\terp_len = 3;\n\t\terpinfo_content = 0;\n\t\tif (ieee->current_network.buseprotection)\n\t\t\terpinfo_content |= ERP_UseProtection;\n\t} else\n\t\terp_len = 0;\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\tencrypt = ieee->host_encrypt && crypt && crypt->ops &&\n\t\t((strcmp(crypt->ops->name, "R-WEP") == 0 || wpa_ie_len));\n\tif (ieee->pHTInfo->bCurrentHTSupport) {\n\t\ttmp_ht_cap_buf = (u8 *) &(ieee->pHTInfo->SelfHTCap);\n\t\ttmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\n\t\ttmp_ht_info_buf = (u8 *) &(ieee->pHTInfo->SelfHTInfo);\n\t\ttmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);\n\t\tHTConstructCapabilityElement(ieee, tmp_ht_cap_buf,\n\t\t\t\t\t     &tmp_ht_cap_len, encrypt, false);\n\t\tHTConstructInfoElement(ieee, tmp_ht_info_buf, &tmp_ht_info_len,\n\t\t\t\t       encrypt);\n\n\t\tif (pHTInfo->bRegRT2RTAggregation) {\n\t\t\ttmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\n\t\t\ttmp_generic_ie_len =\n\t\t\t\t sizeof(ieee->pHTInfo->szRT2RTAggBuffer);\n\t\t\tHTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf,\n\t\t\t\t\t\t   &tmp_generic_ie_len);\n\t\t}\n\t}\n\n\tbeacon_size = sizeof(struct rtllib_probe_response)+2+\n\t\tssid_len + 3 + rate_len + rate_ex_len + atim_len + erp_len\n\t\t+ wpa_ie_len + ieee->tx_headroom;\n\tskb = dev_alloc_skb(beacon_size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n	f
25587	2693	rtllib_process_probe_response	drivers/staging/rtl8192e/rtllib_rx.c	network	1	13	\N	\N	\tstruct rtllib_network *target;\n\tstruct rtllib_network *oldest = NULL;\n\tstruct rtllib_info_element *info_element = &beacon->info_element[0];\n\tunsigned long flags;\n\tshort renew;\n\tstruct rtllib_network *network = kzalloc(sizeof(struct rtllib_network),\n\t\t\t\t\t\t GFP_ATOMIC);\n\tu16 frame_ctl = le16_to_cpu(beacon->header.frame_ctl);\n\n\tif (!network)\n\t\treturn;\n\n\tnetdev_dbg(ieee->dev,\n\t\t   "'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\\n",\n\t\t   escape_essid(info_element->data, info_element->len),\n\t\t   beacon->header.addr3,\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xf)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xe)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xd)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xc)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xb)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0xa)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x9)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x8)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x7)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x6)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x5)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x4)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x3)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x2)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x1)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1<<0x0)) ? '1' : '0');\n\n\tif (rtllib_network_init(ieee, beacon, network, stats)) {\n\t\tnetdev_dbg(ieee->dev, "Dropped '%s' ( %pM) via %s.\\n",\n\t\t\t   escape_essid(info_element->data, info_element->len),\n\t\t\t   beacon->header.addr3,\n\t\t\t   is_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");\n\t\tgoto free_network;\n\t}\n\n\n\tif (!rtllib_legal_channel(ieee, network->channel))\n\t\tgoto free_network;\n\n\tif (WLAN_FC_GET_STYPE(frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {\n\t\tif (IsPassiveChannel(ieee, network->channel)) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    "GetScanInfo(): For Global Domain, filter probe response at channel(%d).\\n",\n\t\t\t\t    network->channel);\n\t\t\tgoto free_network;\n\t\t}\n\t}\n\n\t/* The network parsed correctly -- so now we scan our known networks\n\t * to see if we can find it in our list.\n\t *\n\t * NOTE:  This search is definitely not optimized.  Once its doing\n\t *\tthe "right thing" we'll optimize it for efficiency if\n\t *\tnecessary\n\t */\n\n\t/* Search for this entry in the list and update it if it is\n\t * already there.\n\t */\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tif (is_same_network(&ieee->current_network, network,\n\t   (network->ssid_len ? 1 : 0))) {\n\t\tupdate_network(ieee, &ieee->current_network, network);\n\t\tif ((ieee->current_network.mode == IEEE_N_24G ||\n\t\t     ieee->current_network.mode == IEEE_G)\n\t\t     && ieee->current_network.berp_info_valid) {\n\t\t\tif (ieee->current_network.erp_value & ERP_UseProtection)\n\t\t\t\tieee->current_network.buseprotection = true;\n\t\t\telse\n\t\t\t\tieee->current_network.buseprotection = false;\n\t\t}\n\t\tif (is_beacon(frame_ctl)) {\n\t\t\tif (ieee->state >= RTLLIB_LINKED)\n\t\t\t\tieee->LinkDetectInfo.NumRecvBcnInPeriod++;\n\t\t}\n\t}\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\tif (is_same_network(target, network,\n\t\t   (target->ssid_len ? 1 : 0)))\n\t\t\tbreak;\n\t\tif ((oldest == NULL) ||\n\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\toldest = target;\n\t}\n\n\t/* If we didn't find a match, then get a new network slot to initialize\n\t * with this beacon's information\n\t */\n\tif (&target->list == &ieee->network_list) {\n\t\tif (list_empty(&ieee->network_free_list)) {\n\t\t\t/* If there are no more slots, expire the oldest */\n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   "Expired '%s' ( %pM) from network list.\\n",\n\t\t\t\t   escape_essid(target->ssid, target->ssid_len),\n\t\t\t\t   target->bssid);\n\t\t} else {\n\t\t\t/* Otherwise just pull from the free list */\n\t\t\ttarget = list_entry(ieee->network_free_list.next,\n\t\t\t\t\t    struct rtllib_network, list);\n\t\t\tlist_del(ieee->network_free_list.next);\n\t\t}\n\n\t\tnetdev_dbg(ieee->dev, "Adding '%s' ( %pM) via %s.\\n",\n\t\t\t   escape_essid(network->ssid, network->ssid_len),\n\t\t\t   network->bssid,\n\t\t\t   is_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");\n\n\t\tmemcpy(target, network, sizeof(*target));\n	f
25626	2775	ath10k_wmi_tlv_op_gen_update_fw_tdls_state	drivers/net/wireless/ath/ath10k/wmi-tlv.c	ptr	1	13	\N	\N	\tstruct wmi_tdls_set_state_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\t/* Set to options from wmi_tlv_tdls_options,\n\t * for now none of them are enabled.\n\t */\n\tu32 options = 0;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_SET_STATE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->state = __cpu_to_le32(state);\n\tcmd->notification_interval_ms = __cpu_to_le32(5000);\n\tcmd->tx_discovery_threshold = __cpu_to_le32(100);\n\tcmd->tx_teardown_threshold = __cpu_to_le32(5);\n\tcmd->rssi_teardown_threshold = __cpu_to_le32(-75);\n\tcmd->rssi_delta = __cpu_to_le32(-20);\n\tcmd->tdls_options = __cpu_to_le32(options);\n\tcmd->tdls_peer_traffic_ind_window = __cpu_to_le32(2);\n\tcmd->tdls_peer_traffic_response_timeout_ms = __cpu_to_le32(5000);\n\tcmd->tdls_puapsd_mask = __cpu_to_le32(0xf);\n\tcmd->tdls_puapsd_inactivity_time_ms = __cpu_to_le32(0);\n\tcmd->tdls_puapsd_rx_frame_threshold = __cpu_to_le32(10);\n\n\tptr += sizeof(*tlv);\n	f
25782	661	ds_write_block	drivers/w1/masters/ds2490.c	err	1	13	\N	\N	\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_data(dev, buf, len);\n\tif (err < 0)\n	f
25789	617	ssi_aead_setkey	drivers/staging/ccree/ssi_aead.c	desc	1	13	\N	\N	\tstruct ssi_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct ssi_crypto_req ssi_req = {};\n\tstruct crypto_authenc_key_param *param;\n\tstruct cc_hw_desc desc[MAX_AEAD_SETKEY_SEQ];\n\tint seq_len = 0, rc = -EINVAL;\n\n\tSSI_LOG_DEBUG("Setting key in context @%p for %s. key=%p keylen=%u\\n",\n\t\t      ctx, crypto_tfm_alg_name(crypto_aead_tfm(tfm)),\n\t\t      key, keylen);\n\n\t/* STAT_PHASE_0: Init and sanity checks */\n\n\tif (ctx->auth_mode != DRV_HASH_NULL) { /* authenc() alg. */\n\t\tif (!RTA_OK(rta, keylen))\n\t\t\tgoto badkey;\n\t\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\t\tgoto badkey;\n\t\tif (RTA_PAYLOAD(rta) < sizeof(*param))\n\t\t\tgoto badkey;\n\t\tparam = RTA_DATA(rta);\n\t\tctx->enc_keylen = be32_to_cpu(param->enckeylen);\n\t\tkey += RTA_ALIGN(rta->rta_len);\n\t\tkeylen -= RTA_ALIGN(rta->rta_len);\n\t\tif (keylen < ctx->enc_keylen)\n\t\t\tgoto badkey;\n\t\tctx->auth_keylen = keylen - ctx->enc_keylen;\n\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CTR) {\n\t\t\t/* the nonce is stored in bytes at end of key */\n\t\t\tif (ctx->enc_keylen <\n\t\t\t    (AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE))\n\t\t\t\tgoto badkey;\n\t\t\t/* Copy nonce from last 4 bytes in CTR key to\n\t\t\t *  first 4 bytes in CTR IV\n\t\t\t */\n\t\t\tmemcpy(ctx->ctr_nonce, key + ctx->auth_keylen + ctx->enc_keylen -\n\t\t\t\tCTR_RFC3686_NONCE_SIZE, CTR_RFC3686_NONCE_SIZE);\n\t\t\t/* Set CTR key size */\n\t\t\tctx->enc_keylen -= CTR_RFC3686_NONCE_SIZE;\n\t\t}\n\t} else { /* non-authenc - has just one key */\n\t\tctx->enc_keylen = keylen;\n\t\tctx->auth_keylen = 0;\n\t}\n\n\trc = validate_keys_sizes(ctx);\n\tif (unlikely(rc != 0))\n\t\tgoto badkey;\n\n\t/* STAT_PHASE_1: Copy key to ctx */\n\n\t/* Get key material */\n\tmemcpy(ctx->enckey, key + ctx->auth_keylen, ctx->enc_keylen);\n\tif (ctx->enc_keylen == 24)\n\t\tmemset(ctx->enckey + 24, 0, CC_AES_KEY_SIZE_MAX - 24);\n\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {\n\t\tmemcpy(ctx->auth_state.xcbc.xcbc_keys, key, ctx->auth_keylen);\n\t} else if (ctx->auth_mode != DRV_HASH_NULL) { /* HMAC */\n\t\trc = ssi_get_plain_hmac_key(tfm, key, ctx->auth_keylen);\n\t\tif (rc != 0)\n\t\t\tgoto badkey;\n\t}\n\n\t/* STAT_PHASE_2: Create sequence */\n\n\tswitch (ctx->auth_mode) {\n\tcase DRV_HASH_SHA1:\n\tcase DRV_HASH_SHA256:\n\t\tseq_len = hmac_setkey(desc, ctx);\n	f
25862	264	tps65218_probe	drivers/mfd/tps65218.c	ret	1	13	\N	\N	\tstruct tps65218 *tps;\n\tconst struct of_device_id *match;\n\tint ret;\n\tunsigned int chipid;\n\n\tmatch = of_match_device(of_tps65218_match_table, &client->dev);\n\tif (!match) {\n\t\tdev_err(&client->dev,\n\t\t\t"Failed to find matching dt id\\n");\n\t\treturn -EINVAL;\n\t}\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = &client->dev;\n\ttps->irq = client->irq;\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65218_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(tps->dev, "Failed to allocate register map: %d\\n",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&tps->tps_lock);\n\n\tret = regmap_add_irq_chip(tps->regmap, tps->irq,\n\t\t\tIRQF_ONESHOT, 0, &tps65218_irq_chip,\n\t\t\t&tps->irq_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(tps->regmap, TPS65218_REG_CHIPID, &chipid);\n\tif (ret) {\n\t\tdev_err(tps->dev, "Failed to read chipid: %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\ttps->rev = chipid & TPS65218_CHIPID_REV_MASK;\n\n\tret = mfd_add_devices(tps->dev, PLATFORM_DEVID_AUTO, tps65218_cells,\n\t\t\t      ARRAY_SIZE(tps65218_cells), NULL, 0,\n\t\t\t      regmap_irq_get_domain(tps->irq_data));\n\n\tif (ret < 0)\n	f
25876	415	pxa2xx_pinctrl_init	drivers/pinctrl/pxa/pinctrl-pxa2xx.c	pctl	1	13	\N	\N	\tstruct pxa_pinctrl *pctl;\n\tint ret, i, maxpin = 0;\n\n\tfor (i = 0; i < npins; i++)\n\t\tmaxpin = max_t(int, ppins[i].pin.number, maxpin);\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\tpctl->base_gafr = devm_kcalloc(&pdev->dev, roundup(maxpin, 16),\n\t\t\t\t       sizeof(*pctl->base_gafr), GFP_KERNEL);\n\tpctl->base_gpdr = devm_kcalloc(&pdev->dev, roundup(maxpin, 32),\n\t\t\t\t       sizeof(*pctl->base_gpdr), GFP_KERNEL);\n\tpctl->base_pgsr = devm_kcalloc(&pdev->dev, roundup(maxpin, 32),\n\t\t\t\t       sizeof(*pctl->base_pgsr), GFP_KERNEL);\n\tif (!pctl->base_gafr || !pctl->base_gpdr || !pctl->base_pgsr)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\tspin_lock_init(&pctl->lock);\n\n\tpctl->dev = &pdev->dev;\n\tpctl->desc = pxa2xx_pinctrl_desc;\n\tpctl->desc.name = dev_name(&pdev->dev);\n\tpctl->desc.owner = THIS_MODULE;\n\n\tfor (i = 0; i < roundup(maxpin, 16); i += 16)\n\t\tpctl->base_gafr[i / 16] = base_gafr[i / 16];\n\tfor (i = 0; i < roundup(maxpin, 32); i += 32) {\n\t\tpctl->base_gpdr[i / 32] = base_gpdr[i / 32];\n\t\tpctl->base_pgsr[i / 32] = base_pgsr[i / 32];\n\t}\n\n\tret = pxa2xx_build_state(pctl, ppins, npins);\n	f
25950	689	max77693_muic_adc_handler	drivers/extcon/extcon-max77693.c	attached	1	13	\N	\N	\tint cable_type;\n\tint button_type;\n\tbool attached;\n\tint ret = 0;\n\n\t/* Check accessory state which is either detached or attached */\n\tcable_type = max77693_muic_get_cable_type(info,\n\t\t\t\tMAX77693_CABLE_GROUP_ADC, &attached);\n\n\tdev_info(info->dev,\n\t\t"external connector is %s (adc:0x%02x, prev_adc:0x%x)\\n",\n\t\tattached ? "attached" : "detached", cable_type,\n\t\tinfo->prev_cable_type);\n\n\tswitch (cable_type) {\n\tcase MAX77693_MUIC_ADC_GROUND:\n\t\t/* USB_HOST/MHL/Audio */\n\t\tmax77693_muic_adc_ground_handler(info);\n\t\tbreak;\n\tcase MAX77693_MUIC_ADC_FACTORY_MODE_USB_OFF:\n\tcase MAX77693_MUIC_ADC_FACTORY_MODE_USB_ON:\n\tcase MAX77693_MUIC_ADC_FACTORY_MODE_UART_OFF:\n\tcase MAX77693_MUIC_ADC_FACTORY_MODE_UART_ON:\n\t\t/* JIG */\n\t\tret = max77693_muic_jig_handler(info, cable_type, attached);\n	f
26062	126	ahci_qoriq_hardreset	drivers/ata/ahci_qoriq.c	px_cmd	1	13	\N	\N	\tconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tu32 px_cmd, px_is, px_val;\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_qoriq_priv *qoriq_priv = hpriv->plat_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc;\n\tbool ls1021a_workaround = (qoriq_priv->type == AHCI_LS1021A);\n\n\tDPRINTK("ENTER\\n");\n\n\tahci_stop_engine(ap);\n\n\t/*\n\t * There is a errata on ls1021a Rev1.0 and Rev2.0 which is:\n\t * A-009042: The device detection initialization sequence\n\t * mistakenly resets some registers.\n\t *\n\t * Workaround for this is:\n\t * The software should read and store PxCMD and PxIS values\n\t * before issuing the device detection initialization sequence.\n\t * After the sequence is complete, software should restore the\n\t * PxCMD and PxIS with the stored values.\n\t */\n\tif (ls1021a_workaround) {\n\t\tpx_cmd = readl(port_mmio + PORT_CMD);\n\t\tpx_is = readl(port_mmio + PORT_IRQ_STAT);\n\t}\n\n\t/* clear D2H reception area to properly wait for D2H FIS */\n\tata_tf_init(link->device, &tf);\n\ttf.command = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\trc = sata_link_hardreset(link, timing, deadline, &online,\n\t\t\t\t ahci_check_ready);\n\n\t/* restore the PxCMD and PxIS on ls1021 */\n\tif (ls1021a_workaround) {\n\t\tpx_val = readl(port_mmio + PORT_CMD);\n\t\tif (px_val != px_cmd)\n	f
26068	240	exynos4_pm_init_power_domain	drivers/soc/samsung/pm_domains.c	parent.np	1	13	\N	\N	\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\n\tfor_each_matching_node_and_match(np, exynos_pm_domain_of_match, &match) {\n\t\tconst struct exynos_pm_domain_config *pm_domain_cfg;\n\t\tstruct exynos_pm_domain *pd;\n\t\tint on, i;\n\n\t\tpm_domain_cfg = match->data;\n\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd) {\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpd->pd.name = exynos_get_domain_name(np);\n\t\tif (!pd->pd.name) {\n\t\t\tkfree(pd);\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpd->base = of_iomap(np, 0);\n\t\tif (!pd->base) {\n\t\t\tpr_warn("%s: failed to map memory\\n", __func__);\n\t\t\tkfree_const(pd->pd.name);\n\t\t\tkfree(pd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpd->pd.power_off = exynos_pd_power_off;\n\t\tpd->pd.power_on = exynos_pd_power_on;\n\t\tpd->local_pwr_cfg = pm_domain_cfg->local_pwr_cfg;\n\n\t\tfor (i = 0; i < MAX_CLK_PER_DOMAIN; i++) {\n\t\t\tchar clk_name[8];\n\n\t\t\tsnprintf(clk_name, sizeof(clk_name), "asb%d", i);\n\t\t\tpd->asb_clk[i] = of_clk_get_by_name(np, clk_name);\n\t\t\tif (IS_ERR(pd->asb_clk[i]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpd->oscclk = of_clk_get_by_name(np, "oscclk");\n\t\tif (IS_ERR(pd->oscclk))\n\t\t\tgoto no_clk;\n\n\t\tfor (i = 0; i < MAX_CLK_PER_DOMAIN; i++) {\n\t\t\tchar clk_name[8];\n\n\t\t\tsnprintf(clk_name, sizeof(clk_name), "clk%d", i);\n\t\t\tpd->clk[i] = of_clk_get_by_name(np, clk_name);\n\t\t\tif (IS_ERR(pd->clk[i]))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Skip setting parent on first power up.\n\t\t\t * The parent at this time may not be useful at all.\n\t\t\t */\n\t\t\tpd->pclk[i] = ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (IS_ERR(pd->clk[0]))\n\t\t\tclk_put(pd->oscclk);\n\nno_clk:\n\t\ton = readl_relaxed(pd->base + 0x4) & pd->local_pwr_cfg;\n\n\t\tpm_genpd_init(&pd->pd, NULL, !on);\n\t\tof_genpd_add_provider_simple(np, &pd->pd);\n\t}\n\n\t/* Assign the child power domains to their parents */\n\tfor_each_matching_node(np, exynos_pm_domain_of_match) {\n\t\tstruct of_phandle_args child, parent;\n\n\t\tchild.np = np;\n\t\tchild.args_count = 0;\n\n\t\tif (of_parse_phandle_with_args(np, "power-domains",\n\t\t\t\t\t       "#power-domain-cells", 0,\n\t\t\t\t\t       &parent) != 0)\n\t\t\tcontinue;\n\n\t\tif (of_genpd_add_subdomain(&parent, &child))\n\t\t\tpr_warn("%pOF failed to add subdomain: %pOF\\n",\n	f
26420	961	igb_set_ringparam	drivers/net/ethernet/intel/igb/igb_ethtool.c	&temp_ring[i]	1	13	\N	\N	\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct igb_ring *temp_ring;\n\tint i, err = 0;\n\tu16 new_rx_count, new_tx_count;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tnew_rx_count = min_t(u32, ring->rx_pending, IGB_MAX_RXD);\n\tnew_rx_count = max_t(u16, new_rx_count, IGB_MIN_RXD);\n\tnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\n\n\tnew_tx_count = min_t(u32, ring->tx_pending, IGB_MAX_TXD);\n\tnew_tx_count = max_t(u16, new_tx_count, IGB_MIN_TXD);\n\tnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\n\n\tif ((new_tx_count == adapter->tx_ring_count) &&\n\t    (new_rx_count == adapter->rx_ring_count)) {\n\t\t/* nothing to do */\n\t\treturn 0;\n\t}\n\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (!netif_running(adapter->netdev)) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tadapter->tx_ring[i]->count = new_tx_count;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->count = new_rx_count;\n\t\tadapter->tx_ring_count = new_tx_count;\n\t\tadapter->rx_ring_count = new_rx_count;\n\t\tgoto clear_reset;\n\t}\n\n\tif (adapter->num_tx_queues > adapter->num_rx_queues)\n\t\ttemp_ring = vmalloc(adapter->num_tx_queues *\n\t\t\t\t    sizeof(struct igb_ring));\n\telse\n\t\ttemp_ring = vmalloc(adapter->num_rx_queues *\n\t\t\t\t    sizeof(struct igb_ring));\n\n\tif (!temp_ring) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_reset;\n\t}\n\n\tigb_down(adapter);\n\n\t/* We can't just free everything and then setup again,\n\t * because the ISRs in MSI-X mode get passed pointers\n\t * to the Tx and Rx ring structs.\n\t */\n\tif (new_tx_count != adapter->tx_ring_count) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tmemcpy(&temp_ring[i], adapter->tx_ring[i],\n\t\t\t       sizeof(struct igb_ring));\n\n\t\t\ttemp_ring[i].count = new_tx_count;\n\t\t\terr = igb_setup_tx_resources(&temp_ring[i]);\n\t\t\tif (err) {\n\t\t\t\twhile (i) {\n\t\t\t\t\ti--;\n\t\t\t\t\tigb_free_tx_resources(&temp_ring[i]);\n\t\t\t\t}\n\t\t\t\tgoto err_setup;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tigb_free_tx_resources(adapter->tx_ring[i]);\n\n\t\t\tmemcpy(adapter->tx_ring[i], &temp_ring[i],\n	f
26570	604	gfs2_statfs_sync	fs/gfs2/super.c	m_sc	1	13	\N	\N	\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_holder gh;\n\tstruct buffer_head *m_bh, *l_bh;\n\tint error;\n\n\tsb_start_write(sb);\n\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE, GL_NOCACHE,\n\t\t\t\t   &gh);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_meta_inode_buffer(m_ip, &m_bh);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n	f
26796	117	dn_rt_finish_output	net/decnet/dn_route.c	struct dst_entry *	1	13	\N	\N	\tstruct dn_route __rcu *chain;\n\tspinlock_t lock;\n};\n\nextern struct neigh_table dn_neigh_table;\n\n\nstatic unsigned char dn_hiord_addr[6] = {0xAA,0x00,0x04,0x00,0x00,0x00};\n\nstatic const int dn_rt_min_delay = 2 * HZ;\nstatic const int dn_rt_max_delay = 10 * HZ;\nstatic const int dn_rt_mtu_expires = 10 * 60 * HZ;\n\nstatic unsigned long dn_rt_deadline;\n\nstatic int dn_dst_gc(struct dst_ops *ops);\nstatic struct dst_entry *dn_dst_check(struct dst_entry *, __u32);\nstatic unsigned int dn_dst_default_advmss(const struct dst_entry *dst);\nstatic unsigned int dn_dst_mtu(const struct dst_entry *dst);\nstatic void dn_dst_destroy(struct dst_entry *);\nstatic void dn_dst_ifdown(struct dst_entry *, struct net_device *dev, int how);\n	f
26801	266	mt9t112_reset	drivers/media/i2c/soc_camera/mt9t112.c	ret	1	13	\N	\N	\tint ret;\n\n\tmt9t112_reg_mask_set(ret, client, 0x001a, 0x0001, 0x0001);\n	f
26927	71	mid_pbstat	drivers/platform/x86/intel_mid_powerbtn.c	pbstat	1	13	\N	\N	\tstruct input_dev *input = ddata->input;\n\tint ret;\n\tu8 pbstat;\n\n\tret = intel_scu_ipc_ioread8(ddata->pbstat_addr, &pbstat);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(input->dev.parent, "PB_INT status= %d\\n", pbstat);\n	f
26928	7633	volume_read	drivers/platform/x86/thinkpad_acpi.c	status	1	13	\N	\N	\tu8 status;\n\n\tif (volume_get_status(&status) < 0) {\n\t\tseq_printf(m, "level:\\t\\tunreadable\\n");\n\t} else {\n\t\tif (tp_features.mixer_no_level_control)\n\t\t\tseq_printf(m, "level:\\t\\tunsupported\\n");\n\t\telse\n\t\t\tseq_printf(m, "level:\\t\\t%d\\n",\n	f
-1035	138	acpi_ds_build_internal_object	drivers/acpi/acpica/dsobject.c	obj_desc	2	3	\N	\N	\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ds_build_internal_object);\n\n\t*obj_desc_ptr = NULL;\n\tif (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {\n\t\t/*\n\t\t * This is a named object reference. If this name was\n\t\t * previously looked up in the namespace, it was stored in\n\t\t * this op. Otherwise, go ahead and look it up now\n\t\t */\n\t\tif (!op->common.node) {\n\n\t\t\t/* Check if we are resolving a named reference within a package */\n\n\t\t\tif ((op->common.parent->common.aml_opcode ==\n\t\t\t     AML_PACKAGE_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_VARIABLE_PACKAGE_OP)) {\n\t\t\t\t/*\n\t\t\t\t * We won't resolve package elements here, we will do this\n\t\t\t\t * after all ACPI tables are loaded into the namespace. This\n\t\t\t\t * behavior supports both forward references to named objects\n\t\t\t\t * and external references to objects in other tables.\n\t\t\t\t */\n\t\t\t\tgoto create_new_object;\n\t\t\t} else {\n\t\t\t\tstatus = acpi_ns_lookup(walk_state->scope_info,\n\t\t\t\t\t\t\top->common.value.string,\n\t\t\t\t\t\t\tACPI_TYPE_ANY,\n\t\t\t\t\t\t\tACPI_IMODE_EXECUTE,\n\t\t\t\t\t\t\tACPI_NS_SEARCH_PARENT |\n\t\t\t\t\t\t\tACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tACPI_CAST_INDIRECT_PTR\n\t\t\t\t\t\t\t(struct\n\t\t\t\t\t\t\t acpi_namespace_node,\n\t\t\t\t\t\t\t &(op->common.node)));\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tACPI_ERROR_NAMESPACE(op->common.value.\n\t\t\t\t\t\t\t     string, status);\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ncreate_new_object:\n\n\t/* Create and init a new internal ACPI object */\n\n\tobj_desc = acpi_ut_create_internal_object((acpi_ps_get_opcode_info\n\t\t\t\t\t\t   (op->common.aml_opcode))->\n\t\t\t\t\t\t  object_type);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tstatus =\n\t    acpi_ds_init_object_from_op(walk_state, op, op->common.aml_opcode,\n\t\t\t\t\t&obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(obj_desc);\n	f
-1016	250	max30102_led_init	drivers/iio/health/max30102.c	reg	2	3	\N	\N	\tstruct device *dev = &data->client->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int val;\n\tint reg, ret;\n\n\tret = of_property_read_u32(np, "maxim,red-led-current-microamp", &val);\n\tif (ret) {\n\t\tdev_info(dev, "no red-led-current-microamp set\\n");\n\n\t\t/* Default to 7 mA RED LED */\n\t\tval = 7000;\n\t}\n\n\tret = max30102_get_current_idx(val, &reg);\n\tif (ret) {\n\t\tdev_err(dev, "invalid RED LED current setting %d\\n", val);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, MAX30102_REG_RED_LED_CONFIG, reg);\n	f
-1009	174	exynos_ppmu_set_event	drivers/devfreq/event/exynos-ppmu.c	pmnc	2	3	\N	\N	\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\tu32 pmnc, cntens;\n\n\tif (id < 0)\n\t\treturn id;\n\n\t/* Enable specific counter */\n\tret = regmap_read(info->regmap, PPMU_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Set the event of Read/Write data count  */\n\tret = regmap_write(info->regmap, PPMU_BEVTxSEL(id),\n\t\t\t\tPPMU_RO_DATA_CNT | PPMU_WO_DATA_CNT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Reset cycle counter/performance counter and enable PPMU */\n\tret = regmap_read(info->regmap, PPMU_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tret = regmap_write(info->regmap, PPMU_PMNC, pmnc);\n	f
-1042	466	apply_tx_eq_prog	drivers/infiniband/hw/hfi1/platform.c	tx_preset	2	3	\N	\N	\tu8 *cache = ppd->qsfp_info.cache;\n\tu32 tx_preset;\n\tu8 tx_eq;\n\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x4))\n\t\treturn;\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index, TX_PRESET_TABLE_QSFP_TX_EQ_APPLY,\n\t\t&tx_preset, 4);\n\tif (!tx_preset) {\n	f
-1036	737	cdv_intel_dp_aux_native_read	drivers/gpu/drm/gma500/cdv_intel_dp.c	ack	2	3	\N	\N	\tuint8_t msg[4];\n\tint msg_bytes;\n\tuint8_t reply[20];\n\tint reply_bytes;\n\tuint8_t ack;\n\tint ret;\n\n\tmsg[0] = DP_AUX_NATIVE_READ << 4;\n\tmsg[1] = address >> 8;\n\tmsg[2] = address & 0xff;\n\tmsg[3] = recv_bytes - 1;\n\n\tmsg_bytes = 4;\n\treply_bytes = recv_bytes + 1;\n\n\tfor (;;) {\n\t\tret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes,\n\t\t\t\t      reply, reply_bytes);\n\t\tif (ret == 0)\n\t\t\treturn -EPROTO;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tack = reply[0] >> 4;\n\t\tif ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK) {\n	f
-1002	14031	bnx2x_init_mod_abs_int	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c	phy.type	2	3	\N	\N	\tu8 gpio_num = 0xff, gpio_port = 0xff, phy_index;\n\tu32 val;\n\tu32 offset, aeu_mask, swap_val, swap_override, sync_offset;\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (bnx2x_get_mod_abs_int_cfg(bp, chip_id,\n\t\t\t\t\t      shmem_base,\n\t\t\t\t\t      port,\n\t\t\t\t\t      &gpio_num,\n\t\t\t\t\t      &gpio_port) != 0)\n\t\t\treturn;\n\t} else {\n\t\tstruct bnx2x_phy phy;\n\t\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t\t      phy_index++) {\n\t\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base,\n\t\t\t\t\t       shmem2_base, port, &phy)\n\t\t\t    != 0) {\n\t\t\t\tDP(NETIF_MSG_LINK, "populate phy failed\\n");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (phy.type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {\n	f
-1055	1866	get_memory_layout	drivers/edac/sb_edac.c	rir_way	2	3	\N	\N	\tstruct sbridge_pvt *pvt = mci->pvt_info;\n\tint i, j, k, n_sads, n_tads, sad_interl;\n\tu32 reg;\n\tu64 limit, prv = 0;\n\tu64 tmp_mb;\n\tu32 gb, mb;\n\tu32 rir_way;\n\n\t/*\n\t * Step 1) Get TOLM/TOHM ranges\n\t */\n\n\tpvt->tolm = pvt->info.get_tolm(pvt);\n\ttmp_mb = (1 + pvt->tolm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tolm);\n\n\t/* Address range is already 45:25 */\n\tpvt->tohm = pvt->info.get_tohm(pvt);\n\ttmp_mb = (1 + pvt->tohm) >> 20;\n\n\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\tedac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\\n",\n\t\tgb, (mb*1000)/1024, (u64)pvt->tohm);\n\n\t/*\n\t * Step 2) Get SAD range and SAD Interleave list\n\t * TAD registers contain the interleave wayness. However, it\n\t * seems simpler to just discover it indirectly, with the\n\t * algorithm bellow.\n\t */\n\tprv = 0;\n\tfor (n_sads = 0; n_sads < pvt->info.max_sad; n_sads++) {\n\t\t/* SAD_LIMIT Address range is 45:26 */\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.dram_rule[n_sads],\n\t\t\t\t      &reg);\n\t\tlimit = pvt->info.sad_limit(reg);\n\n\t\tif (!DRAM_RULE_ENABLE(reg))\n\t\t\tcontinue;\n\n\t\tif (limit <= prv)\n\t\t\tbreak;\n\n\t\ttmp_mb = (limit + 1) >> 20;\n\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\tedac_dbg(0, "SAD#%d %s up to %u.%03u GB (0x%016Lx) Interleave: %s reg=0x%08x\\n",\n\t\t\t n_sads,\n\t\t\t show_dram_attr(pvt->info.dram_attr(reg)),\n\t\t\t gb, (mb*1000)/1024,\n\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t get_intlv_mode_str(reg, pvt->info.type),\n\t\t\t reg);\n\t\tprv = limit;\n\n\t\tpci_read_config_dword(pvt->pci_sad0, pvt->info.interleave_list[n_sads],\n\t\t\t\t      &reg);\n\t\tsad_interl = sad_pkg(pvt->info.interleave_pkg, reg, 0);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tu32 pkg = sad_pkg(pvt->info.interleave_pkg, reg, j);\n\t\t\tif (j > 0 && sad_interl == pkg)\n\t\t\t\tbreak;\n\n\t\t\tedac_dbg(0, "SAD#%d, interleave #%d: %d\\n",\n\t\t\t\t n_sads, j, pkg);\n\t\t}\n\t}\n\n\tif (pvt->info.type == KNIGHTS_LANDING)\n\t\treturn;\n\n\t/*\n\t * Step 3) Get TAD range\n\t */\n\tprv = 0;\n\tfor (n_tads = 0; n_tads < MAX_TAD; n_tads++) {\n\t\tpci_read_config_dword(pvt->pci_ha, tad_dram_rule[n_tads], &reg);\n\t\tlimit = TAD_LIMIT(reg);\n\t\tif (limit <= prv)\n\t\t\tbreak;\n\t\ttmp_mb = (limit + 1) >> 20;\n\n\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\tedac_dbg(0, "TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\\n",\n\t\t\t n_tads, gb, (mb*1000)/1024,\n\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t (u32)(1 << TAD_SOCK(reg)),\n\t\t\t (u32)TAD_CH(reg) + 1,\n\t\t\t (u32)TAD_TGT0(reg),\n\t\t\t (u32)TAD_TGT1(reg),\n\t\t\t (u32)TAD_TGT2(reg),\n\t\t\t (u32)TAD_TGT3(reg),\n\t\t\t reg);\n\t\tprv = limit;\n\t}\n\n\t/*\n\t * Step 4) Get TAD offsets, per each channel\n\t */\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tif (!pvt->channel[i].dimms)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < n_tads; j++) {\n\t\t\tpci_read_config_dword(pvt->pci_tad[i],\n\t\t\t\t\t      tad_ch_nilv_offset[j],\n\t\t\t\t\t      &reg);\n\t\t\ttmp_mb = TAD_OFFSET(reg) >> 20;\n\t\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\t\tedac_dbg(0, "TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\\n",\n\t\t\t\t i, j,\n\t\t\t\t gb, (mb*1000)/1024,\n\t\t\t\t ((u64)tmp_mb) << 20L,\n\t\t\t\t reg);\n\t\t}\n\t}\n\n\t/*\n\t * Step 6) Get RIR Wayness/Limit, per each channel\n\t */\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tif (!pvt->channel[i].dimms)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < MAX_RIR_RANGES; j++) {\n\t\t\tpci_read_config_dword(pvt->pci_tad[i],\n\t\t\t\t\t      rir_way_limit[j],\n\t\t\t\t\t      &reg);\n\n\t\t\tif (!IS_RIR_VALID(reg))\n\t\t\t\tcontinue;\n\n\t\t\ttmp_mb = pvt->info.rir_limit(reg) >> 20;\n\t\t\trir_way = 1 << RIR_WAY(reg);\n\t\t\tgb = div_u64_rem(tmp_mb, 1024, &mb);\n\t\t\tedac_dbg(0, "CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\\n",\n	f
-1038	2429	__xfrm_policy_check	net/xfrm/xfrm_policy.c	pols	2	3	\N	\N	\tstruct net *net = dev_net(skb->dev);\n\tstruct xfrm_policy *pol;\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tint npols = 0;\n\tint xfrm_nr;\n\tint pi;\n\tint reverse;\n\tstruct flowi fl;\n\tint xerr_idx = -1;\n\n\treverse = dir & ~XFRM_POLICY_MASK;\n\tdir &= XFRM_POLICY_MASK;\n\n\tif (__xfrm_decode_session(skb, &fl, family, reverse) < 0) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\treturn 0;\n\t}\n\n\tnf_nat_decode_session(skb, &fl, family);\n\n\t/* First, check used SA against their selectors. */\n\tif (skb->sp) {\n\t\tint i;\n\n\t\tfor (i = skb->sp->len-1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = skb->sp->xvec[i];\n\t\t\tif (!xfrm_selector_match(&x->sel, &fl, family)) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpol = NULL;\n\tsk = sk_to_full_sk(sk);\n\tif (sk && sk->sk_policy[dir]) {\n\t\tpol = xfrm_sk_policy_lookup(sk, dir, &fl, family);\n\t\tif (IS_ERR(pol)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!pol)\n\t\tpol = xfrm_policy_lookup(net, &fl, family, dir);\n\n\tif (IS_ERR(pol)) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\treturn 0;\n\t}\n\n\tif (!pol) {\n\t\tif (skb->sp && secpath_has_nontransport(skb->sp, 0, &xerr_idx)) {\n\t\t\txfrm_secpath_reject(xerr_idx, skb, &fl);\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOPOLS);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tpol->curlft.use_time = get_seconds();\n\n\tpols[0] = pol;\n\tnpols++;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n	f
-1011	259	s5m_check_peding_alarm_interrupt	drivers/rtc/rtc-s5m.c	val	2	3	\N	\N	\tint ret;\n\tunsigned int val;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S5M8763X:\n\t\tret = regmap_read(info->regmap, S5M_RTC_STATUS, &val);\n\t\tval &= S5M_ALARM0_STATUS;\n\t\tbreak;\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tret = regmap_read(info->s5m87xx->regmap_pmic, S2MPS14_REG_ST2,\n\t\t\t\t&val);\n\t\tval &= S2MPS_ALARM0_STATUS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val)\n	f
-620	190	da9052_rtc_read_time	drivers/rtc/rtc-da9052.c	rtc_tm	2	3	\N	\N	\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\tuint8_t v[2][6];\n\tint idx = 1;\n\tint timeout = DA9052_GET_TIME_RETRIES;\n\n\tret = da9052_group_read(rtc->da9052, DA9052_COUNT_S_REG, 6, &v[0][0]);\n\tif (ret) {\n\t\trtc_err(rtc, "Failed to read RTC time : %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tret = da9052_group_read(rtc->da9052,\n\t\t\t\t\tDA9052_COUNT_S_REG, 6, &v[idx][0]);\n\t\tif (ret) {\n\t\t\trtc_err(rtc, "Failed to read RTC time : %d\\n", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(&v[0][0], &v[1][0], 6) == 0) {\n\t\t\trtc_tm->tm_year = (v[0][5] & DA9052_RTC_YEAR) + 100;\n\t\t\trtc_tm->tm_mon  = (v[0][4] & DA9052_RTC_MONTH) - 1;\n\t\t\trtc_tm->tm_mday = v[0][3] & DA9052_RTC_DAY;\n\t\t\trtc_tm->tm_hour = v[0][2] & DA9052_RTC_HOUR;\n\t\t\trtc_tm->tm_min  = v[0][1] & DA9052_RTC_MIN;\n\t\t\trtc_tm->tm_sec  = v[0][0] & DA9052_RTC_SEC;\n\n\t\t\tret = rtc_valid_tm(rtc_tm);\n	f
-1040	479	rio_mport_obw_free	drivers/rapidio/devices/rio_mport_cdev.c	handle	2	3	\N	\N	\tstruct mport_cdev_priv *priv = filp->private_data;\n\tstruct mport_dev *md = priv->md;\n\tu64 handle;\n\tstruct rio_mport_mapping *map, *_map;\n\n\tif (!md->mport->ops->unmap_outb)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (copy_from_user(&handle, arg, sizeof(handle)))\n\t\treturn -EFAULT;\n\n\trmcd_debug(OBW, "h=0x%llx", handle);\n	f
-1039	1313	moxa_tiocmset	drivers/tty/moxa.c	rts	2	3	\N	\N	\tstruct moxa_port *ch;\n\tint dtr, rts;\n\n\tmutex_lock(&moxa_openlock);\n\tch = tty->driver_data;\n\tif (!ch) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -EINVAL;\n\t}\n\n\tMoxaPortGetLineOut(ch, &dtr, &rts);\n\tif (set & TIOCM_RTS)\n\t\trts = 1;\n\tif (set & TIOCM_DTR)\n\t\tdtr = 1;\n\tif (clear & TIOCM_RTS)\n\t\trts = 0;\n\tif (clear & TIOCM_DTR)\n\t\tdtr = 0;\n\tMoxaPortLineCtrl(ch, dtr, rts);\n	f
-1019	3522	ip_vs_genl_set_config	net/netfilter/ipvs/ip_vs_ctl.c	&t	2	3	\N	\N	\tstruct ip_vs_timeout_user t;\n\n\t__ip_vs_get_timeouts(ipvs, &t);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\n\t\tt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\n\t\tt.tcp_fin_timeout =\n\t\t\tnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\n\t\tt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\n\n\treturn ip_vs_set_timeout(ipvs, &t);\n	f
-1047	77	max8997_battery_get_property	drivers/power/supply/max8997_charger.c	reg	2	3	\N	\N	\tstruct charger_data *charger = power_supply_get_drvdata(psy);\n\tstruct i2c_client *i2c = charger->iodev->i2c;\n\tint ret;\n\tu8 reg;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & (1 << 0)) == 0x1)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & (1 << 2)) == 0x0)\n\t\t\tval->intval = 1;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t/* DCINOK */\n\t\tif (reg & (1 << 1))\n	f
-1034	153	acpi_ps_alloc_op	drivers/acpi/acpica/psutils.c	op	2	3	\N	\N	\tunion acpi_parse_object *op;\n\tconst struct acpi_opcode_info *op_info;\n\tu8 flags = ACPI_PARSEOP_GENERIC;\n\n\tACPI_FUNCTION_ENTRY();\n\n\top_info = acpi_ps_get_opcode_info(opcode);\n\n\t/* Determine type of parse_op required */\n\n\tif (op_info->flags & AML_DEFER) {\n\t\tflags = ACPI_PARSEOP_DEFERRED;\n\t} else if (op_info->flags & AML_NAMED) {\n\t\tflags = ACPI_PARSEOP_NAMED_OBJECT;\n\t} else if (opcode == AML_INT_BYTELIST_OP) {\n\t\tflags = ACPI_PARSEOP_BYTELIST;\n\t}\n\n\t/* Allocate the minimum required size object */\n\n\tif (flags == ACPI_PARSEOP_GENERIC) {\n\n\t\t/* The generic op (default) is by far the most common (16 to 1) */\n\n\t\top = acpi_os_acquire_object(acpi_gbl_ps_node_cache);\n\t} else {\n\t\t/* Extended parseop */\n\n\t\top = acpi_os_acquire_object(acpi_gbl_ps_node_ext_cache);\n\t}\n\n\t/* Initialize the Op */\n\n\tif (op) {\n\t\tacpi_ps_init_op(op, opcode);\n	f
-1064	533	nouveau_bios_parse_lvds_table	drivers/gpu/drm/nouveau/nouveau_bios.c	lth.lvds_ver	2	3	\N	\N	\t/*\n\t * The LVDS table header is (mostly) described in\n\t * parse_lvds_manufacturer_table_header(): the BIT header additionally\n\t * contains the dual-link transition pxclk (in 10s kHz), at byte 5 - if\n\t * straps are not being used for the panel, this specifies the frequency\n\t * at which modes should be set up in the dual link style.\n\t *\n\t * Following the header, the BMP (ver 0xa) table has several records,\n\t * indexed by a separate xlat table, indexed in turn by the fp strap in\n\t * EXTDEV_BOOT. Each record had a config byte, followed by 6 script\n\t * numbers for use by INIT_SUB which controlled panel init and power,\n\t * and finally a dword of ms to sleep between power off and on\n\t * operations.\n\t *\n\t * In the BIT versions, the table following the header serves as an\n\t * integrated config and xlat table: the records in the table are\n\t * indexed by the FP strap nibble in EXTDEV_BOOT, and each record has\n\t * two bytes - the first as a config byte, the second for indexing the\n\t * fp mode table pointed to by the BIT 'D' table\n\t *\n\t * DDC is not used until after card init, so selecting the correct table\n\t * entry and setting the dual link flag for EDID equipped panels,\n\t * requiring tests against the native-mode pixel clock, cannot be done\n\t * until later, when this function should be called with non-zero pxclk\n\t */\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tint fpstrapping = get_fp_strap(dev, bios), lvdsmanufacturerindex = 0;\n\tstruct lvdstableheader lth;\n\tuint16_t lvdsofs;\n\tint ret, chip_version = bios->chip_version;\n\n\tret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (lth.lvds_ver) {\n	f
-1046	4942	set_agc_rf	drivers/media/dvb-frontends/drx39xyj/drxj.c	data	2	3	\N	\N	\tstruct i2c_device_addr *dev_addr = NULL;\n\tstruct drxj_data *ext_attr = NULL;\n\tstruct drxj_cfg_agc *p_agc_settings = NULL;\n\tstruct drx_common_attr *common_attr = NULL;\n\tint rc;\n\tdrx_write_reg16func_t scu_wr16 = NULL;\n\tdrx_read_reg16func_t scu_rr16 = NULL;\n\n\tcommon_attr = (struct drx_common_attr *) demod->my_common_attr;\n\tdev_addr = demod->my_i2c_dev_addr;\n\text_attr = (struct drxj_data *) demod->my_ext_attr;\n\n\tif (atomic) {\n\t\tscu_rr16 = drxj_dap_scu_atomic_read_reg16;\n\t\tscu_wr16 = drxj_dap_scu_atomic_write_reg16;\n\t} else {\n\t\tscu_rr16 = drxj_dap_read_reg16;\n\t\tscu_wr16 = drxj_dap_write_reg16;\n\t}\n\n\t/* Configure AGC only if standard is currently active */\n\tif ((ext_attr->standard == agc_settings->standard) ||\n\t    (DRXJ_ISQAMSTD(ext_attr->standard) &&\n\t     DRXJ_ISQAMSTD(agc_settings->standard)) ||\n\t    (DRXJ_ISATVSTD(ext_attr->standard) &&\n\t     DRXJ_ISATVSTD(agc_settings->standard))) {\n\t\tu16 data = 0;\n\n\t\tswitch (agc_settings->ctrl_mode) {\n\t\tcase DRX_AGC_CTRL_AUTO:\n\n\t\t\t/* Enable RF AGC DAC */\n\t\t\trc = drxj_dap_read_reg16(dev_addr, IQM_AF_STDBY__A, &data, 0);\n\t\t\tif (rc != 0) {\n\t\t\t\tpr_err("error %d\\n", rc);\n\t\t\t\tgoto rw_error;\n\t\t\t}\n\t\t\tdata |= IQM_AF_STDBY_STDBY_TAGC_RF_A2_ACTIVE;\n\t\t\trc = drxj_dap_write_reg16(dev_addr, IQM_AF_STDBY__A, data, 0);\n	f
-1051	874	area_cache_get	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c	err	2	3	\N	\N	\tstruct nfp_cpp_area_cache *cache;\n\tint err;\n\n\t/* Early exit when length == 0, which prevents\n\t * the need for special case code below when\n\t * checking against available cache size.\n\t */\n\tif (length == 0 || id == 0)\n\t\treturn NULL;\n\n\t/* Remap from cpp_island to cpp_target */\n\terr = nfp_target_cpp(id, addr, &id, &addr, cpp->imb_cat_table);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tmutex_lock(&cpp->area_cache_mutex);\n\n\tif (list_empty(&cpp->area_cache_list)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\taddr += *offset;\n\n\t/* See if we have a match */\n\tlist_for_each_entry(cache, &cpp->area_cache_list, entry) {\n\t\tif (id == cache->id &&\n\t\t    addr >= cache->addr &&\n\t\t    addr + length <= cache->addr + cache->size)\n\t\t\tgoto exit;\n\t}\n\n\t/* No matches - inspect the tail of the LRU */\n\tcache = list_entry(cpp->area_cache_list.prev,\n\t\t\t   struct nfp_cpp_area_cache, entry);\n\n\t/* Can we fit in the cache entry? */\n\tif (round_down(addr + length - 1, cache->size) !=\n\t    round_down(addr, cache->size)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\t/* If id != 0, we will need to release it */\n\tif (cache->id) {\n\t\tnfp_cpp_area_release(cache->area);\n\t\tcache->id = 0;\n\t\tcache->addr = 0;\n\t}\n\n\t/* Adjust the start address to be cache size aligned */\n\tcache->id = id;\n\tcache->addr = addr & ~(u64)(cache->size - 1);\n\n\t/* Re-init to the new ID and address */\n\tif (cpp->op->area_init) {\n\t\terr = cpp->op->area_init(cache->area,\n\t\t\t\t\t id, cache->addr, cache->size);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Attempt to acquire */\n\terr = nfp_cpp_area_acquire(cache->area);\n\tif (err < 0) {\n	f
-409	193	my3126_phy_reset	drivers/net/ethernet/chelsio/cxgb/my3126.c	val	2	3	\N	\N	\tu32 val;\n\n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~4;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n	f
-402	637	ep0_handle_setup	drivers/usb/mtu3/mtu3_gadget_ep0.c	setup.bRequestType	2	3	\N	\N	\tstruct usb_ctrlrequest setup;\n\tstruct mtu3_request *mreq;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint handled = 0;\n\n\tep0_read_setup(mtu, &setup);\n\n\tif ((setup.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n	f
-626	2353	fail_postponed_requests	drivers/block/drbd/drbd_receiver.c	&m	2	3	\N	\N	\tstruct drbd_interval *i;\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tstruct drbd_request *req;\n\t\tstruct bio_and_error m;\n\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (!(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\treq->rq_state &= ~RQ_POSTPONED;\n\t\t__req_mod(req, NEG_ACKED, &m);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tif (m.bio)\n\t\t\tcomplete_master_bio(device, &m);\n	f
-610	1243	keyctl_reject_key	security/keys/keyctl.c	dest_keyring	2	3	\N	\N	\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter("%d,%u,%u,%d", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n	f
-608	2285	team_nl_fill_one_option_get	drivers/net/team/team.c	ctx.data.bin_val.len	2	3	\N	\N	\tstruct nlattr *option_item;\n\tstruct team_option *option = opt_inst->option;\n\tstruct team_option_inst_info *opt_inst_info = &opt_inst->info;\n\tstruct team_gsetter_ctx ctx;\n\tint err;\n\n\tctx.info = opt_inst_info;\n\terr = team_option_get(team, opt_inst, &ctx);\n\tif (err)\n\t\treturn err;\n\n\toption_item = nla_nest_start(skb, TEAM_ATTR_ITEM_OPTION);\n\tif (!option_item)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TEAM_ATTR_OPTION_NAME, option->name))\n\t\tgoto nest_cancel;\n\tif (opt_inst_info->port &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_PORT_IFINDEX,\n\t\t\topt_inst_info->port->dev->ifindex))\n\t\tgoto nest_cancel;\n\tif (opt_inst->option->array_size &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_ARRAY_INDEX,\n\t\t\topt_inst_info->array_index))\n\t\tgoto nest_cancel;\n\n\tswitch (option->type) {\n\tcase TEAM_OPTION_TYPE_U32:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_U32))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_u32(skb, TEAM_ATTR_OPTION_DATA, ctx.data.u32_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_STRING:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_STRING))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_string(skb, TEAM_ATTR_OPTION_DATA,\n\t\t\t\t   ctx.data.str_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_BINARY:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_BINARY))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put(skb, TEAM_ATTR_OPTION_DATA, ctx.data.bin_val.len,\n	f
-624	3303	finish_port_resume	drivers/usb/core/hub.c	devstatus	2	3	\N	\N	\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, "%s\\n",\n\t\tudev->reset_resume ? "finish reset-resume" : "finish resume");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, "retry with reset-resume\\n");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, "gone after usb resume? status %d\\n",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n	f
-1058	470	set_temp_hyst	drivers/hwmon/asb100.c	HYST	2	3	\N	\N	\tint ret = 0;\n\n\tswitch (nr) {\n\tcase 1: case 2:\n\t\tret = sprintf(buf, "%d\\n", LM75_TEMP_FROM_REG(reg));\n\t\tbreak;\n\tcase 0: case 3: default:\n\t\tret = sprintf(buf, "%d\\n", TEMP_FROM_REG(reg));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#define show_temp_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tchar *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct asb100_data *data = asb100_update_device(dev); \\\n\treturn sprintf_temp_from_reg(data->reg[nr], buf, nr); \\\n}\n\nshow_temp_reg(temp);\nshow_temp_reg(temp_max);\nshow_temp_reg(temp_hyst);\n\n#define set_temp_reg(REG, reg) \\\nstatic ssize_t set_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tconst char *buf, size_t count) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct asb100_data *data = i2c_get_clientdata(client); \\\n\tlong val; \\\n\tint err = kstrtol(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tswitch (nr) { \\\n\tcase 1: case 2: \\\n\t\tdata->reg[nr] = LM75_TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\tcase 0: case 3: default: \\\n\t\tdata->reg[nr] = TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\t} \\\n\tasb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), \\\n\t\t\tdata->reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nset_temp_reg(MAX, temp_max);\nset_temp_reg(HYST, temp_hyst);\n	f
-612	2432	intel_haswell_fixup_enable_dp12	sound/pci/hda/patch_hdmi.c	vendor_param	2	3	\N	\N	\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, "Quotacheck needed: Please wait.");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n	f
\.


--
-- PostgreSQL database dump complete
--

